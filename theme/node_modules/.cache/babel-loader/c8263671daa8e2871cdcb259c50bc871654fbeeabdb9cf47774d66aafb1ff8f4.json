{"ast":null,"code":"import _defineProperty from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classCallCheck from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _callSuper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reverse.js\";\nimport \"core-js/modules/es.number.constructor.js\";\n/**\n * @module ol/format/EsriJSON\n */\nimport Feature from '../Feature.js';\nimport JSONFeature from './JSONFeature.js';\nimport LineString from '../geom/LineString.js';\nimport LinearRing from '../geom/LinearRing.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport { containsExtent } from '../extent.js';\nimport { deflateCoordinates } from '../geom/flat/deflate.js';\nimport { get as getProjection } from '../proj.js';\nimport { isEmpty } from '../obj.js';\nimport { linearRingIsClockwise } from '../geom/flat/orient.js';\nimport { transformGeometryWithOptions } from './Feature.js';\n\n/**\n * @typedef {import(\"arcgis-rest-api\").Feature} EsriJSONFeature\n * @typedef {import(\"arcgis-rest-api\").FeatureSet} EsriJSONFeatureSet\n * @typedef {import(\"arcgis-rest-api\").Geometry} EsriJSONGeometry\n * @typedef {import(\"arcgis-rest-api\").Point} EsriJSONPoint\n * @typedef {import(\"arcgis-rest-api\").Polyline} EsriJSONPolyline\n * @typedef {import(\"arcgis-rest-api\").Polygon} EsriJSONPolygon\n * @typedef {import(\"arcgis-rest-api\").Multipoint} EsriJSONMultipoint\n * @typedef {import(\"arcgis-rest-api\").HasZM} EsriJSONHasZM\n * @typedef {import(\"arcgis-rest-api\").Position} EsriJSONPosition\n * @typedef {import(\"arcgis-rest-api\").SpatialReferenceWkid} EsriJSONSpatialReferenceWkid\n */\n\n/**\n * @typedef {Object} EsriJSONMultiPolygon\n * @property {Array<Array<Array<Array<number>>>>} rings Rings for the MultiPolygon.\n * @property {boolean} [hasM] If the polygon coordinates have an M value.\n * @property {boolean} [hasZ] If the polygon coordinates have a Z value.\n * @property {EsriJSONSpatialReferenceWkid} [spatialReference] The coordinate reference system.\n */\n\n/**\n * @const\n * @type {Object<import(\"../geom/Geometry.js\").Type, function(EsriJSONGeometry): import(\"../geom/Geometry.js\").default>}\n */\nvar GEOMETRY_READERS = {\n  Point: readPointGeometry,\n  LineString: readLineStringGeometry,\n  Polygon: readPolygonGeometry,\n  MultiPoint: readMultiPointGeometry,\n  MultiLineString: readMultiLineStringGeometry,\n  MultiPolygon: readMultiPolygonGeometry\n};\n\n/**\n * @const\n * @type {Object<import(\"../geom/Geometry.js\").Type, function(import(\"../geom/Geometry.js\").default, import(\"./Feature.js\").WriteOptions=): (EsriJSONGeometry)>}\n */\nvar GEOMETRY_WRITERS = {\n  Point: writePointGeometry,\n  LineString: writeLineStringGeometry,\n  Polygon: writePolygonGeometry,\n  MultiPoint: writeMultiPointGeometry,\n  MultiLineString: writeMultiLineStringGeometry,\n  MultiPolygon: writeMultiPolygonGeometry\n};\n\n/**\n * @typedef {Object} Options\n * @property {string} [geometryName] Geometry name to use when creating features.\n */\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the EsriJSON format.\n *\n * @api\n */\nvar EsriJSON = /*#__PURE__*/function (_JSONFeature) {\n  /**\n   * @param {Options} [options] Options.\n   */\n  function EsriJSON(options) {\n    var _this;\n    _classCallCheck(this, EsriJSON);\n    options = options ? options : {};\n    _this = _callSuper(this, EsriJSON);\n\n    /**\n     * Name of the geometry attribute for features.\n     * @type {string|undefined}\n     * @private\n     */\n    _this.geometryName_ = options.geometryName;\n    return _this;\n  }\n\n  /**\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @param {string} [idField] Name of the field where to get the id from.\n   * @protected\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  _inherits(EsriJSON, _JSONFeature);\n  return _createClass(EsriJSON, [{\n    key: \"readFeatureFromObject\",\n    value: function readFeatureFromObject(object, options, idField) {\n      var esriJSONFeature = /** @type {EsriJSONFeature} */object;\n      var geometry = readGeometry(esriJSONFeature.geometry, options);\n      var feature = new Feature();\n      if (this.geometryName_) {\n        feature.setGeometryName(this.geometryName_);\n      }\n      feature.setGeometry(geometry);\n      if (esriJSONFeature.attributes) {\n        feature.setProperties(esriJSONFeature.attributes, true);\n        var id = esriJSONFeature.attributes[idField];\n        if (id !== undefined) {\n          feature.setId(/** @type {number} */id);\n        }\n      }\n      return feature;\n    }\n\n    /**\n     * @param {Object} object Object.\n     * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n     * @protected\n     * @return {Array<Feature>} Features.\n     */\n  }, {\n    key: \"readFeaturesFromObject\",\n    value: function readFeaturesFromObject(object, options) {\n      options = options ? options : {};\n      if (object['features']) {\n        var esriJSONFeatureSet = /** @type {EsriJSONFeatureSet} */object;\n        /** @type {Array<import(\"../Feature.js\").default>} */\n        var features = [];\n        var esriJSONFeatures = esriJSONFeatureSet.features;\n        for (var i = 0, ii = esriJSONFeatures.length; i < ii; ++i) {\n          features.push(this.readFeatureFromObject(esriJSONFeatures[i], options, object.objectIdFieldName));\n        }\n        return features;\n      }\n      return [this.readFeatureFromObject(object, options)];\n    }\n\n    /**\n     * @param {EsriJSONGeometry} object Object.\n     * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n     * @protected\n     * @return {import(\"../geom/Geometry.js\").default} Geometry.\n     */\n  }, {\n    key: \"readGeometryFromObject\",\n    value: function readGeometryFromObject(object, options) {\n      return readGeometry(object, options);\n    }\n\n    /**\n     * @param {Object} object Object.\n     * @protected\n     * @return {import(\"../proj/Projection.js\").default} Projection.\n     */\n  }, {\n    key: \"readProjectionFromObject\",\n    value: function readProjectionFromObject(object) {\n      if (object['spatialReference'] && object['spatialReference']['wkid'] !== undefined) {\n        var spatialReference = /** @type {EsriJSONSpatialReferenceWkid} */\n        object['spatialReference'];\n        var crs = spatialReference.wkid;\n        return getProjection('EPSG:' + crs);\n      }\n      return null;\n    }\n\n    /**\n     * Encode a geometry as a EsriJSON object.\n     *\n     * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n     * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n     * @return {EsriJSONGeometry} Object.\n     * @api\n     */\n  }, {\n    key: \"writeGeometryObject\",\n    value: function writeGeometryObject(geometry, options) {\n      return writeGeometry(geometry, this.adaptOptions(options));\n    }\n\n    /**\n     * Encode a feature as a esriJSON Feature object.\n     *\n     * @param {import(\"../Feature.js\").default} feature Feature.\n     * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n     * @return {Object} Object.\n     * @api\n     */\n  }, {\n    key: \"writeFeatureObject\",\n    value: function writeFeatureObject(feature, options) {\n      options = this.adaptOptions(options);\n      var object = {};\n      if (!feature.hasProperties()) {\n        object['attributes'] = {};\n        return object;\n      }\n      var properties = feature.getProperties();\n      var geometry = feature.getGeometry();\n      if (geometry) {\n        object['geometry'] = writeGeometry(geometry, options);\n        var projection = options && (options.dataProjection || options.featureProjection);\n        if (projection) {\n          object['geometry']['spatialReference'] = /** @type {EsriJSONSpatialReferenceWkid} */{\n            wkid: Number(getProjection(projection).getCode().split(':').pop())\n          };\n        }\n        delete properties[feature.getGeometryName()];\n      }\n      if (!isEmpty(properties)) {\n        object['attributes'] = properties;\n      } else {\n        object['attributes'] = {};\n      }\n      return object;\n    }\n\n    /**\n     * Encode an array of features as a EsriJSON object.\n     *\n     * @param {Array<import(\"../Feature.js\").default>} features Features.\n     * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n     * @return {EsriJSONFeatureSet} EsriJSON Object.\n     * @api\n     */\n  }, {\n    key: \"writeFeaturesObject\",\n    value: function writeFeaturesObject(features, options) {\n      options = this.adaptOptions(options);\n      var objects = [];\n      for (var i = 0, ii = features.length; i < ii; ++i) {\n        objects.push(this.writeFeatureObject(features[i], options));\n      }\n      return {\n        'features': objects\n      };\n    }\n  }]);\n}(JSONFeature);\n/**\n * @param {EsriJSONGeometry} object Object.\n * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n * @return {import(\"../geom/Geometry.js\").default} Geometry.\n */\nfunction readGeometry(object, options) {\n  if (!object) {\n    return null;\n  }\n  /** @type {import(\"../geom/Geometry.js\").Type} */\n  var type;\n  if (typeof object['x'] === 'number' && typeof object['y'] === 'number') {\n    type = 'Point';\n  } else if (object['points']) {\n    type = 'MultiPoint';\n  } else if (object['paths']) {\n    var esriJSONPolyline = /** @type {EsriJSONPolyline} */object;\n    if (esriJSONPolyline.paths.length === 1) {\n      type = 'LineString';\n    } else {\n      type = 'MultiLineString';\n    }\n  } else if (object['rings']) {\n    var esriJSONPolygon = /** @type {EsriJSONPolygon} */object;\n    var layout = getGeometryLayout(esriJSONPolygon);\n    var rings = convertRings(esriJSONPolygon.rings, layout);\n    if (rings.length === 1) {\n      type = 'Polygon';\n      object = Object.assign({}, object, _defineProperty({}, 'rings', rings[0]));\n    } else {\n      type = 'MultiPolygon';\n      object = Object.assign({}, object, _defineProperty({}, 'rings', rings));\n    }\n  }\n  var geometryReader = GEOMETRY_READERS[type];\n  return transformGeometryWithOptions(geometryReader(object), false, options);\n}\n\n/**\n * Determines inner and outer rings.\n * Checks if any polygons in this array contain any other polygons in this\n * array. It is used for checking for holes.\n * Logic inspired by: https://github.com/Esri/terraformer-arcgis-parser\n * @param {Array<!Array<!Array<number>>>} rings Rings.\n * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout Geometry layout.\n * @return {Array<!Array<!Array<!Array<number>>>>} Transformed rings.\n */\nfunction convertRings(rings, layout) {\n  var flatRing = [];\n  var outerRings = [];\n  var holes = [];\n  var i, ii;\n  for (i = 0, ii = rings.length; i < ii; ++i) {\n    flatRing.length = 0;\n    deflateCoordinates(flatRing, 0, rings[i], layout.length);\n    // is this ring an outer ring? is it clockwise?\n    var clockwise = linearRingIsClockwise(flatRing, 0, flatRing.length, layout.length);\n    if (clockwise) {\n      outerRings.push([rings[i]]);\n    } else {\n      holes.push(rings[i]);\n    }\n  }\n  while (holes.length) {\n    var hole = holes.shift();\n    var matched = false;\n    // loop over all outer rings and see if they contain our hole.\n    for (i = outerRings.length - 1; i >= 0; i--) {\n      var outerRing = outerRings[i][0];\n      var containsHole = containsExtent(new LinearRing(outerRing).getExtent(), new LinearRing(hole).getExtent());\n      if (containsHole) {\n        // the hole is contained push it into our polygon\n        outerRings[i].push(hole);\n        matched = true;\n        break;\n      }\n    }\n    if (!matched) {\n      // no outer rings contain this hole turn it into and outer\n      // ring (reverse it)\n      outerRings.push([hole.reverse()]);\n    }\n  }\n  return outerRings;\n}\n\n/**\n * @param {EsriJSONPoint} object Object.\n * @return {import(\"../geom/Geometry.js\").default} Point.\n */\nfunction readPointGeometry(object) {\n  var point;\n  if (object.m !== undefined && object.z !== undefined) {\n    point = new Point([object.x, object.y, object.z, object.m], 'XYZM');\n  } else if (object.z !== undefined) {\n    point = new Point([object.x, object.y, object.z], 'XYZ');\n  } else if (object.m !== undefined) {\n    point = new Point([object.x, object.y, object.m], 'XYM');\n  } else {\n    point = new Point([object.x, object.y]);\n  }\n  return point;\n}\n\n/**\n * @param {EsriJSONPolyline} object Object.\n * @return {import(\"../geom/Geometry.js\").default} LineString.\n */\nfunction readLineStringGeometry(object) {\n  var layout = getGeometryLayout(object);\n  return new LineString(object.paths[0], layout);\n}\n\n/**\n * @param {EsriJSONPolyline} object Object.\n * @return {import(\"../geom/Geometry.js\").default} MultiLineString.\n */\nfunction readMultiLineStringGeometry(object) {\n  var layout = getGeometryLayout(object);\n  return new MultiLineString(object.paths, layout);\n}\n\n/**\n * @param {EsriJSONHasZM} object Object.\n * @return {import(\"../geom/Geometry.js\").GeometryLayout} The geometry layout to use.\n */\nfunction getGeometryLayout(object) {\n  /** @type {import(\"../geom/Geometry.js\").GeometryLayout} */\n  var layout = 'XY';\n  if (object.hasZ === true && object.hasM === true) {\n    layout = 'XYZM';\n  } else if (object.hasZ === true) {\n    layout = 'XYZ';\n  } else if (object.hasM === true) {\n    layout = 'XYM';\n  }\n  return layout;\n}\n\n/**\n * @param {EsriJSONMultipoint} object Object.\n * @return {import(\"../geom/Geometry.js\").default} MultiPoint.\n */\nfunction readMultiPointGeometry(object) {\n  var layout = getGeometryLayout(object);\n  return new MultiPoint(object.points, layout);\n}\n\n/**\n * @param {EsriJSONMultiPolygon} object Object.\n * @return {import(\"../geom/Geometry.js\").default} MultiPolygon.\n */\nfunction readMultiPolygonGeometry(object) {\n  var layout = getGeometryLayout(object);\n  return new MultiPolygon(object.rings, layout);\n}\n\n/**\n * @param {EsriJSONPolygon} object Object.\n * @return {import(\"../geom/Geometry.js\").default} Polygon.\n */\nfunction readPolygonGeometry(object) {\n  var layout = getGeometryLayout(object);\n  return new Polygon(object.rings, layout);\n}\n\n/**\n * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {EsriJSONPoint} EsriJSON geometry.\n */\nfunction writePointGeometry(geometry, options) {\n  var coordinates = geometry.getCoordinates();\n  /** @type {EsriJSONPoint} */\n  var esriJSON;\n  var layout = geometry.getLayout();\n  if (layout === 'XYZ') {\n    esriJSON = {\n      x: coordinates[0],\n      y: coordinates[1],\n      z: coordinates[2]\n    };\n  } else if (layout === 'XYM') {\n    esriJSON = {\n      x: coordinates[0],\n      y: coordinates[1],\n      m: coordinates[2]\n    };\n  } else if (layout === 'XYZM') {\n    esriJSON = {\n      x: coordinates[0],\n      y: coordinates[1],\n      z: coordinates[2],\n      m: coordinates[3]\n    };\n  } else if (layout === 'XY') {\n    esriJSON = {\n      x: coordinates[0],\n      y: coordinates[1]\n    };\n  } else {\n    throw new Error('Invalid geometry layout');\n  }\n  return esriJSON;\n}\n\n/**\n * @param {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n * @return {Object} Object with boolean hasZ and hasM keys.\n */\nfunction getHasZM(geometry) {\n  var layout = geometry.getLayout();\n  return {\n    hasZ: layout === 'XYZ' || layout === 'XYZM',\n    hasM: layout === 'XYM' || layout === 'XYZM'\n  };\n}\n\n/**\n * @param {import(\"../geom/LineString.js\").default} lineString Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {EsriJSONPolyline} EsriJSON geometry.\n */\nfunction writeLineStringGeometry(lineString, options) {\n  var hasZM = getHasZM(lineString);\n  return {\n    hasZ: hasZM.hasZ,\n    hasM: hasZM.hasM,\n    paths: [(/** @type {Array<EsriJSONPosition>} */lineString.getCoordinates())]\n  };\n}\n\n/**\n * @param {import(\"../geom/Polygon.js\").default} polygon Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {EsriJSONPolygon} EsriJSON geometry.\n */\nfunction writePolygonGeometry(polygon, options) {\n  // Esri geometries use the left-hand rule\n  var hasZM = getHasZM(polygon);\n  return {\n    hasZ: hasZM.hasZ,\n    hasM: hasZM.hasM,\n    rings: (/** @type {Array<Array<EsriJSONPosition>>} */\n    polygon.getCoordinates(false))\n  };\n}\n\n/**\n * @param {import(\"../geom/MultiLineString.js\").default} multiLineString Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {EsriJSONPolyline} EsriJSON geometry.\n */\nfunction writeMultiLineStringGeometry(multiLineString, options) {\n  var hasZM = getHasZM(multiLineString);\n  return {\n    hasZ: hasZM.hasZ,\n    hasM: hasZM.hasM,\n    paths: (/** @type {Array<Array<EsriJSONPosition>>} */\n    multiLineString.getCoordinates())\n  };\n}\n\n/**\n * @param {import(\"../geom/MultiPoint.js\").default} multiPoint Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {EsriJSONMultipoint} EsriJSON geometry.\n */\nfunction writeMultiPointGeometry(multiPoint, options) {\n  var hasZM = getHasZM(multiPoint);\n  return {\n    hasZ: hasZM.hasZ,\n    hasM: hasZM.hasM,\n    points: (/** @type {Array<EsriJSONPosition>} */\n    multiPoint.getCoordinates())\n  };\n}\n\n/**\n * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {EsriJSONPolygon} EsriJSON geometry.\n */\nfunction writeMultiPolygonGeometry(geometry, options) {\n  var hasZM = getHasZM(geometry);\n  var coordinates = geometry.getCoordinates(false);\n  var output = [];\n  for (var i = 0; i < coordinates.length; i++) {\n    for (var x = coordinates[i].length - 1; x >= 0; x--) {\n      output.push(coordinates[i][x]);\n    }\n  }\n  return {\n    hasZ: hasZM.hasZ,\n    hasM: hasZM.hasM,\n    rings: (/** @type {Array<Array<EsriJSONPosition>>} */output)\n  };\n}\n\n/**\n * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {EsriJSONGeometry} EsriJSON geometry.\n */\nfunction writeGeometry(geometry, options) {\n  var geometryWriter = GEOMETRY_WRITERS[geometry.getType()];\n  return geometryWriter(transformGeometryWithOptions(geometry, true, options), options);\n}\nexport default EsriJSON;","map":{"version":3,"names":["Feature","JSONFeature","LineString","LinearRing","MultiLineString","MultiPoint","MultiPolygon","Point","Polygon","containsExtent","deflateCoordinates","get","getProjection","isEmpty","linearRingIsClockwise","transformGeometryWithOptions","GEOMETRY_READERS","readPointGeometry","readLineStringGeometry","readPolygonGeometry","readMultiPointGeometry","readMultiLineStringGeometry","readMultiPolygonGeometry","GEOMETRY_WRITERS","writePointGeometry","writeLineStringGeometry","writePolygonGeometry","writeMultiPointGeometry","writeMultiLineStringGeometry","writeMultiPolygonGeometry","EsriJSON","_JSONFeature","options","_this","_classCallCheck","_callSuper","geometryName_","geometryName","_inherits","_createClass","key","value","readFeatureFromObject","object","idField","esriJSONFeature","geometry","readGeometry","feature","setGeometryName","setGeometry","attributes","setProperties","id","undefined","setId","readFeaturesFromObject","esriJSONFeatureSet","features","esriJSONFeatures","i","ii","length","push","objectIdFieldName","readGeometryFromObject","readProjectionFromObject","spatialReference","crs","wkid","writeGeometryObject","writeGeometry","adaptOptions","writeFeatureObject","hasProperties","properties","getProperties","getGeometry","projection","dataProjection","featureProjection","Number","getCode","split","pop","getGeometryName","writeFeaturesObject","objects","type","esriJSONPolyline","paths","esriJSONPolygon","layout","getGeometryLayout","rings","convertRings","Object","assign","_defineProperty","geometryReader","flatRing","outerRings","holes","clockwise","hole","shift","matched","outerRing","containsHole","getExtent","reverse","point","m","z","x","y","hasZ","hasM","points","coordinates","getCoordinates","esriJSON","getLayout","Error","getHasZM","lineString","hasZM","polygon","multiLineString","multiPoint","output","geometryWriter","getType"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol/format/EsriJSON.js"],"sourcesContent":["/**\n * @module ol/format/EsriJSON\n */\nimport Feature from '../Feature.js';\nimport JSONFeature from './JSONFeature.js';\nimport LineString from '../geom/LineString.js';\nimport LinearRing from '../geom/LinearRing.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport {containsExtent} from '../extent.js';\nimport {deflateCoordinates} from '../geom/flat/deflate.js';\nimport {get as getProjection} from '../proj.js';\nimport {isEmpty} from '../obj.js';\nimport {linearRingIsClockwise} from '../geom/flat/orient.js';\nimport {transformGeometryWithOptions} from './Feature.js';\n\n/**\n * @typedef {import(\"arcgis-rest-api\").Feature} EsriJSONFeature\n * @typedef {import(\"arcgis-rest-api\").FeatureSet} EsriJSONFeatureSet\n * @typedef {import(\"arcgis-rest-api\").Geometry} EsriJSONGeometry\n * @typedef {import(\"arcgis-rest-api\").Point} EsriJSONPoint\n * @typedef {import(\"arcgis-rest-api\").Polyline} EsriJSONPolyline\n * @typedef {import(\"arcgis-rest-api\").Polygon} EsriJSONPolygon\n * @typedef {import(\"arcgis-rest-api\").Multipoint} EsriJSONMultipoint\n * @typedef {import(\"arcgis-rest-api\").HasZM} EsriJSONHasZM\n * @typedef {import(\"arcgis-rest-api\").Position} EsriJSONPosition\n * @typedef {import(\"arcgis-rest-api\").SpatialReferenceWkid} EsriJSONSpatialReferenceWkid\n */\n\n/**\n * @typedef {Object} EsriJSONMultiPolygon\n * @property {Array<Array<Array<Array<number>>>>} rings Rings for the MultiPolygon.\n * @property {boolean} [hasM] If the polygon coordinates have an M value.\n * @property {boolean} [hasZ] If the polygon coordinates have a Z value.\n * @property {EsriJSONSpatialReferenceWkid} [spatialReference] The coordinate reference system.\n */\n\n/**\n * @const\n * @type {Object<import(\"../geom/Geometry.js\").Type, function(EsriJSONGeometry): import(\"../geom/Geometry.js\").default>}\n */\nconst GEOMETRY_READERS = {\n  Point: readPointGeometry,\n  LineString: readLineStringGeometry,\n  Polygon: readPolygonGeometry,\n  MultiPoint: readMultiPointGeometry,\n  MultiLineString: readMultiLineStringGeometry,\n  MultiPolygon: readMultiPolygonGeometry,\n};\n\n/**\n * @const\n * @type {Object<import(\"../geom/Geometry.js\").Type, function(import(\"../geom/Geometry.js\").default, import(\"./Feature.js\").WriteOptions=): (EsriJSONGeometry)>}\n */\nconst GEOMETRY_WRITERS = {\n  Point: writePointGeometry,\n  LineString: writeLineStringGeometry,\n  Polygon: writePolygonGeometry,\n  MultiPoint: writeMultiPointGeometry,\n  MultiLineString: writeMultiLineStringGeometry,\n  MultiPolygon: writeMultiPolygonGeometry,\n};\n\n/**\n * @typedef {Object} Options\n * @property {string} [geometryName] Geometry name to use when creating features.\n */\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the EsriJSON format.\n *\n * @api\n */\nclass EsriJSON extends JSONFeature {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super();\n\n    /**\n     * Name of the geometry attribute for features.\n     * @type {string|undefined}\n     * @private\n     */\n    this.geometryName_ = options.geometryName;\n  }\n\n  /**\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @param {string} [idField] Name of the field where to get the id from.\n   * @protected\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromObject(object, options, idField) {\n    const esriJSONFeature = /** @type {EsriJSONFeature} */ (object);\n    const geometry = readGeometry(esriJSONFeature.geometry, options);\n    const feature = new Feature();\n    if (this.geometryName_) {\n      feature.setGeometryName(this.geometryName_);\n    }\n    feature.setGeometry(geometry);\n    if (esriJSONFeature.attributes) {\n      feature.setProperties(esriJSONFeature.attributes, true);\n      const id = esriJSONFeature.attributes[idField];\n      if (id !== undefined) {\n        feature.setId(/** @type {number} */ (id));\n      }\n    }\n    return feature;\n  }\n\n  /**\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<Feature>} Features.\n   */\n  readFeaturesFromObject(object, options) {\n    options = options ? options : {};\n    if (object['features']) {\n      const esriJSONFeatureSet = /** @type {EsriJSONFeatureSet} */ (object);\n      /** @type {Array<import(\"../Feature.js\").default>} */\n      const features = [];\n      const esriJSONFeatures = esriJSONFeatureSet.features;\n      for (let i = 0, ii = esriJSONFeatures.length; i < ii; ++i) {\n        features.push(\n          this.readFeatureFromObject(\n            esriJSONFeatures[i],\n            options,\n            object.objectIdFieldName\n          )\n        );\n      }\n      return features;\n    }\n    return [this.readFeatureFromObject(object, options)];\n  }\n\n  /**\n   * @param {EsriJSONGeometry} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromObject(object, options) {\n    return readGeometry(object, options);\n  }\n\n  /**\n   * @param {Object} object Object.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromObject(object) {\n    if (\n      object['spatialReference'] &&\n      object['spatialReference']['wkid'] !== undefined\n    ) {\n      const spatialReference = /** @type {EsriJSONSpatialReferenceWkid} */ (\n        object['spatialReference']\n      );\n      const crs = spatialReference.wkid;\n      return getProjection('EPSG:' + crs);\n    }\n    return null;\n  }\n\n  /**\n   * Encode a geometry as a EsriJSON object.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {EsriJSONGeometry} Object.\n   * @api\n   */\n  writeGeometryObject(geometry, options) {\n    return writeGeometry(geometry, this.adaptOptions(options));\n  }\n\n  /**\n   * Encode a feature as a esriJSON Feature object.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {Object} Object.\n   * @api\n   */\n  writeFeatureObject(feature, options) {\n    options = this.adaptOptions(options);\n    const object = {};\n    if (!feature.hasProperties()) {\n      object['attributes'] = {};\n      return object;\n    }\n    const properties = feature.getProperties();\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      object['geometry'] = writeGeometry(geometry, options);\n      const projection =\n        options && (options.dataProjection || options.featureProjection);\n      if (projection) {\n        object['geometry']['spatialReference'] =\n          /** @type {EsriJSONSpatialReferenceWkid} */ ({\n            wkid: Number(getProjection(projection).getCode().split(':').pop()),\n          });\n      }\n      delete properties[feature.getGeometryName()];\n    }\n    if (!isEmpty(properties)) {\n      object['attributes'] = properties;\n    } else {\n      object['attributes'] = {};\n    }\n    return object;\n  }\n\n  /**\n   * Encode an array of features as a EsriJSON object.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {EsriJSONFeatureSet} EsriJSON Object.\n   * @api\n   */\n  writeFeaturesObject(features, options) {\n    options = this.adaptOptions(options);\n    const objects = [];\n    for (let i = 0, ii = features.length; i < ii; ++i) {\n      objects.push(this.writeFeatureObject(features[i], options));\n    }\n    return {\n      'features': objects,\n    };\n  }\n}\n\n/**\n * @param {EsriJSONGeometry} object Object.\n * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n * @return {import(\"../geom/Geometry.js\").default} Geometry.\n */\nfunction readGeometry(object, options) {\n  if (!object) {\n    return null;\n  }\n  /** @type {import(\"../geom/Geometry.js\").Type} */\n  let type;\n  if (typeof object['x'] === 'number' && typeof object['y'] === 'number') {\n    type = 'Point';\n  } else if (object['points']) {\n    type = 'MultiPoint';\n  } else if (object['paths']) {\n    const esriJSONPolyline = /** @type {EsriJSONPolyline} */ (object);\n    if (esriJSONPolyline.paths.length === 1) {\n      type = 'LineString';\n    } else {\n      type = 'MultiLineString';\n    }\n  } else if (object['rings']) {\n    const esriJSONPolygon = /** @type {EsriJSONPolygon} */ (object);\n    const layout = getGeometryLayout(esriJSONPolygon);\n    const rings = convertRings(esriJSONPolygon.rings, layout);\n    if (rings.length === 1) {\n      type = 'Polygon';\n      object = Object.assign({}, object, {['rings']: rings[0]});\n    } else {\n      type = 'MultiPolygon';\n      object = Object.assign({}, object, {['rings']: rings});\n    }\n  }\n  const geometryReader = GEOMETRY_READERS[type];\n  return transformGeometryWithOptions(geometryReader(object), false, options);\n}\n\n/**\n * Determines inner and outer rings.\n * Checks if any polygons in this array contain any other polygons in this\n * array. It is used for checking for holes.\n * Logic inspired by: https://github.com/Esri/terraformer-arcgis-parser\n * @param {Array<!Array<!Array<number>>>} rings Rings.\n * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout Geometry layout.\n * @return {Array<!Array<!Array<!Array<number>>>>} Transformed rings.\n */\nfunction convertRings(rings, layout) {\n  const flatRing = [];\n  const outerRings = [];\n  const holes = [];\n  let i, ii;\n  for (i = 0, ii = rings.length; i < ii; ++i) {\n    flatRing.length = 0;\n    deflateCoordinates(flatRing, 0, rings[i], layout.length);\n    // is this ring an outer ring? is it clockwise?\n    const clockwise = linearRingIsClockwise(\n      flatRing,\n      0,\n      flatRing.length,\n      layout.length\n    );\n    if (clockwise) {\n      outerRings.push([rings[i]]);\n    } else {\n      holes.push(rings[i]);\n    }\n  }\n  while (holes.length) {\n    const hole = holes.shift();\n    let matched = false;\n    // loop over all outer rings and see if they contain our hole.\n    for (i = outerRings.length - 1; i >= 0; i--) {\n      const outerRing = outerRings[i][0];\n      const containsHole = containsExtent(\n        new LinearRing(outerRing).getExtent(),\n        new LinearRing(hole).getExtent()\n      );\n      if (containsHole) {\n        // the hole is contained push it into our polygon\n        outerRings[i].push(hole);\n        matched = true;\n        break;\n      }\n    }\n    if (!matched) {\n      // no outer rings contain this hole turn it into and outer\n      // ring (reverse it)\n      outerRings.push([hole.reverse()]);\n    }\n  }\n  return outerRings;\n}\n\n/**\n * @param {EsriJSONPoint} object Object.\n * @return {import(\"../geom/Geometry.js\").default} Point.\n */\nfunction readPointGeometry(object) {\n  let point;\n  if (object.m !== undefined && object.z !== undefined) {\n    point = new Point([object.x, object.y, object.z, object.m], 'XYZM');\n  } else if (object.z !== undefined) {\n    point = new Point([object.x, object.y, object.z], 'XYZ');\n  } else if (object.m !== undefined) {\n    point = new Point([object.x, object.y, object.m], 'XYM');\n  } else {\n    point = new Point([object.x, object.y]);\n  }\n  return point;\n}\n\n/**\n * @param {EsriJSONPolyline} object Object.\n * @return {import(\"../geom/Geometry.js\").default} LineString.\n */\nfunction readLineStringGeometry(object) {\n  const layout = getGeometryLayout(object);\n  return new LineString(object.paths[0], layout);\n}\n\n/**\n * @param {EsriJSONPolyline} object Object.\n * @return {import(\"../geom/Geometry.js\").default} MultiLineString.\n */\nfunction readMultiLineStringGeometry(object) {\n  const layout = getGeometryLayout(object);\n  return new MultiLineString(object.paths, layout);\n}\n\n/**\n * @param {EsriJSONHasZM} object Object.\n * @return {import(\"../geom/Geometry.js\").GeometryLayout} The geometry layout to use.\n */\nfunction getGeometryLayout(object) {\n  /** @type {import(\"../geom/Geometry.js\").GeometryLayout} */\n  let layout = 'XY';\n  if (object.hasZ === true && object.hasM === true) {\n    layout = 'XYZM';\n  } else if (object.hasZ === true) {\n    layout = 'XYZ';\n  } else if (object.hasM === true) {\n    layout = 'XYM';\n  }\n  return layout;\n}\n\n/**\n * @param {EsriJSONMultipoint} object Object.\n * @return {import(\"../geom/Geometry.js\").default} MultiPoint.\n */\nfunction readMultiPointGeometry(object) {\n  const layout = getGeometryLayout(object);\n  return new MultiPoint(object.points, layout);\n}\n\n/**\n * @param {EsriJSONMultiPolygon} object Object.\n * @return {import(\"../geom/Geometry.js\").default} MultiPolygon.\n */\nfunction readMultiPolygonGeometry(object) {\n  const layout = getGeometryLayout(object);\n  return new MultiPolygon(object.rings, layout);\n}\n\n/**\n * @param {EsriJSONPolygon} object Object.\n * @return {import(\"../geom/Geometry.js\").default} Polygon.\n */\nfunction readPolygonGeometry(object) {\n  const layout = getGeometryLayout(object);\n  return new Polygon(object.rings, layout);\n}\n\n/**\n * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {EsriJSONPoint} EsriJSON geometry.\n */\nfunction writePointGeometry(geometry, options) {\n  const coordinates = geometry.getCoordinates();\n  /** @type {EsriJSONPoint} */\n  let esriJSON;\n  const layout = geometry.getLayout();\n  if (layout === 'XYZ') {\n    esriJSON = {\n      x: coordinates[0],\n      y: coordinates[1],\n      z: coordinates[2],\n    };\n  } else if (layout === 'XYM') {\n    esriJSON = {\n      x: coordinates[0],\n      y: coordinates[1],\n      m: coordinates[2],\n    };\n  } else if (layout === 'XYZM') {\n    esriJSON = {\n      x: coordinates[0],\n      y: coordinates[1],\n      z: coordinates[2],\n      m: coordinates[3],\n    };\n  } else if (layout === 'XY') {\n    esriJSON = {\n      x: coordinates[0],\n      y: coordinates[1],\n    };\n  } else {\n    throw new Error('Invalid geometry layout');\n  }\n  return esriJSON;\n}\n\n/**\n * @param {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n * @return {Object} Object with boolean hasZ and hasM keys.\n */\nfunction getHasZM(geometry) {\n  const layout = geometry.getLayout();\n  return {\n    hasZ: layout === 'XYZ' || layout === 'XYZM',\n    hasM: layout === 'XYM' || layout === 'XYZM',\n  };\n}\n\n/**\n * @param {import(\"../geom/LineString.js\").default} lineString Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {EsriJSONPolyline} EsriJSON geometry.\n */\nfunction writeLineStringGeometry(lineString, options) {\n  const hasZM = getHasZM(lineString);\n  return {\n    hasZ: hasZM.hasZ,\n    hasM: hasZM.hasM,\n    paths: [\n      /** @type {Array<EsriJSONPosition>} */ (lineString.getCoordinates()),\n    ],\n  };\n}\n\n/**\n * @param {import(\"../geom/Polygon.js\").default} polygon Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {EsriJSONPolygon} EsriJSON geometry.\n */\nfunction writePolygonGeometry(polygon, options) {\n  // Esri geometries use the left-hand rule\n  const hasZM = getHasZM(polygon);\n  return {\n    hasZ: hasZM.hasZ,\n    hasM: hasZM.hasM,\n    rings: /** @type {Array<Array<EsriJSONPosition>>} */ (\n      polygon.getCoordinates(false)\n    ),\n  };\n}\n\n/**\n * @param {import(\"../geom/MultiLineString.js\").default} multiLineString Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {EsriJSONPolyline} EsriJSON geometry.\n */\nfunction writeMultiLineStringGeometry(multiLineString, options) {\n  const hasZM = getHasZM(multiLineString);\n  return {\n    hasZ: hasZM.hasZ,\n    hasM: hasZM.hasM,\n    paths: /** @type {Array<Array<EsriJSONPosition>>} */ (\n      multiLineString.getCoordinates()\n    ),\n  };\n}\n\n/**\n * @param {import(\"../geom/MultiPoint.js\").default} multiPoint Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {EsriJSONMultipoint} EsriJSON geometry.\n */\nfunction writeMultiPointGeometry(multiPoint, options) {\n  const hasZM = getHasZM(multiPoint);\n  return {\n    hasZ: hasZM.hasZ,\n    hasM: hasZM.hasM,\n    points: /** @type {Array<EsriJSONPosition>} */ (\n      multiPoint.getCoordinates()\n    ),\n  };\n}\n\n/**\n * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {EsriJSONPolygon} EsriJSON geometry.\n */\nfunction writeMultiPolygonGeometry(geometry, options) {\n  const hasZM = getHasZM(geometry);\n  const coordinates = geometry.getCoordinates(false);\n  const output = [];\n  for (let i = 0; i < coordinates.length; i++) {\n    for (let x = coordinates[i].length - 1; x >= 0; x--) {\n      output.push(coordinates[i][x]);\n    }\n  }\n  return {\n    hasZ: hasZM.hasZ,\n    hasM: hasZM.hasM,\n    rings: /** @type {Array<Array<EsriJSONPosition>>} */ (output),\n  };\n}\n\n/**\n * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {EsriJSONGeometry} EsriJSON geometry.\n */\nfunction writeGeometry(geometry, options) {\n  const geometryWriter = GEOMETRY_WRITERS[geometry.getType()];\n  return geometryWriter(\n    transformGeometryWithOptions(geometry, true, options),\n    options\n  );\n}\n\nexport default EsriJSON;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}