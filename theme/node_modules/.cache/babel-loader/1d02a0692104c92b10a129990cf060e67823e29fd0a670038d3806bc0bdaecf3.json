{"ast":null,"code":"import _callSuper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _classCallCheck from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.parse-float.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.match.js\";\n/**\n * @module ol/format/WKT\n */\nimport Feature from '../Feature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport TextFeature from './TextFeature.js';\nimport { transformGeometryWithOptions } from './Feature.js';\n\n/**\n * Geometry constructors\n * @enum {function (new:import(\"../geom/Geometry.js\").default, Array, import(\"../geom/Geometry.js\").GeometryLayout)}\n */\nvar GeometryConstructor = {\n  'POINT': Point,\n  'LINESTRING': LineString,\n  'POLYGON': Polygon,\n  'MULTIPOINT': MultiPoint,\n  'MULTILINESTRING': MultiLineString,\n  'MULTIPOLYGON': MultiPolygon\n};\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into\n * multiple features on reading.\n */\n\n/**\n * @typedef {Object} Token\n * @property {number} type Type.\n * @property {number|string} [value] Value.\n * @property {number} position Position.\n */\n\n/**\n * @const\n * @type {string}\n */\nvar EMPTY = 'EMPTY';\n\n/**\n * @const\n * @type {string}\n */\nvar Z = 'Z';\n\n/**\n * @const\n * @type {string}\n */\nvar M = 'M';\n\n/**\n * @const\n * @type {string}\n */\nvar ZM = 'ZM';\n\n/**\n * @const\n * @enum {number}\n */\nvar TokenType = {\n  START: 0,\n  TEXT: 1,\n  LEFT_PAREN: 2,\n  RIGHT_PAREN: 3,\n  NUMBER: 4,\n  COMMA: 5,\n  EOF: 6\n};\n\n/**\n * @type {Object<import(\"../geom/Geometry.js\").Type, string>}\n */\nvar wktTypeLookup = {\n  Point: 'POINT',\n  LineString: 'LINESTRING',\n  Polygon: 'POLYGON',\n  MultiPoint: 'MULTIPOINT',\n  MultiLineString: 'MULTILINESTRING',\n  MultiPolygon: 'MULTIPOLYGON',\n  GeometryCollection: 'GEOMETRYCOLLECTION',\n  Circle: 'CIRCLE'\n};\n\n/**\n * Class to tokenize a WKT string.\n */\nvar Lexer = /*#__PURE__*/function () {\n  /**\n   * @param {string} wkt WKT string.\n   */\n  function Lexer(wkt) {\n    _classCallCheck(this, Lexer);\n    /**\n     * @type {string}\n     */\n    this.wkt = wkt;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.index_ = -1;\n  }\n\n  /**\n   * @param {string} c Character.\n   * @return {boolean} Whether the character is alphabetic.\n   * @private\n   */\n  return _createClass(Lexer, [{\n    key: \"isAlpha_\",\n    value: function isAlpha_(c) {\n      return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z';\n    }\n\n    /**\n     * @param {string} c Character.\n     * @param {boolean} [decimal] Whether the string number\n     *     contains a dot, i.e. is a decimal number.\n     * @return {boolean} Whether the character is numeric.\n     * @private\n     */\n  }, {\n    key: \"isNumeric_\",\n    value: function isNumeric_(c, decimal) {\n      decimal = decimal !== undefined ? decimal : false;\n      return c >= '0' && c <= '9' || c == '.' && !decimal;\n    }\n\n    /**\n     * @param {string} c Character.\n     * @return {boolean} Whether the character is whitespace.\n     * @private\n     */\n  }, {\n    key: \"isWhiteSpace_\",\n    value: function isWhiteSpace_(c) {\n      return c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n    }\n\n    /**\n     * @return {string} Next string character.\n     * @private\n     */\n  }, {\n    key: \"nextChar_\",\n    value: function nextChar_() {\n      return this.wkt.charAt(++this.index_);\n    }\n\n    /**\n     * Fetch and return the next token.\n     * @return {Token} Next string token.\n     */\n  }, {\n    key: \"nextToken\",\n    value: function nextToken() {\n      var c = this.nextChar_();\n      var position = this.index_;\n      /** @type {number|string} */\n      var value = c;\n      var type;\n      if (c == '(') {\n        type = TokenType.LEFT_PAREN;\n      } else if (c == ',') {\n        type = TokenType.COMMA;\n      } else if (c == ')') {\n        type = TokenType.RIGHT_PAREN;\n      } else if (this.isNumeric_(c) || c == '-') {\n        type = TokenType.NUMBER;\n        value = this.readNumber_();\n      } else if (this.isAlpha_(c)) {\n        type = TokenType.TEXT;\n        value = this.readText_();\n      } else if (this.isWhiteSpace_(c)) {\n        return this.nextToken();\n      } else if (c === '') {\n        type = TokenType.EOF;\n      } else {\n        throw new Error('Unexpected character: ' + c);\n      }\n      return {\n        position: position,\n        value: value,\n        type: type\n      };\n    }\n\n    /**\n     * @return {number} Numeric token value.\n     * @private\n     */\n  }, {\n    key: \"readNumber_\",\n    value: function readNumber_() {\n      var c;\n      var index = this.index_;\n      var decimal = false;\n      var scientificNotation = false;\n      do {\n        if (c == '.') {\n          decimal = true;\n        } else if (c == 'e' || c == 'E') {\n          scientificNotation = true;\n        }\n        c = this.nextChar_();\n      } while (this.isNumeric_(c, decimal) ||\n      // if we haven't detected a scientific number before, 'e' or 'E'\n      // hint that we should continue to read\n      !scientificNotation && (c == 'e' || c == 'E') ||\n      // once we know that we have a scientific number, both '-' and '+'\n      // are allowed\n      scientificNotation && (c == '-' || c == '+'));\n      return parseFloat(this.wkt.substring(index, this.index_--));\n    }\n\n    /**\n     * @return {string} String token value.\n     * @private\n     */\n  }, {\n    key: \"readText_\",\n    value: function readText_() {\n      var c;\n      var index = this.index_;\n      do {\n        c = this.nextChar_();\n      } while (this.isAlpha_(c));\n      return this.wkt.substring(index, this.index_--).toUpperCase();\n    }\n  }]);\n}();\n/**\n * Class to parse the tokens from the WKT string.\n */\nvar Parser = /*#__PURE__*/function () {\n  /**\n   * @param {Lexer} lexer The lexer.\n   */\n  function Parser(lexer) {\n    _classCallCheck(this, Parser);\n    /**\n     * @type {Lexer}\n     * @private\n     */\n    this.lexer_ = lexer;\n\n    /**\n     * @type {Token}\n     * @private\n     */\n    this.token_ = {\n      position: 0,\n      type: TokenType.START\n    };\n\n    /**\n     * @type {import(\"../geom/Geometry.js\").GeometryLayout}\n     * @private\n     */\n    this.layout_ = 'XY';\n  }\n\n  /**\n   * Fetch the next token form the lexer and replace the active token.\n   * @private\n   */\n  return _createClass(Parser, [{\n    key: \"consume_\",\n    value: function consume_() {\n      this.token_ = this.lexer_.nextToken();\n    }\n\n    /**\n     * Tests if the given type matches the type of the current token.\n     * @param {TokenType} type Token type.\n     * @return {boolean} Whether the token matches the given type.\n     */\n  }, {\n    key: \"isTokenType\",\n    value: function isTokenType(type) {\n      return this.token_.type == type;\n    }\n\n    /**\n     * If the given type matches the current token, consume it.\n     * @param {TokenType} type Token type.\n     * @return {boolean} Whether the token matches the given type.\n     */\n  }, {\n    key: \"match\",\n    value: function match(type) {\n      var isMatch = this.isTokenType(type);\n      if (isMatch) {\n        this.consume_();\n      }\n      return isMatch;\n    }\n\n    /**\n     * Try to parse the tokens provided by the lexer.\n     * @return {import(\"../geom/Geometry.js\").default} The geometry.\n     */\n  }, {\n    key: \"parse\",\n    value: function parse() {\n      this.consume_();\n      return this.parseGeometry_();\n    }\n\n    /**\n     * Try to parse the dimensional info.\n     * @return {import(\"../geom/Geometry.js\").GeometryLayout} The layout.\n     * @private\n     */\n  }, {\n    key: \"parseGeometryLayout_\",\n    value: function parseGeometryLayout_() {\n      /** @type {import(\"../geom/Geometry.js\").GeometryLayout} */\n      var layout = 'XY';\n      var dimToken = this.token_;\n      if (this.isTokenType(TokenType.TEXT)) {\n        var dimInfo = dimToken.value;\n        if (dimInfo === Z) {\n          layout = 'XYZ';\n        } else if (dimInfo === M) {\n          layout = 'XYM';\n        } else if (dimInfo === ZM) {\n          layout = 'XYZM';\n        }\n        if (layout !== 'XY') {\n          this.consume_();\n        }\n      }\n      return layout;\n    }\n\n    /**\n     * @return {Array<import(\"../geom/Geometry.js\").default>} A collection of geometries.\n     * @private\n     */\n  }, {\n    key: \"parseGeometryCollectionText_\",\n    value: function parseGeometryCollectionText_() {\n      if (this.match(TokenType.LEFT_PAREN)) {\n        var geometries = [];\n        do {\n          geometries.push(this.parseGeometry_());\n        } while (this.match(TokenType.COMMA));\n        if (this.match(TokenType.RIGHT_PAREN)) {\n          return geometries;\n        }\n      }\n      throw new Error(this.formatErrorMessage_());\n    }\n\n    /**\n     * @return {Array<number>} All values in a point.\n     * @private\n     */\n  }, {\n    key: \"parsePointText_\",\n    value: function parsePointText_() {\n      if (this.match(TokenType.LEFT_PAREN)) {\n        var coordinates = this.parsePoint_();\n        if (this.match(TokenType.RIGHT_PAREN)) {\n          return coordinates;\n        }\n      }\n      throw new Error(this.formatErrorMessage_());\n    }\n\n    /**\n     * @return {Array<Array<number>>} All points in a linestring.\n     * @private\n     */\n  }, {\n    key: \"parseLineStringText_\",\n    value: function parseLineStringText_() {\n      if (this.match(TokenType.LEFT_PAREN)) {\n        var coordinates = this.parsePointList_();\n        if (this.match(TokenType.RIGHT_PAREN)) {\n          return coordinates;\n        }\n      }\n      throw new Error(this.formatErrorMessage_());\n    }\n\n    /**\n     * @return {Array<Array<Array<number>>>} All points in a polygon.\n     * @private\n     */\n  }, {\n    key: \"parsePolygonText_\",\n    value: function parsePolygonText_() {\n      if (this.match(TokenType.LEFT_PAREN)) {\n        var coordinates = this.parseLineStringTextList_();\n        if (this.match(TokenType.RIGHT_PAREN)) {\n          return coordinates;\n        }\n      }\n      throw new Error(this.formatErrorMessage_());\n    }\n\n    /**\n     * @return {Array<Array<number>>} All points in a multipoint.\n     * @private\n     */\n  }, {\n    key: \"parseMultiPointText_\",\n    value: function parseMultiPointText_() {\n      if (this.match(TokenType.LEFT_PAREN)) {\n        var coordinates;\n        if (this.token_.type == TokenType.LEFT_PAREN) {\n          coordinates = this.parsePointTextList_();\n        } else {\n          coordinates = this.parsePointList_();\n        }\n        if (this.match(TokenType.RIGHT_PAREN)) {\n          return coordinates;\n        }\n      }\n      throw new Error(this.formatErrorMessage_());\n    }\n\n    /**\n     * @return {Array<Array<Array<number>>>} All linestring points\n     *                                          in a multilinestring.\n     * @private\n     */\n  }, {\n    key: \"parseMultiLineStringText_\",\n    value: function parseMultiLineStringText_() {\n      if (this.match(TokenType.LEFT_PAREN)) {\n        var coordinates = this.parseLineStringTextList_();\n        if (this.match(TokenType.RIGHT_PAREN)) {\n          return coordinates;\n        }\n      }\n      throw new Error(this.formatErrorMessage_());\n    }\n\n    /**\n     * @return {Array<Array<Array<Array<number>>>>} All polygon points in a multipolygon.\n     * @private\n     */\n  }, {\n    key: \"parseMultiPolygonText_\",\n    value: function parseMultiPolygonText_() {\n      if (this.match(TokenType.LEFT_PAREN)) {\n        var coordinates = this.parsePolygonTextList_();\n        if (this.match(TokenType.RIGHT_PAREN)) {\n          return coordinates;\n        }\n      }\n      throw new Error(this.formatErrorMessage_());\n    }\n\n    /**\n     * @return {Array<number>} A point.\n     * @private\n     */\n  }, {\n    key: \"parsePoint_\",\n    value: function parsePoint_() {\n      var coordinates = [];\n      var dimensions = this.layout_.length;\n      for (var i = 0; i < dimensions; ++i) {\n        var token = this.token_;\n        if (this.match(TokenType.NUMBER)) {\n          coordinates.push(/** @type {number} */token.value);\n        } else {\n          break;\n        }\n      }\n      if (coordinates.length == dimensions) {\n        return coordinates;\n      }\n      throw new Error(this.formatErrorMessage_());\n    }\n\n    /**\n     * @return {Array<Array<number>>} An array of points.\n     * @private\n     */\n  }, {\n    key: \"parsePointList_\",\n    value: function parsePointList_() {\n      var coordinates = [this.parsePoint_()];\n      while (this.match(TokenType.COMMA)) {\n        coordinates.push(this.parsePoint_());\n      }\n      return coordinates;\n    }\n\n    /**\n     * @return {Array<Array<number>>} An array of points.\n     * @private\n     */\n  }, {\n    key: \"parsePointTextList_\",\n    value: function parsePointTextList_() {\n      var coordinates = [this.parsePointText_()];\n      while (this.match(TokenType.COMMA)) {\n        coordinates.push(this.parsePointText_());\n      }\n      return coordinates;\n    }\n\n    /**\n     * @return {Array<Array<Array<number>>>} An array of points.\n     * @private\n     */\n  }, {\n    key: \"parseLineStringTextList_\",\n    value: function parseLineStringTextList_() {\n      var coordinates = [this.parseLineStringText_()];\n      while (this.match(TokenType.COMMA)) {\n        coordinates.push(this.parseLineStringText_());\n      }\n      return coordinates;\n    }\n\n    /**\n     * @return {Array<Array<Array<Array<number>>>>} An array of points.\n     * @private\n     */\n  }, {\n    key: \"parsePolygonTextList_\",\n    value: function parsePolygonTextList_() {\n      var coordinates = [this.parsePolygonText_()];\n      while (this.match(TokenType.COMMA)) {\n        coordinates.push(this.parsePolygonText_());\n      }\n      return coordinates;\n    }\n\n    /**\n     * @return {boolean} Whether the token implies an empty geometry.\n     * @private\n     */\n  }, {\n    key: \"isEmptyGeometry_\",\n    value: function isEmptyGeometry_() {\n      var isEmpty = this.isTokenType(TokenType.TEXT) && this.token_.value == EMPTY;\n      if (isEmpty) {\n        this.consume_();\n      }\n      return isEmpty;\n    }\n\n    /**\n     * Create an error message for an unexpected token error.\n     * @return {string} Error message.\n     * @private\n     */\n  }, {\n    key: \"formatErrorMessage_\",\n    value: function formatErrorMessage_() {\n      return 'Unexpected `' + this.token_.value + '` at position ' + this.token_.position + ' in `' + this.lexer_.wkt + '`';\n    }\n\n    /**\n     * @return {import(\"../geom/Geometry.js\").default} The geometry.\n     * @private\n     */\n  }, {\n    key: \"parseGeometry_\",\n    value: function parseGeometry_() {\n      var token = this.token_;\n      if (this.match(TokenType.TEXT)) {\n        var geomType = /** @type {string} */token.value;\n        this.layout_ = this.parseGeometryLayout_();\n        var isEmpty = this.isEmptyGeometry_();\n        if (geomType == 'GEOMETRYCOLLECTION') {\n          if (isEmpty) {\n            return new GeometryCollection([]);\n          }\n          var geometries = this.parseGeometryCollectionText_();\n          return new GeometryCollection(geometries);\n        }\n        var ctor = GeometryConstructor[geomType];\n        if (!ctor) {\n          throw new Error('Invalid geometry type: ' + geomType);\n        }\n        var coordinates;\n        if (isEmpty) {\n          if (geomType == 'POINT') {\n            coordinates = [NaN, NaN];\n          } else {\n            coordinates = [];\n          }\n        } else {\n          switch (geomType) {\n            case 'POINT':\n              {\n                coordinates = this.parsePointText_();\n                break;\n              }\n            case 'LINESTRING':\n              {\n                coordinates = this.parseLineStringText_();\n                break;\n              }\n            case 'POLYGON':\n              {\n                coordinates = this.parsePolygonText_();\n                break;\n              }\n            case 'MULTIPOINT':\n              {\n                coordinates = this.parseMultiPointText_();\n                break;\n              }\n            case 'MULTILINESTRING':\n              {\n                coordinates = this.parseMultiLineStringText_();\n                break;\n              }\n            case 'MULTIPOLYGON':\n              {\n                coordinates = this.parseMultiPolygonText_();\n                break;\n              }\n            default:\n              break;\n          }\n        }\n        return new ctor(coordinates, this.layout_);\n      }\n      throw new Error(this.formatErrorMessage_());\n    }\n  }]);\n}();\n/**\n * @classdesc\n * Geometry format for reading and writing data in the `WellKnownText` (WKT)\n * format.\n *\n * @api\n */\nvar WKT = /*#__PURE__*/function (_TextFeature) {\n  /**\n   * @param {Options} [options] Options.\n   */\n  function WKT(options) {\n    var _this;\n    _classCallCheck(this, WKT);\n    _this = _callSuper(this, WKT);\n    options = options ? options : {};\n\n    /**\n     * Split GeometryCollection into multiple features.\n     * @type {boolean}\n     * @private\n     */\n    _this.splitCollection_ = options.splitCollection !== undefined ? options.splitCollection : false;\n    return _this;\n  }\n\n  /**\n   * Parse a WKT string.\n   * @param {string} wkt WKT string.\n   * @return {import(\"../geom/Geometry.js\").default}\n   *     The geometry created.\n   * @private\n   */\n  _inherits(WKT, _TextFeature);\n  return _createClass(WKT, [{\n    key: \"parse_\",\n    value: function parse_(wkt) {\n      var lexer = new Lexer(wkt);\n      var parser = new Parser(lexer);\n      return parser.parse();\n    }\n\n    /**\n     * @protected\n     * @param {string} text Text.\n     * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n     * @return {import(\"../Feature.js\").default} Feature.\n     */\n  }, {\n    key: \"readFeatureFromText\",\n    value: function readFeatureFromText(text, options) {\n      var geom = this.readGeometryFromText(text, options);\n      var feature = new Feature();\n      feature.setGeometry(geom);\n      return feature;\n    }\n\n    /**\n     * @param {string} text Text.\n     * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n     * @protected\n     * @return {Array<Feature>} Features.\n     */\n  }, {\n    key: \"readFeaturesFromText\",\n    value: function readFeaturesFromText(text, options) {\n      var geometries = [];\n      var geometry = this.readGeometryFromText(text, options);\n      if (this.splitCollection_ && geometry.getType() == 'GeometryCollection') {\n        geometries = /** @type {GeometryCollection} */geometry.getGeometriesArray();\n      } else {\n        geometries = [geometry];\n      }\n      var features = [];\n      for (var i = 0, ii = geometries.length; i < ii; ++i) {\n        var feature = new Feature();\n        feature.setGeometry(geometries[i]);\n        features.push(feature);\n      }\n      return features;\n    }\n\n    /**\n     * @param {string} text Text.\n     * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n     * @protected\n     * @return {import(\"../geom/Geometry.js\").default} Geometry.\n     */\n  }, {\n    key: \"readGeometryFromText\",\n    value: function readGeometryFromText(text, options) {\n      var geometry = this.parse_(text);\n      return transformGeometryWithOptions(geometry, false, options);\n    }\n\n    /**\n     * @param {import(\"../Feature.js\").default} feature Features.\n     * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n     * @protected\n     * @return {string} Text.\n     */\n  }, {\n    key: \"writeFeatureText\",\n    value: function writeFeatureText(feature, options) {\n      var geometry = feature.getGeometry();\n      if (geometry) {\n        return this.writeGeometryText(geometry, options);\n      }\n      return '';\n    }\n\n    /**\n     * @param {Array<import(\"../Feature.js\").default>} features Features.\n     * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n     * @protected\n     * @return {string} Text.\n     */\n  }, {\n    key: \"writeFeaturesText\",\n    value: function writeFeaturesText(features, options) {\n      if (features.length == 1) {\n        return this.writeFeatureText(features[0], options);\n      }\n      var geometries = [];\n      for (var i = 0, ii = features.length; i < ii; ++i) {\n        geometries.push(features[i].getGeometry());\n      }\n      var collection = new GeometryCollection(geometries);\n      return this.writeGeometryText(collection, options);\n    }\n\n    /**\n     * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n     * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n     * @protected\n     * @return {string} Text.\n     */\n  }, {\n    key: \"writeGeometryText\",\n    value: function writeGeometryText(geometry, options) {\n      return encode(transformGeometryWithOptions(geometry, true, options));\n    }\n  }]);\n}(TextFeature);\n/**\n * @param {Point} geom Point geometry.\n * @return {string} Coordinates part of Point as WKT.\n */\nfunction encodePointGeometry(geom) {\n  var coordinates = geom.getCoordinates();\n  if (coordinates.length === 0) {\n    return '';\n  }\n  return coordinates.join(' ');\n}\n\n/**\n * @param {MultiPoint} geom MultiPoint geometry.\n * @return {string} Coordinates part of MultiPoint as WKT.\n */\nfunction encodeMultiPointGeometry(geom) {\n  var array = [];\n  var components = geom.getPoints();\n  for (var i = 0, ii = components.length; i < ii; ++i) {\n    array.push('(' + encodePointGeometry(components[i]) + ')');\n  }\n  return array.join(',');\n}\n\n/**\n * @param {GeometryCollection} geom GeometryCollection geometry.\n * @return {string} Coordinates part of GeometryCollection as WKT.\n */\nfunction encodeGeometryCollectionGeometry(geom) {\n  var array = [];\n  var geoms = geom.getGeometries();\n  for (var i = 0, ii = geoms.length; i < ii; ++i) {\n    array.push(encode(geoms[i]));\n  }\n  return array.join(',');\n}\n\n/**\n * @param {LineString|import(\"../geom/LinearRing.js\").default} geom LineString geometry.\n * @return {string} Coordinates part of LineString as WKT.\n */\nfunction encodeLineStringGeometry(geom) {\n  var coordinates = geom.getCoordinates();\n  var array = [];\n  for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n    array.push(coordinates[i].join(' '));\n  }\n  return array.join(',');\n}\n\n/**\n * @param {MultiLineString} geom MultiLineString geometry.\n * @return {string} Coordinates part of MultiLineString as WKT.\n */\nfunction encodeMultiLineStringGeometry(geom) {\n  var array = [];\n  var components = geom.getLineStrings();\n  for (var i = 0, ii = components.length; i < ii; ++i) {\n    array.push('(' + encodeLineStringGeometry(components[i]) + ')');\n  }\n  return array.join(',');\n}\n\n/**\n * @param {Polygon} geom Polygon geometry.\n * @return {string} Coordinates part of Polygon as WKT.\n */\nfunction encodePolygonGeometry(geom) {\n  var array = [];\n  var rings = geom.getLinearRings();\n  for (var i = 0, ii = rings.length; i < ii; ++i) {\n    array.push('(' + encodeLineStringGeometry(rings[i]) + ')');\n  }\n  return array.join(',');\n}\n\n/**\n * @param {MultiPolygon} geom MultiPolygon geometry.\n * @return {string} Coordinates part of MultiPolygon as WKT.\n */\nfunction encodeMultiPolygonGeometry(geom) {\n  var array = [];\n  var components = geom.getPolygons();\n  for (var i = 0, ii = components.length; i < ii; ++i) {\n    array.push('(' + encodePolygonGeometry(components[i]) + ')');\n  }\n  return array.join(',');\n}\n\n/**\n * @param {import(\"../geom/SimpleGeometry.js\").default} geom SimpleGeometry geometry.\n * @return {string} Potential dimensional information for WKT type.\n */\nfunction encodeGeometryLayout(geom) {\n  var layout = geom.getLayout();\n  var dimInfo = '';\n  if (layout === 'XYZ' || layout === 'XYZM') {\n    dimInfo += Z;\n  }\n  if (layout === 'XYM' || layout === 'XYZM') {\n    dimInfo += M;\n  }\n  return dimInfo;\n}\n\n/**\n * @const\n * @type {Object<string, function(import(\"../geom/Geometry.js\").default): string>}\n */\nvar GeometryEncoder = {\n  'Point': encodePointGeometry,\n  'LineString': encodeLineStringGeometry,\n  'Polygon': encodePolygonGeometry,\n  'MultiPoint': encodeMultiPointGeometry,\n  'MultiLineString': encodeMultiLineStringGeometry,\n  'MultiPolygon': encodeMultiPolygonGeometry,\n  'GeometryCollection': encodeGeometryCollectionGeometry\n};\n\n/**\n * Encode a geometry as WKT.\n * @param {import(\"../geom/Geometry.js\").default} geom The geometry to encode.\n * @return {string} WKT string for the geometry.\n */\nfunction encode(geom) {\n  var type = geom.getType();\n  var geometryEncoder = GeometryEncoder[type];\n  var enc = geometryEncoder(geom);\n  var wktType = wktTypeLookup[type];\n  if (typeof (/** @type {?} */geom.getFlatCoordinates) === 'function') {\n    var dimInfo = encodeGeometryLayout(/** @type {import(\"../geom/SimpleGeometry.js\").default} */geom);\n    if (dimInfo.length > 0) {\n      wktType += ' ' + dimInfo;\n    }\n  }\n  if (enc.length === 0) {\n    return wktType + ' ' + EMPTY;\n  }\n  return wktType + '(' + enc + ')';\n}\nexport default WKT;","map":{"version":3,"names":["Feature","GeometryCollection","LineString","MultiLineString","MultiPoint","MultiPolygon","Point","Polygon","TextFeature","transformGeometryWithOptions","GeometryConstructor","EMPTY","Z","M","ZM","TokenType","START","TEXT","LEFT_PAREN","RIGHT_PAREN","NUMBER","COMMA","EOF","wktTypeLookup","Circle","Lexer","wkt","_classCallCheck","index_","_createClass","key","value","isAlpha_","c","isNumeric_","decimal","undefined","isWhiteSpace_","nextChar_","charAt","nextToken","position","type","readNumber_","readText_","Error","index","scientificNotation","parseFloat","substring","toUpperCase","Parser","lexer","lexer_","token_","layout_","consume_","isTokenType","match","isMatch","parse","parseGeometry_","parseGeometryLayout_","layout","dimToken","dimInfo","parseGeometryCollectionText_","geometries","push","formatErrorMessage_","parsePointText_","coordinates","parsePoint_","parseLineStringText_","parsePointList_","parsePolygonText_","parseLineStringTextList_","parseMultiPointText_","parsePointTextList_","parseMultiLineStringText_","parseMultiPolygonText_","parsePolygonTextList_","dimensions","length","i","token","isEmptyGeometry_","isEmpty","geomType","ctor","NaN","WKT","_TextFeature","options","_this","_callSuper","splitCollection_","splitCollection","_inherits","parse_","parser","readFeatureFromText","text","geom","readGeometryFromText","feature","setGeometry","readFeaturesFromText","geometry","getType","getGeometriesArray","features","ii","writeFeatureText","getGeometry","writeGeometryText","writeFeaturesText","collection","encode","encodePointGeometry","getCoordinates","join","encodeMultiPointGeometry","array","components","getPoints","encodeGeometryCollectionGeometry","geoms","getGeometries","encodeLineStringGeometry","encodeMultiLineStringGeometry","getLineStrings","encodePolygonGeometry","rings","getLinearRings","encodeMultiPolygonGeometry","getPolygons","encodeGeometryLayout","getLayout","GeometryEncoder","geometryEncoder","enc","wktType","getFlatCoordinates"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol/format/WKT.js"],"sourcesContent":["/**\n * @module ol/format/WKT\n */\nimport Feature from '../Feature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport TextFeature from './TextFeature.js';\nimport {transformGeometryWithOptions} from './Feature.js';\n\n/**\n * Geometry constructors\n * @enum {function (new:import(\"../geom/Geometry.js\").default, Array, import(\"../geom/Geometry.js\").GeometryLayout)}\n */\nconst GeometryConstructor = {\n  'POINT': Point,\n  'LINESTRING': LineString,\n  'POLYGON': Polygon,\n  'MULTIPOINT': MultiPoint,\n  'MULTILINESTRING': MultiLineString,\n  'MULTIPOLYGON': MultiPolygon,\n};\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into\n * multiple features on reading.\n */\n\n/**\n * @typedef {Object} Token\n * @property {number} type Type.\n * @property {number|string} [value] Value.\n * @property {number} position Position.\n */\n\n/**\n * @const\n * @type {string}\n */\nconst EMPTY = 'EMPTY';\n\n/**\n * @const\n * @type {string}\n */\nconst Z = 'Z';\n\n/**\n * @const\n * @type {string}\n */\nconst M = 'M';\n\n/**\n * @const\n * @type {string}\n */\nconst ZM = 'ZM';\n\n/**\n * @const\n * @enum {number}\n */\nconst TokenType = {\n  START: 0,\n  TEXT: 1,\n  LEFT_PAREN: 2,\n  RIGHT_PAREN: 3,\n  NUMBER: 4,\n  COMMA: 5,\n  EOF: 6,\n};\n\n/**\n * @type {Object<import(\"../geom/Geometry.js\").Type, string>}\n */\nconst wktTypeLookup = {\n  Point: 'POINT',\n  LineString: 'LINESTRING',\n  Polygon: 'POLYGON',\n  MultiPoint: 'MULTIPOINT',\n  MultiLineString: 'MULTILINESTRING',\n  MultiPolygon: 'MULTIPOLYGON',\n  GeometryCollection: 'GEOMETRYCOLLECTION',\n  Circle: 'CIRCLE',\n};\n\n/**\n * Class to tokenize a WKT string.\n */\nclass Lexer {\n  /**\n   * @param {string} wkt WKT string.\n   */\n  constructor(wkt) {\n    /**\n     * @type {string}\n     */\n    this.wkt = wkt;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.index_ = -1;\n  }\n\n  /**\n   * @param {string} c Character.\n   * @return {boolean} Whether the character is alphabetic.\n   * @private\n   */\n  isAlpha_(c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n  }\n\n  /**\n   * @param {string} c Character.\n   * @param {boolean} [decimal] Whether the string number\n   *     contains a dot, i.e. is a decimal number.\n   * @return {boolean} Whether the character is numeric.\n   * @private\n   */\n  isNumeric_(c, decimal) {\n    decimal = decimal !== undefined ? decimal : false;\n    return (c >= '0' && c <= '9') || (c == '.' && !decimal);\n  }\n\n  /**\n   * @param {string} c Character.\n   * @return {boolean} Whether the character is whitespace.\n   * @private\n   */\n  isWhiteSpace_(c) {\n    return c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n  }\n\n  /**\n   * @return {string} Next string character.\n   * @private\n   */\n  nextChar_() {\n    return this.wkt.charAt(++this.index_);\n  }\n\n  /**\n   * Fetch and return the next token.\n   * @return {Token} Next string token.\n   */\n  nextToken() {\n    const c = this.nextChar_();\n    const position = this.index_;\n    /** @type {number|string} */\n    let value = c;\n    let type;\n\n    if (c == '(') {\n      type = TokenType.LEFT_PAREN;\n    } else if (c == ',') {\n      type = TokenType.COMMA;\n    } else if (c == ')') {\n      type = TokenType.RIGHT_PAREN;\n    } else if (this.isNumeric_(c) || c == '-') {\n      type = TokenType.NUMBER;\n      value = this.readNumber_();\n    } else if (this.isAlpha_(c)) {\n      type = TokenType.TEXT;\n      value = this.readText_();\n    } else if (this.isWhiteSpace_(c)) {\n      return this.nextToken();\n    } else if (c === '') {\n      type = TokenType.EOF;\n    } else {\n      throw new Error('Unexpected character: ' + c);\n    }\n\n    return {position: position, value: value, type: type};\n  }\n\n  /**\n   * @return {number} Numeric token value.\n   * @private\n   */\n  readNumber_() {\n    let c;\n    const index = this.index_;\n    let decimal = false;\n    let scientificNotation = false;\n    do {\n      if (c == '.') {\n        decimal = true;\n      } else if (c == 'e' || c == 'E') {\n        scientificNotation = true;\n      }\n      c = this.nextChar_();\n    } while (\n      this.isNumeric_(c, decimal) ||\n      // if we haven't detected a scientific number before, 'e' or 'E'\n      // hint that we should continue to read\n      (!scientificNotation && (c == 'e' || c == 'E')) ||\n      // once we know that we have a scientific number, both '-' and '+'\n      // are allowed\n      (scientificNotation && (c == '-' || c == '+'))\n    );\n    return parseFloat(this.wkt.substring(index, this.index_--));\n  }\n\n  /**\n   * @return {string} String token value.\n   * @private\n   */\n  readText_() {\n    let c;\n    const index = this.index_;\n    do {\n      c = this.nextChar_();\n    } while (this.isAlpha_(c));\n    return this.wkt.substring(index, this.index_--).toUpperCase();\n  }\n}\n\n/**\n * Class to parse the tokens from the WKT string.\n */\nclass Parser {\n  /**\n   * @param {Lexer} lexer The lexer.\n   */\n  constructor(lexer) {\n    /**\n     * @type {Lexer}\n     * @private\n     */\n    this.lexer_ = lexer;\n\n    /**\n     * @type {Token}\n     * @private\n     */\n    this.token_ = {\n      position: 0,\n      type: TokenType.START,\n    };\n\n    /**\n     * @type {import(\"../geom/Geometry.js\").GeometryLayout}\n     * @private\n     */\n    this.layout_ = 'XY';\n  }\n\n  /**\n   * Fetch the next token form the lexer and replace the active token.\n   * @private\n   */\n  consume_() {\n    this.token_ = this.lexer_.nextToken();\n  }\n\n  /**\n   * Tests if the given type matches the type of the current token.\n   * @param {TokenType} type Token type.\n   * @return {boolean} Whether the token matches the given type.\n   */\n  isTokenType(type) {\n    return this.token_.type == type;\n  }\n\n  /**\n   * If the given type matches the current token, consume it.\n   * @param {TokenType} type Token type.\n   * @return {boolean} Whether the token matches the given type.\n   */\n  match(type) {\n    const isMatch = this.isTokenType(type);\n    if (isMatch) {\n      this.consume_();\n    }\n    return isMatch;\n  }\n\n  /**\n   * Try to parse the tokens provided by the lexer.\n   * @return {import(\"../geom/Geometry.js\").default} The geometry.\n   */\n  parse() {\n    this.consume_();\n    return this.parseGeometry_();\n  }\n\n  /**\n   * Try to parse the dimensional info.\n   * @return {import(\"../geom/Geometry.js\").GeometryLayout} The layout.\n   * @private\n   */\n  parseGeometryLayout_() {\n    /** @type {import(\"../geom/Geometry.js\").GeometryLayout} */\n    let layout = 'XY';\n    const dimToken = this.token_;\n    if (this.isTokenType(TokenType.TEXT)) {\n      const dimInfo = dimToken.value;\n      if (dimInfo === Z) {\n        layout = 'XYZ';\n      } else if (dimInfo === M) {\n        layout = 'XYM';\n      } else if (dimInfo === ZM) {\n        layout = 'XYZM';\n      }\n      if (layout !== 'XY') {\n        this.consume_();\n      }\n    }\n    return layout;\n  }\n\n  /**\n   * @return {Array<import(\"../geom/Geometry.js\").default>} A collection of geometries.\n   * @private\n   */\n  parseGeometryCollectionText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const geometries = [];\n      do {\n        geometries.push(this.parseGeometry_());\n      } while (this.match(TokenType.COMMA));\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return geometries;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<number>} All values in a point.\n   * @private\n   */\n  parsePointText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parsePoint_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<number>>} All points in a linestring.\n   * @private\n   */\n  parseLineStringText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parsePointList_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<Array<number>>>} All points in a polygon.\n   * @private\n   */\n  parsePolygonText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parseLineStringTextList_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<number>>} All points in a multipoint.\n   * @private\n   */\n  parseMultiPointText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      let coordinates;\n      if (this.token_.type == TokenType.LEFT_PAREN) {\n        coordinates = this.parsePointTextList_();\n      } else {\n        coordinates = this.parsePointList_();\n      }\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<Array<number>>>} All linestring points\n   *                                          in a multilinestring.\n   * @private\n   */\n  parseMultiLineStringText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parseLineStringTextList_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<Array<Array<number>>>>} All polygon points in a multipolygon.\n   * @private\n   */\n  parseMultiPolygonText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parsePolygonTextList_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<number>} A point.\n   * @private\n   */\n  parsePoint_() {\n    const coordinates = [];\n    const dimensions = this.layout_.length;\n    for (let i = 0; i < dimensions; ++i) {\n      const token = this.token_;\n      if (this.match(TokenType.NUMBER)) {\n        coordinates.push(/** @type {number} */ (token.value));\n      } else {\n        break;\n      }\n    }\n    if (coordinates.length == dimensions) {\n      return coordinates;\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n\n  /**\n   * @return {Array<Array<number>>} An array of points.\n   * @private\n   */\n  parsePointList_() {\n    const coordinates = [this.parsePoint_()];\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parsePoint_());\n    }\n    return coordinates;\n  }\n\n  /**\n   * @return {Array<Array<number>>} An array of points.\n   * @private\n   */\n  parsePointTextList_() {\n    const coordinates = [this.parsePointText_()];\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parsePointText_());\n    }\n    return coordinates;\n  }\n\n  /**\n   * @return {Array<Array<Array<number>>>} An array of points.\n   * @private\n   */\n  parseLineStringTextList_() {\n    const coordinates = [this.parseLineStringText_()];\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parseLineStringText_());\n    }\n    return coordinates;\n  }\n\n  /**\n   * @return {Array<Array<Array<Array<number>>>>} An array of points.\n   * @private\n   */\n  parsePolygonTextList_() {\n    const coordinates = [this.parsePolygonText_()];\n    while (this.match(TokenType.COMMA)) {\n      coordinates.push(this.parsePolygonText_());\n    }\n    return coordinates;\n  }\n\n  /**\n   * @return {boolean} Whether the token implies an empty geometry.\n   * @private\n   */\n  isEmptyGeometry_() {\n    const isEmpty =\n      this.isTokenType(TokenType.TEXT) && this.token_.value == EMPTY;\n    if (isEmpty) {\n      this.consume_();\n    }\n    return isEmpty;\n  }\n\n  /**\n   * Create an error message for an unexpected token error.\n   * @return {string} Error message.\n   * @private\n   */\n  formatErrorMessage_() {\n    return (\n      'Unexpected `' +\n      this.token_.value +\n      '` at position ' +\n      this.token_.position +\n      ' in `' +\n      this.lexer_.wkt +\n      '`'\n    );\n  }\n\n  /**\n   * @return {import(\"../geom/Geometry.js\").default} The geometry.\n   * @private\n   */\n  parseGeometry_() {\n    const token = this.token_;\n    if (this.match(TokenType.TEXT)) {\n      const geomType = /** @type {string} */ (token.value);\n      this.layout_ = this.parseGeometryLayout_();\n      const isEmpty = this.isEmptyGeometry_();\n      if (geomType == 'GEOMETRYCOLLECTION') {\n        if (isEmpty) {\n          return new GeometryCollection([]);\n        }\n        const geometries = this.parseGeometryCollectionText_();\n        return new GeometryCollection(geometries);\n      }\n      const ctor = GeometryConstructor[geomType];\n      if (!ctor) {\n        throw new Error('Invalid geometry type: ' + geomType);\n      }\n\n      let coordinates;\n\n      if (isEmpty) {\n        if (geomType == 'POINT') {\n          coordinates = [NaN, NaN];\n        } else {\n          coordinates = [];\n        }\n      } else {\n        switch (geomType) {\n          case 'POINT': {\n            coordinates = this.parsePointText_();\n            break;\n          }\n          case 'LINESTRING': {\n            coordinates = this.parseLineStringText_();\n            break;\n          }\n          case 'POLYGON': {\n            coordinates = this.parsePolygonText_();\n            break;\n          }\n          case 'MULTIPOINT': {\n            coordinates = this.parseMultiPointText_();\n            break;\n          }\n          case 'MULTILINESTRING': {\n            coordinates = this.parseMultiLineStringText_();\n            break;\n          }\n          case 'MULTIPOLYGON': {\n            coordinates = this.parseMultiPolygonText_();\n            break;\n          }\n          default:\n            break;\n        }\n      }\n\n      return new ctor(coordinates, this.layout_);\n    }\n    throw new Error(this.formatErrorMessage_());\n  }\n}\n\n/**\n * @classdesc\n * Geometry format for reading and writing data in the `WellKnownText` (WKT)\n * format.\n *\n * @api\n */\nclass WKT extends TextFeature {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * Split GeometryCollection into multiple features.\n     * @type {boolean}\n     * @private\n     */\n    this.splitCollection_ =\n      options.splitCollection !== undefined ? options.splitCollection : false;\n  }\n\n  /**\n   * Parse a WKT string.\n   * @param {string} wkt WKT string.\n   * @return {import(\"../geom/Geometry.js\").default}\n   *     The geometry created.\n   * @private\n   */\n  parse_(wkt) {\n    const lexer = new Lexer(wkt);\n    const parser = new Parser(lexer);\n    return parser.parse();\n  }\n\n  /**\n   * @protected\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromText(text, options) {\n    const geom = this.readGeometryFromText(text, options);\n    const feature = new Feature();\n    feature.setGeometry(geom);\n    return feature;\n  }\n\n  /**\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<Feature>} Features.\n   */\n  readFeaturesFromText(text, options) {\n    let geometries = [];\n    const geometry = this.readGeometryFromText(text, options);\n    if (this.splitCollection_ && geometry.getType() == 'GeometryCollection') {\n      geometries = /** @type {GeometryCollection} */ (\n        geometry\n      ).getGeometriesArray();\n    } else {\n      geometries = [geometry];\n    }\n    const features = [];\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      const feature = new Feature();\n      feature.setGeometry(geometries[i]);\n      features.push(feature);\n    }\n    return features;\n  }\n\n  /**\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromText(text, options) {\n    const geometry = this.parse_(text);\n    return transformGeometryWithOptions(geometry, false, options);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  writeFeatureText(feature, options) {\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      return this.writeGeometryText(geometry, options);\n    }\n    return '';\n  }\n\n  /**\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  writeFeaturesText(features, options) {\n    if (features.length == 1) {\n      return this.writeFeatureText(features[0], options);\n    }\n    const geometries = [];\n    for (let i = 0, ii = features.length; i < ii; ++i) {\n      geometries.push(features[i].getGeometry());\n    }\n    const collection = new GeometryCollection(geometries);\n    return this.writeGeometryText(collection, options);\n  }\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @protected\n   * @return {string} Text.\n   */\n  writeGeometryText(geometry, options) {\n    return encode(transformGeometryWithOptions(geometry, true, options));\n  }\n}\n\n/**\n * @param {Point} geom Point geometry.\n * @return {string} Coordinates part of Point as WKT.\n */\nfunction encodePointGeometry(geom) {\n  const coordinates = geom.getCoordinates();\n  if (coordinates.length === 0) {\n    return '';\n  }\n  return coordinates.join(' ');\n}\n\n/**\n * @param {MultiPoint} geom MultiPoint geometry.\n * @return {string} Coordinates part of MultiPoint as WKT.\n */\nfunction encodeMultiPointGeometry(geom) {\n  const array = [];\n  const components = geom.getPoints();\n  for (let i = 0, ii = components.length; i < ii; ++i) {\n    array.push('(' + encodePointGeometry(components[i]) + ')');\n  }\n  return array.join(',');\n}\n\n/**\n * @param {GeometryCollection} geom GeometryCollection geometry.\n * @return {string} Coordinates part of GeometryCollection as WKT.\n */\nfunction encodeGeometryCollectionGeometry(geom) {\n  const array = [];\n  const geoms = geom.getGeometries();\n  for (let i = 0, ii = geoms.length; i < ii; ++i) {\n    array.push(encode(geoms[i]));\n  }\n  return array.join(',');\n}\n\n/**\n * @param {LineString|import(\"../geom/LinearRing.js\").default} geom LineString geometry.\n * @return {string} Coordinates part of LineString as WKT.\n */\nfunction encodeLineStringGeometry(geom) {\n  const coordinates = geom.getCoordinates();\n  const array = [];\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n    array.push(coordinates[i].join(' '));\n  }\n  return array.join(',');\n}\n\n/**\n * @param {MultiLineString} geom MultiLineString geometry.\n * @return {string} Coordinates part of MultiLineString as WKT.\n */\nfunction encodeMultiLineStringGeometry(geom) {\n  const array = [];\n  const components = geom.getLineStrings();\n  for (let i = 0, ii = components.length; i < ii; ++i) {\n    array.push('(' + encodeLineStringGeometry(components[i]) + ')');\n  }\n  return array.join(',');\n}\n\n/**\n * @param {Polygon} geom Polygon geometry.\n * @return {string} Coordinates part of Polygon as WKT.\n */\nfunction encodePolygonGeometry(geom) {\n  const array = [];\n  const rings = geom.getLinearRings();\n  for (let i = 0, ii = rings.length; i < ii; ++i) {\n    array.push('(' + encodeLineStringGeometry(rings[i]) + ')');\n  }\n  return array.join(',');\n}\n\n/**\n * @param {MultiPolygon} geom MultiPolygon geometry.\n * @return {string} Coordinates part of MultiPolygon as WKT.\n */\nfunction encodeMultiPolygonGeometry(geom) {\n  const array = [];\n  const components = geom.getPolygons();\n  for (let i = 0, ii = components.length; i < ii; ++i) {\n    array.push('(' + encodePolygonGeometry(components[i]) + ')');\n  }\n  return array.join(',');\n}\n\n/**\n * @param {import(\"../geom/SimpleGeometry.js\").default} geom SimpleGeometry geometry.\n * @return {string} Potential dimensional information for WKT type.\n */\nfunction encodeGeometryLayout(geom) {\n  const layout = geom.getLayout();\n  let dimInfo = '';\n  if (layout === 'XYZ' || layout === 'XYZM') {\n    dimInfo += Z;\n  }\n  if (layout === 'XYM' || layout === 'XYZM') {\n    dimInfo += M;\n  }\n  return dimInfo;\n}\n\n/**\n * @const\n * @type {Object<string, function(import(\"../geom/Geometry.js\").default): string>}\n */\nconst GeometryEncoder = {\n  'Point': encodePointGeometry,\n  'LineString': encodeLineStringGeometry,\n  'Polygon': encodePolygonGeometry,\n  'MultiPoint': encodeMultiPointGeometry,\n  'MultiLineString': encodeMultiLineStringGeometry,\n  'MultiPolygon': encodeMultiPolygonGeometry,\n  'GeometryCollection': encodeGeometryCollectionGeometry,\n};\n\n/**\n * Encode a geometry as WKT.\n * @param {import(\"../geom/Geometry.js\").default} geom The geometry to encode.\n * @return {string} WKT string for the geometry.\n */\nfunction encode(geom) {\n  const type = geom.getType();\n  const geometryEncoder = GeometryEncoder[type];\n  const enc = geometryEncoder(geom);\n  let wktType = wktTypeLookup[type];\n  if (typeof (/** @type {?} */ (geom).getFlatCoordinates) === 'function') {\n    const dimInfo = encodeGeometryLayout(\n      /** @type {import(\"../geom/SimpleGeometry.js\").default} */ (geom)\n    );\n    if (dimInfo.length > 0) {\n      wktType += ' ' + dimInfo;\n    }\n  }\n  if (enc.length === 0) {\n    return wktType + ' ' + EMPTY;\n  }\n  return wktType + '(' + enc + ')';\n}\n\nexport default WKT;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}