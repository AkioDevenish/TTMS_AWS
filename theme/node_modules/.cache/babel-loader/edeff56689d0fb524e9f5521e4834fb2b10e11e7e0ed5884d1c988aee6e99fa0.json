{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.date.to-json.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.filter.js\";\n/**\n * @module ol/render/canvas/style\n */\n\nimport Circle from '../../style/Circle.js';\nimport Fill from '../../style/Fill.js';\nimport Icon from '../../style/Icon.js';\nimport RegularShape from '../../style/RegularShape.js';\nimport Stroke from '../../style/Stroke.js';\nimport Style from '../../style/Style.js';\nimport Text from '../../style/Text.js';\nimport { BooleanType, ColorType, NumberArrayType, NumberType, StringType, newParsingContext } from '../../expr/expression.js';\nimport { buildExpression, newEvaluationContext } from '../../expr/cpu.js';\nimport { isEmpty } from '../../obj.js';\nimport { toSize } from '../../size.js';\n\n/**\n * @fileoverview This module includes functions to build styles for the canvas renderer.  Building\n * is composed of two steps: parsing and compiling.  The parsing step takes an encoded expression\n * and returns an instance of one of the expression classes.  The compiling step takes the\n * expression instance and returns a function that can be evaluated to return a literal value.  The\n * evaluator function should do as little allocation and work as possible.\n */\n\n/**\n * @typedef {import(\"../../style/flat.js\").FlatStyle} FlatStyle\n */\n\n/**\n * @typedef {import(\"../../expr/expression.js\").EncodedExpression} EncodedExpression\n */\n\n/**\n * @typedef {import(\"../../expr/expression.js\").ParsingContext} ParsingContext\n */\n\n/**\n * @typedef {import(\"../../expr/expression.js\").CallExpression} CallExpression\n */\n\n/**\n * @typedef {import(\"../../expr/cpu.js\").EvaluationContext} EvaluationContext\n */\n\n/**\n * @typedef {import(\"../../expr/cpu.js\").ExpressionEvaluator} ExpressionEvaluator\n */\n\n/**\n * @param {EvaluationContext} context The evaluation context.\n * @return {boolean} Always true.\n */\nfunction always(context) {\n  return true;\n}\n\n/**\n * This function adapts a rule evaluator to the existing style function interface.\n * After we have deprecated the style function, we can use the compiled rules directly\n * and pass a more complete evaluation context (variables, zoom, time, etc.).\n *\n * @param {Array<import('../../style/flat.js').Rule>} rules The rules.\n * @return {import('../../style/Style.js').StyleFunction} A style function.\n */\nexport function rulesToStyleFunction(rules) {\n  var parsingContext = newParsingContext();\n  var evaluator = buildRuleSet(rules, parsingContext);\n  var evaluationContext = newEvaluationContext();\n  return function (feature, resolution) {\n    evaluationContext.properties = feature.getPropertiesInternal();\n    evaluationContext.resolution = resolution;\n    if (parsingContext.featureId) {\n      var id = feature.getId();\n      if (id !== undefined) {\n        evaluationContext.featureId = id;\n      } else {\n        evaluationContext.featureId = null;\n      }\n    }\n    return evaluator(evaluationContext);\n  };\n}\n\n/**\n * This function adapts a style evaluator to the existing style function interface.\n * After we have deprecated the style function, we can use the compiled rules directly\n * and pass a more complete evaluation context (variables, zoom, time, etc.).\n *\n * @param {Array<import('../../style/flat.js').FlatStyle>} flatStyles The flat styles.\n * @return {import('../../style/Style.js').StyleFunction} A style function.\n */\nexport function flatStylesToStyleFunction(flatStyles) {\n  var parsingContext = newParsingContext();\n  var length = flatStyles.length;\n\n  /**\n   * @type {Array<StyleEvaluator>}\n   */\n  var evaluators = new Array(length);\n  for (var i = 0; i < length; ++i) {\n    evaluators[i] = buildStyle(flatStyles[i], parsingContext);\n  }\n  var evaluationContext = newEvaluationContext();\n\n  /**\n   * @type {Array<Style>}\n   */\n  var styles = new Array(length);\n  return function (feature, resolution) {\n    evaluationContext.properties = feature.getPropertiesInternal();\n    evaluationContext.resolution = resolution;\n    if (parsingContext.featureId) {\n      var id = feature.getId();\n      if (id !== undefined) {\n        evaluationContext.featureId = id;\n      } else {\n        evaluationContext.featureId = null;\n      }\n    }\n    var nonNullCount = 0;\n    for (var _i = 0; _i < length; ++_i) {\n      var style = evaluators[_i](evaluationContext);\n      if (style) {\n        styles[nonNullCount] = style;\n        nonNullCount += 1;\n      }\n    }\n    styles.length = nonNullCount;\n    return styles;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Array<Style>} RuleSetEvaluator\n */\n\n/**\n * @typedef {Object} CompiledRule\n * @property {ExpressionEvaluator} filter The compiled filter evaluator.\n * @property {Array<StyleEvaluator>} styles The list of compiled style evaluators.\n */\n\n/**\n * @param {Array<import('../../style/flat.js').Rule>} rules The rules.\n * @param {ParsingContext} context The parsing context.\n * @return {RuleSetEvaluator} The evaluator function.\n */\nexport function buildRuleSet(rules, context) {\n  var length = rules.length;\n\n  /**\n   * @type {Array<CompiledRule>}\n   */\n  var compiledRules = new Array(length);\n  for (var i = 0; i < length; ++i) {\n    var rule = rules[i];\n    var filter = 'filter' in rule ? buildExpression(rule.filter, BooleanType, context) : always;\n\n    /**\n     * @type {Array<StyleEvaluator>}\n     */\n    var styles = void 0;\n    if (Array.isArray(rule.style)) {\n      var styleLength = rule.style.length;\n      styles = new Array(styleLength);\n      for (var j = 0; j < styleLength; ++j) {\n        styles[j] = buildStyle(rule.style[j], context);\n      }\n    } else {\n      styles = [buildStyle(rule.style, context)];\n    }\n    compiledRules[i] = {\n      filter: filter,\n      styles: styles\n    };\n  }\n  return function (context) {\n    /**\n     * @type {Array<Style>}\n     */\n    var styles = [];\n    var someMatched = false;\n    for (var _i2 = 0; _i2 < length; ++_i2) {\n      var filterEvaluator = compiledRules[_i2].filter;\n      if (!filterEvaluator(context)) {\n        continue;\n      }\n      if (rules[_i2][\"else\"] && someMatched) {\n        continue;\n      }\n      someMatched = true;\n      var _iterator = _createForOfIteratorHelper(compiledRules[_i2].styles),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var styleEvaluator = _step.value;\n          var style = styleEvaluator(context);\n          if (!style) {\n            continue;\n          }\n          styles.push(style);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    return styles;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Style|null} StyleEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle A flat style literal.\n * @param {ParsingContext} context The parsing context.\n * @return {StyleEvaluator} A function that evaluates to a style.  The style returned by\n * this function will be reused between invocations.\n */\nexport function buildStyle(flatStyle, context) {\n  var evaluateFill = buildFill(flatStyle, '', context);\n  var evaluateStroke = buildStroke(flatStyle, '', context);\n  var evaluateText = buildText(flatStyle, context);\n  var evaluateImage = buildImage(flatStyle, context);\n  var evaluateZIndex = numberEvaluator(flatStyle, 'z-index', context);\n  if (!evaluateFill && !evaluateStroke && !evaluateText && !evaluateImage && !isEmpty(flatStyle)) {\n    // assume this is a user error\n    // would be nice to check the properties and suggest \"did you mean...\"\n    throw new Error('No fill, stroke, point, or text symbolizer properties in style: ' + JSON.stringify(flatStyle));\n  }\n  var style = new Style();\n  return function (context) {\n    var empty = true;\n    if (evaluateFill) {\n      var fill = evaluateFill(context);\n      if (fill) {\n        empty = false;\n      }\n      style.setFill(fill);\n    }\n    if (evaluateStroke) {\n      var stroke = evaluateStroke(context);\n      if (stroke) {\n        empty = false;\n      }\n      style.setStroke(stroke);\n    }\n    if (evaluateText) {\n      var text = evaluateText(context);\n      if (text) {\n        empty = false;\n      }\n      style.setText(text);\n    }\n    if (evaluateImage) {\n      var image = evaluateImage(context);\n      if (image) {\n        empty = false;\n      }\n      style.setImage(image);\n    }\n    if (evaluateZIndex) {\n      style.setZIndex(evaluateZIndex(context));\n    }\n    if (empty) {\n      return null;\n    }\n    return style;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Fill|null} FillEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} prefix The property prefix.\n * @param {ParsingContext} context The parsing context.\n * @return {FillEvaluator?} A function that evaluates to a fill.\n */\nfunction buildFill(flatStyle, prefix, context) {\n  var evaluateColor = colorLikeEvaluator(flatStyle, prefix + 'fill-color', context);\n  if (!evaluateColor) {\n    return null;\n  }\n  var fill = new Fill();\n  return function (context) {\n    var color = evaluateColor(context);\n    if (color === 'none') {\n      return null;\n    }\n    fill.setColor(color);\n    return fill;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Stroke|null} StrokeEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} prefix The property prefix.\n * @param {ParsingContext} context The parsing context.\n * @return {StrokeEvaluator?} A function the evaluates to a stroke.\n */\nfunction buildStroke(flatStyle, prefix, context) {\n  var evaluateWidth = numberEvaluator(flatStyle, prefix + 'stroke-width', context);\n  var evaluateColor = colorLikeEvaluator(flatStyle, prefix + 'stroke-color', context);\n  if (!evaluateWidth && !evaluateColor) {\n    return null;\n  }\n  var evaluateLineCap = stringEvaluator(flatStyle, prefix + 'stroke-line-cap', context);\n  var evaluateLineJoin = stringEvaluator(flatStyle, prefix + 'stroke-line-join', context);\n  var evaluateLineDash = numberArrayEvaluator(flatStyle, prefix + 'stroke-line-dash', context);\n  var evaluateLineDashOffset = numberEvaluator(flatStyle, prefix + 'stroke-line-dash-offset', context);\n  var evaluateMiterLimit = numberEvaluator(flatStyle, prefix + 'stroke-miter-limit', context);\n  var stroke = new Stroke();\n  return function (context) {\n    if (evaluateColor) {\n      var color = evaluateColor(context);\n      if (color === 'none') {\n        return null;\n      }\n      stroke.setColor(color);\n    }\n    if (evaluateWidth) {\n      stroke.setWidth(evaluateWidth(context));\n    }\n    if (evaluateLineCap) {\n      var lineCap = evaluateLineCap(context);\n      if (lineCap !== 'butt' && lineCap !== 'round' && lineCap !== 'square') {\n        throw new Error('Expected butt, round, or square line cap');\n      }\n      stroke.setLineCap(lineCap);\n    }\n    if (evaluateLineJoin) {\n      var lineJoin = evaluateLineJoin(context);\n      if (lineJoin !== 'bevel' && lineJoin !== 'round' && lineJoin !== 'miter') {\n        throw new Error('Expected bevel, round, or miter line join');\n      }\n      stroke.setLineJoin(lineJoin);\n    }\n    if (evaluateLineDash) {\n      stroke.setLineDash(evaluateLineDash(context));\n    }\n    if (evaluateLineDashOffset) {\n      stroke.setLineDashOffset(evaluateLineDashOffset(context));\n    }\n    if (evaluateMiterLimit) {\n      stroke.setMiterLimit(evaluateMiterLimit(context));\n    }\n    return stroke;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Text} TextEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {TextEvaluator?} A function that evaluates to a text symbolizer.\n */\nfunction buildText(flatStyle, context) {\n  var prefix = 'text-';\n\n  // Currently, an Array<string> may be used for rich text support.  This doesn't\n  // work with our expression syntax where arrays of strings are interpreted as\n  // call expressions.  To support rich text, we could add a 'strings' operator\n  // where all the following arguments would be string values.\n  var evaluateValue = stringEvaluator(flatStyle, prefix + 'value', context);\n  if (!evaluateValue) {\n    return null;\n  }\n  var evaluateFill = buildFill(flatStyle, prefix, context);\n  var evaluateBackgroundFill = buildFill(flatStyle, prefix + 'background-', context);\n  var evaluateStroke = buildStroke(flatStyle, prefix, context);\n  var evaluateBackgroundStroke = buildStroke(flatStyle, prefix + 'background-', context);\n  var evaluateFont = stringEvaluator(flatStyle, prefix + 'font', context);\n  var evaluateMaxAngle = numberEvaluator(flatStyle, prefix + 'max-angle', context);\n  var evaluateOffsetX = numberEvaluator(flatStyle, prefix + 'offset-x', context);\n  var evaluateOffsetY = numberEvaluator(flatStyle, prefix + 'offset-y', context);\n  var evaluateOverflow = booleanEvaluator(flatStyle, prefix + 'overflow', context);\n  var evaluatePlacement = stringEvaluator(flatStyle, prefix + 'placement', context);\n  var evaluateRepeat = numberEvaluator(flatStyle, prefix + 'repeat', context);\n  var evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  var evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);\n  var evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);\n  var evaluateAlign = stringEvaluator(flatStyle, prefix + 'align', context);\n  var evaluateJustify = stringEvaluator(flatStyle, prefix + 'justify', context);\n  var evaluateBaseline = stringEvaluator(flatStyle, prefix + 'baseline', context);\n  var evaluatePadding = numberArrayEvaluator(flatStyle, prefix + 'padding', context);\n  var text = new Text({});\n  return function (context) {\n    text.setText(evaluateValue(context));\n    if (evaluateFill) {\n      text.setFill(evaluateFill(context));\n    }\n    if (evaluateBackgroundFill) {\n      text.setBackgroundFill(evaluateBackgroundFill(context));\n    }\n    if (evaluateStroke) {\n      text.setStroke(evaluateStroke(context));\n    }\n    if (evaluateBackgroundStroke) {\n      text.setBackgroundStroke(evaluateBackgroundStroke(context));\n    }\n    if (evaluateFont) {\n      text.setFont(evaluateFont(context));\n    }\n    if (evaluateMaxAngle) {\n      text.setMaxAngle(evaluateMaxAngle(context));\n    }\n    if (evaluateOffsetX) {\n      text.setOffsetX(evaluateOffsetX(context));\n    }\n    if (evaluateOffsetY) {\n      text.setOffsetY(evaluateOffsetY(context));\n    }\n    if (evaluateOverflow) {\n      text.setOverflow(evaluateOverflow(context));\n    }\n    if (evaluatePlacement) {\n      var placement = evaluatePlacement(context);\n      if (placement !== 'point' && placement !== 'line') {\n        throw new Error('Expected point or line for text-placement');\n      }\n      text.setPlacement(placement);\n    }\n    if (evaluateRepeat) {\n      text.setRepeat(evaluateRepeat(context));\n    }\n    if (evaluateScale) {\n      text.setScale(evaluateScale(context));\n    }\n    if (evaluateRotateWithView) {\n      text.setRotateWithView(evaluateRotateWithView(context));\n    }\n    if (evaluateRotation) {\n      text.setRotation(evaluateRotation(context));\n    }\n    if (evaluateAlign) {\n      var textAlign = evaluateAlign(context);\n      if (textAlign !== 'left' && textAlign !== 'center' && textAlign !== 'right' && textAlign !== 'end' && textAlign !== 'start') {\n        throw new Error('Expected left, right, center, start, or end for text-align');\n      }\n      text.setTextAlign(textAlign);\n    }\n    if (evaluateJustify) {\n      var justify = evaluateJustify(context);\n      if (justify !== 'left' && justify !== 'right' && justify !== 'center') {\n        throw new Error('Expected left, right, or center for text-justify');\n      }\n      text.setJustify(justify);\n    }\n    if (evaluateBaseline) {\n      var textBaseline = evaluateBaseline(context);\n      if (textBaseline !== 'bottom' && textBaseline !== 'top' && textBaseline !== 'middle' && textBaseline !== 'alphabetic' && textBaseline !== 'hanging') {\n        throw new Error('Expected bottom, top, middle, alphabetic, or hanging for text-baseline');\n      }\n      text.setTextBaseline(textBaseline);\n    }\n    if (evaluatePadding) {\n      text.setPadding(evaluatePadding(context));\n    }\n    return text;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):import(\"../../style/Image.js\").default} ImageEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator?} A function that evaluates to an image symbolizer.\n */\nfunction buildImage(flatStyle, context) {\n  if ('icon-src' in flatStyle) {\n    return buildIcon(flatStyle, context);\n  }\n  if ('shape-points' in flatStyle) {\n    return buildShape(flatStyle, context);\n  }\n  if ('circle-radius' in flatStyle) {\n    return buildCircle(flatStyle, context);\n  }\n  return null;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator} A function that evaluates to an image symbolizer.\n */\nfunction buildIcon(flatStyle, context) {\n  var prefix = 'icon-';\n\n  // required property\n  var srcName = prefix + 'src';\n  var src = requireString(flatStyle[srcName], srcName);\n\n  // settable properties\n  var evaluateAnchor = coordinateEvaluator(flatStyle, prefix + 'anchor', context);\n  var evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  var evaluateOpacity = numberEvaluator(flatStyle, prefix + 'opacity', context);\n  var evaluateDisplacement = coordinateEvaluator(flatStyle, prefix + 'displacement', context);\n  var evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);\n  var evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);\n\n  // the remaining symbolizer properties are not currently settable\n  var anchorOrigin = optionalIconOrigin(flatStyle, prefix + 'anchor-origin');\n  var anchorXUnits = optionalIconAnchorUnits(flatStyle, prefix + 'anchor-x-units');\n  var anchorYUnits = optionalIconAnchorUnits(flatStyle, prefix + 'anchor-y-units');\n  var color = optionalColorLike(flatStyle, prefix + 'color');\n  var crossOrigin = optionalString(flatStyle, prefix + 'cross-origin');\n  var offset = optionalNumberArray(flatStyle, prefix + 'offset');\n  var offsetOrigin = optionalIconOrigin(flatStyle, prefix + 'offset-origin');\n  var width = optionalNumber(flatStyle, prefix + 'width');\n  var height = optionalNumber(flatStyle, prefix + 'height');\n  var size = optionalSize(flatStyle, prefix + 'size');\n  var declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter');\n  var icon = new Icon({\n    src: src,\n    anchorOrigin: anchorOrigin,\n    anchorXUnits: anchorXUnits,\n    anchorYUnits: anchorYUnits,\n    color: color,\n    crossOrigin: crossOrigin,\n    offset: offset,\n    offsetOrigin: offsetOrigin,\n    height: height,\n    width: width,\n    size: size,\n    declutterMode: declutterMode\n  });\n  return function (context) {\n    if (evaluateOpacity) {\n      icon.setOpacity(evaluateOpacity(context));\n    }\n    if (evaluateDisplacement) {\n      icon.setDisplacement(evaluateDisplacement(context));\n    }\n    if (evaluateRotation) {\n      icon.setRotation(evaluateRotation(context));\n    }\n    if (evaluateRotateWithView) {\n      icon.setRotateWithView(evaluateRotateWithView(context));\n    }\n    if (evaluateScale) {\n      icon.setScale(evaluateScale(context));\n    }\n    if (evaluateAnchor) {\n      icon.setAnchor(evaluateAnchor(context));\n    }\n    return icon;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator} A function that evaluates to an icon symbolizer.\n */\nfunction buildShape(flatStyle, context) {\n  var prefix = 'shape-';\n\n  // required property\n  var pointsName = prefix + 'points';\n  var points = requireNumber(flatStyle[pointsName], pointsName);\n\n  // settable properties\n  var evaluateFill = buildFill(flatStyle, prefix, context);\n  var evaluateStroke = buildStroke(flatStyle, prefix, context);\n  var evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  var evaluateDisplacement = coordinateEvaluator(flatStyle, prefix + 'displacement', context);\n  var evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);\n  var evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);\n\n  // the remaining properties are not currently settable\n  var radius = optionalNumber(flatStyle, prefix + 'radius');\n  var radius1 = optionalNumber(flatStyle, prefix + 'radius1');\n  var radius2 = optionalNumber(flatStyle, prefix + 'radius2');\n  var angle = optionalNumber(flatStyle, prefix + 'angle');\n  var declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter-mode');\n  var shape = new RegularShape({\n    points: points,\n    radius: radius,\n    radius1: radius1,\n    radius2: radius2,\n    angle: angle,\n    declutterMode: declutterMode\n  });\n  return function (context) {\n    if (evaluateFill) {\n      shape.setFill(evaluateFill(context));\n    }\n    if (evaluateStroke) {\n      shape.setStroke(evaluateStroke(context));\n    }\n    if (evaluateDisplacement) {\n      shape.setDisplacement(evaluateDisplacement(context));\n    }\n    if (evaluateRotation) {\n      shape.setRotation(evaluateRotation(context));\n    }\n    if (evaluateRotateWithView) {\n      shape.setRotateWithView(evaluateRotateWithView(context));\n    }\n    if (evaluateScale) {\n      shape.setScale(evaluateScale(context));\n    }\n    return shape;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator} A function that evaluates to a circle symbolizer.\n */\nfunction buildCircle(flatStyle, context) {\n  var prefix = 'circle-';\n\n  // settable properties\n  var evaluateFill = buildFill(flatStyle, prefix, context);\n  var evaluateStroke = buildStroke(flatStyle, prefix, context);\n  var evaluateRadius = numberEvaluator(flatStyle, prefix + 'radius', context);\n  var evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  var evaluateDisplacement = coordinateEvaluator(flatStyle, prefix + 'displacement', context);\n  var evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);\n  var evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);\n\n  // the remaining properties are not currently settable\n  var declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter-mode');\n  var circle = new Circle({\n    radius: 5,\n    // this is arbitrary, but required - the evaluated radius is used below\n    declutterMode: declutterMode\n  });\n  return function (context) {\n    if (evaluateRadius) {\n      circle.setRadius(evaluateRadius(context));\n    }\n    if (evaluateFill) {\n      circle.setFill(evaluateFill(context));\n    }\n    if (evaluateStroke) {\n      circle.setStroke(evaluateStroke(context));\n    }\n    if (evaluateDisplacement) {\n      circle.setDisplacement(evaluateDisplacement(context));\n    }\n    if (evaluateRotation) {\n      circle.setRotation(evaluateRotation(context));\n    }\n    if (evaluateRotateWithView) {\n      circle.setRotateWithView(evaluateRotateWithView(context));\n    }\n    if (evaluateScale) {\n      circle.setScale(evaluateScale(context));\n    }\n    return circle;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').NumberEvaluator|undefined} The expression evaluator or undefined.\n */\nfunction numberEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return undefined;\n  }\n  var evaluator = buildExpression(flatStyle[name], NumberType, context);\n  return function (context) {\n    return requireNumber(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').StringEvaluator?} The expression evaluator.\n */\nfunction stringEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  var evaluator = buildExpression(flatStyle[name], StringType, context);\n  return function (context) {\n    return requireString(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').BooleanEvaluator?} The expression evaluator.\n */\nfunction booleanEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  var evaluator = buildExpression(flatStyle[name], BooleanType, context);\n  return function (context) {\n    var value = evaluator(context);\n    if (typeof value !== 'boolean') {\n      throw new Error(\"Expected a boolean for \".concat(name));\n    }\n    return value;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').ColorLikeEvaluator?} The expression evaluator.\n */\nfunction colorLikeEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  var evaluator = buildExpression(flatStyle[name], ColorType | StringType, context);\n  return function (context) {\n    return requireColorLike(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').NumberArrayEvaluator?} The expression evaluator.\n */\nfunction numberArrayEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  var evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\n  return function (context) {\n    return requireNumberArray(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').CoordinateEvaluator?} The expression evaluator.\n */\nfunction coordinateEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  var evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\n  return function (context) {\n    var array = requireNumberArray(evaluator(context), name);\n    if (array.length !== 2) {\n      throw new Error(\"Expected two numbers for \".concat(name));\n    }\n    return array;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').SizeLikeEvaluator?} The expression evaluator.\n */\nfunction sizeLikeEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  var evaluator = buildExpression(flatStyle[name], NumberArrayType | NumberType, context);\n  return function (context) {\n    return requireSizeLike(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {number|undefined} A number or undefined.\n */\nfunction optionalNumber(flatStyle, property) {\n  var value = flatStyle[property];\n  if (value === undefined) {\n    return undefined;\n  }\n  if (typeof value !== 'number') {\n    throw new Error(\"Expected a number for \".concat(property));\n  }\n  return value;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import(\"../../size.js\").Size|undefined} A size or undefined.\n */\nfunction optionalSize(flatStyle, property) {\n  var encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (typeof encoded === 'number') {\n    return toSize(encoded);\n  }\n  if (!Array.isArray(encoded)) {\n    throw new Error(\"Expected a number or size array for \".concat(property));\n  }\n  if (encoded.length !== 2 || typeof encoded[0] !== 'number' || typeof encoded[1] !== 'number') {\n    throw new Error(\"Expected a number or size array for \".concat(property));\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {string|undefined} A string or undefined.\n */\nfunction optionalString(flatStyle, property) {\n  var encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (typeof encoded !== 'string') {\n    throw new Error(\"Expected a string for \".concat(property));\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import(\"../../style/Icon.js\").IconOrigin|undefined} An icon origin or undefined.\n */\nfunction optionalIconOrigin(flatStyle, property) {\n  var encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (encoded !== 'bottom-left' && encoded !== 'bottom-right' && encoded !== 'top-left' && encoded !== 'top-right') {\n    throw new Error(\"Expected bottom-left, bottom-right, top-left, or top-right for \".concat(property));\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import(\"../../style/Icon.js\").IconAnchorUnits|undefined} Icon anchor units or undefined.\n */\nfunction optionalIconAnchorUnits(flatStyle, property) {\n  var encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (encoded !== 'pixels' && encoded !== 'fraction') {\n    throw new Error(\"Expected pixels or fraction for \".concat(property));\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {Array<number>|undefined} An array of numbers or undefined.\n */\nfunction optionalNumberArray(flatStyle, property) {\n  var encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  return requireNumberArray(encoded, property);\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {\"declutter\"|\"obstacle\"|\"none\"|undefined} Icon declutter mode.\n */\nfunction optionalDeclutterMode(flatStyle, property) {\n  var encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (typeof encoded !== 'string') {\n    throw new Error(\"Expected a string for \".concat(property));\n  }\n  if (encoded !== 'declutter' && encoded !== 'obstacle' && encoded !== 'none') {\n    throw new Error(\"Expected declutter, obstacle, or none for \".concat(property));\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {string|Array<number>|undefined} A string or an array of color values or undefined.\n */\nfunction optionalColorLike(flatStyle, property) {\n  var encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  return requireColorLike(encoded, property);\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {Array<number>} An array of numbers.\n */\nfunction requireNumberArray(value, property) {\n  if (!Array.isArray(value)) {\n    throw new Error(\"Expected an array for \".concat(property));\n  }\n  var length = value.length;\n  for (var i = 0; i < length; ++i) {\n    if (typeof value[i] !== 'number') {\n      throw new Error(\"Expected an array of numbers for \".concat(property));\n    }\n  }\n  return value;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {string} A string.\n */\nfunction requireString(value, property) {\n  if (typeof value !== 'string') {\n    throw new Error(\"Expected a string for \".concat(property));\n  }\n  return value;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {number} A number.\n */\nfunction requireNumber(value, property) {\n  if (typeof value !== 'number') {\n    throw new Error(\"Expected a number for \".concat(property));\n  }\n  return value;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {Array<number>|string} A color.\n */\nfunction requireColorLike(value, property) {\n  if (typeof value === 'string') {\n    return value;\n  }\n  var array = requireNumberArray(value, property);\n  var length = array.length;\n  if (length < 3 || length > 4) {\n    throw new Error(\"Expected a color with 3 or 4 values for \".concat(property));\n  }\n  return array;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {number|Array<number>} A number or an array of two numbers.\n */\nfunction requireSizeLike(value, property) {\n  if (typeof value === 'number') {\n    return value;\n  }\n  var size = requireNumberArray(value, property);\n  if (size.length !== 2) {\n    throw new Error(\"Expected an array of two numbers for \".concat(property));\n  }\n  return size;\n}","map":{"version":3,"names":["Circle","Fill","Icon","RegularShape","Stroke","Style","Text","BooleanType","ColorType","NumberArrayType","NumberType","StringType","newParsingContext","buildExpression","newEvaluationContext","isEmpty","toSize","always","context","rulesToStyleFunction","rules","parsingContext","evaluator","buildRuleSet","evaluationContext","feature","resolution","properties","getPropertiesInternal","featureId","id","getId","undefined","flatStylesToStyleFunction","flatStyles","length","evaluators","Array","i","buildStyle","styles","nonNullCount","style","compiledRules","rule","filter","isArray","styleLength","j","someMatched","filterEvaluator","_iterator","_createForOfIteratorHelper","_step","s","n","done","styleEvaluator","value","push","err","e","f","flatStyle","evaluateFill","buildFill","evaluateStroke","buildStroke","evaluateText","buildText","evaluateImage","buildImage","evaluateZIndex","numberEvaluator","Error","JSON","stringify","empty","fill","setFill","stroke","setStroke","text","setText","image","setImage","setZIndex","prefix","evaluateColor","colorLikeEvaluator","color","setColor","evaluateWidth","evaluateLineCap","stringEvaluator","evaluateLineJoin","evaluateLineDash","numberArrayEvaluator","evaluateLineDashOffset","evaluateMiterLimit","setWidth","lineCap","setLineCap","lineJoin","setLineJoin","setLineDash","setLineDashOffset","setMiterLimit","evaluateValue","evaluateBackgroundFill","evaluateBackgroundStroke","evaluateFont","evaluateMaxAngle","evaluateOffsetX","evaluateOffsetY","evaluateOverflow","booleanEvaluator","evaluatePlacement","evaluateRepeat","evaluateScale","sizeLikeEvaluator","evaluateRotateWithView","evaluateRotation","evaluateAlign","evaluateJustify","evaluateBaseline","evaluatePadding","setBackgroundFill","setBackgroundStroke","setFont","setMaxAngle","setOffsetX","setOffsetY","setOverflow","placement","setPlacement","setRepeat","setScale","setRotateWithView","setRotation","textAlign","setTextAlign","justify","setJustify","textBaseline","setTextBaseline","setPadding","buildIcon","buildShape","buildCircle","srcName","src","requireString","evaluateAnchor","coordinateEvaluator","evaluateOpacity","evaluateDisplacement","anchorOrigin","optionalIconOrigin","anchorXUnits","optionalIconAnchorUnits","anchorYUnits","optionalColorLike","crossOrigin","optionalString","offset","optionalNumberArray","offsetOrigin","width","optionalNumber","height","size","optionalSize","declutterMode","optionalDeclutterMode","icon","setOpacity","setDisplacement","setAnchor","pointsName","points","requireNumber","radius","radius1","radius2","angle","shape","evaluateRadius","circle","setRadius","name","concat","requireColorLike","requireNumberArray","array","requireSizeLike","property","encoded"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol/render/canvas/style.js"],"sourcesContent":["/**\n * @module ol/render/canvas/style\n */\n\nimport Circle from '../../style/Circle.js';\nimport Fill from '../../style/Fill.js';\nimport Icon from '../../style/Icon.js';\nimport RegularShape from '../../style/RegularShape.js';\nimport Stroke from '../../style/Stroke.js';\nimport Style from '../../style/Style.js';\nimport Text from '../../style/Text.js';\nimport {\n  BooleanType,\n  ColorType,\n  NumberArrayType,\n  NumberType,\n  StringType,\n  newParsingContext,\n} from '../../expr/expression.js';\nimport {buildExpression, newEvaluationContext} from '../../expr/cpu.js';\nimport {isEmpty} from '../../obj.js';\nimport {toSize} from '../../size.js';\n\n/**\n * @fileoverview This module includes functions to build styles for the canvas renderer.  Building\n * is composed of two steps: parsing and compiling.  The parsing step takes an encoded expression\n * and returns an instance of one of the expression classes.  The compiling step takes the\n * expression instance and returns a function that can be evaluated to return a literal value.  The\n * evaluator function should do as little allocation and work as possible.\n */\n\n/**\n * @typedef {import(\"../../style/flat.js\").FlatStyle} FlatStyle\n */\n\n/**\n * @typedef {import(\"../../expr/expression.js\").EncodedExpression} EncodedExpression\n */\n\n/**\n * @typedef {import(\"../../expr/expression.js\").ParsingContext} ParsingContext\n */\n\n/**\n * @typedef {import(\"../../expr/expression.js\").CallExpression} CallExpression\n */\n\n/**\n * @typedef {import(\"../../expr/cpu.js\").EvaluationContext} EvaluationContext\n */\n\n/**\n * @typedef {import(\"../../expr/cpu.js\").ExpressionEvaluator} ExpressionEvaluator\n */\n\n/**\n * @param {EvaluationContext} context The evaluation context.\n * @return {boolean} Always true.\n */\nfunction always(context) {\n  return true;\n}\n\n/**\n * This function adapts a rule evaluator to the existing style function interface.\n * After we have deprecated the style function, we can use the compiled rules directly\n * and pass a more complete evaluation context (variables, zoom, time, etc.).\n *\n * @param {Array<import('../../style/flat.js').Rule>} rules The rules.\n * @return {import('../../style/Style.js').StyleFunction} A style function.\n */\nexport function rulesToStyleFunction(rules) {\n  const parsingContext = newParsingContext();\n  const evaluator = buildRuleSet(rules, parsingContext);\n  const evaluationContext = newEvaluationContext();\n  return function (feature, resolution) {\n    evaluationContext.properties = feature.getPropertiesInternal();\n    evaluationContext.resolution = resolution;\n    if (parsingContext.featureId) {\n      const id = feature.getId();\n      if (id !== undefined) {\n        evaluationContext.featureId = id;\n      } else {\n        evaluationContext.featureId = null;\n      }\n    }\n    return evaluator(evaluationContext);\n  };\n}\n\n/**\n * This function adapts a style evaluator to the existing style function interface.\n * After we have deprecated the style function, we can use the compiled rules directly\n * and pass a more complete evaluation context (variables, zoom, time, etc.).\n *\n * @param {Array<import('../../style/flat.js').FlatStyle>} flatStyles The flat styles.\n * @return {import('../../style/Style.js').StyleFunction} A style function.\n */\nexport function flatStylesToStyleFunction(flatStyles) {\n  const parsingContext = newParsingContext();\n  const length = flatStyles.length;\n\n  /**\n   * @type {Array<StyleEvaluator>}\n   */\n  const evaluators = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    evaluators[i] = buildStyle(flatStyles[i], parsingContext);\n  }\n  const evaluationContext = newEvaluationContext();\n\n  /**\n   * @type {Array<Style>}\n   */\n  const styles = new Array(length);\n\n  return function (feature, resolution) {\n    evaluationContext.properties = feature.getPropertiesInternal();\n    evaluationContext.resolution = resolution;\n    if (parsingContext.featureId) {\n      const id = feature.getId();\n      if (id !== undefined) {\n        evaluationContext.featureId = id;\n      } else {\n        evaluationContext.featureId = null;\n      }\n    }\n    let nonNullCount = 0;\n    for (let i = 0; i < length; ++i) {\n      const style = evaluators[i](evaluationContext);\n      if (style) {\n        styles[nonNullCount] = style;\n        nonNullCount += 1;\n      }\n    }\n    styles.length = nonNullCount;\n    return styles;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Array<Style>} RuleSetEvaluator\n */\n\n/**\n * @typedef {Object} CompiledRule\n * @property {ExpressionEvaluator} filter The compiled filter evaluator.\n * @property {Array<StyleEvaluator>} styles The list of compiled style evaluators.\n */\n\n/**\n * @param {Array<import('../../style/flat.js').Rule>} rules The rules.\n * @param {ParsingContext} context The parsing context.\n * @return {RuleSetEvaluator} The evaluator function.\n */\nexport function buildRuleSet(rules, context) {\n  const length = rules.length;\n\n  /**\n   * @type {Array<CompiledRule>}\n   */\n  const compiledRules = new Array(length);\n\n  for (let i = 0; i < length; ++i) {\n    const rule = rules[i];\n    const filter =\n      'filter' in rule\n        ? buildExpression(rule.filter, BooleanType, context)\n        : always;\n\n    /**\n     * @type {Array<StyleEvaluator>}\n     */\n    let styles;\n    if (Array.isArray(rule.style)) {\n      const styleLength = rule.style.length;\n      styles = new Array(styleLength);\n      for (let j = 0; j < styleLength; ++j) {\n        styles[j] = buildStyle(rule.style[j], context);\n      }\n    } else {\n      styles = [buildStyle(rule.style, context)];\n    }\n\n    compiledRules[i] = {filter, styles};\n  }\n\n  return function (context) {\n    /**\n     * @type {Array<Style>}\n     */\n    const styles = [];\n\n    let someMatched = false;\n    for (let i = 0; i < length; ++i) {\n      const filterEvaluator = compiledRules[i].filter;\n      if (!filterEvaluator(context)) {\n        continue;\n      }\n      if (rules[i].else && someMatched) {\n        continue;\n      }\n      someMatched = true;\n      for (const styleEvaluator of compiledRules[i].styles) {\n        const style = styleEvaluator(context);\n        if (!style) {\n          continue;\n        }\n        styles.push(style);\n      }\n    }\n\n    return styles;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Style|null} StyleEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle A flat style literal.\n * @param {ParsingContext} context The parsing context.\n * @return {StyleEvaluator} A function that evaluates to a style.  The style returned by\n * this function will be reused between invocations.\n */\nexport function buildStyle(flatStyle, context) {\n  const evaluateFill = buildFill(flatStyle, '', context);\n  const evaluateStroke = buildStroke(flatStyle, '', context);\n  const evaluateText = buildText(flatStyle, context);\n  const evaluateImage = buildImage(flatStyle, context);\n  const evaluateZIndex = numberEvaluator(flatStyle, 'z-index', context);\n\n  if (\n    !evaluateFill &&\n    !evaluateStroke &&\n    !evaluateText &&\n    !evaluateImage &&\n    !isEmpty(flatStyle)\n  ) {\n    // assume this is a user error\n    // would be nice to check the properties and suggest \"did you mean...\"\n    throw new Error(\n      'No fill, stroke, point, or text symbolizer properties in style: ' +\n        JSON.stringify(flatStyle)\n    );\n  }\n\n  const style = new Style();\n  return function (context) {\n    let empty = true;\n    if (evaluateFill) {\n      const fill = evaluateFill(context);\n      if (fill) {\n        empty = false;\n      }\n      style.setFill(fill);\n    }\n    if (evaluateStroke) {\n      const stroke = evaluateStroke(context);\n      if (stroke) {\n        empty = false;\n      }\n      style.setStroke(stroke);\n    }\n    if (evaluateText) {\n      const text = evaluateText(context);\n      if (text) {\n        empty = false;\n      }\n      style.setText(text);\n    }\n    if (evaluateImage) {\n      const image = evaluateImage(context);\n      if (image) {\n        empty = false;\n      }\n      style.setImage(image);\n    }\n    if (evaluateZIndex) {\n      style.setZIndex(evaluateZIndex(context));\n    }\n    if (empty) {\n      return null;\n    }\n    return style;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Fill|null} FillEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} prefix The property prefix.\n * @param {ParsingContext} context The parsing context.\n * @return {FillEvaluator?} A function that evaluates to a fill.\n */\nfunction buildFill(flatStyle, prefix, context) {\n  const evaluateColor = colorLikeEvaluator(\n    flatStyle,\n    prefix + 'fill-color',\n    context\n  );\n  if (!evaluateColor) {\n    return null;\n  }\n\n  const fill = new Fill();\n  return function (context) {\n    const color = evaluateColor(context);\n    if (color === 'none') {\n      return null;\n    }\n    fill.setColor(color);\n    return fill;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Stroke|null} StrokeEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} prefix The property prefix.\n * @param {ParsingContext} context The parsing context.\n * @return {StrokeEvaluator?} A function the evaluates to a stroke.\n */\nfunction buildStroke(flatStyle, prefix, context) {\n  const evaluateWidth = numberEvaluator(\n    flatStyle,\n    prefix + 'stroke-width',\n    context\n  );\n\n  const evaluateColor = colorLikeEvaluator(\n    flatStyle,\n    prefix + 'stroke-color',\n    context\n  );\n\n  if (!evaluateWidth && !evaluateColor) {\n    return null;\n  }\n\n  const evaluateLineCap = stringEvaluator(\n    flatStyle,\n    prefix + 'stroke-line-cap',\n    context\n  );\n\n  const evaluateLineJoin = stringEvaluator(\n    flatStyle,\n    prefix + 'stroke-line-join',\n    context\n  );\n\n  const evaluateLineDash = numberArrayEvaluator(\n    flatStyle,\n    prefix + 'stroke-line-dash',\n    context\n  );\n\n  const evaluateLineDashOffset = numberEvaluator(\n    flatStyle,\n    prefix + 'stroke-line-dash-offset',\n    context\n  );\n\n  const evaluateMiterLimit = numberEvaluator(\n    flatStyle,\n    prefix + 'stroke-miter-limit',\n    context\n  );\n\n  const stroke = new Stroke();\n  return function (context) {\n    if (evaluateColor) {\n      const color = evaluateColor(context);\n      if (color === 'none') {\n        return null;\n      }\n      stroke.setColor(color);\n    }\n\n    if (evaluateWidth) {\n      stroke.setWidth(evaluateWidth(context));\n    }\n\n    if (evaluateLineCap) {\n      const lineCap = evaluateLineCap(context);\n      if (lineCap !== 'butt' && lineCap !== 'round' && lineCap !== 'square') {\n        throw new Error('Expected butt, round, or square line cap');\n      }\n      stroke.setLineCap(lineCap);\n    }\n\n    if (evaluateLineJoin) {\n      const lineJoin = evaluateLineJoin(context);\n      if (\n        lineJoin !== 'bevel' &&\n        lineJoin !== 'round' &&\n        lineJoin !== 'miter'\n      ) {\n        throw new Error('Expected bevel, round, or miter line join');\n      }\n      stroke.setLineJoin(lineJoin);\n    }\n\n    if (evaluateLineDash) {\n      stroke.setLineDash(evaluateLineDash(context));\n    }\n\n    if (evaluateLineDashOffset) {\n      stroke.setLineDashOffset(evaluateLineDashOffset(context));\n    }\n\n    if (evaluateMiterLimit) {\n      stroke.setMiterLimit(evaluateMiterLimit(context));\n    }\n\n    return stroke;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Text} TextEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {TextEvaluator?} A function that evaluates to a text symbolizer.\n */\nfunction buildText(flatStyle, context) {\n  const prefix = 'text-';\n\n  // Currently, an Array<string> may be used for rich text support.  This doesn't\n  // work with our expression syntax where arrays of strings are interpreted as\n  // call expressions.  To support rich text, we could add a 'strings' operator\n  // where all the following arguments would be string values.\n  const evaluateValue = stringEvaluator(flatStyle, prefix + 'value', context);\n  if (!evaluateValue) {\n    return null;\n  }\n\n  const evaluateFill = buildFill(flatStyle, prefix, context);\n\n  const evaluateBackgroundFill = buildFill(\n    flatStyle,\n    prefix + 'background-',\n    context\n  );\n\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\n\n  const evaluateBackgroundStroke = buildStroke(\n    flatStyle,\n    prefix + 'background-',\n    context\n  );\n\n  const evaluateFont = stringEvaluator(flatStyle, prefix + 'font', context);\n\n  const evaluateMaxAngle = numberEvaluator(\n    flatStyle,\n    prefix + 'max-angle',\n    context\n  );\n\n  const evaluateOffsetX = numberEvaluator(\n    flatStyle,\n    prefix + 'offset-x',\n    context\n  );\n\n  const evaluateOffsetY = numberEvaluator(\n    flatStyle,\n    prefix + 'offset-y',\n    context\n  );\n\n  const evaluateOverflow = booleanEvaluator(\n    flatStyle,\n    prefix + 'overflow',\n    context\n  );\n\n  const evaluatePlacement = stringEvaluator(\n    flatStyle,\n    prefix + 'placement',\n    context\n  );\n\n  const evaluateRepeat = numberEvaluator(flatStyle, prefix + 'repeat', context);\n\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n\n  const evaluateRotateWithView = booleanEvaluator(\n    flatStyle,\n    prefix + 'rotate-with-view',\n    context\n  );\n\n  const evaluateRotation = numberEvaluator(\n    flatStyle,\n    prefix + 'rotation',\n    context\n  );\n\n  const evaluateAlign = stringEvaluator(flatStyle, prefix + 'align', context);\n\n  const evaluateJustify = stringEvaluator(\n    flatStyle,\n    prefix + 'justify',\n    context\n  );\n\n  const evaluateBaseline = stringEvaluator(\n    flatStyle,\n    prefix + 'baseline',\n    context\n  );\n\n  const evaluatePadding = numberArrayEvaluator(\n    flatStyle,\n    prefix + 'padding',\n    context\n  );\n\n  const text = new Text({});\n  return function (context) {\n    text.setText(evaluateValue(context));\n\n    if (evaluateFill) {\n      text.setFill(evaluateFill(context));\n    }\n\n    if (evaluateBackgroundFill) {\n      text.setBackgroundFill(evaluateBackgroundFill(context));\n    }\n\n    if (evaluateStroke) {\n      text.setStroke(evaluateStroke(context));\n    }\n\n    if (evaluateBackgroundStroke) {\n      text.setBackgroundStroke(evaluateBackgroundStroke(context));\n    }\n\n    if (evaluateFont) {\n      text.setFont(evaluateFont(context));\n    }\n\n    if (evaluateMaxAngle) {\n      text.setMaxAngle(evaluateMaxAngle(context));\n    }\n\n    if (evaluateOffsetX) {\n      text.setOffsetX(evaluateOffsetX(context));\n    }\n\n    if (evaluateOffsetY) {\n      text.setOffsetY(evaluateOffsetY(context));\n    }\n\n    if (evaluateOverflow) {\n      text.setOverflow(evaluateOverflow(context));\n    }\n\n    if (evaluatePlacement) {\n      const placement = evaluatePlacement(context);\n      if (placement !== 'point' && placement !== 'line') {\n        throw new Error('Expected point or line for text-placement');\n      }\n      text.setPlacement(placement);\n    }\n\n    if (evaluateRepeat) {\n      text.setRepeat(evaluateRepeat(context));\n    }\n\n    if (evaluateScale) {\n      text.setScale(evaluateScale(context));\n    }\n\n    if (evaluateRotateWithView) {\n      text.setRotateWithView(evaluateRotateWithView(context));\n    }\n\n    if (evaluateRotation) {\n      text.setRotation(evaluateRotation(context));\n    }\n\n    if (evaluateAlign) {\n      const textAlign = evaluateAlign(context);\n      if (\n        textAlign !== 'left' &&\n        textAlign !== 'center' &&\n        textAlign !== 'right' &&\n        textAlign !== 'end' &&\n        textAlign !== 'start'\n      ) {\n        throw new Error(\n          'Expected left, right, center, start, or end for text-align'\n        );\n      }\n      text.setTextAlign(textAlign);\n    }\n\n    if (evaluateJustify) {\n      const justify = evaluateJustify(context);\n      if (justify !== 'left' && justify !== 'right' && justify !== 'center') {\n        throw new Error('Expected left, right, or center for text-justify');\n      }\n      text.setJustify(justify);\n    }\n\n    if (evaluateBaseline) {\n      const textBaseline = evaluateBaseline(context);\n      if (\n        textBaseline !== 'bottom' &&\n        textBaseline !== 'top' &&\n        textBaseline !== 'middle' &&\n        textBaseline !== 'alphabetic' &&\n        textBaseline !== 'hanging'\n      ) {\n        throw new Error(\n          'Expected bottom, top, middle, alphabetic, or hanging for text-baseline'\n        );\n      }\n      text.setTextBaseline(textBaseline);\n    }\n\n    if (evaluatePadding) {\n      text.setPadding(evaluatePadding(context));\n    }\n\n    return text;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):import(\"../../style/Image.js\").default} ImageEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator?} A function that evaluates to an image symbolizer.\n */\nfunction buildImage(flatStyle, context) {\n  if ('icon-src' in flatStyle) {\n    return buildIcon(flatStyle, context);\n  }\n\n  if ('shape-points' in flatStyle) {\n    return buildShape(flatStyle, context);\n  }\n\n  if ('circle-radius' in flatStyle) {\n    return buildCircle(flatStyle, context);\n  }\n\n  return null;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator} A function that evaluates to an image symbolizer.\n */\nfunction buildIcon(flatStyle, context) {\n  const prefix = 'icon-';\n\n  // required property\n  const srcName = prefix + 'src';\n  const src = requireString(flatStyle[srcName], srcName);\n\n  // settable properties\n  const evaluateAnchor = coordinateEvaluator(\n    flatStyle,\n    prefix + 'anchor',\n    context\n  );\n\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n\n  const evaluateOpacity = numberEvaluator(\n    flatStyle,\n    prefix + 'opacity',\n    context\n  );\n\n  const evaluateDisplacement = coordinateEvaluator(\n    flatStyle,\n    prefix + 'displacement',\n    context\n  );\n\n  const evaluateRotation = numberEvaluator(\n    flatStyle,\n    prefix + 'rotation',\n    context\n  );\n\n  const evaluateRotateWithView = booleanEvaluator(\n    flatStyle,\n    prefix + 'rotate-with-view',\n    context\n  );\n\n  // the remaining symbolizer properties are not currently settable\n  const anchorOrigin = optionalIconOrigin(flatStyle, prefix + 'anchor-origin');\n  const anchorXUnits = optionalIconAnchorUnits(\n    flatStyle,\n    prefix + 'anchor-x-units'\n  );\n  const anchorYUnits = optionalIconAnchorUnits(\n    flatStyle,\n    prefix + 'anchor-y-units'\n  );\n  const color = optionalColorLike(flatStyle, prefix + 'color');\n  const crossOrigin = optionalString(flatStyle, prefix + 'cross-origin');\n  const offset = optionalNumberArray(flatStyle, prefix + 'offset');\n  const offsetOrigin = optionalIconOrigin(flatStyle, prefix + 'offset-origin');\n  const width = optionalNumber(flatStyle, prefix + 'width');\n  const height = optionalNumber(flatStyle, prefix + 'height');\n  const size = optionalSize(flatStyle, prefix + 'size');\n  const declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter');\n\n  const icon = new Icon({\n    src,\n    anchorOrigin,\n    anchorXUnits,\n    anchorYUnits,\n    color,\n    crossOrigin,\n    offset,\n    offsetOrigin,\n    height,\n    width,\n    size,\n    declutterMode,\n  });\n\n  return function (context) {\n    if (evaluateOpacity) {\n      icon.setOpacity(evaluateOpacity(context));\n    }\n\n    if (evaluateDisplacement) {\n      icon.setDisplacement(evaluateDisplacement(context));\n    }\n\n    if (evaluateRotation) {\n      icon.setRotation(evaluateRotation(context));\n    }\n\n    if (evaluateRotateWithView) {\n      icon.setRotateWithView(evaluateRotateWithView(context));\n    }\n\n    if (evaluateScale) {\n      icon.setScale(evaluateScale(context));\n    }\n\n    if (evaluateAnchor) {\n      icon.setAnchor(evaluateAnchor(context));\n    }\n    return icon;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator} A function that evaluates to an icon symbolizer.\n */\nfunction buildShape(flatStyle, context) {\n  const prefix = 'shape-';\n\n  // required property\n  const pointsName = prefix + 'points';\n  const points = requireNumber(flatStyle[pointsName], pointsName);\n\n  // settable properties\n  const evaluateFill = buildFill(flatStyle, prefix, context);\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  const evaluateDisplacement = coordinateEvaluator(\n    flatStyle,\n    prefix + 'displacement',\n    context\n  );\n  const evaluateRotation = numberEvaluator(\n    flatStyle,\n    prefix + 'rotation',\n    context\n  );\n  const evaluateRotateWithView = booleanEvaluator(\n    flatStyle,\n    prefix + 'rotate-with-view',\n    context\n  );\n\n  // the remaining properties are not currently settable\n  const radius = optionalNumber(flatStyle, prefix + 'radius');\n  const radius1 = optionalNumber(flatStyle, prefix + 'radius1');\n  const radius2 = optionalNumber(flatStyle, prefix + 'radius2');\n  const angle = optionalNumber(flatStyle, prefix + 'angle');\n  const declutterMode = optionalDeclutterMode(\n    flatStyle,\n    prefix + 'declutter-mode'\n  );\n\n  const shape = new RegularShape({\n    points,\n    radius,\n    radius1,\n    radius2,\n    angle,\n    declutterMode,\n  });\n\n  return function (context) {\n    if (evaluateFill) {\n      shape.setFill(evaluateFill(context));\n    }\n    if (evaluateStroke) {\n      shape.setStroke(evaluateStroke(context));\n    }\n    if (evaluateDisplacement) {\n      shape.setDisplacement(evaluateDisplacement(context));\n    }\n    if (evaluateRotation) {\n      shape.setRotation(evaluateRotation(context));\n    }\n    if (evaluateRotateWithView) {\n      shape.setRotateWithView(evaluateRotateWithView(context));\n    }\n    if (evaluateScale) {\n      shape.setScale(evaluateScale(context));\n    }\n\n    return shape;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator} A function that evaluates to a circle symbolizer.\n */\nfunction buildCircle(flatStyle, context) {\n  const prefix = 'circle-';\n\n  // settable properties\n  const evaluateFill = buildFill(flatStyle, prefix, context);\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\n  const evaluateRadius = numberEvaluator(flatStyle, prefix + 'radius', context);\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  const evaluateDisplacement = coordinateEvaluator(\n    flatStyle,\n    prefix + 'displacement',\n    context\n  );\n  const evaluateRotation = numberEvaluator(\n    flatStyle,\n    prefix + 'rotation',\n    context\n  );\n  const evaluateRotateWithView = booleanEvaluator(\n    flatStyle,\n    prefix + 'rotate-with-view',\n    context\n  );\n\n  // the remaining properties are not currently settable\n  const declutterMode = optionalDeclutterMode(\n    flatStyle,\n    prefix + 'declutter-mode'\n  );\n\n  const circle = new Circle({\n    radius: 5, // this is arbitrary, but required - the evaluated radius is used below\n    declutterMode,\n  });\n\n  return function (context) {\n    if (evaluateRadius) {\n      circle.setRadius(evaluateRadius(context));\n    }\n    if (evaluateFill) {\n      circle.setFill(evaluateFill(context));\n    }\n    if (evaluateStroke) {\n      circle.setStroke(evaluateStroke(context));\n    }\n    if (evaluateDisplacement) {\n      circle.setDisplacement(evaluateDisplacement(context));\n    }\n    if (evaluateRotation) {\n      circle.setRotation(evaluateRotation(context));\n    }\n    if (evaluateRotateWithView) {\n      circle.setRotateWithView(evaluateRotateWithView(context));\n    }\n    if (evaluateScale) {\n      circle.setScale(evaluateScale(context));\n    }\n\n    return circle;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').NumberEvaluator|undefined} The expression evaluator or undefined.\n */\nfunction numberEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return undefined;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberType, context);\n  return function (context) {\n    return requireNumber(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').StringEvaluator?} The expression evaluator.\n */\nfunction stringEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], StringType, context);\n  return function (context) {\n    return requireString(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').BooleanEvaluator?} The expression evaluator.\n */\nfunction booleanEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], BooleanType, context);\n  return function (context) {\n    const value = evaluator(context);\n    if (typeof value !== 'boolean') {\n      throw new Error(`Expected a boolean for ${name}`);\n    }\n    return value;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').ColorLikeEvaluator?} The expression evaluator.\n */\nfunction colorLikeEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(\n    flatStyle[name],\n    ColorType | StringType,\n    context\n  );\n  return function (context) {\n    return requireColorLike(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').NumberArrayEvaluator?} The expression evaluator.\n */\nfunction numberArrayEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\n  return function (context) {\n    return requireNumberArray(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').CoordinateEvaluator?} The expression evaluator.\n */\nfunction coordinateEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\n  return function (context) {\n    const array = requireNumberArray(evaluator(context), name);\n    if (array.length !== 2) {\n      throw new Error(`Expected two numbers for ${name}`);\n    }\n    return array;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').SizeLikeEvaluator?} The expression evaluator.\n */\nfunction sizeLikeEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(\n    flatStyle[name],\n    NumberArrayType | NumberType,\n    context\n  );\n  return function (context) {\n    return requireSizeLike(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {number|undefined} A number or undefined.\n */\nfunction optionalNumber(flatStyle, property) {\n  const value = flatStyle[property];\n  if (value === undefined) {\n    return undefined;\n  }\n  if (typeof value !== 'number') {\n    throw new Error(`Expected a number for ${property}`);\n  }\n  return value;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import(\"../../size.js\").Size|undefined} A size or undefined.\n */\nfunction optionalSize(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (typeof encoded === 'number') {\n    return toSize(encoded);\n  }\n  if (!Array.isArray(encoded)) {\n    throw new Error(`Expected a number or size array for ${property}`);\n  }\n  if (\n    encoded.length !== 2 ||\n    typeof encoded[0] !== 'number' ||\n    typeof encoded[1] !== 'number'\n  ) {\n    throw new Error(`Expected a number or size array for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {string|undefined} A string or undefined.\n */\nfunction optionalString(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (typeof encoded !== 'string') {\n    throw new Error(`Expected a string for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import(\"../../style/Icon.js\").IconOrigin|undefined} An icon origin or undefined.\n */\nfunction optionalIconOrigin(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (\n    encoded !== 'bottom-left' &&\n    encoded !== 'bottom-right' &&\n    encoded !== 'top-left' &&\n    encoded !== 'top-right'\n  ) {\n    throw new Error(\n      `Expected bottom-left, bottom-right, top-left, or top-right for ${property}`\n    );\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import(\"../../style/Icon.js\").IconAnchorUnits|undefined} Icon anchor units or undefined.\n */\nfunction optionalIconAnchorUnits(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (encoded !== 'pixels' && encoded !== 'fraction') {\n    throw new Error(`Expected pixels or fraction for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {Array<number>|undefined} An array of numbers or undefined.\n */\nfunction optionalNumberArray(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  return requireNumberArray(encoded, property);\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {\"declutter\"|\"obstacle\"|\"none\"|undefined} Icon declutter mode.\n */\nfunction optionalDeclutterMode(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (typeof encoded !== 'string') {\n    throw new Error(`Expected a string for ${property}`);\n  }\n  if (encoded !== 'declutter' && encoded !== 'obstacle' && encoded !== 'none') {\n    throw new Error(`Expected declutter, obstacle, or none for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {string|Array<number>|undefined} A string or an array of color values or undefined.\n */\nfunction optionalColorLike(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  return requireColorLike(encoded, property);\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {Array<number>} An array of numbers.\n */\nfunction requireNumberArray(value, property) {\n  if (!Array.isArray(value)) {\n    throw new Error(`Expected an array for ${property}`);\n  }\n  const length = value.length;\n  for (let i = 0; i < length; ++i) {\n    if (typeof value[i] !== 'number') {\n      throw new Error(`Expected an array of numbers for ${property}`);\n    }\n  }\n  return value;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {string} A string.\n */\nfunction requireString(value, property) {\n  if (typeof value !== 'string') {\n    throw new Error(`Expected a string for ${property}`);\n  }\n  return value;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {number} A number.\n */\nfunction requireNumber(value, property) {\n  if (typeof value !== 'number') {\n    throw new Error(`Expected a number for ${property}`);\n  }\n  return value;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {Array<number>|string} A color.\n */\nfunction requireColorLike(value, property) {\n  if (typeof value === 'string') {\n    return value;\n  }\n  const array = requireNumberArray(value, property);\n  const length = array.length;\n  if (length < 3 || length > 4) {\n    throw new Error(`Expected a color with 3 or 4 values for ${property}`);\n  }\n  return array;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {number|Array<number>} A number or an array of two numbers.\n */\nfunction requireSizeLike(value, property) {\n  if (typeof value === 'number') {\n    return value;\n  }\n  const size = requireNumberArray(value, property);\n  if (size.length !== 2) {\n    throw new Error(`Expected an array of two numbers for ${property}`);\n  }\n  return size;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}