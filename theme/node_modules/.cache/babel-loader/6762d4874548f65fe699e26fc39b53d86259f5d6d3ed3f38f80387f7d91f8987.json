{"ast":null,"code":"import _construct from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/construct.js\";\nimport _toConsumableArray from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _typeof from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport _createClass from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createForOfIteratorHelper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _defineProperty from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nvar _parsers;\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.date.to-json.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/**\n * @module ol/expr/expression\n */\nimport { ascending } from '../array.js';\nimport { isStringColor } from '../color.js';\n\n/**\n * @fileoverview This module includes types and functions for parsing array encoded expressions.\n * The result of parsing an encoded expression is one of the specific expression classes.\n * During parsing, information is added to the parsing context about the data accessed by the\n * expression.\n */\n\n/**\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\n * which in turns takes {@link import(\"./expression.js\").ExpressionValue} arguments.\n *\n * The following operators can be used:\n *\n * * Reading operators:\n *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band\n *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values\n *     are in the 0..1 range. {@link import(\"../source/TileImage.js\").default} sources have 4 bands: red,\n *     green, blue and alpha. {@link import(\"../source/DataTile.js\").default} sources can have any number\n *     of bands, depending on the underlying data source and\n *     {@link import(\"../source/GeoTIFF.js\").Options configuration}. `xOffset` and `yOffset` are optional\n *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels.\n *   * `['get', 'attributeName', typeHint]` fetches a feature property value, similar to `feature.get('attributeName')`\n *     A type hint can optionally be specified, in case the resulting expression contains a type ambiguity which\n *     will make it invalid. Type hints can be one of: 'string', 'color', 'number', 'boolean', 'number[]'\n *   * `['geometry-type']` returns a feature's geometry type as string, either: 'LineString', 'Point' or 'Polygon'\n *     `Multi*` values are returned as their singular equivalent\n *     `Circle` geometries are returned as 'Polygon'\n *     `GeometryCollection` geometries are returned as the type of the first geometry found in the collection\n *   * `['resolution']` returns the current resolution\n *   * `['time']` returns the time in seconds since the creation of the layer\n *   * `['var', 'varName']` fetches a value from the style variables; will throw an error if that variable is undefined\n *   * `['zoom']` returns the current zoom level\n *\n * * Math operators:\n *   * `['*', value1, value2, ...]` multiplies the values (either numbers or colors)\n *   * `['/', value1, value2]` divides `value1` by `value2`\n *   * `['+', value1, value2, ...]` adds the values\n *   * `['-', value1, value2]` subtracts `value2` from `value1`\n *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`\n *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\n *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\n *   * `['abs', value1]` returns the absolute value of `value1`\n *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`\n *   * `['round', value1]` returns the nearest integer to `value1`\n *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`\n *   * `['sin', value1]` returns the sine of `value1`\n *   * `['cos', value1]` returns the cosine of `value1`\n *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`\n *   * `['sqrt', value1]` returns the square root of `value1`\n *\n * * Transform operators:\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\n *     All conditions should be `boolean`, output and fallback can be any kind.\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\n *     returns the `fallback` value.\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\n *     `fallback` values must be of the same type, and can be of any kind.\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\n *     of 1 is equivalent to `['linear']`.\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\n *     between `output1` and `outputN`.\n *\n * * Logical operators:\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\n *     (inclusively), or `false` otherwise.\n *   * `['in', needle, haystack]` returns `true` if `needle` is found in `haystack`, and\n *     `false` otherwise.\n *     This operator has the following limitations:\n *     * `haystack` has to be an array of numbers or strings (searching for a substring in a string is not supported yet)\n *     * Only literal arrays are supported as `haystack` for now; this means that `haystack` cannot be the result of an\n *     expression. If `haystack` is an array of strings, use the `literal` operator to disambiguate from an expression:\n *     `['literal', ['abc', 'def', 'ghi']]`\n *\n * * Conversion operators:\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\n *     values can currently only be 2, 3 or 4.\n *   * `['color', red, green, blue, alpha]` creates a `color` value from `number` values; the `alpha` parameter is\n *     optional; if not specified, it will be set to 1.\n *     Note: `red`, `green` and `blue` components must be values between 0 and 255; `alpha` between 0 and 1.\n *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`\n *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors\n *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),\n *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b\n *     in the 0-255 range and a in the 0-1 range).\n *\n * Values can either be literals or another operator, as they will be evaluated recursively.\n * Literal values can be of the following types:\n * * `boolean`\n * * `number`\n * * `number[]` (number arrays can only have a length of 2, 3 or 4)\n * * `string`\n * * {@link module:ol/color~Color}\n *\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\n * @api\n */\n\nvar numTypes = 0;\nexport var NoneType = 0;\nexport var BooleanType = 1 << numTypes++;\nexport var NumberType = 1 << numTypes++;\nexport var StringType = 1 << numTypes++;\nexport var ColorType = 1 << numTypes++;\nexport var NumberArrayType = 1 << numTypes++;\nexport var AnyType = Math.pow(2, numTypes) - 1;\nvar typeNames = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, BooleanType, 'boolean'), NumberType, 'number'), StringType, 'string'), ColorType, 'color'), NumberArrayType, 'number[]');\nvar namedTypes = Object.keys(typeNames).map(Number).sort(ascending);\n\n/**\n * Get a string representation for a type.\n * @param {number} type The type.\n * @return {string} The type name.\n */\nexport function typeName(type) {\n  var names = [];\n  var _iterator = _createForOfIteratorHelper(namedTypes),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var namedType = _step.value;\n      if (includesType(type, namedType)) {\n        names.push(typeNames[namedType]);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  if (names.length === 0) {\n    return 'untyped';\n  }\n  if (names.length < 3) {\n    return names.join(' or ');\n  }\n  return names.slice(0, -1).join(', ') + ', or ' + names[names.length - 1];\n}\n\n/**\n * @param {number} broad The broad type.\n * @param {number} specific The specific type.\n * @return {boolean} The broad type includes the specific type.\n */\nexport function includesType(broad, specific) {\n  return (broad & specific) === specific;\n}\n\n/**\n * @param {number} oneType One type.\n * @param {number} otherType Another type.\n * @return {boolean} The set of types overlap (share a common specific type)\n */\nexport function overlapsType(oneType, otherType) {\n  return !!(oneType & otherType);\n}\n\n/**\n * @param {number} type The type.\n * @param {number} expected The expected type.\n * @return {boolean} The given type is exactly the expected type.\n */\nexport function isType(type, expected) {\n  return type === expected;\n}\n\n/**\n * @typedef {boolean|number|string|Array<number>} LiteralValue\n */\n\nexport var LiteralExpression = /*#__PURE__*/_createClass(\n/**\n * @param {number} type The value type.\n * @param {LiteralValue} value The literal value.\n */\nfunction LiteralExpression(type, value) {\n  _classCallCheck(this, LiteralExpression);\n  this.type = type;\n  this.value = value;\n});\nexport var CallExpression = /*#__PURE__*/_createClass(\n/**\n * @param {number} type The return type.\n * @param {string} operator The operator.\n * @param {...Expression} args The arguments.\n */\nfunction CallExpression(type, operator) {\n  _classCallCheck(this, CallExpression);\n  this.type = type;\n  this.operator = operator;\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n  this.args = args;\n});\n\n/**\n * @typedef {LiteralExpression|CallExpression} Expression\n */\n\n/**\n * @typedef {Object} ParsingContext\n * @property {Set<string>} variables Variables referenced with the 'var' operator.\n * @property {Set<string>} properties Properties referenced with the 'get' operator.\n * @property {boolean} featureId The style uses the feature id.\n * @property {import(\"../style/flat.js\").FlatStyle|import(\"../style/webgl.js\").WebGLStyle} style The style being parsed\n */\n\n/**\n * @return {ParsingContext} A new parsing context.\n */\nexport function newParsingContext() {\n  return {\n    variables: new Set(),\n    properties: new Set(),\n    featureId: false,\n    style: {}\n  };\n}\n\n/**\n * @param {string} typeHint Type hint\n * @return {number} Resulting value type (will be a single type)\n */\nfunction getTypeFromHint(typeHint) {\n  switch (typeHint) {\n    case 'string':\n      return StringType;\n    case 'color':\n      return ColorType;\n    case 'number':\n      return NumberType;\n    case 'boolean':\n      return BooleanType;\n    case 'number[]':\n      return NumberArrayType;\n    default:\n      throw new Error(\"Unrecognized type hint: \".concat(typeHint));\n  }\n}\n\n/**\n * @typedef {LiteralValue|Array} EncodedExpression\n */\n\n/**\n * @param {EncodedExpression} encoded The encoded expression.\n * @param {ParsingContext} context The parsing context.\n * @param {number} [typeHint] Optional type hint\n * @return {Expression} The parsed expression result.\n */\nexport function parse(encoded, context, typeHint) {\n  switch (_typeof(encoded)) {\n    case 'boolean':\n      {\n        return new LiteralExpression(BooleanType, encoded);\n      }\n    case 'number':\n      {\n        return new LiteralExpression(NumberType, encoded);\n      }\n    case 'string':\n      {\n        var _type = StringType;\n        if (isStringColor(encoded)) {\n          _type |= ColorType;\n        }\n        // apply the given type hint only if it won't result in an empty type\n        if (!isType(_type & typeHint, NoneType)) {\n          _type &= typeHint;\n        }\n        return new LiteralExpression(_type, encoded);\n      }\n    default:\n      {\n        // pass\n      }\n  }\n  if (!Array.isArray(encoded)) {\n    throw new Error('Expression must be an array or a primitive value');\n  }\n  if (encoded.length === 0) {\n    throw new Error('Empty expression');\n  }\n  if (typeof encoded[0] === 'string') {\n    return parseCallExpression(encoded, context, typeHint);\n  }\n  var _iterator2 = _createForOfIteratorHelper(encoded),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var item = _step2.value;\n      if (typeof item !== 'number') {\n        throw new Error('Expected an array of numbers');\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  var type = NumberArrayType;\n  if (encoded.length === 3 || encoded.length === 4) {\n    type |= ColorType;\n  }\n  if (typeHint) {\n    type &= typeHint;\n  }\n  return new LiteralExpression(type, encoded);\n}\n\n/**\n * @type {Object<string, string>}\n */\nexport var Ops = {\n  Get: 'get',\n  Var: 'var',\n  Concat: 'concat',\n  GeometryType: 'geometry-type',\n  Any: 'any',\n  All: 'all',\n  Not: '!',\n  Resolution: 'resolution',\n  Zoom: 'zoom',\n  Time: 'time',\n  Equal: '==',\n  NotEqual: '!=',\n  GreaterThan: '>',\n  GreaterThanOrEqualTo: '>=',\n  LessThan: '<',\n  LessThanOrEqualTo: '<=',\n  Multiply: '*',\n  Divide: '/',\n  Add: '+',\n  Subtract: '-',\n  Clamp: 'clamp',\n  Mod: '%',\n  Pow: '^',\n  Abs: 'abs',\n  Floor: 'floor',\n  Ceil: 'ceil',\n  Round: 'round',\n  Sin: 'sin',\n  Cos: 'cos',\n  Atan: 'atan',\n  Sqrt: 'sqrt',\n  Match: 'match',\n  Between: 'between',\n  Interpolate: 'interpolate',\n  Case: 'case',\n  In: 'in',\n  Number: 'number',\n  String: 'string',\n  Array: 'array',\n  Color: 'color',\n  Id: 'id',\n  Band: 'band',\n  Palette: 'palette'\n};\n\n/**\n * @typedef {function(Array, ParsingContext, number):Expression} Parser\n * Third argument is a type hint\n */\n\n/**\n * @type {Object<string, Parser>}\n */\nvar parsers = (_parsers = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_parsers, Ops.Get, createParser(function (_ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n    _ = _ref2[0],\n    typeHint = _ref2[1];\n  if (typeHint !== undefined) {\n    return getTypeFromHint(/** @type {string} */\n    /** @type {LiteralExpression} */typeHint.value);\n  }\n  return AnyType;\n}, withArgsCount(1, 2), withGetArgs)), Ops.Var, createParser(function (_ref3) {\n  var _ref4 = _slicedToArray(_ref3, 1),\n    firstArg = _ref4[0];\n  return firstArg.type;\n}, withArgsCount(1, 1), withVarArgs)), Ops.Id, createParser(NumberType | StringType, withNoArgs, usesFeatureId)), Ops.Concat, createParser(StringType, withArgsCount(2, Infinity), parseArgsOfType(AnyType))), Ops.GeometryType, createParser(StringType, withNoArgs)), Ops.Resolution, createParser(NumberType, withNoArgs)), Ops.Zoom, createParser(NumberType, withNoArgs)), Ops.Time, createParser(NumberType, withNoArgs)), Ops.Any, createParser(BooleanType, withArgsCount(2, Infinity), parseArgsOfType(BooleanType))), Ops.All, createParser(BooleanType, withArgsCount(2, Infinity), parseArgsOfType(BooleanType))), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_parsers, Ops.Not, createParser(BooleanType, withArgsCount(1, 1), parseArgsOfType(BooleanType))), Ops.Equal, createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType)), Ops.NotEqual, createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType)), Ops.GreaterThan, createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType)), Ops.GreaterThanOrEqualTo, createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType)), Ops.LessThan, createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType)), Ops.LessThanOrEqualTo, createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType)), Ops.Multiply, createParser(function (parsedArgs) {\n  var outputType = NumberType | ColorType;\n  for (var i = 0; i < parsedArgs.length; i++) {\n    outputType &= parsedArgs[i].type;\n  }\n  return outputType;\n}, withArgsCount(2, Infinity), parseArgsOfType(NumberType | ColorType), narrowArgsType)), Ops.Divide, createParser(NumberType, withArgsCount(2, 2), parseArgsOfType(NumberType))), Ops.Add, createParser(NumberType, withArgsCount(2, Infinity), parseArgsOfType(NumberType))), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_parsers, Ops.Subtract, createParser(NumberType, withArgsCount(2, 2), parseArgsOfType(NumberType))), Ops.Clamp, createParser(NumberType, withArgsCount(3, 3), parseArgsOfType(NumberType))), Ops.Mod, createParser(NumberType, withArgsCount(2, 2), parseArgsOfType(NumberType))), Ops.Pow, createParser(NumberType, withArgsCount(2, 2), parseArgsOfType(NumberType))), Ops.Abs, createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType))), Ops.Floor, createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType))), Ops.Ceil, createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType))), Ops.Round, createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType))), Ops.Sin, createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType))), Ops.Cos, createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType))), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_parsers, Ops.Atan, createParser(NumberType, withArgsCount(1, 2), parseArgsOfType(NumberType))), Ops.Sqrt, createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType))), Ops.Match, createParser(function (parsedArgs) {\n  var type = AnyType;\n  for (var i = 2; i < parsedArgs.length; i += 2) {\n    type &= parsedArgs[i].type;\n  }\n  type &= parsedArgs[parsedArgs.length - 1].type;\n  return type;\n}, withArgsCount(4, Infinity), withEvenArgs, parseMatchArgs)), Ops.Between, createParser(BooleanType, withArgsCount(3, 3), parseArgsOfType(NumberType))), Ops.Interpolate, createParser(function (parsedArgs) {\n  var type = ColorType | NumberType;\n  for (var i = 3; i < parsedArgs.length; i += 2) {\n    type &= parsedArgs[i].type;\n  }\n  return type;\n}, withArgsCount(6, Infinity), withEvenArgs, parseInterpolateArgs)), Ops.Case, createParser(function (parsedArgs) {\n  var type = AnyType;\n  for (var i = 1; i < parsedArgs.length; i += 2) {\n    type &= parsedArgs[i].type;\n  }\n  type &= parsedArgs[parsedArgs.length - 1].type;\n  return type;\n}, withArgsCount(3, Infinity), withOddArgs, parseCaseArgs)), Ops.In, createParser(BooleanType, withArgsCount(2, 2), parseInArgs)), Ops.Number, createParser(NumberType, withArgsCount(1, Infinity), parseArgsOfType(AnyType))), Ops.String, createParser(StringType, withArgsCount(1, Infinity), parseArgsOfType(AnyType))), Ops.Array, createParser(function (parsedArgs) {\n  return parsedArgs.length === 3 || parsedArgs.length === 4 ? NumberArrayType | ColorType : NumberArrayType;\n}, withArgsCount(1, Infinity), parseArgsOfType(NumberType))), _defineProperty(_defineProperty(_defineProperty(_parsers, Ops.Color, createParser(ColorType, withArgsCount(3, 4), parseArgsOfType(NumberType))), Ops.Band, createParser(NumberType, withArgsCount(1, 3), parseArgsOfType(NumberType))), Ops.Palette, createParser(ColorType, withArgsCount(2, 2), parsePaletteArgs)));\n\n/**\n * @typedef {function(Array<EncodedExpression>, ParsingContext, Array<Expression>, number?):Array<Expression>|void} ArgValidator\n * An argument validator applies various checks to an encoded expression arguments\n * Returns the parsed arguments if any.\n * Third argument is the array of parsed arguments from previous validators\n * Fourth argument is an optional type hint\n */\n\n/**\n * @type ArgValidator\n */\nfunction withGetArgs(encoded, context) {\n  var arg = parse(encoded[1], context);\n  if (!(arg instanceof LiteralExpression)) {\n    throw new Error('Expected a literal argument for get operation');\n  }\n  if (typeof arg.value !== 'string') {\n    throw new Error('Expected a string argument for get operation');\n  }\n  context.properties.add(arg.value);\n  if (encoded.length === 3) {\n    var hint = parse(encoded[2], context);\n    return [arg, hint];\n  }\n  return [arg];\n}\n\n/**\n * @type ArgValidator\n */\nfunction withVarArgs(encoded, context, parsedArgs, typeHint) {\n  var varName = encoded[1];\n  if (typeof varName !== 'string') {\n    throw new Error('Expected a string argument for var operation');\n  }\n  context.variables.add(varName);\n  if (!('variables' in context.style) || context.style.variables[varName] === undefined) {\n    return [new LiteralExpression(AnyType, varName)];\n  }\n  var initialValue = context.style.variables[varName];\n  var arg = /** @type {LiteralExpression} */parse(initialValue, context);\n  arg.value = varName;\n  if (typeHint && !overlapsType(typeHint, arg.type)) {\n    throw new Error(\"The variable \".concat(varName, \" has type \").concat(typeName(arg.type), \" but the following type was expected: \").concat(typeName(typeHint)));\n  }\n  return [arg];\n}\n\n/**\n * @type ArgValidator\n */\nfunction usesFeatureId(encoded, context) {\n  context.featureId = true;\n}\n\n/**\n * @type ArgValidator\n */\nfunction withNoArgs(encoded, context) {\n  var operation = encoded[0];\n  if (encoded.length !== 1) {\n    throw new Error(\"Expected no arguments for \".concat(operation, \" operation\"));\n  }\n  return [];\n}\n\n/**\n * @param {number} minArgs The minimum number of arguments.\n * @param {number} maxArgs The maximum number of arguments.\n * @return {ArgValidator} The argument validator\n */\nfunction withArgsCount(minArgs, maxArgs) {\n  return function (encoded, context) {\n    var operation = encoded[0];\n    var argCount = encoded.length - 1;\n    if (minArgs === maxArgs) {\n      if (argCount !== minArgs) {\n        var plural = minArgs === 1 ? '' : 's';\n        throw new Error(\"Expected \".concat(minArgs, \" argument\").concat(plural, \" for \").concat(operation, \", got \").concat(argCount));\n      }\n    } else if (argCount < minArgs || argCount > maxArgs) {\n      var range = maxArgs === Infinity ? \"\".concat(minArgs, \" or more\") : \"\".concat(minArgs, \" to \").concat(maxArgs);\n      throw new Error(\"Expected \".concat(range, \" arguments for \").concat(operation, \", got \").concat(argCount));\n    }\n  };\n}\n\n/**\n * @param {number} argType The argument type.\n * @return {ArgValidator} The argument validator\n */\nfunction parseArgsOfType(argType) {\n  return function (encoded, context) {\n    var operation = encoded[0];\n    var argCount = encoded.length - 1;\n    /**\n     * @type {Array<Expression>}\n     */\n    var args = new Array(argCount);\n    for (var i = 0; i < argCount; ++i) {\n      var expression = parse(encoded[i + 1], context);\n      if (!overlapsType(argType, expression.type)) {\n        var gotType = typeName(argType);\n        var expectedType = typeName(expression.type);\n        throw new Error(\"Unexpected type for argument \".concat(i, \" of \").concat(operation, \" operation\") + \", got \".concat(gotType, \" but expected \").concat(expectedType));\n      }\n      expression.type &= argType;\n      args[i] = expression;\n    }\n    return args;\n  };\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction narrowArgsType(encoded, context, parsedArgs) {\n  var operation = encoded[0];\n  var argCount = encoded.length - 1;\n\n  // first pass to determine a narrowed down type\n  var sameType = AnyType;\n  for (var i = 0; i < parsedArgs.length; ++i) {\n    sameType &= parsedArgs[i].type;\n  }\n  if (sameType === NoneType) {\n    throw new Error(\"No common type could be found for arguments of \".concat(operation, \" operation\"));\n  }\n\n  // re-parse args\n  var args = new Array(argCount);\n  for (var _i = 0; _i < argCount; ++_i) {\n    args[_i] = parse(encoded[_i + 1], context, sameType);\n  }\n  return args;\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withOddArgs(encoded, context) {\n  var operation = encoded[0];\n  var argCount = encoded.length - 1;\n  if (argCount % 2 === 0) {\n    throw new Error(\"An odd amount of arguments was expected for operation \".concat(operation, \", got \").concat(JSON.stringify(argCount), \" instead\"));\n  }\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withEvenArgs(encoded, context) {\n  var operation = encoded[0];\n  var argCount = encoded.length - 1;\n  if (argCount % 2 === 1) {\n    throw new Error(\"An even amount of arguments was expected for operation \".concat(operation, \", got \").concat(JSON.stringify(argCount), \" instead\"));\n  }\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseMatchArgs(encoded, context, parsedArgs, typeHint) {\n  var argsCount = encoded.length - 1;\n  var input = parse(encoded[1], context);\n  var inputType = input.type;\n  var fallback = parse(encoded[encoded.length - 1], context);\n  var outputType = typeHint !== undefined ? typeHint & fallback.type : fallback.type;\n\n  // first parse args to figure out possible types\n  var args = new Array(argsCount - 2);\n  for (var i = 0; i < argsCount - 2; i += 2) {\n    var match = parse(encoded[i + 2], context);\n    var output = parse(encoded[i + 3], context);\n    inputType &= match.type;\n    outputType &= output.type;\n    args[i] = match;\n    args[i + 1] = output;\n  }\n\n  // check input and output types validity\n  var expectedInputType = StringType | NumberType | BooleanType;\n  if (!overlapsType(expectedInputType, inputType)) {\n    throw new Error(\"Expected an input of type \".concat(typeName(expectedInputType), \" for the interpolate operation\") + \", got \".concat(typeName(inputType), \" instead\"));\n  }\n  if (isType(outputType, NoneType)) {\n    throw new Error(\"Could not find a common output type for the following match operation: \" + JSON.stringify(encoded));\n  }\n\n  // parse again inputs and outputs with common type\n  for (var _i2 = 0; _i2 < argsCount - 2; _i2 += 2) {\n    var _match = parse(encoded[_i2 + 2], context, inputType);\n    var _output = parse(encoded[_i2 + 3], context, outputType);\n    args[_i2] = _match;\n    args[_i2 + 1] = _output;\n  }\n  return [parse(encoded[1], context, inputType)].concat(args, [parse(encoded[encoded.length - 1], context, outputType)]);\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseInterpolateArgs(encoded, context, parsedArgs, typeHint) {\n  var interpolationType = encoded[1];\n  var interpolation;\n  switch (interpolationType[0]) {\n    case 'linear':\n      interpolation = 1;\n      break;\n    case 'exponential':\n      interpolation = interpolationType[1];\n      if (typeof interpolation !== 'number') {\n        throw new Error(\"Expected a number base for exponential interpolation\" + \", got \".concat(JSON.stringify(interpolation), \" instead\"));\n      }\n      break;\n    default:\n      interpolation = null;\n  }\n  if (!interpolation) {\n    throw new Error(\"Invalid interpolation type: \".concat(JSON.stringify(interpolationType)));\n  }\n  interpolation = parse(interpolation, context);\n\n  // check input types\n  var input = parse(encoded[2], context);\n  if (!overlapsType(NumberType, input.type)) {\n    throw new Error(\"Expected an input of type number for the interpolate operation\" + \", got \".concat(typeName(input.type), \" instead\"));\n  }\n  input = parse(encoded[2], context, NumberType); // parse again with narrower output\n\n  var args = new Array(encoded.length - 3);\n  for (var i = 0; i < args.length; i += 2) {\n    var stop = parse(encoded[i + 3], context);\n    if (!overlapsType(NumberType, stop.type)) {\n      throw new Error(\"Expected all stop input values in the interpolate operation to be of type number\" + \", got \".concat(typeName(stop.type), \" at position \").concat(i + 2, \" instead\"));\n    }\n    var output = parse(encoded[i + 4], context);\n    if (!overlapsType(NumberType | ColorType, output.type)) {\n      throw new Error(\"Expected all stop output values in the interpolate operation to be a number or color\" + \", got \".concat(typeName(output.type), \" at position \").concat(i + 3, \" instead\"));\n    }\n    // parse again with narrower types\n    stop = parse(encoded[i + 3], context, NumberType);\n    output = parse(encoded[i + 4], context, NumberType | ColorType);\n    args[i] = stop;\n    args[i + 1] = output;\n  }\n  return [interpolation, input].concat(args);\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseCaseArgs(encoded, context, parsedArgs, typeHint) {\n  var fallback = parse(encoded[encoded.length - 1], context);\n  var outputType = typeHint !== undefined ? typeHint & fallback.type : fallback.type;\n\n  // first parse args to figure out possible types\n  var args = new Array(encoded.length - 1);\n  for (var i = 0; i < args.length - 1; i += 2) {\n    var condition = parse(encoded[i + 1], context);\n    var output = parse(encoded[i + 2], context);\n    if (!overlapsType(BooleanType, condition.type)) {\n      throw new Error(\"Expected all conditions in the case operation to be of type boolean\" + \", got \".concat(typeName(condition.type), \" at position \").concat(i, \" instead\"));\n    }\n    outputType &= output.type;\n    args[i] = condition;\n    args[i + 1] = output;\n  }\n  if (isType(outputType, NoneType)) {\n    throw new Error(\"Could not find a common output type for the following case operation: \" + JSON.stringify(encoded));\n  }\n\n  // parse again args with common output type\n  for (var _i3 = 0; _i3 < args.length - 1; _i3 += 2) {\n    args[_i3 + 1] = parse(encoded[_i3 + 2], context, outputType);\n  }\n  args[args.length - 1] = parse(encoded[encoded.length - 1], context, outputType);\n  return args;\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseInArgs(encoded, context) {\n  /** @type {Array<number|string>} */\n  var haystack = /** @type {any} */encoded[2];\n  if (!Array.isArray(haystack)) {\n    throw new Error(\"The \\\"in\\\" operator was provided a literal value which was not an array as second argument.\");\n  }\n  if (typeof haystack[0] === 'string') {\n    if (haystack[0] !== 'literal') {\n      throw new Error(\"For the \\\"in\\\" operator, a string array should be wrapped in a \\\"literal\\\" operator to disambiguate from expressions.\");\n    }\n    if (!Array.isArray(haystack[1])) {\n      throw new Error(\"The \\\"in\\\" operator was provided a literal value which was not an array as second argument.\");\n    }\n    haystack = haystack[1];\n  }\n  var needleType = StringType | NumberType;\n  var args = new Array(haystack.length);\n  for (var i = 0; i < args.length; i++) {\n    var arg = parse(haystack[i], context);\n    needleType &= arg.type;\n    args[i] = arg;\n  }\n  if (isType(needleType, NoneType)) {\n    throw new Error(\"Could not find a common type for the following in operation: \" + JSON.stringify(encoded));\n  }\n  var needle = parse(encoded[1], context, needleType);\n  return [needle].concat(args);\n}\n\n/**\n * @type ArgValidator\n */\nfunction parsePaletteArgs(encoded, context) {\n  var index = parse(encoded[1], context, NumberType);\n  if (index.type !== NumberType) {\n    throw new Error(\"The first argument of palette must be an number, got \".concat(typeName(index.type), \" instead\"));\n  }\n  var colors = encoded[2];\n  if (!Array.isArray(colors)) {\n    throw new Error('The second argument of palette must be an array');\n  }\n  var parsedColors = new Array(colors.length);\n  for (var i = 0; i < parsedColors.length; i++) {\n    var color = parse(colors[i], context, ColorType);\n    if (!(color instanceof LiteralExpression)) {\n      throw new Error(\"The palette color at index \".concat(i, \" must be a literal value\"));\n    }\n    if (!overlapsType(color.type, ColorType)) {\n      throw new Error(\"The palette color at index \".concat(i, \" should be of type color, got \").concat(typeName(color.type), \" instead\"));\n    }\n    parsedColors[i] = color;\n  }\n  return [index].concat(parsedColors);\n}\n\n/**\n * @param {number|function(Array<Expression>):number} returnType The return type of the operator; can be a fixed value or a callback taking the parsed\n * arguments\n * @param {Array<ArgValidator>} argValidators A chain of argument validators; the return value of the last validator\n * will be used as parsed arguments\n * @return {Parser} The parser.\n */\nfunction createParser(returnType) {\n  for (var _len2 = arguments.length, argValidators = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    argValidators[_key2 - 1] = arguments[_key2];\n  }\n  return function (encoded, context, typeHint) {\n    var operator = encoded[0];\n    var parsedArgs = [];\n    for (var i = 0; i < argValidators.length; i++) {\n      parsedArgs = argValidators[i](encoded, context, parsedArgs, typeHint) || parsedArgs;\n    }\n    var actualType = typeof returnType === 'function' ? returnType(parsedArgs) : returnType;\n    if (typeHint !== undefined) {\n      if (!overlapsType(actualType, typeHint)) {\n        throw new Error(\"The following expression was expected to return \".concat(typeName(typeHint), \", but returns \").concat(typeName(actualType), \" instead: \").concat(JSON.stringify(encoded)));\n      }\n      actualType &= typeHint;\n    }\n    if (actualType === NoneType) {\n      throw new Error(\"No matching type was found for the following expression: \".concat(JSON.stringify(encoded)));\n    }\n    return _construct(CallExpression, [actualType, operator].concat(_toConsumableArray(parsedArgs)));\n  };\n}\n\n/**\n * @param {Array} encoded The encoded expression.\n * @param {ParsingContext} context The parsing context.\n * @param {number} [typeHint] Optional type hint\n * @return {Expression} The parsed expression.\n */\nfunction parseCallExpression(encoded, context, typeHint) {\n  var operator = encoded[0];\n  var parser = parsers[operator];\n  if (!parser) {\n    throw new Error(\"Unknown operator: \".concat(operator));\n  }\n  return parser(encoded, context, typeHint);\n}","map":{"version":3,"names":["ascending","isStringColor","numTypes","NoneType","BooleanType","NumberType","StringType","ColorType","NumberArrayType","AnyType","Math","pow","typeNames","_defineProperty","namedTypes","Object","keys","map","Number","sort","typeName","type","names","_iterator","_createForOfIteratorHelper","_step","s","n","done","namedType","value","includesType","push","err","e","f","length","join","slice","broad","specific","overlapsType","oneType","otherType","isType","expected","LiteralExpression","_createClass","_classCallCheck","CallExpression","operator","_len","arguments","args","Array","_key","newParsingContext","variables","Set","properties","featureId","style","getTypeFromHint","typeHint","Error","concat","parse","encoded","context","_typeof","isArray","parseCallExpression","_iterator2","_step2","item","Ops","Get","Var","Concat","GeometryType","Any","All","Not","Resolution","Zoom","Time","Equal","NotEqual","GreaterThan","GreaterThanOrEqualTo","LessThan","LessThanOrEqualTo","Multiply","Divide","Add","Subtract","Clamp","Mod","Pow","Abs","Floor","Ceil","Round","Sin","Cos","Atan","Sqrt","Match","Between","Interpolate","Case","In","String","Color","Id","Band","Palette","parsers","_parsers","createParser","_ref","_ref2","_slicedToArray","_","undefined","withArgsCount","withGetArgs","_ref3","_ref4","firstArg","withVarArgs","withNoArgs","usesFeatureId","Infinity","parseArgsOfType","narrowArgsType","parsedArgs","outputType","i","withEvenArgs","parseMatchArgs","parseInterpolateArgs","withOddArgs","parseCaseArgs","parseInArgs","parsePaletteArgs","arg","add","hint","varName","initialValue","operation","minArgs","maxArgs","argCount","plural","range","argType","expression","gotType","expectedType","sameType","JSON","stringify","argsCount","input","inputType","fallback","match","output","expectedInputType","interpolationType","interpolation","stop","condition","haystack","needleType","needle","index","colors","parsedColors","color","returnType","_len2","argValidators","_key2","actualType","_construct","_toConsumableArray","parser"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol/expr/expression.js"],"sourcesContent":["/**\n * @module ol/expr/expression\n */\nimport {ascending} from '../array.js';\nimport {isStringColor} from '../color.js';\n\n/**\n * @fileoverview This module includes types and functions for parsing array encoded expressions.\n * The result of parsing an encoded expression is one of the specific expression classes.\n * During parsing, information is added to the parsing context about the data accessed by the\n * expression.\n */\n\n/**\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\n * which in turns takes {@link import(\"./expression.js\").ExpressionValue} arguments.\n *\n * The following operators can be used:\n *\n * * Reading operators:\n *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band\n *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values\n *     are in the 0..1 range. {@link import(\"../source/TileImage.js\").default} sources have 4 bands: red,\n *     green, blue and alpha. {@link import(\"../source/DataTile.js\").default} sources can have any number\n *     of bands, depending on the underlying data source and\n *     {@link import(\"../source/GeoTIFF.js\").Options configuration}. `xOffset` and `yOffset` are optional\n *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels.\n *   * `['get', 'attributeName', typeHint]` fetches a feature property value, similar to `feature.get('attributeName')`\n *     A type hint can optionally be specified, in case the resulting expression contains a type ambiguity which\n *     will make it invalid. Type hints can be one of: 'string', 'color', 'number', 'boolean', 'number[]'\n *   * `['geometry-type']` returns a feature's geometry type as string, either: 'LineString', 'Point' or 'Polygon'\n *     `Multi*` values are returned as their singular equivalent\n *     `Circle` geometries are returned as 'Polygon'\n *     `GeometryCollection` geometries are returned as the type of the first geometry found in the collection\n *   * `['resolution']` returns the current resolution\n *   * `['time']` returns the time in seconds since the creation of the layer\n *   * `['var', 'varName']` fetches a value from the style variables; will throw an error if that variable is undefined\n *   * `['zoom']` returns the current zoom level\n *\n * * Math operators:\n *   * `['*', value1, value2, ...]` multiplies the values (either numbers or colors)\n *   * `['/', value1, value2]` divides `value1` by `value2`\n *   * `['+', value1, value2, ...]` adds the values\n *   * `['-', value1, value2]` subtracts `value2` from `value1`\n *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`\n *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\n *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\n *   * `['abs', value1]` returns the absolute value of `value1`\n *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`\n *   * `['round', value1]` returns the nearest integer to `value1`\n *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`\n *   * `['sin', value1]` returns the sine of `value1`\n *   * `['cos', value1]` returns the cosine of `value1`\n *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`\n *   * `['sqrt', value1]` returns the square root of `value1`\n *\n * * Transform operators:\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\n *     All conditions should be `boolean`, output and fallback can be any kind.\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\n *     returns the `fallback` value.\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\n *     `fallback` values must be of the same type, and can be of any kind.\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\n *     of 1 is equivalent to `['linear']`.\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\n *     between `output1` and `outputN`.\n *\n * * Logical operators:\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\n *     (inclusively), or `false` otherwise.\n *   * `['in', needle, haystack]` returns `true` if `needle` is found in `haystack`, and\n *     `false` otherwise.\n *     This operator has the following limitations:\n *     * `haystack` has to be an array of numbers or strings (searching for a substring in a string is not supported yet)\n *     * Only literal arrays are supported as `haystack` for now; this means that `haystack` cannot be the result of an\n *     expression. If `haystack` is an array of strings, use the `literal` operator to disambiguate from an expression:\n *     `['literal', ['abc', 'def', 'ghi']]`\n *\n * * Conversion operators:\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\n *     values can currently only be 2, 3 or 4.\n *   * `['color', red, green, blue, alpha]` creates a `color` value from `number` values; the `alpha` parameter is\n *     optional; if not specified, it will be set to 1.\n *     Note: `red`, `green` and `blue` components must be values between 0 and 255; `alpha` between 0 and 1.\n *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`\n *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors\n *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),\n *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b\n *     in the 0-255 range and a in the 0-1 range).\n *\n * Values can either be literals or another operator, as they will be evaluated recursively.\n * Literal values can be of the following types:\n * * `boolean`\n * * `number`\n * * `number[]` (number arrays can only have a length of 2, 3 or 4)\n * * `string`\n * * {@link module:ol/color~Color}\n *\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\n * @api\n */\n\nlet numTypes = 0;\nexport const NoneType = 0;\nexport const BooleanType = 1 << numTypes++;\nexport const NumberType = 1 << numTypes++;\nexport const StringType = 1 << numTypes++;\nexport const ColorType = 1 << numTypes++;\nexport const NumberArrayType = 1 << numTypes++;\nexport const AnyType = Math.pow(2, numTypes) - 1;\n\nconst typeNames = {\n  [BooleanType]: 'boolean',\n  [NumberType]: 'number',\n  [StringType]: 'string',\n  [ColorType]: 'color',\n  [NumberArrayType]: 'number[]',\n};\n\nconst namedTypes = Object.keys(typeNames).map(Number).sort(ascending);\n\n/**\n * Get a string representation for a type.\n * @param {number} type The type.\n * @return {string} The type name.\n */\nexport function typeName(type) {\n  const names = [];\n  for (const namedType of namedTypes) {\n    if (includesType(type, namedType)) {\n      names.push(typeNames[namedType]);\n    }\n  }\n  if (names.length === 0) {\n    return 'untyped';\n  }\n  if (names.length < 3) {\n    return names.join(' or ');\n  }\n  return names.slice(0, -1).join(', ') + ', or ' + names[names.length - 1];\n}\n\n/**\n * @param {number} broad The broad type.\n * @param {number} specific The specific type.\n * @return {boolean} The broad type includes the specific type.\n */\nexport function includesType(broad, specific) {\n  return (broad & specific) === specific;\n}\n\n/**\n * @param {number} oneType One type.\n * @param {number} otherType Another type.\n * @return {boolean} The set of types overlap (share a common specific type)\n */\nexport function overlapsType(oneType, otherType) {\n  return !!(oneType & otherType);\n}\n\n/**\n * @param {number} type The type.\n * @param {number} expected The expected type.\n * @return {boolean} The given type is exactly the expected type.\n */\nexport function isType(type, expected) {\n  return type === expected;\n}\n\n/**\n * @typedef {boolean|number|string|Array<number>} LiteralValue\n */\n\nexport class LiteralExpression {\n  /**\n   * @param {number} type The value type.\n   * @param {LiteralValue} value The literal value.\n   */\n  constructor(type, value) {\n    this.type = type;\n    this.value = value;\n  }\n}\n\nexport class CallExpression {\n  /**\n   * @param {number} type The return type.\n   * @param {string} operator The operator.\n   * @param {...Expression} args The arguments.\n   */\n  constructor(type, operator, ...args) {\n    this.type = type;\n    this.operator = operator;\n    this.args = args;\n  }\n}\n\n/**\n * @typedef {LiteralExpression|CallExpression} Expression\n */\n\n/**\n * @typedef {Object} ParsingContext\n * @property {Set<string>} variables Variables referenced with the 'var' operator.\n * @property {Set<string>} properties Properties referenced with the 'get' operator.\n * @property {boolean} featureId The style uses the feature id.\n * @property {import(\"../style/flat.js\").FlatStyle|import(\"../style/webgl.js\").WebGLStyle} style The style being parsed\n */\n\n/**\n * @return {ParsingContext} A new parsing context.\n */\nexport function newParsingContext() {\n  return {\n    variables: new Set(),\n    properties: new Set(),\n    featureId: false,\n    style: {},\n  };\n}\n\n/**\n * @param {string} typeHint Type hint\n * @return {number} Resulting value type (will be a single type)\n */\nfunction getTypeFromHint(typeHint) {\n  switch (typeHint) {\n    case 'string':\n      return StringType;\n    case 'color':\n      return ColorType;\n    case 'number':\n      return NumberType;\n    case 'boolean':\n      return BooleanType;\n    case 'number[]':\n      return NumberArrayType;\n    default:\n      throw new Error(`Unrecognized type hint: ${typeHint}`);\n  }\n}\n\n/**\n * @typedef {LiteralValue|Array} EncodedExpression\n */\n\n/**\n * @param {EncodedExpression} encoded The encoded expression.\n * @param {ParsingContext} context The parsing context.\n * @param {number} [typeHint] Optional type hint\n * @return {Expression} The parsed expression result.\n */\nexport function parse(encoded, context, typeHint) {\n  switch (typeof encoded) {\n    case 'boolean': {\n      return new LiteralExpression(BooleanType, encoded);\n    }\n    case 'number': {\n      return new LiteralExpression(NumberType, encoded);\n    }\n    case 'string': {\n      let type = StringType;\n      if (isStringColor(encoded)) {\n        type |= ColorType;\n      }\n      // apply the given type hint only if it won't result in an empty type\n      if (!isType(type & typeHint, NoneType)) {\n        type &= typeHint;\n      }\n      return new LiteralExpression(type, encoded);\n    }\n    default: {\n      // pass\n    }\n  }\n\n  if (!Array.isArray(encoded)) {\n    throw new Error('Expression must be an array or a primitive value');\n  }\n\n  if (encoded.length === 0) {\n    throw new Error('Empty expression');\n  }\n\n  if (typeof encoded[0] === 'string') {\n    return parseCallExpression(encoded, context, typeHint);\n  }\n\n  for (const item of encoded) {\n    if (typeof item !== 'number') {\n      throw new Error('Expected an array of numbers');\n    }\n  }\n\n  let type = NumberArrayType;\n  if (encoded.length === 3 || encoded.length === 4) {\n    type |= ColorType;\n  }\n  if (typeHint) {\n    type &= typeHint;\n  }\n  return new LiteralExpression(type, encoded);\n}\n\n/**\n * @type {Object<string, string>}\n */\nexport const Ops = {\n  Get: 'get',\n  Var: 'var',\n  Concat: 'concat',\n  GeometryType: 'geometry-type',\n  Any: 'any',\n  All: 'all',\n  Not: '!',\n  Resolution: 'resolution',\n  Zoom: 'zoom',\n  Time: 'time',\n  Equal: '==',\n  NotEqual: '!=',\n  GreaterThan: '>',\n  GreaterThanOrEqualTo: '>=',\n  LessThan: '<',\n  LessThanOrEqualTo: '<=',\n  Multiply: '*',\n  Divide: '/',\n  Add: '+',\n  Subtract: '-',\n  Clamp: 'clamp',\n  Mod: '%',\n  Pow: '^',\n  Abs: 'abs',\n  Floor: 'floor',\n  Ceil: 'ceil',\n  Round: 'round',\n  Sin: 'sin',\n  Cos: 'cos',\n  Atan: 'atan',\n  Sqrt: 'sqrt',\n  Match: 'match',\n  Between: 'between',\n  Interpolate: 'interpolate',\n  Case: 'case',\n  In: 'in',\n  Number: 'number',\n  String: 'string',\n  Array: 'array',\n  Color: 'color',\n  Id: 'id',\n  Band: 'band',\n  Palette: 'palette',\n};\n\n/**\n * @typedef {function(Array, ParsingContext, number):Expression} Parser\n * Third argument is a type hint\n */\n\n/**\n * @type {Object<string, Parser>}\n */\nconst parsers = {\n  [Ops.Get]: createParser(\n    ([_, typeHint]) => {\n      if (typeHint !== undefined) {\n        return getTypeFromHint(\n          /** @type {string} */ (\n            /** @type {LiteralExpression} */ (typeHint).value\n          )\n        );\n      }\n      return AnyType;\n    },\n    withArgsCount(1, 2),\n    withGetArgs\n  ),\n  [Ops.Var]: createParser(\n    ([firstArg]) => firstArg.type,\n    withArgsCount(1, 1),\n    withVarArgs\n  ),\n  [Ops.Id]: createParser(NumberType | StringType, withNoArgs, usesFeatureId),\n  [Ops.Concat]: createParser(\n    StringType,\n    withArgsCount(2, Infinity),\n    parseArgsOfType(AnyType)\n  ),\n  [Ops.GeometryType]: createParser(StringType, withNoArgs),\n  [Ops.Resolution]: createParser(NumberType, withNoArgs),\n  [Ops.Zoom]: createParser(NumberType, withNoArgs),\n  [Ops.Time]: createParser(NumberType, withNoArgs),\n  [Ops.Any]: createParser(\n    BooleanType,\n    withArgsCount(2, Infinity),\n    parseArgsOfType(BooleanType)\n  ),\n  [Ops.All]: createParser(\n    BooleanType,\n    withArgsCount(2, Infinity),\n    parseArgsOfType(BooleanType)\n  ),\n  [Ops.Not]: createParser(\n    BooleanType,\n    withArgsCount(1, 1),\n    parseArgsOfType(BooleanType)\n  ),\n  [Ops.Equal]: createParser(\n    BooleanType,\n    withArgsCount(2, 2),\n    parseArgsOfType(AnyType),\n    narrowArgsType\n  ),\n  [Ops.NotEqual]: createParser(\n    BooleanType,\n    withArgsCount(2, 2),\n    parseArgsOfType(AnyType),\n    narrowArgsType\n  ),\n  [Ops.GreaterThan]: createParser(\n    BooleanType,\n    withArgsCount(2, 2),\n    parseArgsOfType(AnyType),\n    narrowArgsType\n  ),\n  [Ops.GreaterThanOrEqualTo]: createParser(\n    BooleanType,\n    withArgsCount(2, 2),\n    parseArgsOfType(AnyType),\n    narrowArgsType\n  ),\n  [Ops.LessThan]: createParser(\n    BooleanType,\n    withArgsCount(2, 2),\n    parseArgsOfType(AnyType),\n    narrowArgsType\n  ),\n  [Ops.LessThanOrEqualTo]: createParser(\n    BooleanType,\n    withArgsCount(2, 2),\n    parseArgsOfType(AnyType),\n    narrowArgsType\n  ),\n  [Ops.Multiply]: createParser(\n    (parsedArgs) => {\n      let outputType = NumberType | ColorType;\n      for (let i = 0; i < parsedArgs.length; i++) {\n        outputType &= parsedArgs[i].type;\n      }\n      return outputType;\n    },\n    withArgsCount(2, Infinity),\n    parseArgsOfType(NumberType | ColorType),\n    narrowArgsType\n  ),\n  [Ops.Divide]: createParser(\n    NumberType,\n    withArgsCount(2, 2),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Add]: createParser(\n    NumberType,\n    withArgsCount(2, Infinity),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Subtract]: createParser(\n    NumberType,\n    withArgsCount(2, 2),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Clamp]: createParser(\n    NumberType,\n    withArgsCount(3, 3),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Mod]: createParser(\n    NumberType,\n    withArgsCount(2, 2),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Pow]: createParser(\n    NumberType,\n    withArgsCount(2, 2),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Abs]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Floor]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Ceil]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Round]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Sin]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Cos]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Atan]: createParser(\n    NumberType,\n    withArgsCount(1, 2),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Sqrt]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Match]: createParser(\n    (parsedArgs) => {\n      let type = AnyType;\n      for (let i = 2; i < parsedArgs.length; i += 2) {\n        type &= parsedArgs[i].type;\n      }\n      type &= parsedArgs[parsedArgs.length - 1].type;\n      return type;\n    },\n    withArgsCount(4, Infinity),\n    withEvenArgs,\n    parseMatchArgs\n  ),\n  [Ops.Between]: createParser(\n    BooleanType,\n    withArgsCount(3, 3),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Interpolate]: createParser(\n    (parsedArgs) => {\n      let type = ColorType | NumberType;\n      for (let i = 3; i < parsedArgs.length; i += 2) {\n        type &= parsedArgs[i].type;\n      }\n      return type;\n    },\n    withArgsCount(6, Infinity),\n    withEvenArgs,\n    parseInterpolateArgs\n  ),\n  [Ops.Case]: createParser(\n    (parsedArgs) => {\n      let type = AnyType;\n      for (let i = 1; i < parsedArgs.length; i += 2) {\n        type &= parsedArgs[i].type;\n      }\n      type &= parsedArgs[parsedArgs.length - 1].type;\n      return type;\n    },\n    withArgsCount(3, Infinity),\n    withOddArgs,\n    parseCaseArgs\n  ),\n  [Ops.In]: createParser(BooleanType, withArgsCount(2, 2), parseInArgs),\n  [Ops.Number]: createParser(\n    NumberType,\n    withArgsCount(1, Infinity),\n    parseArgsOfType(AnyType)\n  ),\n  [Ops.String]: createParser(\n    StringType,\n    withArgsCount(1, Infinity),\n    parseArgsOfType(AnyType)\n  ),\n  [Ops.Array]: createParser(\n    (parsedArgs) => {\n      return parsedArgs.length === 3 || parsedArgs.length === 4\n        ? NumberArrayType | ColorType\n        : NumberArrayType;\n    },\n    withArgsCount(1, Infinity),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Color]: createParser(\n    ColorType,\n    withArgsCount(3, 4),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Band]: createParser(\n    NumberType,\n    withArgsCount(1, 3),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Palette]: createParser(ColorType, withArgsCount(2, 2), parsePaletteArgs),\n};\n\n/**\n * @typedef {function(Array<EncodedExpression>, ParsingContext, Array<Expression>, number?):Array<Expression>|void} ArgValidator\n * An argument validator applies various checks to an encoded expression arguments\n * Returns the parsed arguments if any.\n * Third argument is the array of parsed arguments from previous validators\n * Fourth argument is an optional type hint\n */\n\n/**\n * @type ArgValidator\n */\nfunction withGetArgs(encoded, context) {\n  const arg = parse(encoded[1], context);\n  if (!(arg instanceof LiteralExpression)) {\n    throw new Error('Expected a literal argument for get operation');\n  }\n  if (typeof arg.value !== 'string') {\n    throw new Error('Expected a string argument for get operation');\n  }\n  context.properties.add(arg.value);\n  if (encoded.length === 3) {\n    const hint = parse(encoded[2], context);\n    return [arg, hint];\n  }\n  return [arg];\n}\n\n/**\n * @type ArgValidator\n */\nfunction withVarArgs(encoded, context, parsedArgs, typeHint) {\n  const varName = encoded[1];\n  if (typeof varName !== 'string') {\n    throw new Error('Expected a string argument for var operation');\n  }\n  context.variables.add(varName);\n  if (\n    !('variables' in context.style) ||\n    context.style.variables[varName] === undefined\n  ) {\n    return [new LiteralExpression(AnyType, varName)];\n  }\n  const initialValue = context.style.variables[varName];\n  const arg = /** @type {LiteralExpression} */ (parse(initialValue, context));\n  arg.value = varName;\n  if (typeHint && !overlapsType(typeHint, arg.type)) {\n    throw new Error(\n      `The variable ${varName} has type ${typeName(\n        arg.type\n      )} but the following type was expected: ${typeName(typeHint)}`\n    );\n  }\n  return [arg];\n}\n\n/**\n * @type ArgValidator\n */\nfunction usesFeatureId(encoded, context) {\n  context.featureId = true;\n}\n\n/**\n * @type ArgValidator\n */\nfunction withNoArgs(encoded, context) {\n  const operation = encoded[0];\n  if (encoded.length !== 1) {\n    throw new Error(`Expected no arguments for ${operation} operation`);\n  }\n  return [];\n}\n\n/**\n * @param {number} minArgs The minimum number of arguments.\n * @param {number} maxArgs The maximum number of arguments.\n * @return {ArgValidator} The argument validator\n */\nfunction withArgsCount(minArgs, maxArgs) {\n  return function (encoded, context) {\n    const operation = encoded[0];\n    const argCount = encoded.length - 1;\n    if (minArgs === maxArgs) {\n      if (argCount !== minArgs) {\n        const plural = minArgs === 1 ? '' : 's';\n        throw new Error(\n          `Expected ${minArgs} argument${plural} for ${operation}, got ${argCount}`\n        );\n      }\n    } else if (argCount < minArgs || argCount > maxArgs) {\n      const range =\n        maxArgs === Infinity\n          ? `${minArgs} or more`\n          : `${minArgs} to ${maxArgs}`;\n      throw new Error(\n        `Expected ${range} arguments for ${operation}, got ${argCount}`\n      );\n    }\n  };\n}\n\n/**\n * @param {number} argType The argument type.\n * @return {ArgValidator} The argument validator\n */\nfunction parseArgsOfType(argType) {\n  return function (encoded, context) {\n    const operation = encoded[0];\n    const argCount = encoded.length - 1;\n    /**\n     * @type {Array<Expression>}\n     */\n    const args = new Array(argCount);\n    for (let i = 0; i < argCount; ++i) {\n      const expression = parse(encoded[i + 1], context);\n      if (!overlapsType(argType, expression.type)) {\n        const gotType = typeName(argType);\n        const expectedType = typeName(expression.type);\n        throw new Error(\n          `Unexpected type for argument ${i} of ${operation} operation` +\n            `, got ${gotType} but expected ${expectedType}`\n        );\n      }\n      expression.type &= argType;\n      args[i] = expression;\n    }\n    return args;\n  };\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction narrowArgsType(encoded, context, parsedArgs) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n\n  // first pass to determine a narrowed down type\n  let sameType = AnyType;\n  for (let i = 0; i < parsedArgs.length; ++i) {\n    sameType &= parsedArgs[i].type;\n  }\n\n  if (sameType === NoneType) {\n    throw new Error(\n      `No common type could be found for arguments of ${operation} operation`\n    );\n  }\n\n  // re-parse args\n  const args = new Array(argCount);\n  for (let i = 0; i < argCount; ++i) {\n    args[i] = parse(encoded[i + 1], context, sameType);\n  }\n  return args;\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withOddArgs(encoded, context) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n  if (argCount % 2 === 0) {\n    throw new Error(\n      `An odd amount of arguments was expected for operation ${operation}, got ${JSON.stringify(\n        argCount\n      )} instead`\n    );\n  }\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withEvenArgs(encoded, context) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n  if (argCount % 2 === 1) {\n    throw new Error(\n      `An even amount of arguments was expected for operation ${operation}, got ${JSON.stringify(\n        argCount\n      )} instead`\n    );\n  }\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseMatchArgs(encoded, context, parsedArgs, typeHint) {\n  const argsCount = encoded.length - 1;\n\n  const input = parse(encoded[1], context);\n  let inputType = input.type;\n  const fallback = parse(encoded[encoded.length - 1], context);\n  let outputType =\n    typeHint !== undefined ? typeHint & fallback.type : fallback.type;\n\n  // first parse args to figure out possible types\n  const args = new Array(argsCount - 2);\n  for (let i = 0; i < argsCount - 2; i += 2) {\n    const match = parse(encoded[i + 2], context);\n    const output = parse(encoded[i + 3], context);\n    inputType &= match.type;\n    outputType &= output.type;\n    args[i] = match;\n    args[i + 1] = output;\n  }\n\n  // check input and output types validity\n  const expectedInputType = StringType | NumberType | BooleanType;\n  if (!overlapsType(expectedInputType, inputType)) {\n    throw new Error(\n      `Expected an input of type ${typeName(\n        expectedInputType\n      )} for the interpolate operation` + `, got ${typeName(inputType)} instead`\n    );\n  }\n  if (isType(outputType, NoneType)) {\n    throw new Error(\n      `Could not find a common output type for the following match operation: ` +\n        JSON.stringify(encoded)\n    );\n  }\n\n  // parse again inputs and outputs with common type\n  for (let i = 0; i < argsCount - 2; i += 2) {\n    const match = parse(encoded[i + 2], context, inputType);\n    const output = parse(encoded[i + 3], context, outputType);\n    args[i] = match;\n    args[i + 1] = output;\n  }\n\n  return [\n    parse(encoded[1], context, inputType),\n    ...args,\n    parse(encoded[encoded.length - 1], context, outputType),\n  ];\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseInterpolateArgs(encoded, context, parsedArgs, typeHint) {\n  const interpolationType = encoded[1];\n  let interpolation;\n  switch (interpolationType[0]) {\n    case 'linear':\n      interpolation = 1;\n      break;\n    case 'exponential':\n      interpolation = interpolationType[1];\n      if (typeof interpolation !== 'number') {\n        throw new Error(\n          `Expected a number base for exponential interpolation` +\n            `, got ${JSON.stringify(interpolation)} instead`\n        );\n      }\n      break;\n    default:\n      interpolation = null;\n  }\n  if (!interpolation) {\n    throw new Error(\n      `Invalid interpolation type: ${JSON.stringify(interpolationType)}`\n    );\n  }\n  interpolation = parse(interpolation, context);\n\n  // check input types\n  let input = parse(encoded[2], context);\n  if (!overlapsType(NumberType, input.type)) {\n    throw new Error(\n      `Expected an input of type number for the interpolate operation` +\n        `, got ${typeName(input.type)} instead`\n    );\n  }\n  input = parse(encoded[2], context, NumberType); // parse again with narrower output\n\n  const args = new Array(encoded.length - 3);\n  for (let i = 0; i < args.length; i += 2) {\n    let stop = parse(encoded[i + 3], context);\n    if (!overlapsType(NumberType, stop.type)) {\n      throw new Error(\n        `Expected all stop input values in the interpolate operation to be of type number` +\n          `, got ${typeName(stop.type)} at position ${i + 2} instead`\n      );\n    }\n    let output = parse(encoded[i + 4], context);\n    if (!overlapsType(NumberType | ColorType, output.type)) {\n      throw new Error(\n        `Expected all stop output values in the interpolate operation to be a number or color` +\n          `, got ${typeName(output.type)} at position ${i + 3} instead`\n      );\n    }\n    // parse again with narrower types\n    stop = parse(encoded[i + 3], context, NumberType);\n    output = parse(encoded[i + 4], context, NumberType | ColorType);\n    args[i] = stop;\n    args[i + 1] = output;\n  }\n\n  return [interpolation, input, ...args];\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseCaseArgs(encoded, context, parsedArgs, typeHint) {\n  const fallback = parse(encoded[encoded.length - 1], context);\n  let outputType =\n    typeHint !== undefined ? typeHint & fallback.type : fallback.type;\n\n  // first parse args to figure out possible types\n  const args = new Array(encoded.length - 1);\n  for (let i = 0; i < args.length - 1; i += 2) {\n    const condition = parse(encoded[i + 1], context);\n    const output = parse(encoded[i + 2], context);\n    if (!overlapsType(BooleanType, condition.type)) {\n      throw new Error(\n        `Expected all conditions in the case operation to be of type boolean` +\n          `, got ${typeName(condition.type)} at position ${i} instead`\n      );\n    }\n    outputType &= output.type;\n    args[i] = condition;\n    args[i + 1] = output;\n  }\n\n  if (isType(outputType, NoneType)) {\n    throw new Error(\n      `Could not find a common output type for the following case operation: ` +\n        JSON.stringify(encoded)\n    );\n  }\n\n  // parse again args with common output type\n  for (let i = 0; i < args.length - 1; i += 2) {\n    args[i + 1] = parse(encoded[i + 2], context, outputType);\n  }\n  args[args.length - 1] = parse(\n    encoded[encoded.length - 1],\n    context,\n    outputType\n  );\n\n  return args;\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseInArgs(encoded, context) {\n  /** @type {Array<number|string>} */\n  let haystack = /** @type {any} */ (encoded[2]);\n  if (!Array.isArray(haystack)) {\n    throw new Error(\n      `The \"in\" operator was provided a literal value which was not an array as second argument.`\n    );\n  }\n  if (typeof haystack[0] === 'string') {\n    if (haystack[0] !== 'literal') {\n      throw new Error(\n        `For the \"in\" operator, a string array should be wrapped in a \"literal\" operator to disambiguate from expressions.`\n      );\n    }\n    if (!Array.isArray(haystack[1])) {\n      throw new Error(\n        `The \"in\" operator was provided a literal value which was not an array as second argument.`\n      );\n    }\n    haystack = haystack[1];\n  }\n\n  let needleType = StringType | NumberType;\n  const args = new Array(haystack.length);\n  for (let i = 0; i < args.length; i++) {\n    const arg = parse(haystack[i], context);\n    needleType &= arg.type;\n    args[i] = arg;\n  }\n  if (isType(needleType, NoneType)) {\n    throw new Error(\n      `Could not find a common type for the following in operation: ` +\n        JSON.stringify(encoded)\n    );\n  }\n\n  const needle = parse(encoded[1], context, needleType);\n  return [needle, ...args];\n}\n\n/**\n * @type ArgValidator\n */\nfunction parsePaletteArgs(encoded, context) {\n  const index = parse(encoded[1], context, NumberType);\n  if (index.type !== NumberType) {\n    throw new Error(\n      `The first argument of palette must be an number, got ${typeName(\n        index.type\n      )} instead`\n    );\n  }\n  const colors = encoded[2];\n  if (!Array.isArray(colors)) {\n    throw new Error('The second argument of palette must be an array');\n  }\n  const parsedColors = new Array(colors.length);\n  for (let i = 0; i < parsedColors.length; i++) {\n    const color = parse(colors[i], context, ColorType);\n    if (!(color instanceof LiteralExpression)) {\n      throw new Error(\n        `The palette color at index ${i} must be a literal value`\n      );\n    }\n    if (!overlapsType(color.type, ColorType)) {\n      throw new Error(\n        `The palette color at index ${i} should be of type color, got ${typeName(\n          color.type\n        )} instead`\n      );\n    }\n    parsedColors[i] = color;\n  }\n  return [index, ...parsedColors];\n}\n\n/**\n * @param {number|function(Array<Expression>):number} returnType The return type of the operator; can be a fixed value or a callback taking the parsed\n * arguments\n * @param {Array<ArgValidator>} argValidators A chain of argument validators; the return value of the last validator\n * will be used as parsed arguments\n * @return {Parser} The parser.\n */\nfunction createParser(returnType, ...argValidators) {\n  return function (encoded, context, typeHint) {\n    const operator = encoded[0];\n    let parsedArgs = [];\n    for (let i = 0; i < argValidators.length; i++) {\n      parsedArgs =\n        argValidators[i](encoded, context, parsedArgs, typeHint) || parsedArgs;\n    }\n    let actualType =\n      typeof returnType === 'function' ? returnType(parsedArgs) : returnType;\n    if (typeHint !== undefined) {\n      if (!overlapsType(actualType, typeHint)) {\n        throw new Error(\n          `The following expression was expected to return ${typeName(\n            typeHint\n          )}, but returns ${typeName(actualType)} instead: ${JSON.stringify(\n            encoded\n          )}`\n        );\n      }\n      actualType &= typeHint;\n    }\n    if (actualType === NoneType) {\n      throw new Error(\n        `No matching type was found for the following expression: ${JSON.stringify(\n          encoded\n        )}`\n      );\n    }\n    return new CallExpression(actualType, operator, ...parsedArgs);\n  };\n}\n\n/**\n * @param {Array} encoded The encoded expression.\n * @param {ParsingContext} context The parsing context.\n * @param {number} [typeHint] Optional type hint\n * @return {Expression} The parsed expression.\n */\nfunction parseCallExpression(encoded, context, typeHint) {\n  const operator = encoded[0];\n\n  const parser = parsers[operator];\n  if (!parser) {\n    throw new Error(`Unknown operator: ${operator}`);\n  }\n  return parser(encoded, context, typeHint);\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA,SAAQA,SAAS,QAAO,aAAa;AACrC,SAAQC,aAAa,QAAO,aAAa;;AAEzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,QAAQ,GAAG,CAAC;AAChB,OAAO,IAAMC,QAAQ,GAAG,CAAC;AACzB,OAAO,IAAMC,WAAW,GAAG,CAAC,IAAIF,QAAQ,EAAE;AAC1C,OAAO,IAAMG,UAAU,GAAG,CAAC,IAAIH,QAAQ,EAAE;AACzC,OAAO,IAAMI,UAAU,GAAG,CAAC,IAAIJ,QAAQ,EAAE;AACzC,OAAO,IAAMK,SAAS,GAAG,CAAC,IAAIL,QAAQ,EAAE;AACxC,OAAO,IAAMM,eAAe,GAAG,CAAC,IAAIN,QAAQ,EAAE;AAC9C,OAAO,IAAMO,OAAO,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAET,QAAQ,CAAC,GAAG,CAAC;AAEhD,IAAMU,SAAS,GAAAC,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAAA,eAAA,CAAAA,eAAA,KACZT,WAAW,EAAG,SAAS,GACvBC,UAAU,EAAG,QAAQ,GACrBC,UAAU,EAAG,QAAQ,GACrBC,SAAS,EAAG,OAAO,GACnBC,eAAe,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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}