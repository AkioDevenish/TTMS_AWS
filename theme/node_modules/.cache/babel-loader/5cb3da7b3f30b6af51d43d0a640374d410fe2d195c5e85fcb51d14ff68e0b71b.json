{"ast":null,"code":"import _superPropGet from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/superPropGet.js\";\nimport _createClass from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _callSuper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.date.now.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/web.timers.js\";\n/**\n * @module ol/interaction/Draw\n */\nimport Circle from '../geom/Circle.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport Feature from '../Feature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport InteractionProperty from './Property.js';\nimport LineString from '../geom/LineString.js';\nimport MapBrowserEvent from '../MapBrowserEvent.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport PointerInteraction from './Pointer.js';\nimport Polygon, { fromCircle, makeRegular } from '../geom/Polygon.js';\nimport VectorLayer from '../layer/Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport { FALSE, TRUE } from '../functions.js';\nimport { always, never, noModifierKeys, shiftKeyOnly } from '../events/condition.js';\nimport { boundingExtent, getBottomLeft, getBottomRight, getTopLeft, getTopRight } from '../extent.js';\nimport { clamp, squaredDistance, toFixed } from '../math.js';\nimport { createEditingStyle } from '../style/Style.js';\nimport { distance, squaredDistance as squaredCoordinateDistance } from '../coordinate.js';\nimport { fromUserCoordinate, getUserProjection } from '../proj.js';\nimport { getStrideForLayout } from '../geom/SimpleGeometry.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../geom/Geometry.js\").Type} type Geometry type of\n * the geometries being drawn with this instance.\n * @property {number} [clickTolerance=6] The maximum distance in pixels between\n * \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\n * actually add a point/vertex to the geometry being drawn.  The default of `6`\n * was chosen for the draw interaction to behave correctly on mouse as well as\n * on touch devices.\n * @property {import(\"../Collection.js\").default<Feature>} [features]\n * Destination collection for the drawn features.\n * @property {VectorSource} [source] Destination source for\n * the drawn features.\n * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown\n * before the current vertex can be dragged to its exact position.\n * @property {number} [snapTolerance=12] Pixel distance for snapping to the\n * drawing finish. Must be greater than `0`.\n * @property {boolean} [stopClick=false] Stop click, singleclick, and\n * doubleclick events from firing during drawing.\n * @property {number} [maxPoints] The number of points that can be drawn before\n * a polygon ring or line string is finished. By default there is no\n * restriction.\n * @property {number} [minPoints] The number of points that must be drawn\n * before a polygon ring or line string can be finished. Default is `3` for\n * polygon rings and `2` for line strings.\n * @property {import(\"../events/condition.js\").Condition} [finishCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether the drawing can be finished. Not used when drawing\n * POINT or MULTI_POINT geometries.\n * @property {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike} [style]\n * Style for sketch features. The draw interaction can have up to three sketch features, depending on the mode.\n * It will always contain a feature with a `Point` geometry that corresponds to the current cursor position.\n * If the mode is `LineString` or `Polygon`, and there is at least one drawn point, it will also contain a feature with\n * a `LineString` geometry that corresponds to the line between the already drawn points and the current cursor position.\n * If the mode is `Polygon`, and there is at least one drawn point, it will also contain a feature with a `Polygon`\n * geometry that corresponds to the polygon between the already drawn points and the current cursor position\n * (note that this polygon has only two points if only one point is drawn).\n * If the mode is `Circle`, and there is one point drawn, it will also contain a feature with a `Circle` geometry whose\n * center is the drawn point and the radius is determined by the distance between the drawn point and the cursor.\n * @property {GeometryFunction} [geometryFunction]\n * Function that is called when a geometry's coordinates are updated.\n * @property {string} [geometryName] Geometry name to use for features created\n * by the draw interaction.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default {@link module:ol/events/condition.noModifierKeys}, i.e. a click,\n * adds a vertex or deactivates freehand drawing.\n * @property {boolean} [freehand=false] Operate in freehand mode for lines,\n * polygons, and circles.  This makes the interaction always operate in freehand\n * mode and takes precedence over any `freehandCondition` option.\n * @property {import(\"../events/condition.js\").Condition} [freehandCondition]\n * Condition that activates freehand drawing for lines and polygons. This\n * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\n * returns a boolean to indicate whether that event should be handled. The\n * default is {@link module:ol/events/condition.shiftKeyOnly}, meaning that the\n * Shift key activates freehand drawing.\n * @property {boolean|import(\"../events/condition.js\").Condition} [trace=false] Trace a portion of another geometry.\n * Ignored when in freehand mode.\n * @property {VectorSource} [traceSource] Source for features to trace.  If tracing is active and a `traceSource` is\n * not provided, the interaction's `source` will be used.  Tracing requires that the interaction is configured with\n * either a `traceSource` or a `source`.\n * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\n * overlay.\n * @property {import(\"../geom/Geometry.js\").GeometryLayout} [geometryLayout='XY'] Layout of the\n * feature geometries created by the draw interaction.\n */\n\n/**\n * Coordinate type when drawing points.\n * @typedef {import(\"../coordinate.js\").Coordinate} PointCoordType\n */\n\n/**\n * Coordinate type when drawing lines.\n * @typedef {Array<import(\"../coordinate.js\").Coordinate>} LineCoordType\n */\n\n/**\n * Coordinate type when drawing polygons.\n * @typedef {Array<Array<import(\"../coordinate.js\").Coordinate>>} PolyCoordType\n */\n\n/**\n * Types used for drawing coordinates.\n * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType\n */\n\n/**\n * @typedef {Object} TraceState\n * @property {boolean} active Tracing active.\n * @property {import(\"../pixel.js\").Pixel} [startPx] The initially clicked pixel location.\n * @property {Array<TraceTarget>} [targets] Targets available for tracing.\n * @property {number} [targetIndex] The index of the currently traced target.  A value of -1 indicates\n * that no trace target is active.\n */\n\n/**\n * @typedef {Object} TraceTarget\n * @property {Array<import(\"../coordinate.js\").Coordinate>} coordinates Target coordinates.\n * @property {boolean} ring The target coordinates are a linear ring.\n * @property {number} startIndex The index of first traced coordinate.  A fractional index represents an\n * edge intersection.  Index values for rings will wrap (may be negative or larger than coordinates length).\n * @property {number} endIndex The index of last traced coordinate.  Details from startIndex also apply here.\n */\n\n/**\n * Function that takes an array of coordinates and an optional existing geometry\n * and a projection as arguments, and returns a geometry. The optional existing\n * geometry is the geometry that is returned when the function is called without\n * a second argument.\n * @typedef {function(!SketchCoordType, import(\"../geom/SimpleGeometry.js\").default,\n *     import(\"../proj/Projection.js\").default):\n *     import(\"../geom/SimpleGeometry.js\").default} GeometryFunction\n */\n\n/**\n * @typedef {'Point' | 'LineString' | 'Polygon' | 'Circle'} Mode\n * Draw mode.  This collapses multi-part geometry types with their single-part\n * cousins.\n */\n\n/**\n * @enum {string}\n */\nvar DrawEventType = {\n  /**\n   * Triggered upon feature draw start\n   * @event DrawEvent#drawstart\n   * @api\n   */\n  DRAWSTART: 'drawstart',\n  /**\n   * Triggered upon feature draw end\n   * @event DrawEvent#drawend\n   * @api\n   */\n  DRAWEND: 'drawend',\n  /**\n   * Triggered upon feature draw abortion\n   * @event DrawEvent#drawabort\n   * @api\n   */\n  DRAWABORT: 'drawabort'\n};\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are\n * instances of this type.\n */\nexport var DrawEvent = /*#__PURE__*/function (_Event) {\n  /**\n   * @param {DrawEventType} type Type.\n   * @param {Feature} feature The feature drawn.\n   */\n  function DrawEvent(type, feature) {\n    var _this;\n    _classCallCheck(this, DrawEvent);\n    _this = _callSuper(this, DrawEvent, [type]);\n\n    /**\n     * The feature being drawn.\n     * @type {Feature}\n     * @api\n     */\n    _this.feature = feature;\n    return _this;\n  }\n  _inherits(DrawEvent, _Event);\n  return _createClass(DrawEvent);\n}(Event);\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {Array<Feature>} features The candidate features.\n * @return {Array<TraceTarget>} The trace targets.\n */\nfunction getTraceTargets(coordinate, features) {\n  /**\n   * @type {Array<TraceTarget>}\n   */\n  var targets = [];\n  for (var i = 0; i < features.length; ++i) {\n    var feature = features[i];\n    var geometry = feature.getGeometry();\n    appendGeometryTraceTargets(coordinate, geometry, targets);\n  }\n  return targets;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} a One coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} b Another coordinate.\n * @return {number} The squared distance between the two coordinates.\n */\nfunction getSquaredDistance(a, b) {\n  return squaredDistance(a[0], a[1], b[0], b[1]);\n}\n\n/**\n * @param {LineCoordType} coordinates The ring coordinates.\n * @param {number} index The index.  May be wrapped.\n * @return {import(\"../coordinate.js\").Coordinate} The coordinate.\n */\nfunction getCoordinate(coordinates, index) {\n  var count = coordinates.length;\n  if (index < 0) {\n    return coordinates[index + count];\n  }\n  if (index >= count) {\n    return coordinates[index - count];\n  }\n  return coordinates[index];\n}\n\n/**\n * Get the cumulative squared distance along a ring path.  The end index index may be \"wrapped\" and it may\n * be less than the start index to indicate the direction of travel.  The start and end index may have\n * a fractional part to indicate a point between two coordinates.\n * @param {LineCoordType} coordinates Ring coordinates.\n * @param {number} startIndex The start index.\n * @param {number} endIndex The end index.\n * @return {number} The cumulative squared distance along the ring path.\n */\nfunction getCumulativeSquaredDistance(coordinates, startIndex, endIndex) {\n  var lowIndex, highIndex;\n  if (startIndex < endIndex) {\n    lowIndex = startIndex;\n    highIndex = endIndex;\n  } else {\n    lowIndex = endIndex;\n    highIndex = startIndex;\n  }\n  var lowWholeIndex = Math.ceil(lowIndex);\n  var highWholeIndex = Math.floor(highIndex);\n  if (lowWholeIndex > highWholeIndex) {\n    // both start and end are on the same segment\n    var start = interpolateCoordinate(coordinates, lowIndex);\n    var end = interpolateCoordinate(coordinates, highIndex);\n    return getSquaredDistance(start, end);\n  }\n  var sd = 0;\n  if (lowIndex < lowWholeIndex) {\n    var _start = interpolateCoordinate(coordinates, lowIndex);\n    var _end = getCoordinate(coordinates, lowWholeIndex);\n    sd += getSquaredDistance(_start, _end);\n  }\n  if (highWholeIndex < highIndex) {\n    var _start2 = getCoordinate(coordinates, highWholeIndex);\n    var _end2 = interpolateCoordinate(coordinates, highIndex);\n    sd += getSquaredDistance(_start2, _end2);\n  }\n  for (var i = lowWholeIndex; i < highWholeIndex - 1; ++i) {\n    var _start3 = getCoordinate(coordinates, i);\n    var _end3 = getCoordinate(coordinates, i + 1);\n    sd += getSquaredDistance(_start3, _end3);\n  }\n  return sd;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {import(\"../geom/Geometry.js\").default} geometry The candidate geometry.\n * @param {Array<TraceTarget>} targets The trace targets.\n */\nfunction appendGeometryTraceTargets(coordinate, geometry, targets) {\n  if (geometry instanceof LineString) {\n    appendTraceTarget(coordinate, geometry.getCoordinates(), false, targets);\n    return;\n  }\n  if (geometry instanceof MultiLineString) {\n    var coordinates = geometry.getCoordinates();\n    for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n      appendTraceTarget(coordinate, coordinates[i], false, targets);\n    }\n    return;\n  }\n  if (geometry instanceof Polygon) {\n    var _coordinates = geometry.getCoordinates();\n    for (var _i = 0, _ii = _coordinates.length; _i < _ii; ++_i) {\n      appendTraceTarget(coordinate, _coordinates[_i], true, targets);\n    }\n    return;\n  }\n  if (geometry instanceof MultiPolygon) {\n    var polys = geometry.getCoordinates();\n    for (var _i2 = 0, _ii2 = polys.length; _i2 < _ii2; ++_i2) {\n      var _coordinates2 = polys[_i2];\n      for (var j = 0, jj = _coordinates2.length; j < jj; ++j) {\n        appendTraceTarget(coordinate, _coordinates2[j], true, targets);\n      }\n    }\n    return;\n  }\n  if (geometry instanceof GeometryCollection) {\n    var geometries = geometry.getGeometries();\n    for (var _i3 = 0; _i3 < geometries.length; ++_i3) {\n      appendGeometryTraceTargets(coordinate, geometries[_i3], targets);\n    }\n    return;\n  }\n  // other types cannot be traced\n}\n\n/**\n * @typedef {Object} TraceTargetUpdateInfo\n * @property {number} index The new target index.\n * @property {number} endIndex The new segment end index.\n */\n\n/**\n * @type {TraceTargetUpdateInfo}\n */\nvar sharedUpdateInfo = {\n  index: -1,\n  endIndex: NaN\n};\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {TraceState} traceState The trace state.\n * @param {import(\"../Map.js\").default} map The map.\n * @param {number} snapTolerance The snap tolerance.\n * @return {TraceTargetUpdateInfo} Information about the new trace target.  The returned\n * object is reused between calls and must not be modified by the caller.\n */\nfunction getTraceTargetUpdate(coordinate, traceState, map, snapTolerance) {\n  var x = coordinate[0];\n  var y = coordinate[1];\n  var closestTargetDistance = Infinity;\n  var newTargetIndex = -1;\n  var newEndIndex = NaN;\n  for (var targetIndex = 0; targetIndex < traceState.targets.length; ++targetIndex) {\n    var target = traceState.targets[targetIndex];\n    var coordinates = target.coordinates;\n    var minSegmentDistance = Infinity;\n    var endIndex = void 0;\n    for (var coordinateIndex = 0; coordinateIndex < coordinates.length - 1; ++coordinateIndex) {\n      var start = coordinates[coordinateIndex];\n      var end = coordinates[coordinateIndex + 1];\n      var rel = getPointSegmentRelationship(x, y, start, end);\n      if (rel.squaredDistance < minSegmentDistance) {\n        minSegmentDistance = rel.squaredDistance;\n        endIndex = coordinateIndex + rel.along;\n      }\n    }\n    if (minSegmentDistance < closestTargetDistance) {\n      closestTargetDistance = minSegmentDistance;\n      if (target.ring && traceState.targetIndex === targetIndex) {\n        // same target, maintain the same trace direction\n        if (target.endIndex > target.startIndex) {\n          // forward trace\n          if (endIndex < target.startIndex) {\n            endIndex += coordinates.length;\n          }\n        } else if (target.endIndex < target.startIndex) {\n          // reverse trace\n          if (endIndex > target.startIndex) {\n            endIndex -= coordinates.length;\n          }\n        }\n      }\n      newEndIndex = endIndex;\n      newTargetIndex = targetIndex;\n    }\n  }\n  var newTarget = traceState.targets[newTargetIndex];\n  var considerBothDirections = newTarget.ring;\n  if (traceState.targetIndex === newTargetIndex && considerBothDirections) {\n    // only consider switching trace direction if close to the start\n    var newCoordinate = interpolateCoordinate(newTarget.coordinates, newEndIndex);\n    var pixel = map.getPixelFromCoordinate(newCoordinate);\n    if (distance(pixel, traceState.startPx) > snapTolerance) {\n      considerBothDirections = false;\n    }\n  }\n  if (considerBothDirections) {\n    var _coordinates3 = newTarget.coordinates;\n    var count = _coordinates3.length;\n    var startIndex = newTarget.startIndex;\n    var _endIndex = newEndIndex;\n    if (startIndex < _endIndex) {\n      var forwardDistance = getCumulativeSquaredDistance(_coordinates3, startIndex, _endIndex);\n      var reverseDistance = getCumulativeSquaredDistance(_coordinates3, startIndex, _endIndex - count);\n      if (reverseDistance < forwardDistance) {\n        newEndIndex -= count;\n      }\n    } else {\n      var _reverseDistance = getCumulativeSquaredDistance(_coordinates3, startIndex, _endIndex);\n      var _forwardDistance = getCumulativeSquaredDistance(_coordinates3, startIndex, _endIndex + count);\n      if (_forwardDistance < _reverseDistance) {\n        newEndIndex += count;\n      }\n    }\n  }\n  sharedUpdateInfo.index = newTargetIndex;\n  sharedUpdateInfo.endIndex = newEndIndex;\n  return sharedUpdateInfo;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The clicked coordinate.\n * @param {Array<import(\"../coordinate.js\").Coordinate>} coordinates The geometry component coordinates.\n * @param {boolean} ring The coordinates represent a linear ring.\n * @param {Array<TraceTarget>} targets The trace targets.\n */\nfunction appendTraceTarget(coordinate, coordinates, ring, targets) {\n  var x = coordinate[0];\n  var y = coordinate[1];\n  for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n    var start = coordinates[i];\n    var end = coordinates[i + 1];\n    var rel = getPointSegmentRelationship(x, y, start, end);\n    if (rel.squaredDistance === 0) {\n      var index = i + rel.along;\n      targets.push({\n        coordinates: coordinates,\n        ring: ring,\n        startIndex: index,\n        endIndex: index\n      });\n      return;\n    }\n  }\n}\n\n/**\n * @typedef {Object} PointSegmentRelationship\n * @property {number} along The closest point expressed as a fraction along the segment length.\n * @property {number} squaredDistance The squared distance of the point to the segment.\n */\n\n/**\n * @type {PointSegmentRelationship}\n */\nvar sharedRel = {\n  along: 0,\n  squaredDistance: 0\n};\n\n/**\n * @param {number} x The point x.\n * @param {number} y The point y.\n * @param {import(\"../coordinate.js\").Coordinate} start The segment start.\n * @param {import(\"../coordinate.js\").Coordinate} end The segment end.\n * @return {PointSegmentRelationship} The point segment relationship.  The returned object is\n * shared between calls and must not be modified by the caller.\n */\nfunction getPointSegmentRelationship(x, y, start, end) {\n  var x1 = start[0];\n  var y1 = start[1];\n  var x2 = end[0];\n  var y2 = end[1];\n  var dx = x2 - x1;\n  var dy = y2 - y1;\n  var along = 0;\n  var px = x1;\n  var py = y1;\n  if (dx !== 0 || dy !== 0) {\n    along = clamp(((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy), 0, 1);\n    px += dx * along;\n    py += dy * along;\n  }\n  sharedRel.along = along;\n  sharedRel.squaredDistance = toFixed(squaredDistance(x, y, px, py), 10);\n  return sharedRel;\n}\n\n/**\n * @param {LineCoordType} coordinates The coordinates.\n * @param {number} index The index.  May be fractional and may wrap.\n * @return {import(\"../coordinate.js\").Coordinate} The interpolated coordinate.\n */\nfunction interpolateCoordinate(coordinates, index) {\n  var count = coordinates.length;\n  var startIndex = Math.floor(index);\n  var along = index - startIndex;\n  if (startIndex >= count) {\n    startIndex -= count;\n  } else if (startIndex < 0) {\n    startIndex += count;\n  }\n  var endIndex = startIndex + 1;\n  if (endIndex >= count) {\n    endIndex -= count;\n  }\n  var start = coordinates[startIndex];\n  var x0 = start[0];\n  var y0 = start[1];\n  var end = coordinates[endIndex];\n  var dx = end[0] - x0;\n  var dy = end[1] - y0;\n  return [x0 + dx * along, y0 + dy * along];\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'drawabort'|'drawend'|'drawstart', DrawEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'drawabort'|'drawend'|'drawstart', Return>} DrawOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for drawing feature geometries.\n *\n * @fires DrawEvent\n * @api\n */\nvar Draw = /*#__PURE__*/function (_PointerInteraction) {\n  /**\n   * @param {Options} options Options.\n   */\n  function Draw(options) {\n    var _this2;\n    _classCallCheck(this, Draw);\n    var pointerOptions = /** @type {import(\"./Pointer.js\").Options} */\n    options;\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n    _this2 = _callSuper(this, Draw, [pointerOptions]);\n\n    /***\n     * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n     */\n    _this2.on;\n\n    /***\n     * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n     */\n    _this2.once;\n\n    /***\n     * @type {DrawOnSignature<void>}\n     */\n    _this2.un;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    _this2.shouldHandle_ = false;\n\n    /**\n     * @type {import(\"../pixel.js\").Pixel}\n     * @private\n     */\n    _this2.downPx_ = null;\n\n    /**\n     * @type {ReturnType<typeof setTimeout>}\n     * @private\n     */\n    _this2.downTimeout_;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    _this2.lastDragTime_;\n\n    /**\n     * Pointer type of the last pointermove event\n     * @type {string}\n     * @private\n     */\n    _this2.pointerType_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    _this2.freehand_ = false;\n\n    /**\n     * Target source for drawn features.\n     * @type {VectorSource|null}\n     * @private\n     */\n    _this2.source_ = options.source ? options.source : null;\n\n    /**\n     * Target collection for drawn features.\n     * @type {import(\"../Collection.js\").default<Feature>|null}\n     * @private\n     */\n    _this2.features_ = options.features ? options.features : null;\n\n    /**\n     * Pixel distance for snapping.\n     * @type {number}\n     * @private\n     */\n    _this2.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;\n\n    /**\n     * Geometry type.\n     * @type {import(\"../geom/Geometry.js\").Type}\n     * @private\n     */\n    _this2.type_ = /** @type {import(\"../geom/Geometry.js\").Type} */\n    options.type;\n\n    /**\n     * Drawing mode (derived from geometry type.\n     * @type {Mode}\n     * @private\n     */\n    _this2.mode_ = getMode(_this2.type_);\n\n    /**\n     * Stop click, singleclick, and doubleclick events from firing during drawing.\n     * Default is `false`.\n     * @type {boolean}\n     * @private\n     */\n    _this2.stopClick_ = !!options.stopClick;\n\n    /**\n     * The number of points that must be drawn before a polygon ring or line\n     * string can be finished.  The default is 3 for polygon rings and 2 for\n     * line strings.\n     * @type {number}\n     * @private\n     */\n    _this2.minPoints_ = options.minPoints ? options.minPoints : _this2.mode_ === 'Polygon' ? 3 : 2;\n\n    /**\n     * The number of points that can be drawn before a polygon ring or line string\n     * is finished. The default is no restriction.\n     * @type {number}\n     * @private\n     */\n    _this2.maxPoints_ = _this2.mode_ === 'Circle' ? 2 : options.maxPoints ? options.maxPoints : Infinity;\n\n    /**\n     * A function to decide if a potential finish coordinate is permissible\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    _this2.finishCondition_ = options.finishCondition ? options.finishCondition : TRUE;\n\n    /**\n     * @private\n     * @type {import(\"../geom/Geometry.js\").GeometryLayout}\n     */\n    _this2.geometryLayout_ = options.geometryLayout ? options.geometryLayout : 'XY';\n    var geometryFunction = options.geometryFunction;\n    if (!geometryFunction) {\n      var mode = _this2.mode_;\n      if (mode === 'Circle') {\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n         * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n        geometryFunction = function geometryFunction(coordinates, geometry, projection) {\n          var circle = geometry ? (/** @type {Circle} */geometry) : new Circle([NaN, NaN]);\n          var center = fromUserCoordinate(coordinates[0], projection);\n          var squaredLength = squaredCoordinateDistance(center, fromUserCoordinate(coordinates[coordinates.length - 1], projection));\n          circle.setCenterAndRadius(center, Math.sqrt(squaredLength), this.geometryLayout_);\n          var userProjection = getUserProjection();\n          if (userProjection) {\n            circle.transform(projection, userProjection);\n          }\n          return circle;\n        };\n      } else {\n        var Constructor;\n        if (mode === 'Point') {\n          Constructor = Point;\n        } else if (mode === 'LineString') {\n          Constructor = LineString;\n        } else if (mode === 'Polygon') {\n          Constructor = Polygon;\n        }\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n         * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n        geometryFunction = function geometryFunction(coordinates, geometry, projection) {\n          if (geometry) {\n            if (mode === 'Polygon') {\n              if (coordinates[0].length) {\n                // Add a closing coordinate to match the first\n                geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])], this.geometryLayout_);\n              } else {\n                geometry.setCoordinates([], this.geometryLayout_);\n              }\n            } else {\n              geometry.setCoordinates(coordinates, this.geometryLayout_);\n            }\n          } else {\n            geometry = new Constructor(coordinates, this.geometryLayout_);\n          }\n          return geometry;\n        };\n      }\n    }\n\n    /**\n     * @type {GeometryFunction}\n     * @private\n     */\n    _this2.geometryFunction_ = geometryFunction;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    _this2.dragVertexDelay_ = options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;\n\n    /**\n     * Finish coordinate for the feature (first point for polygons, last point for\n     * linestrings).\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    _this2.finishCoordinate_ = null;\n\n    /**\n     * Sketch feature.\n     * @type {Feature<import('../geom/SimpleGeometry.js').default>}\n     * @private\n     */\n    _this2.sketchFeature_ = null;\n\n    /**\n     * Sketch point.\n     * @type {Feature<Point>}\n     * @private\n     */\n    _this2.sketchPoint_ = null;\n\n    /**\n     * Sketch coordinates. Used when drawing a line or polygon.\n     * @type {SketchCoordType}\n     * @private\n     */\n    _this2.sketchCoords_ = null;\n\n    /**\n     * Sketch line. Used when drawing polygon.\n     * @type {Feature<LineString>}\n     * @private\n     */\n    _this2.sketchLine_ = null;\n\n    /**\n     * Sketch line coordinates. Used when drawing a polygon or circle.\n     * @type {LineCoordType}\n     * @private\n     */\n    _this2.sketchLineCoords_ = null;\n\n    /**\n     * Squared tolerance for handling up events.  If the squared distance\n     * between a down and up event is greater than this tolerance, up events\n     * will not be handled.\n     * @type {number}\n     * @private\n     */\n    _this2.squaredClickTolerance_ = options.clickTolerance ? options.clickTolerance * options.clickTolerance : 36;\n\n    /**\n     * Draw overlay where our sketch features are drawn.\n     * @type {VectorLayer}\n     * @private\n     */\n    _this2.overlay_ = new VectorLayer({\n      source: new VectorSource({\n        useSpatialIndex: false,\n        wrapX: options.wrapX ? options.wrapX : false\n      }),\n      style: options.style ? options.style : getDefaultStyleFunction(),\n      updateWhileInteracting: true\n    });\n\n    /**\n     * Name of the geometry attribute for newly created features.\n     * @type {string|undefined}\n     * @private\n     */\n    _this2.geometryName_ = options.geometryName;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    _this2.condition_ = options.condition ? options.condition : noModifierKeys;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    _this2.freehandCondition_;\n    if (options.freehand) {\n      _this2.freehandCondition_ = always;\n    } else {\n      _this2.freehandCondition_ = options.freehandCondition ? options.freehandCondition : shiftKeyOnly;\n    }\n\n    /**\n     * @type {import(\"../events/condition.js\").Condition}\n     * @private\n     */\n    _this2.traceCondition_;\n    _this2.setTrace(options.trace || false);\n\n    /**\n     * @type {TraceState}\n     * @private\n     */\n    _this2.traceState_ = {\n      active: false\n    };\n\n    /**\n     * @type {VectorSource|null}\n     * @private\n     */\n    _this2.traceSource_ = options.traceSource || options.source || null;\n    _this2.addChangeListener(InteractionProperty.ACTIVE, _this2.updateState_);\n    return _this2;\n  }\n\n  /**\n   * Toggle tracing mode or set a tracing condition.\n   *\n   * @param {boolean|import(\"../events/condition.js\").Condition} trace A boolean to toggle tracing mode or an event\n   *     condition that will be checked when a feature is clicked to determine if tracing should be active.\n   */\n  _inherits(Draw, _PointerInteraction);\n  return _createClass(Draw, [{\n    key: \"setTrace\",\n    value: function setTrace(trace) {\n      var condition;\n      if (!trace) {\n        condition = never;\n      } else if (trace === true) {\n        condition = always;\n      } else {\n        condition = trace;\n      }\n      this.traceCondition_ = condition;\n    }\n\n    /**\n     * Remove the interaction from its current map and attach it to the new map.\n     * Subclasses may set up event handlers to get notified about changes to\n     * the map here.\n     * @param {import(\"../Map.js\").default} map Map.\n     */\n  }, {\n    key: \"setMap\",\n    value: function setMap(map) {\n      _superPropGet(Draw, \"setMap\", this, 3)([map]);\n      this.updateState_();\n    }\n\n    /**\n     * Get the overlay layer that this interaction renders sketch features to.\n     * @return {VectorLayer} Overlay layer.\n     * @api\n     */\n  }, {\n    key: \"getOverlay\",\n    value: function getOverlay() {\n      return this.overlay_;\n    }\n\n    /**\n     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.\n     * @param {import(\"../MapBrowserEvent.js\").default} event Map browser event.\n     * @return {boolean} `false` to stop event propagation.\n     * @api\n     */\n  }, {\n    key: \"handleEvent\",\n    value: function handleEvent(event) {\n      if (event.originalEvent.type === EventType.CONTEXTMENU) {\n        // Avoid context menu for long taps when drawing on mobile\n        event.originalEvent.preventDefault();\n      }\n      this.freehand_ = this.mode_ !== 'Point' && this.freehandCondition_(event);\n      var move = event.type === MapBrowserEventType.POINTERMOVE;\n      var pass = true;\n      if (!this.freehand_ && this.lastDragTime_ && event.type === MapBrowserEventType.POINTERDRAG) {\n        var now = Date.now();\n        if (now - this.lastDragTime_ >= this.dragVertexDelay_) {\n          this.downPx_ = event.pixel;\n          this.shouldHandle_ = !this.freehand_;\n          move = true;\n        } else {\n          this.lastDragTime_ = undefined;\n        }\n        if (this.shouldHandle_ && this.downTimeout_ !== undefined) {\n          clearTimeout(this.downTimeout_);\n          this.downTimeout_ = undefined;\n        }\n      }\n      if (this.freehand_ && event.type === MapBrowserEventType.POINTERDRAG && this.sketchFeature_ !== null) {\n        this.addToDrawing_(event.coordinate);\n        pass = false;\n      } else if (this.freehand_ && event.type === MapBrowserEventType.POINTERDOWN) {\n        pass = false;\n      } else if (move && this.getPointerCount() < 2) {\n        pass = event.type === MapBrowserEventType.POINTERMOVE;\n        if (pass && this.freehand_) {\n          this.handlePointerMove_(event);\n          if (this.shouldHandle_) {\n            // Avoid page scrolling when freehand drawing on mobile\n            event.originalEvent.preventDefault();\n          }\n        } else if (event.originalEvent.pointerType === 'mouse' || event.type === MapBrowserEventType.POINTERDRAG && this.downTimeout_ === undefined) {\n          this.handlePointerMove_(event);\n        }\n      } else if (event.type === MapBrowserEventType.DBLCLICK) {\n        pass = false;\n      }\n      return _superPropGet(Draw, \"handleEvent\", this, 3)([event]) && pass;\n    }\n\n    /**\n     * Handle pointer down events.\n     * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n     * @return {boolean} If the event was consumed.\n     */\n  }, {\n    key: \"handleDownEvent\",\n    value: function handleDownEvent(event) {\n      var _this3 = this;\n      this.shouldHandle_ = !this.freehand_;\n      if (this.freehand_) {\n        this.downPx_ = event.pixel;\n        if (!this.finishCoordinate_) {\n          this.startDrawing_(event.coordinate);\n        }\n        return true;\n      }\n      if (!this.condition_(event)) {\n        this.lastDragTime_ = undefined;\n        return false;\n      }\n      this.lastDragTime_ = Date.now();\n      this.downTimeout_ = setTimeout(function () {\n        _this3.handlePointerMove_(new MapBrowserEvent(MapBrowserEventType.POINTERMOVE, event.map, event.originalEvent, false, event.frameState));\n      }, this.dragVertexDelay_);\n      this.downPx_ = event.pixel;\n      return true;\n    }\n\n    /**\n     * @private\n     */\n  }, {\n    key: \"deactivateTrace_\",\n    value: function deactivateTrace_() {\n      this.traceState_ = {\n        active: false\n      };\n    }\n\n    /**\n     * Activate or deactivate trace state based on a browser event.\n     * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n     * @private\n     */\n  }, {\n    key: \"toggleTraceState_\",\n    value: function toggleTraceState_(event) {\n      if (!this.traceSource_ || !this.traceCondition_(event)) {\n        return;\n      }\n      if (this.traceState_.active) {\n        this.deactivateTrace_();\n        return;\n      }\n      var map = this.getMap();\n      var lowerLeft = map.getCoordinateFromPixel([event.pixel[0] - this.snapTolerance_, event.pixel[1] + this.snapTolerance_]);\n      var upperRight = map.getCoordinateFromPixel([event.pixel[0] + this.snapTolerance_, event.pixel[1] - this.snapTolerance_]);\n      var extent = boundingExtent([lowerLeft, upperRight]);\n      var features = this.traceSource_.getFeaturesInExtent(extent);\n      if (features.length === 0) {\n        return;\n      }\n      var targets = getTraceTargets(event.coordinate, features);\n      if (targets.length) {\n        this.traceState_ = {\n          active: true,\n          startPx: event.pixel.slice(),\n          targets: targets,\n          targetIndex: -1\n        };\n      }\n    }\n\n    /**\n     * @param {TraceTarget} target The trace target.\n     * @param {number} endIndex The new end index of the trace.\n     * @private\n     */\n  }, {\n    key: \"addOrRemoveTracedCoordinates_\",\n    value: function addOrRemoveTracedCoordinates_(target, endIndex) {\n      // three cases to handle:\n      //  1. traced in the same direction and points need adding\n      //  2. traced in the same direction and points need removing\n      //  3. traced in a new direction\n      var previouslyForward = target.startIndex <= target.endIndex;\n      var currentlyForward = target.startIndex <= endIndex;\n      if (previouslyForward === currentlyForward) {\n        // same direction\n        if (previouslyForward && endIndex > target.endIndex || !previouslyForward && endIndex < target.endIndex) {\n          // case 1 - add new points\n          this.addTracedCoordinates_(target, target.endIndex, endIndex);\n        } else if (previouslyForward && endIndex < target.endIndex || !previouslyForward && endIndex > target.endIndex) {\n          // case 2 - remove old points\n          this.removeTracedCoordinates_(endIndex, target.endIndex);\n        }\n      } else {\n        // case 3 - remove old points, add new points\n        this.removeTracedCoordinates_(target.startIndex, target.endIndex);\n        this.addTracedCoordinates_(target, target.startIndex, endIndex);\n      }\n    }\n\n    /**\n     * @param {number} fromIndex The start index.\n     * @param {number} toIndex The end index.\n     * @private\n     */\n  }, {\n    key: \"removeTracedCoordinates_\",\n    value: function removeTracedCoordinates_(fromIndex, toIndex) {\n      if (fromIndex === toIndex) {\n        return;\n      }\n      var remove = 0;\n      if (fromIndex < toIndex) {\n        var start = Math.ceil(fromIndex);\n        var end = Math.floor(toIndex);\n        if (end === toIndex) {\n          end -= 1;\n        }\n        remove = end - start + 1;\n      } else {\n        var _start4 = Math.floor(fromIndex);\n        var _end4 = Math.ceil(toIndex);\n        if (_end4 === toIndex) {\n          _end4 += 1;\n        }\n        remove = _start4 - _end4 + 1;\n      }\n      if (remove > 0) {\n        this.removeLastPoints_(remove);\n      }\n    }\n\n    /**\n     * @param {TraceTarget} target The trace target.\n     * @param {number} fromIndex The start index.\n     * @param {number} toIndex The end index.\n     * @private\n     */\n  }, {\n    key: \"addTracedCoordinates_\",\n    value: function addTracedCoordinates_(target, fromIndex, toIndex) {\n      if (fromIndex === toIndex) {\n        return;\n      }\n      var coordinates = [];\n      if (fromIndex < toIndex) {\n        // forward trace\n        var start = Math.ceil(fromIndex);\n        var end = Math.floor(toIndex);\n        if (end === toIndex) {\n          // if end is snapped to a vertex, it will be added later\n          end -= 1;\n        }\n        for (var i = start; i <= end; ++i) {\n          coordinates.push(getCoordinate(target.coordinates, i));\n        }\n      } else {\n        // reverse trace\n        var _start5 = Math.floor(fromIndex);\n        var _end5 = Math.ceil(toIndex);\n        if (_end5 === toIndex) {\n          _end5 += 1;\n        }\n        for (var _i4 = _start5; _i4 >= _end5; --_i4) {\n          coordinates.push(getCoordinate(target.coordinates, _i4));\n        }\n      }\n      if (coordinates.length) {\n        this.appendCoordinates(coordinates);\n      }\n    }\n\n    /**\n     * Update the trace.\n     * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n     * @private\n     */\n  }, {\n    key: \"updateTrace_\",\n    value: function updateTrace_(event) {\n      var traceState = this.traceState_;\n      if (!traceState.active) {\n        return;\n      }\n      if (traceState.targetIndex === -1) {\n        // check if we are ready to pick a target\n        if (distance(traceState.startPx, event.pixel) < this.snapTolerance_) {\n          return;\n        }\n      }\n      var updatedTraceTarget = getTraceTargetUpdate(event.coordinate, traceState, this.getMap(), this.snapTolerance_);\n      if (traceState.targetIndex !== updatedTraceTarget.index) {\n        // target changed\n        if (traceState.targetIndex !== -1) {\n          // remove points added during previous trace\n          var oldTarget = traceState.targets[traceState.targetIndex];\n          this.removeTracedCoordinates_(oldTarget.startIndex, oldTarget.endIndex);\n        }\n        // add points for the new target\n        var newTarget = traceState.targets[updatedTraceTarget.index];\n        this.addTracedCoordinates_(newTarget, newTarget.startIndex, updatedTraceTarget.endIndex);\n      } else {\n        // target stayed the same\n        var _target = traceState.targets[traceState.targetIndex];\n        this.addOrRemoveTracedCoordinates_(_target, updatedTraceTarget.endIndex);\n      }\n\n      // modify the state with updated info\n      traceState.targetIndex = updatedTraceTarget.index;\n      var target = traceState.targets[traceState.targetIndex];\n      target.endIndex = updatedTraceTarget.endIndex;\n\n      // update event coordinate and pixel to match end point of final segment\n      var coordinate = interpolateCoordinate(target.coordinates, target.endIndex);\n      var pixel = this.getMap().getPixelFromCoordinate(coordinate);\n      event.coordinate = coordinate;\n      event.pixel = [Math.round(pixel[0]), Math.round(pixel[1])];\n    }\n\n    /**\n     * Handle pointer up events.\n     * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n     * @return {boolean} If the event was consumed.\n     */\n  }, {\n    key: \"handleUpEvent\",\n    value: function handleUpEvent(event) {\n      var pass = true;\n      if (this.getPointerCount() === 0) {\n        if (this.downTimeout_) {\n          clearTimeout(this.downTimeout_);\n          this.downTimeout_ = undefined;\n        }\n        this.handlePointerMove_(event);\n        var tracing = this.traceState_.active;\n        this.toggleTraceState_(event);\n        if (this.shouldHandle_) {\n          var startingToDraw = !this.finishCoordinate_;\n          if (startingToDraw) {\n            this.startDrawing_(event.coordinate);\n          }\n          if (!startingToDraw && this.freehand_) {\n            this.finishDrawing();\n          } else if (!this.freehand_ && (!startingToDraw || this.mode_ === 'Point')) {\n            if (this.atFinish_(event.pixel, tracing)) {\n              if (this.finishCondition_(event)) {\n                this.finishDrawing();\n              }\n            } else {\n              this.addToDrawing_(event.coordinate);\n            }\n          }\n          pass = false;\n        } else if (this.freehand_) {\n          this.abortDrawing();\n        }\n      }\n      if (!pass && this.stopClick_) {\n        event.preventDefault();\n      }\n      return pass;\n    }\n\n    /**\n     * Handle move events.\n     * @param {import(\"../MapBrowserEvent.js\").default} event A move event.\n     * @private\n     */\n  }, {\n    key: \"handlePointerMove_\",\n    value: function handlePointerMove_(event) {\n      this.pointerType_ = event.originalEvent.pointerType;\n      if (this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {\n        var downPx = this.downPx_;\n        var clickPx = event.pixel;\n        var dx = downPx[0] - clickPx[0];\n        var dy = downPx[1] - clickPx[1];\n        var _squaredDistance = dx * dx + dy * dy;\n        this.shouldHandle_ = this.freehand_ ? _squaredDistance > this.squaredClickTolerance_ : _squaredDistance <= this.squaredClickTolerance_;\n        if (!this.shouldHandle_) {\n          return;\n        }\n      }\n      if (!this.finishCoordinate_) {\n        this.createOrUpdateSketchPoint_(event.coordinate.slice());\n        return;\n      }\n      this.updateTrace_(event);\n      this.modifyDrawing_(event.coordinate);\n    }\n\n    /**\n     * Determine if an event is within the snapping tolerance of the start coord.\n     * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n     * @param {boolean} [tracing] Drawing in trace mode (only stop if at the starting point).\n     * @return {boolean} The event is within the snapping tolerance of the start.\n     * @private\n     */\n  }, {\n    key: \"atFinish_\",\n    value: function atFinish_(pixel, tracing) {\n      var at = false;\n      if (this.sketchFeature_) {\n        var potentiallyDone = false;\n        var potentiallyFinishCoordinates = [this.finishCoordinate_];\n        var mode = this.mode_;\n        if (mode === 'Point') {\n          at = true;\n        } else if (mode === 'Circle') {\n          at = this.sketchCoords_.length === 2;\n        } else if (mode === 'LineString') {\n          potentiallyDone = !tracing && this.sketchCoords_.length > this.minPoints_;\n        } else if (mode === 'Polygon') {\n          var sketchCoords = /** @type {PolyCoordType} */this.sketchCoords_;\n          potentiallyDone = sketchCoords[0].length > this.minPoints_;\n          potentiallyFinishCoordinates = [sketchCoords[0][0], sketchCoords[0][sketchCoords[0].length - 2]];\n          if (tracing) {\n            potentiallyFinishCoordinates = [sketchCoords[0][0]];\n          } else {\n            potentiallyFinishCoordinates = [sketchCoords[0][0], sketchCoords[0][sketchCoords[0].length - 2]];\n          }\n        }\n        if (potentiallyDone) {\n          var map = this.getMap();\n          for (var i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {\n            var finishCoordinate = potentiallyFinishCoordinates[i];\n            var finishPixel = map.getPixelFromCoordinate(finishCoordinate);\n            var dx = pixel[0] - finishPixel[0];\n            var dy = pixel[1] - finishPixel[1];\n            var snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;\n            at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;\n            if (at) {\n              this.finishCoordinate_ = finishCoordinate;\n              break;\n            }\n          }\n        }\n      }\n      return at;\n    }\n\n    /**\n     * @param {import(\"../coordinate\").Coordinate} coordinates Coordinate.\n     * @private\n     */\n  }, {\n    key: \"createOrUpdateSketchPoint_\",\n    value: function createOrUpdateSketchPoint_(coordinates) {\n      if (!this.sketchPoint_) {\n        this.sketchPoint_ = new Feature(new Point(coordinates));\n        this.updateSketchFeatures_();\n      } else {\n        var sketchPointGeom = this.sketchPoint_.getGeometry();\n        sketchPointGeom.setCoordinates(coordinates);\n      }\n    }\n\n    /**\n     * @param {import(\"../geom/Polygon.js\").default} geometry Polygon geometry.\n     * @private\n     */\n  }, {\n    key: \"createOrUpdateCustomSketchLine_\",\n    value: function createOrUpdateCustomSketchLine_(geometry) {\n      if (!this.sketchLine_) {\n        this.sketchLine_ = new Feature();\n      }\n      var ring = geometry.getLinearRing(0);\n      var sketchLineGeom = this.sketchLine_.getGeometry();\n      if (!sketchLineGeom) {\n        sketchLineGeom = new LineString(ring.getFlatCoordinates(), ring.getLayout());\n        this.sketchLine_.setGeometry(sketchLineGeom);\n      } else {\n        sketchLineGeom.setFlatCoordinates(ring.getLayout(), ring.getFlatCoordinates());\n        sketchLineGeom.changed();\n      }\n    }\n\n    /**\n     * Start the drawing.\n     * @param {import(\"../coordinate.js\").Coordinate} start Start coordinate.\n     * @private\n     */\n  }, {\n    key: \"startDrawing_\",\n    value: function startDrawing_(start) {\n      var projection = this.getMap().getView().getProjection();\n      var stride = getStrideForLayout(this.geometryLayout_);\n      while (start.length < stride) {\n        start.push(0);\n      }\n      this.finishCoordinate_ = start;\n      if (this.mode_ === 'Point') {\n        this.sketchCoords_ = start.slice();\n      } else if (this.mode_ === 'Polygon') {\n        this.sketchCoords_ = [[start.slice(), start.slice()]];\n        this.sketchLineCoords_ = this.sketchCoords_[0];\n      } else {\n        this.sketchCoords_ = [start.slice(), start.slice()];\n      }\n      if (this.sketchLineCoords_) {\n        this.sketchLine_ = new Feature(new LineString(this.sketchLineCoords_));\n      }\n      var geometry = this.geometryFunction_(this.sketchCoords_, undefined, projection);\n      this.sketchFeature_ = new Feature();\n      if (this.geometryName_) {\n        this.sketchFeature_.setGeometryName(this.geometryName_);\n      }\n      this.sketchFeature_.setGeometry(geometry);\n      this.updateSketchFeatures_();\n      this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));\n    }\n\n    /**\n     * Modify the drawing.\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @private\n     */\n  }, {\n    key: \"modifyDrawing_\",\n    value: function modifyDrawing_(coordinate) {\n      var map = this.getMap();\n      var geometry = this.sketchFeature_.getGeometry();\n      var projection = map.getView().getProjection();\n      var stride = getStrideForLayout(this.geometryLayout_);\n      var coordinates, last;\n      while (coordinate.length < stride) {\n        coordinate.push(0);\n      }\n      if (this.mode_ === 'Point') {\n        last = this.sketchCoords_;\n      } else if (this.mode_ === 'Polygon') {\n        coordinates = /** @type {PolyCoordType} */this.sketchCoords_[0];\n        last = coordinates[coordinates.length - 1];\n        if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {\n          // snap to finish\n          coordinate = this.finishCoordinate_.slice();\n        }\n      } else {\n        coordinates = this.sketchCoords_;\n        last = coordinates[coordinates.length - 1];\n      }\n      last[0] = coordinate[0];\n      last[1] = coordinate[1];\n      this.geometryFunction_(/** @type {!LineCoordType} */this.sketchCoords_, geometry, projection);\n      if (this.sketchPoint_) {\n        var sketchPointGeom = this.sketchPoint_.getGeometry();\n        sketchPointGeom.setCoordinates(coordinate);\n      }\n      if (geometry.getType() === 'Polygon' && this.mode_ !== 'Polygon') {\n        this.createOrUpdateCustomSketchLine_(/** @type {Polygon} */geometry);\n      } else if (this.sketchLineCoords_) {\n        var sketchLineGeom = this.sketchLine_.getGeometry();\n        sketchLineGeom.setCoordinates(this.sketchLineCoords_);\n      }\n      this.updateSketchFeatures_();\n    }\n\n    /**\n     * Add a new coordinate to the drawing.\n     * @param {!PointCoordType} coordinate Coordinate\n     * @private\n     */\n  }, {\n    key: \"addToDrawing_\",\n    value: function addToDrawing_(coordinate) {\n      var geometry = this.sketchFeature_.getGeometry();\n      var projection = this.getMap().getView().getProjection();\n      var done;\n      var coordinates;\n      var mode = this.mode_;\n      if (mode === 'LineString' || mode === 'Circle') {\n        this.finishCoordinate_ = coordinate.slice();\n        coordinates = /** @type {LineCoordType} */this.sketchCoords_;\n        if (coordinates.length >= this.maxPoints_) {\n          if (this.freehand_) {\n            coordinates.pop();\n          } else {\n            done = true;\n          }\n        }\n        coordinates.push(coordinate.slice());\n        this.geometryFunction_(coordinates, geometry, projection);\n      } else if (mode === 'Polygon') {\n        coordinates = /** @type {PolyCoordType} */this.sketchCoords_[0];\n        if (coordinates.length >= this.maxPoints_) {\n          if (this.freehand_) {\n            coordinates.pop();\n          } else {\n            done = true;\n          }\n        }\n        coordinates.push(coordinate.slice());\n        if (done) {\n          this.finishCoordinate_ = coordinates[0];\n        }\n        this.geometryFunction_(this.sketchCoords_, geometry, projection);\n      }\n      this.createOrUpdateSketchPoint_(coordinate.slice());\n      this.updateSketchFeatures_();\n      if (done) {\n        this.finishDrawing();\n      }\n    }\n\n    /**\n     * @param {number} n The number of points to remove.\n     */\n  }, {\n    key: \"removeLastPoints_\",\n    value: function removeLastPoints_(n) {\n      if (!this.sketchFeature_) {\n        return;\n      }\n      var geometry = this.sketchFeature_.getGeometry();\n      var projection = this.getMap().getView().getProjection();\n      var mode = this.mode_;\n      for (var i = 0; i < n; ++i) {\n        var coordinates = void 0;\n        if (mode === 'LineString' || mode === 'Circle') {\n          coordinates = /** @type {LineCoordType} */this.sketchCoords_;\n          coordinates.splice(-2, 1);\n          if (coordinates.length >= 2) {\n            this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();\n            var finishCoordinate = this.finishCoordinate_.slice();\n            coordinates[coordinates.length - 1] = finishCoordinate;\n            this.createOrUpdateSketchPoint_(finishCoordinate);\n          }\n          this.geometryFunction_(coordinates, geometry, projection);\n          if (geometry.getType() === 'Polygon' && this.sketchLine_) {\n            this.createOrUpdateCustomSketchLine_(/** @type {Polygon} */geometry);\n          }\n        } else if (mode === 'Polygon') {\n          coordinates = /** @type {PolyCoordType} */this.sketchCoords_[0];\n          coordinates.splice(-2, 1);\n          var sketchLineGeom = this.sketchLine_.getGeometry();\n          if (coordinates.length >= 2) {\n            var _finishCoordinate = coordinates[coordinates.length - 2].slice();\n            coordinates[coordinates.length - 1] = _finishCoordinate;\n            this.createOrUpdateSketchPoint_(_finishCoordinate);\n          }\n          sketchLineGeom.setCoordinates(coordinates);\n          this.geometryFunction_(this.sketchCoords_, geometry, projection);\n        }\n        if (coordinates.length === 1) {\n          this.abortDrawing();\n          break;\n        }\n      }\n      this.updateSketchFeatures_();\n    }\n\n    /**\n     * Remove last point of the feature currently being drawn. Does not do anything when\n     * drawing POINT or MULTI_POINT geometries.\n     * @api\n     */\n  }, {\n    key: \"removeLastPoint\",\n    value: function removeLastPoint() {\n      this.removeLastPoints_(1);\n    }\n\n    /**\n     * Stop drawing and add the sketch feature to the target layer.\n     * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is\n     * dispatched before inserting the feature.\n     * @api\n     */\n  }, {\n    key: \"finishDrawing\",\n    value: function finishDrawing() {\n      var sketchFeature = this.abortDrawing_();\n      if (!sketchFeature) {\n        return;\n      }\n      var coordinates = this.sketchCoords_;\n      var geometry = sketchFeature.getGeometry();\n      var projection = this.getMap().getView().getProjection();\n      if (this.mode_ === 'LineString') {\n        // remove the redundant last point\n        coordinates.pop();\n        this.geometryFunction_(coordinates, geometry, projection);\n      } else if (this.mode_ === 'Polygon') {\n        // remove the redundant last point in ring\n        /** @type {PolyCoordType} */\n        coordinates[0].pop();\n        this.geometryFunction_(coordinates, geometry, projection);\n        coordinates = geometry.getCoordinates();\n      }\n\n      // cast multi-part geometries\n      if (this.type_ === 'MultiPoint') {\n        sketchFeature.setGeometry(new MultiPoint([(/** @type {PointCoordType} */coordinates)]));\n      } else if (this.type_ === 'MultiLineString') {\n        sketchFeature.setGeometry(new MultiLineString([(/** @type {LineCoordType} */coordinates)]));\n      } else if (this.type_ === 'MultiPolygon') {\n        sketchFeature.setGeometry(new MultiPolygon([(/** @type {PolyCoordType} */coordinates)]));\n      }\n\n      // First dispatch event to allow full set up of feature\n      this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));\n\n      // Then insert feature\n      if (this.features_) {\n        this.features_.push(sketchFeature);\n      }\n      if (this.source_) {\n        this.source_.addFeature(sketchFeature);\n      }\n    }\n\n    /**\n     * Stop drawing without adding the sketch feature to the target layer.\n     * @return {Feature<import(\"../geom/SimpleGeometry.js\").default>|null} The sketch feature (or null if none).\n     * @private\n     */\n  }, {\n    key: \"abortDrawing_\",\n    value: function abortDrawing_() {\n      this.finishCoordinate_ = null;\n      var sketchFeature = this.sketchFeature_;\n      this.sketchFeature_ = null;\n      this.sketchPoint_ = null;\n      this.sketchLine_ = null;\n      this.overlay_.getSource().clear(true);\n      this.deactivateTrace_();\n      return sketchFeature;\n    }\n\n    /**\n     * Stop drawing without adding the sketch feature to the target layer.\n     * @api\n     */\n  }, {\n    key: \"abortDrawing\",\n    value: function abortDrawing() {\n      var sketchFeature = this.abortDrawing_();\n      if (sketchFeature) {\n        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));\n      }\n    }\n\n    /**\n     * Append coordinates to the end of the geometry that is currently being drawn.\n     * This can be used when drawing LineStrings or Polygons. Coordinates will\n     * either be appended to the current LineString or the outer ring of the current\n     * Polygon. If no geometry is being drawn, a new one will be created.\n     * @param {!LineCoordType} coordinates Linear coordinates to be appended to\n     * the coordinate array.\n     * @api\n     */\n  }, {\n    key: \"appendCoordinates\",\n    value: function appendCoordinates(coordinates) {\n      var mode = this.mode_;\n      var newDrawing = !this.sketchFeature_;\n      if (newDrawing) {\n        this.startDrawing_(coordinates[0]);\n      }\n      /** @type {LineCoordType} */\n      var sketchCoords;\n      if (mode === 'LineString' || mode === 'Circle') {\n        sketchCoords = /** @type {LineCoordType} */this.sketchCoords_;\n      } else if (mode === 'Polygon') {\n        sketchCoords = this.sketchCoords_ && this.sketchCoords_.length ? /** @type {PolyCoordType} */this.sketchCoords_[0] : [];\n      } else {\n        return;\n      }\n      if (newDrawing) {\n        sketchCoords.shift();\n      }\n\n      // Remove last coordinate from sketch drawing (this coordinate follows cursor position)\n      sketchCoords.pop();\n\n      // Append coordinate list\n      for (var i = 0; i < coordinates.length; i++) {\n        this.addToDrawing_(coordinates[i]);\n      }\n      var ending = coordinates[coordinates.length - 1];\n      // Duplicate last coordinate for sketch drawing (cursor position)\n      this.addToDrawing_(ending);\n      this.modifyDrawing_(ending);\n    }\n\n    /**\n     * Initiate draw mode by starting from an existing geometry which will\n     * receive new additional points. This only works on features with\n     * `LineString` geometries, where the interaction will extend lines by adding\n     * points to the end of the coordinates array.\n     * This will change the original feature, instead of drawing a copy.\n     *\n     * The function will dispatch a `drawstart` event.\n     *\n     * @param {!Feature<LineString>} feature Feature to be extended.\n     * @api\n     */\n  }, {\n    key: \"extend\",\n    value: function extend(feature) {\n      var geometry = feature.getGeometry();\n      var lineString = geometry;\n      this.sketchFeature_ = feature;\n      this.sketchCoords_ = lineString.getCoordinates();\n      var last = this.sketchCoords_[this.sketchCoords_.length - 1];\n      this.finishCoordinate_ = last.slice();\n      this.sketchCoords_.push(last.slice());\n      this.sketchPoint_ = new Feature(new Point(last));\n      this.updateSketchFeatures_();\n      this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));\n    }\n\n    /**\n     * Redraw the sketch features.\n     * @private\n     */\n  }, {\n    key: \"updateSketchFeatures_\",\n    value: function updateSketchFeatures_() {\n      var sketchFeatures = [];\n      if (this.sketchFeature_) {\n        sketchFeatures.push(this.sketchFeature_);\n      }\n      if (this.sketchLine_) {\n        sketchFeatures.push(this.sketchLine_);\n      }\n      if (this.sketchPoint_) {\n        sketchFeatures.push(this.sketchPoint_);\n      }\n      var overlaySource = this.overlay_.getSource();\n      overlaySource.clear(true);\n      overlaySource.addFeatures(sketchFeatures);\n    }\n\n    /**\n     * @private\n     */\n  }, {\n    key: \"updateState_\",\n    value: function updateState_() {\n      var map = this.getMap();\n      var active = this.getActive();\n      if (!map || !active) {\n        this.abortDrawing();\n      }\n      this.overlay_.setMap(active ? map : null);\n    }\n  }]);\n}(PointerInteraction);\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\nfunction getDefaultStyleFunction() {\n  var styles = createEditingStyle();\n  return function (feature, resolution) {\n    return styles[feature.getGeometry().getType()];\n  };\n}\n\n/**\n * Create a `geometryFunction` for `type: 'Circle'` that will create a regular\n * polygon with a user specified number of sides and start angle instead of a\n * {@link import(\"../geom/Circle.js\").Circle} geometry.\n * @param {number} [sides] Number of sides of the regular polygon.\n *     Default is 32.\n * @param {number} [angle] Angle of the first point in counter-clockwise\n *     radians. 0 means East.\n *     Default is the angle defined by the heading from the center of the\n *     regular polygon to the current pointer position.\n * @return {GeometryFunction} Function that draws a polygon.\n * @api\n */\nexport function createRegularPolygon(sides, angle) {\n  return function (coordinates, geometry, projection) {\n    var center = fromUserCoordinate(/** @type {LineCoordType} */coordinates[0], projection);\n    var end = fromUserCoordinate(/** @type {LineCoordType} */coordinates[coordinates.length - 1], projection);\n    var radius = Math.sqrt(squaredCoordinateDistance(center, end));\n    geometry = geometry || fromCircle(new Circle(center), sides);\n    var internalAngle = angle;\n    if (!angle && angle !== 0) {\n      var x = end[0] - center[0];\n      var y = end[1] - center[1];\n      internalAngle = Math.atan2(y, x);\n    }\n    makeRegular(/** @type {Polygon} */geometry, center, radius, internalAngle);\n    var userProjection = getUserProjection();\n    if (userProjection) {\n      geometry.transform(projection, userProjection);\n    }\n    return geometry;\n  };\n}\n\n/**\n * Create a `geometryFunction` that will create a box-shaped polygon (aligned\n * with the coordinate system axes).  Use this with the draw interaction and\n * `type: 'Circle'` to return a box instead of a circle geometry.\n * @return {GeometryFunction} Function that draws a box-shaped polygon.\n * @api\n */\nexport function createBox() {\n  return function (coordinates, geometry, projection) {\n    var extent = boundingExtent(/** @type {LineCoordType} */[coordinates[0], coordinates[coordinates.length - 1]].map(function (coordinate) {\n      return fromUserCoordinate(coordinate, projection);\n    }));\n    var boxCoordinates = [[getBottomLeft(extent), getBottomRight(extent), getTopRight(extent), getTopLeft(extent), getBottomLeft(extent)]];\n    if (geometry) {\n      geometry.setCoordinates(boxCoordinates);\n    } else {\n      geometry = new Polygon(boxCoordinates);\n    }\n    var userProjection = getUserProjection();\n    if (userProjection) {\n      geometry.transform(projection, userProjection);\n    }\n    return geometry;\n  };\n}\n\n/**\n * Get the drawing mode.  The mode for multi-part geometries is the same as for\n * their single-part cousins.\n * @param {import(\"../geom/Geometry.js\").Type} type Geometry type.\n * @return {Mode} Drawing mode.\n */\nfunction getMode(type) {\n  switch (type) {\n    case 'Point':\n    case 'MultiPoint':\n      return 'Point';\n    case 'LineString':\n    case 'MultiLineString':\n      return 'LineString';\n    case 'Polygon':\n    case 'MultiPolygon':\n      return 'Polygon';\n    case 'Circle':\n      return 'Circle';\n    default:\n      throw new Error('Invalid type: ' + type);\n  }\n}\nexport default Draw;","map":{"version":3,"names":["Circle","Event","EventType","Feature","GeometryCollection","InteractionProperty","LineString","MapBrowserEvent","MapBrowserEventType","MultiLineString","MultiPoint","MultiPolygon","Point","PointerInteraction","Polygon","fromCircle","makeRegular","VectorLayer","VectorSource","FALSE","TRUE","always","never","noModifierKeys","shiftKeyOnly","boundingExtent","getBottomLeft","getBottomRight","getTopLeft","getTopRight","clamp","squaredDistance","toFixed","createEditingStyle","distance","squaredCoordinateDistance","fromUserCoordinate","getUserProjection","getStrideForLayout","DrawEventType","DRAWSTART","DRAWEND","DRAWABORT","DrawEvent","_Event","type","feature","_this","_classCallCheck","_callSuper","_inherits","_createClass","getTraceTargets","coordinate","features","targets","i","length","geometry","getGeometry","appendGeometryTraceTargets","getSquaredDistance","a","b","getCoordinate","coordinates","index","count","getCumulativeSquaredDistance","startIndex","endIndex","lowIndex","highIndex","lowWholeIndex","Math","ceil","highWholeIndex","floor","start","interpolateCoordinate","end","sd","appendTraceTarget","getCoordinates","ii","polys","j","jj","geometries","getGeometries","sharedUpdateInfo","NaN","getTraceTargetUpdate","traceState","map","snapTolerance","x","y","closestTargetDistance","Infinity","newTargetIndex","newEndIndex","targetIndex","target","minSegmentDistance","coordinateIndex","rel","getPointSegmentRelationship","along","ring","newTarget","considerBothDirections","newCoordinate","pixel","getPixelFromCoordinate","startPx","forwardDistance","reverseDistance","push","sharedRel","x1","y1","x2","y2","dx","dy","px","py","x0","y0","Draw","_PointerInteraction","options","_this2","pointerOptions","stopDown","on","once","un","shouldHandle_","downPx_","downTimeout_","lastDragTime_","pointerType_","freehand_","source_","source","features_","snapTolerance_","type_","mode_","getMode","stopClick_","stopClick","minPoints_","minPoints","maxPoints_","maxPoints","finishCondition_","finishCondition","geometryLayout_","geometryLayout","geometryFunction","mode","projection","circle","center","squaredLength","setCenterAndRadius","sqrt","userProjection","transform","Constructor","setCoordinates","concat","geometryFunction_","dragVertexDelay_","dragVertexDelay","undefined","finishCoordinate_","sketchFeature_","sketchPoint_","sketchCoords_","sketchLine_","sketchLineCoords_","squaredClickTolerance_","clickTolerance","overlay_","useSpatialIndex","wrapX","style","getDefaultStyleFunction","updateWhileInteracting","geometryName_","geometryName","condition_","condition","freehandCondition_","freehand","freehandCondition","traceCondition_","setTrace","trace","traceState_","active","traceSource_","traceSource","addChangeListener","ACTIVE","updateState_","key","value","setMap","_superPropGet","getOverlay","handleEvent","event","originalEvent","CONTEXTMENU","preventDefault","move","POINTERMOVE","pass","POINTERDRAG","now","Date","clearTimeout","addToDrawing_","POINTERDOWN","getPointerCount","handlePointerMove_","pointerType","DBLCLICK","handleDownEvent","_this3","startDrawing_","setTimeout","frameState","deactivateTrace_","toggleTraceState_","getMap","lowerLeft","getCoordinateFromPixel","upperRight","extent","getFeaturesInExtent","slice","addOrRemoveTracedCoordinates_","previouslyForward","currentlyForward","addTracedCoordinates_","removeTracedCoordinates_","fromIndex","toIndex","remove","removeLastPoints_","appendCoordinates","updateTrace_","updatedTraceTarget","oldTarget","round","handleUpEvent","tracing","startingToDraw","finishDrawing","atFinish_","abortDrawing","downPx","clickPx","createOrUpdateSketchPoint_","modifyDrawing_","at","potentiallyDone","potentiallyFinishCoordinates","sketchCoords","finishCoordinate","finishPixel","updateSketchFeatures_","sketchPointGeom","createOrUpdateCustomSketchLine_","getLinearRing","sketchLineGeom","getFlatCoordinates","getLayout","setGeometry","setFlatCoordinates","changed","getView","getProjection","stride","setGeometryName","dispatchEvent","last","getType","done","pop","n","splice","removeLastPoint","sketchFeature","abortDrawing_","addFeature","getSource","clear","newDrawing","shift","ending","extend","lineString","sketchFeatures","overlaySource","addFeatures","getActive","styles","resolution","createRegularPolygon","sides","angle","radius","internalAngle","atan2","createBox","boxCoordinates","Error"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol/interaction/Draw.js"],"sourcesContent":["/**\n * @module ol/interaction/Draw\n */\nimport Circle from '../geom/Circle.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport Feature from '../Feature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport InteractionProperty from './Property.js';\nimport LineString from '../geom/LineString.js';\nimport MapBrowserEvent from '../MapBrowserEvent.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport PointerInteraction from './Pointer.js';\nimport Polygon, {fromCircle, makeRegular} from '../geom/Polygon.js';\nimport VectorLayer from '../layer/Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport {FALSE, TRUE} from '../functions.js';\nimport {\n  always,\n  never,\n  noModifierKeys,\n  shiftKeyOnly,\n} from '../events/condition.js';\nimport {\n  boundingExtent,\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n} from '../extent.js';\nimport {clamp, squaredDistance, toFixed} from '../math.js';\nimport {createEditingStyle} from '../style/Style.js';\nimport {\n  distance,\n  squaredDistance as squaredCoordinateDistance,\n} from '../coordinate.js';\nimport {fromUserCoordinate, getUserProjection} from '../proj.js';\nimport {getStrideForLayout} from '../geom/SimpleGeometry.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../geom/Geometry.js\").Type} type Geometry type of\n * the geometries being drawn with this instance.\n * @property {number} [clickTolerance=6] The maximum distance in pixels between\n * \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\n * actually add a point/vertex to the geometry being drawn.  The default of `6`\n * was chosen for the draw interaction to behave correctly on mouse as well as\n * on touch devices.\n * @property {import(\"../Collection.js\").default<Feature>} [features]\n * Destination collection for the drawn features.\n * @property {VectorSource} [source] Destination source for\n * the drawn features.\n * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown\n * before the current vertex can be dragged to its exact position.\n * @property {number} [snapTolerance=12] Pixel distance for snapping to the\n * drawing finish. Must be greater than `0`.\n * @property {boolean} [stopClick=false] Stop click, singleclick, and\n * doubleclick events from firing during drawing.\n * @property {number} [maxPoints] The number of points that can be drawn before\n * a polygon ring or line string is finished. By default there is no\n * restriction.\n * @property {number} [minPoints] The number of points that must be drawn\n * before a polygon ring or line string can be finished. Default is `3` for\n * polygon rings and `2` for line strings.\n * @property {import(\"../events/condition.js\").Condition} [finishCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether the drawing can be finished. Not used when drawing\n * POINT or MULTI_POINT geometries.\n * @property {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike} [style]\n * Style for sketch features. The draw interaction can have up to three sketch features, depending on the mode.\n * It will always contain a feature with a `Point` geometry that corresponds to the current cursor position.\n * If the mode is `LineString` or `Polygon`, and there is at least one drawn point, it will also contain a feature with\n * a `LineString` geometry that corresponds to the line between the already drawn points and the current cursor position.\n * If the mode is `Polygon`, and there is at least one drawn point, it will also contain a feature with a `Polygon`\n * geometry that corresponds to the polygon between the already drawn points and the current cursor position\n * (note that this polygon has only two points if only one point is drawn).\n * If the mode is `Circle`, and there is one point drawn, it will also contain a feature with a `Circle` geometry whose\n * center is the drawn point and the radius is determined by the distance between the drawn point and the cursor.\n * @property {GeometryFunction} [geometryFunction]\n * Function that is called when a geometry's coordinates are updated.\n * @property {string} [geometryName] Geometry name to use for features created\n * by the draw interaction.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default {@link module:ol/events/condition.noModifierKeys}, i.e. a click,\n * adds a vertex or deactivates freehand drawing.\n * @property {boolean} [freehand=false] Operate in freehand mode for lines,\n * polygons, and circles.  This makes the interaction always operate in freehand\n * mode and takes precedence over any `freehandCondition` option.\n * @property {import(\"../events/condition.js\").Condition} [freehandCondition]\n * Condition that activates freehand drawing for lines and polygons. This\n * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\n * returns a boolean to indicate whether that event should be handled. The\n * default is {@link module:ol/events/condition.shiftKeyOnly}, meaning that the\n * Shift key activates freehand drawing.\n * @property {boolean|import(\"../events/condition.js\").Condition} [trace=false] Trace a portion of another geometry.\n * Ignored when in freehand mode.\n * @property {VectorSource} [traceSource] Source for features to trace.  If tracing is active and a `traceSource` is\n * not provided, the interaction's `source` will be used.  Tracing requires that the interaction is configured with\n * either a `traceSource` or a `source`.\n * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\n * overlay.\n * @property {import(\"../geom/Geometry.js\").GeometryLayout} [geometryLayout='XY'] Layout of the\n * feature geometries created by the draw interaction.\n */\n\n/**\n * Coordinate type when drawing points.\n * @typedef {import(\"../coordinate.js\").Coordinate} PointCoordType\n */\n\n/**\n * Coordinate type when drawing lines.\n * @typedef {Array<import(\"../coordinate.js\").Coordinate>} LineCoordType\n */\n\n/**\n * Coordinate type when drawing polygons.\n * @typedef {Array<Array<import(\"../coordinate.js\").Coordinate>>} PolyCoordType\n */\n\n/**\n * Types used for drawing coordinates.\n * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType\n */\n\n/**\n * @typedef {Object} TraceState\n * @property {boolean} active Tracing active.\n * @property {import(\"../pixel.js\").Pixel} [startPx] The initially clicked pixel location.\n * @property {Array<TraceTarget>} [targets] Targets available for tracing.\n * @property {number} [targetIndex] The index of the currently traced target.  A value of -1 indicates\n * that no trace target is active.\n */\n\n/**\n * @typedef {Object} TraceTarget\n * @property {Array<import(\"../coordinate.js\").Coordinate>} coordinates Target coordinates.\n * @property {boolean} ring The target coordinates are a linear ring.\n * @property {number} startIndex The index of first traced coordinate.  A fractional index represents an\n * edge intersection.  Index values for rings will wrap (may be negative or larger than coordinates length).\n * @property {number} endIndex The index of last traced coordinate.  Details from startIndex also apply here.\n */\n\n/**\n * Function that takes an array of coordinates and an optional existing geometry\n * and a projection as arguments, and returns a geometry. The optional existing\n * geometry is the geometry that is returned when the function is called without\n * a second argument.\n * @typedef {function(!SketchCoordType, import(\"../geom/SimpleGeometry.js\").default,\n *     import(\"../proj/Projection.js\").default):\n *     import(\"../geom/SimpleGeometry.js\").default} GeometryFunction\n */\n\n/**\n * @typedef {'Point' | 'LineString' | 'Polygon' | 'Circle'} Mode\n * Draw mode.  This collapses multi-part geometry types with their single-part\n * cousins.\n */\n\n/**\n * @enum {string}\n */\nconst DrawEventType = {\n  /**\n   * Triggered upon feature draw start\n   * @event DrawEvent#drawstart\n   * @api\n   */\n  DRAWSTART: 'drawstart',\n  /**\n   * Triggered upon feature draw end\n   * @event DrawEvent#drawend\n   * @api\n   */\n  DRAWEND: 'drawend',\n  /**\n   * Triggered upon feature draw abortion\n   * @event DrawEvent#drawabort\n   * @api\n   */\n  DRAWABORT: 'drawabort',\n};\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are\n * instances of this type.\n */\nexport class DrawEvent extends Event {\n  /**\n   * @param {DrawEventType} type Type.\n   * @param {Feature} feature The feature drawn.\n   */\n  constructor(type, feature) {\n    super(type);\n\n    /**\n     * The feature being drawn.\n     * @type {Feature}\n     * @api\n     */\n    this.feature = feature;\n  }\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {Array<Feature>} features The candidate features.\n * @return {Array<TraceTarget>} The trace targets.\n */\nfunction getTraceTargets(coordinate, features) {\n  /**\n   * @type {Array<TraceTarget>}\n   */\n  const targets = [];\n\n  for (let i = 0; i < features.length; ++i) {\n    const feature = features[i];\n    const geometry = feature.getGeometry();\n    appendGeometryTraceTargets(coordinate, geometry, targets);\n  }\n\n  return targets;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} a One coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} b Another coordinate.\n * @return {number} The squared distance between the two coordinates.\n */\nfunction getSquaredDistance(a, b) {\n  return squaredDistance(a[0], a[1], b[0], b[1]);\n}\n\n/**\n * @param {LineCoordType} coordinates The ring coordinates.\n * @param {number} index The index.  May be wrapped.\n * @return {import(\"../coordinate.js\").Coordinate} The coordinate.\n */\nfunction getCoordinate(coordinates, index) {\n  const count = coordinates.length;\n  if (index < 0) {\n    return coordinates[index + count];\n  }\n  if (index >= count) {\n    return coordinates[index - count];\n  }\n  return coordinates[index];\n}\n\n/**\n * Get the cumulative squared distance along a ring path.  The end index index may be \"wrapped\" and it may\n * be less than the start index to indicate the direction of travel.  The start and end index may have\n * a fractional part to indicate a point between two coordinates.\n * @param {LineCoordType} coordinates Ring coordinates.\n * @param {number} startIndex The start index.\n * @param {number} endIndex The end index.\n * @return {number} The cumulative squared distance along the ring path.\n */\nfunction getCumulativeSquaredDistance(coordinates, startIndex, endIndex) {\n  let lowIndex, highIndex;\n  if (startIndex < endIndex) {\n    lowIndex = startIndex;\n    highIndex = endIndex;\n  } else {\n    lowIndex = endIndex;\n    highIndex = startIndex;\n  }\n  const lowWholeIndex = Math.ceil(lowIndex);\n  const highWholeIndex = Math.floor(highIndex);\n\n  if (lowWholeIndex > highWholeIndex) {\n    // both start and end are on the same segment\n    const start = interpolateCoordinate(coordinates, lowIndex);\n    const end = interpolateCoordinate(coordinates, highIndex);\n    return getSquaredDistance(start, end);\n  }\n\n  let sd = 0;\n\n  if (lowIndex < lowWholeIndex) {\n    const start = interpolateCoordinate(coordinates, lowIndex);\n    const end = getCoordinate(coordinates, lowWholeIndex);\n    sd += getSquaredDistance(start, end);\n  }\n\n  if (highWholeIndex < highIndex) {\n    const start = getCoordinate(coordinates, highWholeIndex);\n    const end = interpolateCoordinate(coordinates, highIndex);\n    sd += getSquaredDistance(start, end);\n  }\n\n  for (let i = lowWholeIndex; i < highWholeIndex - 1; ++i) {\n    const start = getCoordinate(coordinates, i);\n    const end = getCoordinate(coordinates, i + 1);\n    sd += getSquaredDistance(start, end);\n  }\n\n  return sd;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {import(\"../geom/Geometry.js\").default} geometry The candidate geometry.\n * @param {Array<TraceTarget>} targets The trace targets.\n */\nfunction appendGeometryTraceTargets(coordinate, geometry, targets) {\n  if (geometry instanceof LineString) {\n    appendTraceTarget(coordinate, geometry.getCoordinates(), false, targets);\n    return;\n  }\n  if (geometry instanceof MultiLineString) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n      appendTraceTarget(coordinate, coordinates[i], false, targets);\n    }\n    return;\n  }\n  if (geometry instanceof Polygon) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n      appendTraceTarget(coordinate, coordinates[i], true, targets);\n    }\n    return;\n  }\n  if (geometry instanceof MultiPolygon) {\n    const polys = geometry.getCoordinates();\n    for (let i = 0, ii = polys.length; i < ii; ++i) {\n      const coordinates = polys[i];\n      for (let j = 0, jj = coordinates.length; j < jj; ++j) {\n        appendTraceTarget(coordinate, coordinates[j], true, targets);\n      }\n    }\n    return;\n  }\n  if (geometry instanceof GeometryCollection) {\n    const geometries = geometry.getGeometries();\n    for (let i = 0; i < geometries.length; ++i) {\n      appendGeometryTraceTargets(coordinate, geometries[i], targets);\n    }\n    return;\n  }\n  // other types cannot be traced\n}\n\n/**\n * @typedef {Object} TraceTargetUpdateInfo\n * @property {number} index The new target index.\n * @property {number} endIndex The new segment end index.\n */\n\n/**\n * @type {TraceTargetUpdateInfo}\n */\nconst sharedUpdateInfo = {index: -1, endIndex: NaN};\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {TraceState} traceState The trace state.\n * @param {import(\"../Map.js\").default} map The map.\n * @param {number} snapTolerance The snap tolerance.\n * @return {TraceTargetUpdateInfo} Information about the new trace target.  The returned\n * object is reused between calls and must not be modified by the caller.\n */\nfunction getTraceTargetUpdate(coordinate, traceState, map, snapTolerance) {\n  const x = coordinate[0];\n  const y = coordinate[1];\n\n  let closestTargetDistance = Infinity;\n\n  let newTargetIndex = -1;\n  let newEndIndex = NaN;\n\n  for (\n    let targetIndex = 0;\n    targetIndex < traceState.targets.length;\n    ++targetIndex\n  ) {\n    const target = traceState.targets[targetIndex];\n    const coordinates = target.coordinates;\n\n    let minSegmentDistance = Infinity;\n    let endIndex;\n    for (\n      let coordinateIndex = 0;\n      coordinateIndex < coordinates.length - 1;\n      ++coordinateIndex\n    ) {\n      const start = coordinates[coordinateIndex];\n      const end = coordinates[coordinateIndex + 1];\n      const rel = getPointSegmentRelationship(x, y, start, end);\n      if (rel.squaredDistance < minSegmentDistance) {\n        minSegmentDistance = rel.squaredDistance;\n        endIndex = coordinateIndex + rel.along;\n      }\n    }\n\n    if (minSegmentDistance < closestTargetDistance) {\n      closestTargetDistance = minSegmentDistance;\n      if (target.ring && traceState.targetIndex === targetIndex) {\n        // same target, maintain the same trace direction\n        if (target.endIndex > target.startIndex) {\n          // forward trace\n          if (endIndex < target.startIndex) {\n            endIndex += coordinates.length;\n          }\n        } else if (target.endIndex < target.startIndex) {\n          // reverse trace\n          if (endIndex > target.startIndex) {\n            endIndex -= coordinates.length;\n          }\n        }\n      }\n      newEndIndex = endIndex;\n      newTargetIndex = targetIndex;\n    }\n  }\n\n  const newTarget = traceState.targets[newTargetIndex];\n  let considerBothDirections = newTarget.ring;\n  if (traceState.targetIndex === newTargetIndex && considerBothDirections) {\n    // only consider switching trace direction if close to the start\n    const newCoordinate = interpolateCoordinate(\n      newTarget.coordinates,\n      newEndIndex\n    );\n    const pixel = map.getPixelFromCoordinate(newCoordinate);\n    if (distance(pixel, traceState.startPx) > snapTolerance) {\n      considerBothDirections = false;\n    }\n  }\n\n  if (considerBothDirections) {\n    const coordinates = newTarget.coordinates;\n    const count = coordinates.length;\n    const startIndex = newTarget.startIndex;\n    const endIndex = newEndIndex;\n    if (startIndex < endIndex) {\n      const forwardDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex\n      );\n      const reverseDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex - count\n      );\n      if (reverseDistance < forwardDistance) {\n        newEndIndex -= count;\n      }\n    } else {\n      const reverseDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex\n      );\n      const forwardDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex + count\n      );\n      if (forwardDistance < reverseDistance) {\n        newEndIndex += count;\n      }\n    }\n  }\n\n  sharedUpdateInfo.index = newTargetIndex;\n  sharedUpdateInfo.endIndex = newEndIndex;\n  return sharedUpdateInfo;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The clicked coordinate.\n * @param {Array<import(\"../coordinate.js\").Coordinate>} coordinates The geometry component coordinates.\n * @param {boolean} ring The coordinates represent a linear ring.\n * @param {Array<TraceTarget>} targets The trace targets.\n */\nfunction appendTraceTarget(coordinate, coordinates, ring, targets) {\n  const x = coordinate[0];\n  const y = coordinate[1];\n  for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n    const start = coordinates[i];\n    const end = coordinates[i + 1];\n    const rel = getPointSegmentRelationship(x, y, start, end);\n    if (rel.squaredDistance === 0) {\n      const index = i + rel.along;\n      targets.push({\n        coordinates: coordinates,\n        ring: ring,\n        startIndex: index,\n        endIndex: index,\n      });\n      return;\n    }\n  }\n}\n\n/**\n * @typedef {Object} PointSegmentRelationship\n * @property {number} along The closest point expressed as a fraction along the segment length.\n * @property {number} squaredDistance The squared distance of the point to the segment.\n */\n\n/**\n * @type {PointSegmentRelationship}\n */\nconst sharedRel = {along: 0, squaredDistance: 0};\n\n/**\n * @param {number} x The point x.\n * @param {number} y The point y.\n * @param {import(\"../coordinate.js\").Coordinate} start The segment start.\n * @param {import(\"../coordinate.js\").Coordinate} end The segment end.\n * @return {PointSegmentRelationship} The point segment relationship.  The returned object is\n * shared between calls and must not be modified by the caller.\n */\nfunction getPointSegmentRelationship(x, y, start, end) {\n  const x1 = start[0];\n  const y1 = start[1];\n  const x2 = end[0];\n  const y2 = end[1];\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  let along = 0;\n  let px = x1;\n  let py = y1;\n  if (dx !== 0 || dy !== 0) {\n    along = clamp(((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy), 0, 1);\n    px += dx * along;\n    py += dy * along;\n  }\n\n  sharedRel.along = along;\n  sharedRel.squaredDistance = toFixed(squaredDistance(x, y, px, py), 10);\n  return sharedRel;\n}\n\n/**\n * @param {LineCoordType} coordinates The coordinates.\n * @param {number} index The index.  May be fractional and may wrap.\n * @return {import(\"../coordinate.js\").Coordinate} The interpolated coordinate.\n */\nfunction interpolateCoordinate(coordinates, index) {\n  const count = coordinates.length;\n\n  let startIndex = Math.floor(index);\n  const along = index - startIndex;\n  if (startIndex >= count) {\n    startIndex -= count;\n  } else if (startIndex < 0) {\n    startIndex += count;\n  }\n\n  let endIndex = startIndex + 1;\n  if (endIndex >= count) {\n    endIndex -= count;\n  }\n\n  const start = coordinates[startIndex];\n  const x0 = start[0];\n  const y0 = start[1];\n  const end = coordinates[endIndex];\n  const dx = end[0] - x0;\n  const dy = end[1] - y0;\n\n  return [x0 + dx * along, y0 + dy * along];\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'drawabort'|'drawend'|'drawstart', DrawEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'drawabort'|'drawend'|'drawstart', Return>} DrawOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for drawing feature geometries.\n *\n * @fires DrawEvent\n * @api\n */\nclass Draw extends PointerInteraction {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\n      options\n    );\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /***\n     * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {DrawOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.shouldHandle_ = false;\n\n    /**\n     * @type {import(\"../pixel.js\").Pixel}\n     * @private\n     */\n    this.downPx_ = null;\n\n    /**\n     * @type {ReturnType<typeof setTimeout>}\n     * @private\n     */\n    this.downTimeout_;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.lastDragTime_;\n\n    /**\n     * Pointer type of the last pointermove event\n     * @type {string}\n     * @private\n     */\n    this.pointerType_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.freehand_ = false;\n\n    /**\n     * Target source for drawn features.\n     * @type {VectorSource|null}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n\n    /**\n     * Target collection for drawn features.\n     * @type {import(\"../Collection.js\").default<Feature>|null}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n\n    /**\n     * Pixel distance for snapping.\n     * @type {number}\n     * @private\n     */\n    this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;\n\n    /**\n     * Geometry type.\n     * @type {import(\"../geom/Geometry.js\").Type}\n     * @private\n     */\n    this.type_ = /** @type {import(\"../geom/Geometry.js\").Type} */ (\n      options.type\n    );\n\n    /**\n     * Drawing mode (derived from geometry type.\n     * @type {Mode}\n     * @private\n     */\n    this.mode_ = getMode(this.type_);\n\n    /**\n     * Stop click, singleclick, and doubleclick events from firing during drawing.\n     * Default is `false`.\n     * @type {boolean}\n     * @private\n     */\n    this.stopClick_ = !!options.stopClick;\n\n    /**\n     * The number of points that must be drawn before a polygon ring or line\n     * string can be finished.  The default is 3 for polygon rings and 2 for\n     * line strings.\n     * @type {number}\n     * @private\n     */\n    this.minPoints_ = options.minPoints\n      ? options.minPoints\n      : this.mode_ === 'Polygon'\n      ? 3\n      : 2;\n\n    /**\n     * The number of points that can be drawn before a polygon ring or line string\n     * is finished. The default is no restriction.\n     * @type {number}\n     * @private\n     */\n    this.maxPoints_ =\n      this.mode_ === 'Circle'\n        ? 2\n        : options.maxPoints\n        ? options.maxPoints\n        : Infinity;\n\n    /**\n     * A function to decide if a potential finish coordinate is permissible\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.finishCondition_ = options.finishCondition\n      ? options.finishCondition\n      : TRUE;\n\n    /**\n     * @private\n     * @type {import(\"../geom/Geometry.js\").GeometryLayout}\n     */\n    this.geometryLayout_ = options.geometryLayout\n      ? options.geometryLayout\n      : 'XY';\n\n    let geometryFunction = options.geometryFunction;\n    if (!geometryFunction) {\n      const mode = this.mode_;\n      if (mode === 'Circle') {\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n         * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n        geometryFunction = function (coordinates, geometry, projection) {\n          const circle = geometry\n            ? /** @type {Circle} */ (geometry)\n            : new Circle([NaN, NaN]);\n          const center = fromUserCoordinate(coordinates[0], projection);\n          const squaredLength = squaredCoordinateDistance(\n            center,\n            fromUserCoordinate(coordinates[coordinates.length - 1], projection)\n          );\n          circle.setCenterAndRadius(\n            center,\n            Math.sqrt(squaredLength),\n            this.geometryLayout_\n          );\n          const userProjection = getUserProjection();\n          if (userProjection) {\n            circle.transform(projection, userProjection);\n          }\n          return circle;\n        };\n      } else {\n        let Constructor;\n        if (mode === 'Point') {\n          Constructor = Point;\n        } else if (mode === 'LineString') {\n          Constructor = LineString;\n        } else if (mode === 'Polygon') {\n          Constructor = Polygon;\n        }\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n         * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n        geometryFunction = function (coordinates, geometry, projection) {\n          if (geometry) {\n            if (mode === 'Polygon') {\n              if (coordinates[0].length) {\n                // Add a closing coordinate to match the first\n                geometry.setCoordinates(\n                  [coordinates[0].concat([coordinates[0][0]])],\n                  this.geometryLayout_\n                );\n              } else {\n                geometry.setCoordinates([], this.geometryLayout_);\n              }\n            } else {\n              geometry.setCoordinates(coordinates, this.geometryLayout_);\n            }\n          } else {\n            geometry = new Constructor(coordinates, this.geometryLayout_);\n          }\n          return geometry;\n        };\n      }\n    }\n\n    /**\n     * @type {GeometryFunction}\n     * @private\n     */\n    this.geometryFunction_ = geometryFunction;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.dragVertexDelay_ =\n      options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;\n\n    /**\n     * Finish coordinate for the feature (first point for polygons, last point for\n     * linestrings).\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.finishCoordinate_ = null;\n\n    /**\n     * Sketch feature.\n     * @type {Feature<import('../geom/SimpleGeometry.js').default>}\n     * @private\n     */\n    this.sketchFeature_ = null;\n\n    /**\n     * Sketch point.\n     * @type {Feature<Point>}\n     * @private\n     */\n    this.sketchPoint_ = null;\n\n    /**\n     * Sketch coordinates. Used when drawing a line or polygon.\n     * @type {SketchCoordType}\n     * @private\n     */\n    this.sketchCoords_ = null;\n\n    /**\n     * Sketch line. Used when drawing polygon.\n     * @type {Feature<LineString>}\n     * @private\n     */\n    this.sketchLine_ = null;\n\n    /**\n     * Sketch line coordinates. Used when drawing a polygon or circle.\n     * @type {LineCoordType}\n     * @private\n     */\n    this.sketchLineCoords_ = null;\n\n    /**\n     * Squared tolerance for handling up events.  If the squared distance\n     * between a down and up event is greater than this tolerance, up events\n     * will not be handled.\n     * @type {number}\n     * @private\n     */\n    this.squaredClickTolerance_ = options.clickTolerance\n      ? options.clickTolerance * options.clickTolerance\n      : 36;\n\n    /**\n     * Draw overlay where our sketch features are drawn.\n     * @type {VectorLayer}\n     * @private\n     */\n    this.overlay_ = new VectorLayer({\n      source: new VectorSource({\n        useSpatialIndex: false,\n        wrapX: options.wrapX ? options.wrapX : false,\n      }),\n      style: options.style ? options.style : getDefaultStyleFunction(),\n      updateWhileInteracting: true,\n    });\n\n    /**\n     * Name of the geometry attribute for newly created features.\n     * @type {string|undefined}\n     * @private\n     */\n    this.geometryName_ = options.geometryName;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : noModifierKeys;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.freehandCondition_;\n    if (options.freehand) {\n      this.freehandCondition_ = always;\n    } else {\n      this.freehandCondition_ = options.freehandCondition\n        ? options.freehandCondition\n        : shiftKeyOnly;\n    }\n\n    /**\n     * @type {import(\"../events/condition.js\").Condition}\n     * @private\n     */\n    this.traceCondition_;\n    this.setTrace(options.trace || false);\n\n    /**\n     * @type {TraceState}\n     * @private\n     */\n    this.traceState_ = {active: false};\n\n    /**\n     * @type {VectorSource|null}\n     * @private\n     */\n    this.traceSource_ = options.traceSource || options.source || null;\n\n    this.addChangeListener(InteractionProperty.ACTIVE, this.updateState_);\n  }\n\n  /**\n   * Toggle tracing mode or set a tracing condition.\n   *\n   * @param {boolean|import(\"../events/condition.js\").Condition} trace A boolean to toggle tracing mode or an event\n   *     condition that will be checked when a feature is clicked to determine if tracing should be active.\n   */\n  setTrace(trace) {\n    let condition;\n    if (!trace) {\n      condition = never;\n    } else if (trace === true) {\n      condition = always;\n    } else {\n      condition = trace;\n    }\n    this.traceCondition_ = condition;\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  setMap(map) {\n    super.setMap(map);\n    this.updateState_();\n  }\n\n  /**\n   * Get the overlay layer that this interaction renders sketch features to.\n   * @return {VectorLayer} Overlay layer.\n   * @api\n   */\n  getOverlay() {\n    return this.overlay_;\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @api\n   */\n  handleEvent(event) {\n    if (event.originalEvent.type === EventType.CONTEXTMENU) {\n      // Avoid context menu for long taps when drawing on mobile\n      event.originalEvent.preventDefault();\n    }\n    this.freehand_ = this.mode_ !== 'Point' && this.freehandCondition_(event);\n    let move = event.type === MapBrowserEventType.POINTERMOVE;\n    let pass = true;\n    if (\n      !this.freehand_ &&\n      this.lastDragTime_ &&\n      event.type === MapBrowserEventType.POINTERDRAG\n    ) {\n      const now = Date.now();\n      if (now - this.lastDragTime_ >= this.dragVertexDelay_) {\n        this.downPx_ = event.pixel;\n        this.shouldHandle_ = !this.freehand_;\n        move = true;\n      } else {\n        this.lastDragTime_ = undefined;\n      }\n      if (this.shouldHandle_ && this.downTimeout_ !== undefined) {\n        clearTimeout(this.downTimeout_);\n        this.downTimeout_ = undefined;\n      }\n    }\n    if (\n      this.freehand_ &&\n      event.type === MapBrowserEventType.POINTERDRAG &&\n      this.sketchFeature_ !== null\n    ) {\n      this.addToDrawing_(event.coordinate);\n      pass = false;\n    } else if (\n      this.freehand_ &&\n      event.type === MapBrowserEventType.POINTERDOWN\n    ) {\n      pass = false;\n    } else if (move && this.getPointerCount() < 2) {\n      pass = event.type === MapBrowserEventType.POINTERMOVE;\n      if (pass && this.freehand_) {\n        this.handlePointerMove_(event);\n        if (this.shouldHandle_) {\n          // Avoid page scrolling when freehand drawing on mobile\n          event.originalEvent.preventDefault();\n        }\n      } else if (\n        event.originalEvent.pointerType === 'mouse' ||\n        (event.type === MapBrowserEventType.POINTERDRAG &&\n          this.downTimeout_ === undefined)\n      ) {\n        this.handlePointerMove_(event);\n      }\n    } else if (event.type === MapBrowserEventType.DBLCLICK) {\n      pass = false;\n    }\n\n    return super.handleEvent(event) && pass;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(event) {\n    this.shouldHandle_ = !this.freehand_;\n\n    if (this.freehand_) {\n      this.downPx_ = event.pixel;\n      if (!this.finishCoordinate_) {\n        this.startDrawing_(event.coordinate);\n      }\n      return true;\n    }\n\n    if (!this.condition_(event)) {\n      this.lastDragTime_ = undefined;\n      return false;\n    }\n\n    this.lastDragTime_ = Date.now();\n    this.downTimeout_ = setTimeout(() => {\n      this.handlePointerMove_(\n        new MapBrowserEvent(\n          MapBrowserEventType.POINTERMOVE,\n          event.map,\n          event.originalEvent,\n          false,\n          event.frameState\n        )\n      );\n    }, this.dragVertexDelay_);\n    this.downPx_ = event.pixel;\n    return true;\n  }\n\n  /**\n   * @private\n   */\n  deactivateTrace_() {\n    this.traceState_ = {active: false};\n  }\n\n  /**\n   * Activate or deactivate trace state based on a browser event.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n  toggleTraceState_(event) {\n    if (!this.traceSource_ || !this.traceCondition_(event)) {\n      return;\n    }\n\n    if (this.traceState_.active) {\n      this.deactivateTrace_();\n      return;\n    }\n\n    const map = this.getMap();\n    const lowerLeft = map.getCoordinateFromPixel([\n      event.pixel[0] - this.snapTolerance_,\n      event.pixel[1] + this.snapTolerance_,\n    ]);\n    const upperRight = map.getCoordinateFromPixel([\n      event.pixel[0] + this.snapTolerance_,\n      event.pixel[1] - this.snapTolerance_,\n    ]);\n    const extent = boundingExtent([lowerLeft, upperRight]);\n    const features = this.traceSource_.getFeaturesInExtent(extent);\n    if (features.length === 0) {\n      return;\n    }\n\n    const targets = getTraceTargets(event.coordinate, features);\n    if (targets.length) {\n      this.traceState_ = {\n        active: true,\n        startPx: event.pixel.slice(),\n        targets: targets,\n        targetIndex: -1,\n      };\n    }\n  }\n\n  /**\n   * @param {TraceTarget} target The trace target.\n   * @param {number} endIndex The new end index of the trace.\n   * @private\n   */\n  addOrRemoveTracedCoordinates_(target, endIndex) {\n    // three cases to handle:\n    //  1. traced in the same direction and points need adding\n    //  2. traced in the same direction and points need removing\n    //  3. traced in a new direction\n    const previouslyForward = target.startIndex <= target.endIndex;\n    const currentlyForward = target.startIndex <= endIndex;\n    if (previouslyForward === currentlyForward) {\n      // same direction\n      if (\n        (previouslyForward && endIndex > target.endIndex) ||\n        (!previouslyForward && endIndex < target.endIndex)\n      ) {\n        // case 1 - add new points\n        this.addTracedCoordinates_(target, target.endIndex, endIndex);\n      } else if (\n        (previouslyForward && endIndex < target.endIndex) ||\n        (!previouslyForward && endIndex > target.endIndex)\n      ) {\n        // case 2 - remove old points\n        this.removeTracedCoordinates_(endIndex, target.endIndex);\n      }\n    } else {\n      // case 3 - remove old points, add new points\n      this.removeTracedCoordinates_(target.startIndex, target.endIndex);\n      this.addTracedCoordinates_(target, target.startIndex, endIndex);\n    }\n  }\n\n  /**\n   * @param {number} fromIndex The start index.\n   * @param {number} toIndex The end index.\n   * @private\n   */\n  removeTracedCoordinates_(fromIndex, toIndex) {\n    if (fromIndex === toIndex) {\n      return;\n    }\n\n    let remove = 0;\n    if (fromIndex < toIndex) {\n      const start = Math.ceil(fromIndex);\n      let end = Math.floor(toIndex);\n      if (end === toIndex) {\n        end -= 1;\n      }\n      remove = end - start + 1;\n    } else {\n      const start = Math.floor(fromIndex);\n      let end = Math.ceil(toIndex);\n      if (end === toIndex) {\n        end += 1;\n      }\n      remove = start - end + 1;\n    }\n\n    if (remove > 0) {\n      this.removeLastPoints_(remove);\n    }\n  }\n\n  /**\n   * @param {TraceTarget} target The trace target.\n   * @param {number} fromIndex The start index.\n   * @param {number} toIndex The end index.\n   * @private\n   */\n  addTracedCoordinates_(target, fromIndex, toIndex) {\n    if (fromIndex === toIndex) {\n      return;\n    }\n\n    const coordinates = [];\n    if (fromIndex < toIndex) {\n      // forward trace\n      const start = Math.ceil(fromIndex);\n      let end = Math.floor(toIndex);\n      if (end === toIndex) {\n        // if end is snapped to a vertex, it will be added later\n        end -= 1;\n      }\n      for (let i = start; i <= end; ++i) {\n        coordinates.push(getCoordinate(target.coordinates, i));\n      }\n    } else {\n      // reverse trace\n      const start = Math.floor(fromIndex);\n      let end = Math.ceil(toIndex);\n      if (end === toIndex) {\n        end += 1;\n      }\n      for (let i = start; i >= end; --i) {\n        coordinates.push(getCoordinate(target.coordinates, i));\n      }\n    }\n    if (coordinates.length) {\n      this.appendCoordinates(coordinates);\n    }\n  }\n\n  /**\n   * Update the trace.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n  updateTrace_(event) {\n    const traceState = this.traceState_;\n    if (!traceState.active) {\n      return;\n    }\n\n    if (traceState.targetIndex === -1) {\n      // check if we are ready to pick a target\n      if (distance(traceState.startPx, event.pixel) < this.snapTolerance_) {\n        return;\n      }\n    }\n\n    const updatedTraceTarget = getTraceTargetUpdate(\n      event.coordinate,\n      traceState,\n      this.getMap(),\n      this.snapTolerance_\n    );\n\n    if (traceState.targetIndex !== updatedTraceTarget.index) {\n      // target changed\n      if (traceState.targetIndex !== -1) {\n        // remove points added during previous trace\n        const oldTarget = traceState.targets[traceState.targetIndex];\n        this.removeTracedCoordinates_(oldTarget.startIndex, oldTarget.endIndex);\n      }\n      // add points for the new target\n      const newTarget = traceState.targets[updatedTraceTarget.index];\n      this.addTracedCoordinates_(\n        newTarget,\n        newTarget.startIndex,\n        updatedTraceTarget.endIndex\n      );\n    } else {\n      // target stayed the same\n      const target = traceState.targets[traceState.targetIndex];\n      this.addOrRemoveTracedCoordinates_(target, updatedTraceTarget.endIndex);\n    }\n\n    // modify the state with updated info\n    traceState.targetIndex = updatedTraceTarget.index;\n    const target = traceState.targets[traceState.targetIndex];\n    target.endIndex = updatedTraceTarget.endIndex;\n\n    // update event coordinate and pixel to match end point of final segment\n    const coordinate = interpolateCoordinate(\n      target.coordinates,\n      target.endIndex\n    );\n    const pixel = this.getMap().getPixelFromCoordinate(coordinate);\n    event.coordinate = coordinate;\n    event.pixel = [Math.round(pixel[0]), Math.round(pixel[1])];\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(event) {\n    let pass = true;\n\n    if (this.getPointerCount() === 0) {\n      if (this.downTimeout_) {\n        clearTimeout(this.downTimeout_);\n        this.downTimeout_ = undefined;\n      }\n\n      this.handlePointerMove_(event);\n      const tracing = this.traceState_.active;\n      this.toggleTraceState_(event);\n\n      if (this.shouldHandle_) {\n        const startingToDraw = !this.finishCoordinate_;\n        if (startingToDraw) {\n          this.startDrawing_(event.coordinate);\n        }\n        if (!startingToDraw && this.freehand_) {\n          this.finishDrawing();\n        } else if (\n          !this.freehand_ &&\n          (!startingToDraw || this.mode_ === 'Point')\n        ) {\n          if (this.atFinish_(event.pixel, tracing)) {\n            if (this.finishCondition_(event)) {\n              this.finishDrawing();\n            }\n          } else {\n            this.addToDrawing_(event.coordinate);\n          }\n        }\n        pass = false;\n      } else if (this.freehand_) {\n        this.abortDrawing();\n      }\n    }\n\n    if (!pass && this.stopClick_) {\n      event.preventDefault();\n    }\n    return pass;\n  }\n\n  /**\n   * Handle move events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event A move event.\n   * @private\n   */\n  handlePointerMove_(event) {\n    this.pointerType_ = event.originalEvent.pointerType;\n    if (\n      this.downPx_ &&\n      ((!this.freehand_ && this.shouldHandle_) ||\n        (this.freehand_ && !this.shouldHandle_))\n    ) {\n      const downPx = this.downPx_;\n      const clickPx = event.pixel;\n      const dx = downPx[0] - clickPx[0];\n      const dy = downPx[1] - clickPx[1];\n      const squaredDistance = dx * dx + dy * dy;\n      this.shouldHandle_ = this.freehand_\n        ? squaredDistance > this.squaredClickTolerance_\n        : squaredDistance <= this.squaredClickTolerance_;\n      if (!this.shouldHandle_) {\n        return;\n      }\n    }\n\n    if (!this.finishCoordinate_) {\n      this.createOrUpdateSketchPoint_(event.coordinate.slice());\n      return;\n    }\n\n    this.updateTrace_(event);\n    this.modifyDrawing_(event.coordinate);\n  }\n\n  /**\n   * Determine if an event is within the snapping tolerance of the start coord.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @param {boolean} [tracing] Drawing in trace mode (only stop if at the starting point).\n   * @return {boolean} The event is within the snapping tolerance of the start.\n   * @private\n   */\n  atFinish_(pixel, tracing) {\n    let at = false;\n    if (this.sketchFeature_) {\n      let potentiallyDone = false;\n      let potentiallyFinishCoordinates = [this.finishCoordinate_];\n      const mode = this.mode_;\n      if (mode === 'Point') {\n        at = true;\n      } else if (mode === 'Circle') {\n        at = this.sketchCoords_.length === 2;\n      } else if (mode === 'LineString') {\n        potentiallyDone =\n          !tracing && this.sketchCoords_.length > this.minPoints_;\n      } else if (mode === 'Polygon') {\n        const sketchCoords = /** @type {PolyCoordType} */ (this.sketchCoords_);\n        potentiallyDone = sketchCoords[0].length > this.minPoints_;\n        potentiallyFinishCoordinates = [\n          sketchCoords[0][0],\n          sketchCoords[0][sketchCoords[0].length - 2],\n        ];\n        if (tracing) {\n          potentiallyFinishCoordinates = [sketchCoords[0][0]];\n        } else {\n          potentiallyFinishCoordinates = [\n            sketchCoords[0][0],\n            sketchCoords[0][sketchCoords[0].length - 2],\n          ];\n        }\n      }\n      if (potentiallyDone) {\n        const map = this.getMap();\n        for (let i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {\n          const finishCoordinate = potentiallyFinishCoordinates[i];\n          const finishPixel = map.getPixelFromCoordinate(finishCoordinate);\n          const dx = pixel[0] - finishPixel[0];\n          const dy = pixel[1] - finishPixel[1];\n          const snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;\n          at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;\n          if (at) {\n            this.finishCoordinate_ = finishCoordinate;\n            break;\n          }\n        }\n      }\n    }\n    return at;\n  }\n\n  /**\n   * @param {import(\"../coordinate\").Coordinate} coordinates Coordinate.\n   * @private\n   */\n  createOrUpdateSketchPoint_(coordinates) {\n    if (!this.sketchPoint_) {\n      this.sketchPoint_ = new Feature(new Point(coordinates));\n      this.updateSketchFeatures_();\n    } else {\n      const sketchPointGeom = this.sketchPoint_.getGeometry();\n      sketchPointGeom.setCoordinates(coordinates);\n    }\n  }\n\n  /**\n   * @param {import(\"../geom/Polygon.js\").default} geometry Polygon geometry.\n   * @private\n   */\n  createOrUpdateCustomSketchLine_(geometry) {\n    if (!this.sketchLine_) {\n      this.sketchLine_ = new Feature();\n    }\n    const ring = geometry.getLinearRing(0);\n    let sketchLineGeom = this.sketchLine_.getGeometry();\n    if (!sketchLineGeom) {\n      sketchLineGeom = new LineString(\n        ring.getFlatCoordinates(),\n        ring.getLayout()\n      );\n      this.sketchLine_.setGeometry(sketchLineGeom);\n    } else {\n      sketchLineGeom.setFlatCoordinates(\n        ring.getLayout(),\n        ring.getFlatCoordinates()\n      );\n      sketchLineGeom.changed();\n    }\n  }\n\n  /**\n   * Start the drawing.\n   * @param {import(\"../coordinate.js\").Coordinate} start Start coordinate.\n   * @private\n   */\n  startDrawing_(start) {\n    const projection = this.getMap().getView().getProjection();\n    const stride = getStrideForLayout(this.geometryLayout_);\n    while (start.length < stride) {\n      start.push(0);\n    }\n    this.finishCoordinate_ = start;\n    if (this.mode_ === 'Point') {\n      this.sketchCoords_ = start.slice();\n    } else if (this.mode_ === 'Polygon') {\n      this.sketchCoords_ = [[start.slice(), start.slice()]];\n      this.sketchLineCoords_ = this.sketchCoords_[0];\n    } else {\n      this.sketchCoords_ = [start.slice(), start.slice()];\n    }\n    if (this.sketchLineCoords_) {\n      this.sketchLine_ = new Feature(new LineString(this.sketchLineCoords_));\n    }\n    const geometry = this.geometryFunction_(\n      this.sketchCoords_,\n      undefined,\n      projection\n    );\n    this.sketchFeature_ = new Feature();\n    if (this.geometryName_) {\n      this.sketchFeature_.setGeometryName(this.geometryName_);\n    }\n    this.sketchFeature_.setGeometry(geometry);\n    this.updateSketchFeatures_();\n    this.dispatchEvent(\n      new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_)\n    );\n  }\n\n  /**\n   * Modify the drawing.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @private\n   */\n  modifyDrawing_(coordinate) {\n    const map = this.getMap();\n    const geometry = this.sketchFeature_.getGeometry();\n    const projection = map.getView().getProjection();\n    const stride = getStrideForLayout(this.geometryLayout_);\n    let coordinates, last;\n    while (coordinate.length < stride) {\n      coordinate.push(0);\n    }\n    if (this.mode_ === 'Point') {\n      last = this.sketchCoords_;\n    } else if (this.mode_ === 'Polygon') {\n      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n      last = coordinates[coordinates.length - 1];\n      if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {\n        // snap to finish\n        coordinate = this.finishCoordinate_.slice();\n      }\n    } else {\n      coordinates = this.sketchCoords_;\n      last = coordinates[coordinates.length - 1];\n    }\n    last[0] = coordinate[0];\n    last[1] = coordinate[1];\n    this.geometryFunction_(\n      /** @type {!LineCoordType} */ (this.sketchCoords_),\n      geometry,\n      projection\n    );\n    if (this.sketchPoint_) {\n      const sketchPointGeom = this.sketchPoint_.getGeometry();\n      sketchPointGeom.setCoordinates(coordinate);\n    }\n    if (geometry.getType() === 'Polygon' && this.mode_ !== 'Polygon') {\n      this.createOrUpdateCustomSketchLine_(/** @type {Polygon} */ (geometry));\n    } else if (this.sketchLineCoords_) {\n      const sketchLineGeom = this.sketchLine_.getGeometry();\n      sketchLineGeom.setCoordinates(this.sketchLineCoords_);\n    }\n    this.updateSketchFeatures_();\n  }\n\n  /**\n   * Add a new coordinate to the drawing.\n   * @param {!PointCoordType} coordinate Coordinate\n   * @private\n   */\n  addToDrawing_(coordinate) {\n    const geometry = this.sketchFeature_.getGeometry();\n    const projection = this.getMap().getView().getProjection();\n    let done;\n    let coordinates;\n    const mode = this.mode_;\n    if (mode === 'LineString' || mode === 'Circle') {\n      this.finishCoordinate_ = coordinate.slice();\n      coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n      coordinates.push(coordinate.slice());\n      this.geometryFunction_(coordinates, geometry, projection);\n    } else if (mode === 'Polygon') {\n      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n      coordinates.push(coordinate.slice());\n      if (done) {\n        this.finishCoordinate_ = coordinates[0];\n      }\n      this.geometryFunction_(this.sketchCoords_, geometry, projection);\n    }\n    this.createOrUpdateSketchPoint_(coordinate.slice());\n    this.updateSketchFeatures_();\n    if (done) {\n      this.finishDrawing();\n    }\n  }\n\n  /**\n   * @param {number} n The number of points to remove.\n   */\n  removeLastPoints_(n) {\n    if (!this.sketchFeature_) {\n      return;\n    }\n    const geometry = this.sketchFeature_.getGeometry();\n    const projection = this.getMap().getView().getProjection();\n    const mode = this.mode_;\n    for (let i = 0; i < n; ++i) {\n      let coordinates;\n      if (mode === 'LineString' || mode === 'Circle') {\n        coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\n        coordinates.splice(-2, 1);\n        if (coordinates.length >= 2) {\n          this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();\n          const finishCoordinate = this.finishCoordinate_.slice();\n          coordinates[coordinates.length - 1] = finishCoordinate;\n          this.createOrUpdateSketchPoint_(finishCoordinate);\n        }\n        this.geometryFunction_(coordinates, geometry, projection);\n        if (geometry.getType() === 'Polygon' && this.sketchLine_) {\n          this.createOrUpdateCustomSketchLine_(\n            /** @type {Polygon} */ (geometry)\n          );\n        }\n      } else if (mode === 'Polygon') {\n        coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n        coordinates.splice(-2, 1);\n        const sketchLineGeom = this.sketchLine_.getGeometry();\n        if (coordinates.length >= 2) {\n          const finishCoordinate = coordinates[coordinates.length - 2].slice();\n          coordinates[coordinates.length - 1] = finishCoordinate;\n          this.createOrUpdateSketchPoint_(finishCoordinate);\n        }\n        sketchLineGeom.setCoordinates(coordinates);\n        this.geometryFunction_(this.sketchCoords_, geometry, projection);\n      }\n\n      if (coordinates.length === 1) {\n        this.abortDrawing();\n        break;\n      }\n    }\n\n    this.updateSketchFeatures_();\n  }\n\n  /**\n   * Remove last point of the feature currently being drawn. Does not do anything when\n   * drawing POINT or MULTI_POINT geometries.\n   * @api\n   */\n  removeLastPoint() {\n    this.removeLastPoints_(1);\n  }\n\n  /**\n   * Stop drawing and add the sketch feature to the target layer.\n   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is\n   * dispatched before inserting the feature.\n   * @api\n   */\n  finishDrawing() {\n    const sketchFeature = this.abortDrawing_();\n    if (!sketchFeature) {\n      return;\n    }\n    let coordinates = this.sketchCoords_;\n    const geometry = sketchFeature.getGeometry();\n    const projection = this.getMap().getView().getProjection();\n    if (this.mode_ === 'LineString') {\n      // remove the redundant last point\n      coordinates.pop();\n      this.geometryFunction_(coordinates, geometry, projection);\n    } else if (this.mode_ === 'Polygon') {\n      // remove the redundant last point in ring\n      /** @type {PolyCoordType} */ (coordinates)[0].pop();\n      this.geometryFunction_(coordinates, geometry, projection);\n      coordinates = geometry.getCoordinates();\n    }\n\n    // cast multi-part geometries\n    if (this.type_ === 'MultiPoint') {\n      sketchFeature.setGeometry(\n        new MultiPoint([/** @type {PointCoordType} */ (coordinates)])\n      );\n    } else if (this.type_ === 'MultiLineString') {\n      sketchFeature.setGeometry(\n        new MultiLineString([/** @type {LineCoordType} */ (coordinates)])\n      );\n    } else if (this.type_ === 'MultiPolygon') {\n      sketchFeature.setGeometry(\n        new MultiPolygon([/** @type {PolyCoordType} */ (coordinates)])\n      );\n    }\n\n    // First dispatch event to allow full set up of feature\n    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));\n\n    // Then insert feature\n    if (this.features_) {\n      this.features_.push(sketchFeature);\n    }\n    if (this.source_) {\n      this.source_.addFeature(sketchFeature);\n    }\n  }\n\n  /**\n   * Stop drawing without adding the sketch feature to the target layer.\n   * @return {Feature<import(\"../geom/SimpleGeometry.js\").default>|null} The sketch feature (or null if none).\n   * @private\n   */\n  abortDrawing_() {\n    this.finishCoordinate_ = null;\n    const sketchFeature = this.sketchFeature_;\n    this.sketchFeature_ = null;\n    this.sketchPoint_ = null;\n    this.sketchLine_ = null;\n    this.overlay_.getSource().clear(true);\n    this.deactivateTrace_();\n    return sketchFeature;\n  }\n\n  /**\n   * Stop drawing without adding the sketch feature to the target layer.\n   * @api\n   */\n  abortDrawing() {\n    const sketchFeature = this.abortDrawing_();\n    if (sketchFeature) {\n      this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));\n    }\n  }\n\n  /**\n   * Append coordinates to the end of the geometry that is currently being drawn.\n   * This can be used when drawing LineStrings or Polygons. Coordinates will\n   * either be appended to the current LineString or the outer ring of the current\n   * Polygon. If no geometry is being drawn, a new one will be created.\n   * @param {!LineCoordType} coordinates Linear coordinates to be appended to\n   * the coordinate array.\n   * @api\n   */\n  appendCoordinates(coordinates) {\n    const mode = this.mode_;\n    const newDrawing = !this.sketchFeature_;\n    if (newDrawing) {\n      this.startDrawing_(coordinates[0]);\n    }\n    /** @type {LineCoordType} */\n    let sketchCoords;\n    if (mode === 'LineString' || mode === 'Circle') {\n      sketchCoords = /** @type {LineCoordType} */ (this.sketchCoords_);\n    } else if (mode === 'Polygon') {\n      sketchCoords =\n        this.sketchCoords_ && this.sketchCoords_.length\n          ? /** @type {PolyCoordType} */ (this.sketchCoords_)[0]\n          : [];\n    } else {\n      return;\n    }\n\n    if (newDrawing) {\n      sketchCoords.shift();\n    }\n\n    // Remove last coordinate from sketch drawing (this coordinate follows cursor position)\n    sketchCoords.pop();\n\n    // Append coordinate list\n    for (let i = 0; i < coordinates.length; i++) {\n      this.addToDrawing_(coordinates[i]);\n    }\n\n    const ending = coordinates[coordinates.length - 1];\n    // Duplicate last coordinate for sketch drawing (cursor position)\n    this.addToDrawing_(ending);\n    this.modifyDrawing_(ending);\n  }\n\n  /**\n   * Initiate draw mode by starting from an existing geometry which will\n   * receive new additional points. This only works on features with\n   * `LineString` geometries, where the interaction will extend lines by adding\n   * points to the end of the coordinates array.\n   * This will change the original feature, instead of drawing a copy.\n   *\n   * The function will dispatch a `drawstart` event.\n   *\n   * @param {!Feature<LineString>} feature Feature to be extended.\n   * @api\n   */\n  extend(feature) {\n    const geometry = feature.getGeometry();\n    const lineString = geometry;\n    this.sketchFeature_ = feature;\n    this.sketchCoords_ = lineString.getCoordinates();\n    const last = this.sketchCoords_[this.sketchCoords_.length - 1];\n    this.finishCoordinate_ = last.slice();\n    this.sketchCoords_.push(last.slice());\n    this.sketchPoint_ = new Feature(new Point(last));\n    this.updateSketchFeatures_();\n    this.dispatchEvent(\n      new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_)\n    );\n  }\n\n  /**\n   * Redraw the sketch features.\n   * @private\n   */\n  updateSketchFeatures_() {\n    const sketchFeatures = [];\n    if (this.sketchFeature_) {\n      sketchFeatures.push(this.sketchFeature_);\n    }\n    if (this.sketchLine_) {\n      sketchFeatures.push(this.sketchLine_);\n    }\n    if (this.sketchPoint_) {\n      sketchFeatures.push(this.sketchPoint_);\n    }\n    const overlaySource = this.overlay_.getSource();\n    overlaySource.clear(true);\n    overlaySource.addFeatures(sketchFeatures);\n  }\n\n  /**\n   * @private\n   */\n  updateState_() {\n    const map = this.getMap();\n    const active = this.getActive();\n    if (!map || !active) {\n      this.abortDrawing();\n    }\n    this.overlay_.setMap(active ? map : null);\n  }\n}\n\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\nfunction getDefaultStyleFunction() {\n  const styles = createEditingStyle();\n  return function (feature, resolution) {\n    return styles[feature.getGeometry().getType()];\n  };\n}\n\n/**\n * Create a `geometryFunction` for `type: 'Circle'` that will create a regular\n * polygon with a user specified number of sides and start angle instead of a\n * {@link import(\"../geom/Circle.js\").Circle} geometry.\n * @param {number} [sides] Number of sides of the regular polygon.\n *     Default is 32.\n * @param {number} [angle] Angle of the first point in counter-clockwise\n *     radians. 0 means East.\n *     Default is the angle defined by the heading from the center of the\n *     regular polygon to the current pointer position.\n * @return {GeometryFunction} Function that draws a polygon.\n * @api\n */\nexport function createRegularPolygon(sides, angle) {\n  return function (coordinates, geometry, projection) {\n    const center = fromUserCoordinate(\n      /** @type {LineCoordType} */ (coordinates)[0],\n      projection\n    );\n    const end = fromUserCoordinate(\n      /** @type {LineCoordType} */ (coordinates)[coordinates.length - 1],\n      projection\n    );\n    const radius = Math.sqrt(squaredCoordinateDistance(center, end));\n    geometry = geometry || fromCircle(new Circle(center), sides);\n\n    let internalAngle = angle;\n    if (!angle && angle !== 0) {\n      const x = end[0] - center[0];\n      const y = end[1] - center[1];\n      internalAngle = Math.atan2(y, x);\n    }\n    makeRegular(\n      /** @type {Polygon} */ (geometry),\n      center,\n      radius,\n      internalAngle\n    );\n\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      geometry.transform(projection, userProjection);\n    }\n    return geometry;\n  };\n}\n\n/**\n * Create a `geometryFunction` that will create a box-shaped polygon (aligned\n * with the coordinate system axes).  Use this with the draw interaction and\n * `type: 'Circle'` to return a box instead of a circle geometry.\n * @return {GeometryFunction} Function that draws a box-shaped polygon.\n * @api\n */\nexport function createBox() {\n  return function (coordinates, geometry, projection) {\n    const extent = boundingExtent(\n      /** @type {LineCoordType} */ ([\n        coordinates[0],\n        coordinates[coordinates.length - 1],\n      ]).map(function (coordinate) {\n        return fromUserCoordinate(coordinate, projection);\n      })\n    );\n    const boxCoordinates = [\n      [\n        getBottomLeft(extent),\n        getBottomRight(extent),\n        getTopRight(extent),\n        getTopLeft(extent),\n        getBottomLeft(extent),\n      ],\n    ];\n    if (geometry) {\n      geometry.setCoordinates(boxCoordinates);\n    } else {\n      geometry = new Polygon(boxCoordinates);\n    }\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      geometry.transform(projection, userProjection);\n    }\n    return geometry;\n  };\n}\n\n/**\n * Get the drawing mode.  The mode for multi-part geometries is the same as for\n * their single-part cousins.\n * @param {import(\"../geom/Geometry.js\").Type} type Geometry type.\n * @return {Mode} Drawing mode.\n */\nfunction getMode(type) {\n  switch (type) {\n    case 'Point':\n    case 'MultiPoint':\n      return 'Point';\n    case 'LineString':\n    case 'MultiLineString':\n      return 'LineString';\n    case 'Polygon':\n    case 'MultiPolygon':\n      return 'Polygon';\n    case 'Circle':\n      return 'Circle';\n    default:\n      throw new Error('Invalid type: ' + type);\n  }\n}\n\nexport default Draw;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}