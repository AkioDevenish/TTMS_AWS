{"ast":null,"code":"import _regeneratorRuntime from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _objectSpread from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _asyncToGenerator from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _callSuper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _wrapNativeSuper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\nimport _createClass from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array-buffer.constructor.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.data-view.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.float64-array.js\";\nimport \"core-js/modules/es.typed-array.int8-array.js\";\nimport \"core-js/modules/es.typed-array.int16-array.js\";\nimport \"core-js/modules/es.typed-array.int32-array.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.uint16-array.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.filter.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/esnext.iterator.reduce.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/** @module geotiff */\nimport GeoTIFFImage from './geotiffimage.js';\nimport DataView64 from './dataview64.js';\nimport DataSlice from './dataslice.js';\nimport Pool from './pool.js';\nimport { makeRemoteSource, makeCustomSource } from './source/remote.js';\nimport { makeBufferSource } from './source/arraybuffer.js';\nimport { makeFileReaderSource } from './source/filereader.js';\nimport { makeFileSource } from './source/file.js';\nimport { BaseClient, BaseResponse } from './source/client/base.js';\nimport { fieldTypes, fieldTagNames, arrayFields, geoKeyNames } from './globals.js';\nimport { writeGeotiff } from './geotiffwriter.js';\nimport * as globals from './globals.js';\nimport * as rgb from './rgb.js';\nimport { getDecoder, addDecoder } from './compression/index.js';\nimport { setLogger } from './logging.js';\nexport { globals };\nexport { rgb };\nexport { default as BaseDecoder } from './compression/basedecoder.js';\nexport { getDecoder, addDecoder };\nexport { setLogger };\n\n/**\n * @typedef {Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array}\n * TypedArray\n */\n\n/**\n * @typedef {{ height:number, width: number }} Dimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray & { height: number; width: number}`\n * @typedef {TypedArray & Dimensions} TypedArrayWithDimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray[] & { height: number; width: number}`\n * @typedef {TypedArray[] & Dimensions} TypedArrayArrayWithDimensions\n */\n\n/**\n *  The autogenerated docs are a little confusing here. The effective type is:\n *\n * `(TypedArray | TypedArray[]) & { height: number; width: number}`\n * @typedef {TypedArrayWithDimensions | TypedArrayArrayWithDimensions} ReadRasterResult\n */\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case fieldTypes.BYTE:\n    case fieldTypes.ASCII:\n    case fieldTypes.SBYTE:\n    case fieldTypes.UNDEFINED:\n      return 1;\n    case fieldTypes.SHORT:\n    case fieldTypes.SSHORT:\n      return 2;\n    case fieldTypes.LONG:\n    case fieldTypes.SLONG:\n    case fieldTypes.FLOAT:\n    case fieldTypes.IFD:\n      return 4;\n    case fieldTypes.RATIONAL:\n    case fieldTypes.SRATIONAL:\n    case fieldTypes.DOUBLE:\n    case fieldTypes.LONG8:\n    case fieldTypes.SLONG8:\n    case fieldTypes.IFD8:\n      return 8;\n    default:\n      throw new RangeError(\"Invalid field type: \".concat(fieldType));\n  }\n}\nfunction parseGeoKeyDirectory(fileDirectory) {\n  var rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n  var geoKeyDirectory = {};\n  for (var i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    var key = geoKeyNames[rawGeoKeyDirectory[i]];\n    var location = rawGeoKeyDirectory[i + 1] ? fieldTagNames[rawGeoKeyDirectory[i + 1]] : null;\n    var count = rawGeoKeyDirectory[i + 2];\n    var offset = rawGeoKeyDirectory[i + 3];\n    var value = null;\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(\"Could not get value of geoKey '\".concat(key, \"'.\"));\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n    geoKeyDirectory[key] = value;\n  }\n  return geoKeyDirectory;\n}\nfunction getValues(dataSlice, fieldType, count, offset) {\n  var values = null;\n  var readMethod = null;\n  var fieldTypeLength = getFieldTypeLength(fieldType);\n  switch (fieldType) {\n    case fieldTypes.BYTE:\n    case fieldTypes.ASCII:\n    case fieldTypes.UNDEFINED:\n      values = new Uint8Array(count);\n      readMethod = dataSlice.readUint8;\n      break;\n    case fieldTypes.SBYTE:\n      values = new Int8Array(count);\n      readMethod = dataSlice.readInt8;\n      break;\n    case fieldTypes.SHORT:\n      values = new Uint16Array(count);\n      readMethod = dataSlice.readUint16;\n      break;\n    case fieldTypes.SSHORT:\n      values = new Int16Array(count);\n      readMethod = dataSlice.readInt16;\n      break;\n    case fieldTypes.LONG:\n    case fieldTypes.IFD:\n      values = new Uint32Array(count);\n      readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SLONG:\n      values = new Int32Array(count);\n      readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.LONG8:\n    case fieldTypes.IFD8:\n      values = new Array(count);\n      readMethod = dataSlice.readUint64;\n      break;\n    case fieldTypes.SLONG8:\n      values = new Array(count);\n      readMethod = dataSlice.readInt64;\n      break;\n    case fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2);\n      readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2);\n      readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.FLOAT:\n      values = new Float32Array(count);\n      readMethod = dataSlice.readFloat32;\n      break;\n    case fieldTypes.DOUBLE:\n      values = new Float64Array(count);\n      readMethod = dataSlice.readFloat64;\n      break;\n    default:\n      throw new RangeError(\"Invalid field type: \".concat(fieldType));\n  }\n\n  // normal fields\n  if (!(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n    for (var i = 0; i < count; ++i) {\n      values[i] = readMethod.call(dataSlice, offset + i * fieldTypeLength);\n    }\n  } else {\n    // RATIONAL or SRATIONAL\n    for (var _i = 0; _i < count; _i += 2) {\n      values[_i] = readMethod.call(dataSlice, offset + _i * fieldTypeLength);\n      values[_i + 1] = readMethod.call(dataSlice, offset + (_i * fieldTypeLength + 4));\n    }\n  }\n  if (fieldType === fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n  return values;\n}\n\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\nvar ImageFileDirectory = /*#__PURE__*/_createClass(function ImageFileDirectory(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n  _classCallCheck(this, ImageFileDirectory);\n  this.fileDirectory = fileDirectory;\n  this.geoKeyDirectory = geoKeyDirectory;\n  this.nextIFDByteOffset = nextIFDByteOffset;\n});\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\nvar GeoTIFFImageIndexError = /*#__PURE__*/function (_Error) {\n  function GeoTIFFImageIndexError(index) {\n    var _this;\n    _classCallCheck(this, GeoTIFFImageIndexError);\n    _this = _callSuper(this, GeoTIFFImageIndexError, [\"No image at index \".concat(index)]);\n    _this.index = index;\n    return _this;\n  }\n  _inherits(GeoTIFFImageIndexError, _Error);\n  return _createClass(GeoTIFFImageIndexError);\n}(/*#__PURE__*/_wrapNativeSuper(Error));\nvar GeoTIFFBase = /*#__PURE__*/function () {\n  function GeoTIFFBase() {\n    _classCallCheck(this, GeoTIFFBase);\n  }\n  return _createClass(GeoTIFFBase, [{\n    key: \"readRasters\",\n    value: (\n    /**\n     * (experimental) Reads raster data from the best fitting image. This function uses\n     * the image with the lowest resolution that is still a higher resolution than the\n     * requested resolution.\n     * When specified, the `bbox` option is translated to the `window` option and the\n     * `resX` and `resY` to `width` and `height` respectively.\n     * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n     * image is called and the result returned.\n     * @see GeoTIFFImage.readRasters\n     * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters\n     * @returns {Promise<ReadRasterResult>} the decoded array(s), with `height` and `width`, as a promise\n     */\n    function () {\n      var _readRasters = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var options,\n          imageWindow,\n          width,\n          height,\n          resX,\n          resY,\n          bbox,\n          firstImage,\n          usedImage,\n          imageCount,\n          imgBBox,\n          _firstImage$getOrigin,\n          _firstImage$getOrigin2,\n          oX,\n          oY,\n          _firstImage$getResolu,\n          _firstImage$getResolu2,\n          rX,\n          rY,\n          usedBBox,\n          allImages,\n          i,\n          image,\n          _image$fileDirectory,\n          subfileType,\n          newSubfileType,\n          _i2,\n          _image,\n          imgResX,\n          imgResY,\n          wnd,\n          _firstImage$getOrigin3,\n          _firstImage$getOrigin4,\n          _oX,\n          _oY,\n          _usedImage$getResolut,\n          _usedImage$getResolut2,\n          imageResX,\n          imageResY,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};\n              imageWindow = options.window, width = options.width, height = options.height;\n              resX = options.resX, resY = options.resY, bbox = options.bbox;\n              _context.next = 5;\n              return this.getImage();\n            case 5:\n              firstImage = _context.sent;\n              usedImage = firstImage;\n              _context.next = 9;\n              return this.getImageCount();\n            case 9:\n              imageCount = _context.sent;\n              imgBBox = firstImage.getBoundingBox();\n              if (!(imageWindow && bbox)) {\n                _context.next = 13;\n                break;\n              }\n              throw new Error('Both \"bbox\" and \"window\" passed.');\n            case 13:\n              if (!(width || height)) {\n                _context.next = 24;\n                break;\n              }\n              // if we have an image window (pixel coordinates), transform it to a BBox\n              // using the origin/resolution of the first image.\n              if (imageWindow) {\n                _firstImage$getOrigin = firstImage.getOrigin(), _firstImage$getOrigin2 = _slicedToArray(_firstImage$getOrigin, 2), oX = _firstImage$getOrigin2[0], oY = _firstImage$getOrigin2[1];\n                _firstImage$getResolu = firstImage.getResolution(), _firstImage$getResolu2 = _slicedToArray(_firstImage$getResolu, 2), rX = _firstImage$getResolu2[0], rY = _firstImage$getResolu2[1];\n                bbox = [oX + imageWindow[0] * rX, oY + imageWindow[1] * rY, oX + imageWindow[2] * rX, oY + imageWindow[3] * rY];\n              }\n\n              // if we have a bbox (or calculated one)\n              usedBBox = bbox || imgBBox;\n              if (!width) {\n                _context.next = 20;\n                break;\n              }\n              if (!resX) {\n                _context.next = 19;\n                break;\n              }\n              throw new Error('Both width and resX passed');\n            case 19:\n              resX = (usedBBox[2] - usedBBox[0]) / width;\n            case 20:\n              if (!height) {\n                _context.next = 24;\n                break;\n              }\n              if (!resY) {\n                _context.next = 23;\n                break;\n              }\n              throw new Error('Both width and resY passed');\n            case 23:\n              resY = (usedBBox[3] - usedBBox[1]) / height;\n            case 24:\n              if (!(resX || resY)) {\n                _context.next = 48;\n                break;\n              }\n              allImages = [];\n              i = 0;\n            case 27:\n              if (!(i < imageCount)) {\n                _context.next = 36;\n                break;\n              }\n              _context.next = 30;\n              return this.getImage(i);\n            case 30:\n              image = _context.sent;\n              _image$fileDirectory = image.fileDirectory, subfileType = _image$fileDirectory.SubfileType, newSubfileType = _image$fileDirectory.NewSubfileType;\n              if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n                allImages.push(image);\n              }\n            case 33:\n              ++i;\n              _context.next = 27;\n              break;\n            case 36:\n              allImages.sort(function (a, b) {\n                return a.getWidth() - b.getWidth();\n              });\n              _i2 = 0;\n            case 38:\n              if (!(_i2 < allImages.length)) {\n                _context.next = 48;\n                break;\n              }\n              _image = allImages[_i2];\n              imgResX = (imgBBox[2] - imgBBox[0]) / _image.getWidth();\n              imgResY = (imgBBox[3] - imgBBox[1]) / _image.getHeight();\n              usedImage = _image;\n              if (!(resX && resX > imgResX || resY && resY > imgResY)) {\n                _context.next = 45;\n                break;\n              }\n              return _context.abrupt(\"break\", 48);\n            case 45:\n              ++_i2;\n              _context.next = 38;\n              break;\n            case 48:\n              wnd = imageWindow;\n              if (bbox) {\n                _firstImage$getOrigin3 = firstImage.getOrigin(), _firstImage$getOrigin4 = _slicedToArray(_firstImage$getOrigin3, 2), _oX = _firstImage$getOrigin4[0], _oY = _firstImage$getOrigin4[1];\n                _usedImage$getResolut = usedImage.getResolution(firstImage), _usedImage$getResolut2 = _slicedToArray(_usedImage$getResolut, 2), imageResX = _usedImage$getResolut2[0], imageResY = _usedImage$getResolut2[1];\n                wnd = [Math.round((bbox[0] - _oX) / imageResX), Math.round((bbox[1] - _oY) / imageResY), Math.round((bbox[2] - _oX) / imageResX), Math.round((bbox[3] - _oY) / imageResY)];\n                wnd = [Math.min(wnd[0], wnd[2]), Math.min(wnd[1], wnd[3]), Math.max(wnd[0], wnd[2]), Math.max(wnd[1], wnd[3])];\n              }\n              return _context.abrupt(\"return\", usedImage.readRasters(_objectSpread(_objectSpread({}, options), {}, {\n                window: wnd\n              })));\n            case 51:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function readRasters() {\n        return _readRasters.apply(this, arguments);\n      }\n      return readRasters;\n    }())\n  }]);\n}();\n/**\n * @typedef {Object} GeoTIFFOptions\n * @property {boolean} [cache=false] whether or not decoded tiles shall be cached.\n */\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\nvar GeoTIFF = /*#__PURE__*/function (_GeoTIFFBase) {\n  /**\n   * @constructor\n   * @param {*} source The datasource to read from.\n   * @param {boolean} littleEndian Whether the image uses little endian.\n   * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {GeoTIFFOptions} [options] further options.\n   */\n  function GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset) {\n    var _this2;\n    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    _classCallCheck(this, GeoTIFF);\n    _this2 = _callSuper(this, GeoTIFF);\n    _this2.source = source;\n    _this2.littleEndian = littleEndian;\n    _this2.bigTiff = bigTiff;\n    _this2.firstIFDOffset = firstIFDOffset;\n    _this2.cache = options.cache || false;\n    _this2.ifdRequests = [];\n    _this2.ghostValues = null;\n    return _this2;\n  }\n  _inherits(GeoTIFF, _GeoTIFFBase);\n  return _createClass(GeoTIFF, [{\n    key: \"getSlice\",\n    value: function () {\n      var _getSlice = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(offset, size) {\n        var fallbackSize;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              fallbackSize = this.bigTiff ? 4048 : 1024;\n              _context2.t0 = DataSlice;\n              _context2.next = 4;\n              return this.source.fetch([{\n                offset: offset,\n                length: typeof size !== 'undefined' ? size : fallbackSize\n              }]);\n            case 4:\n              _context2.t1 = _context2.sent[0];\n              _context2.t2 = offset;\n              _context2.t3 = this.littleEndian;\n              _context2.t4 = this.bigTiff;\n              return _context2.abrupt(\"return\", new _context2.t0(_context2.t1, _context2.t2, _context2.t3, _context2.t4));\n            case 9:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function getSlice(_x, _x2) {\n        return _getSlice.apply(this, arguments);\n      }\n      return getSlice;\n    }()\n    /**\n     * Instructs to parse an image file directory at the given file offset.\n     * As there is no way to ensure that a location is indeed the start of an IFD,\n     * this function must be called with caution (e.g only using the IFD offsets from\n     * the headers or other IFDs).\n     * @param {number} offset the offset to parse the IFD at\n     * @returns {Promise<ImageFileDirectory>} the parsed IFD\n     */\n  }, {\n    key: \"parseFileDirectoryAt\",\n    value: (function () {\n      var _parseFileDirectoryAt = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(offset) {\n        var entrySize, offsetSize, dataSlice, numDirEntries, byteSize, fileDirectory, i, entryCount, fieldTag, fieldType, typeCount, fieldValues, value, fieldTypeLength, valueOffset, actualOffset, length, fieldDataSlice, geoKeyDirectory, nextIFDByteOffset;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              entrySize = this.bigTiff ? 20 : 12;\n              offsetSize = this.bigTiff ? 8 : 2;\n              _context3.next = 4;\n              return this.getSlice(offset);\n            case 4:\n              dataSlice = _context3.sent;\n              numDirEntries = this.bigTiff ? dataSlice.readUint64(offset) : dataSlice.readUint16(offset); // if the slice does not cover the whole IFD, request a bigger slice, where the\n              // whole IFD fits: num of entries + n x tag length + offset to next IFD\n              byteSize = numDirEntries * entrySize + (this.bigTiff ? 16 : 6);\n              if (dataSlice.covers(offset, byteSize)) {\n                _context3.next = 11;\n                break;\n              }\n              _context3.next = 10;\n              return this.getSlice(offset, byteSize);\n            case 10:\n              dataSlice = _context3.sent;\n            case 11:\n              fileDirectory = {}; // loop over the IFD and create a file directory object\n              i = offset + (this.bigTiff ? 8 : 2);\n              entryCount = 0;\n            case 14:\n              if (!(entryCount < numDirEntries)) {\n                _context3.next = 41;\n                break;\n              }\n              fieldTag = dataSlice.readUint16(i);\n              fieldType = dataSlice.readUint16(i + 2);\n              typeCount = this.bigTiff ? dataSlice.readUint64(i + 4) : dataSlice.readUint32(i + 4);\n              fieldValues = void 0;\n              value = void 0;\n              fieldTypeLength = getFieldTypeLength(fieldType);\n              valueOffset = i + (this.bigTiff ? 12 : 8); // check whether the value is directly encoded in the tag or refers to a\n              // different external byte range\n              if (!(fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4))) {\n                _context3.next = 26;\n                break;\n              }\n              fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n              _context3.next = 36;\n              break;\n            case 26:\n              // resolve the reference to the actual byte range\n              actualOffset = dataSlice.readOffset(valueOffset);\n              length = getFieldTypeLength(fieldType) * typeCount; // check, whether we actually cover the referenced byte range; if not,\n              // request a new slice of bytes to read from it\n              if (!dataSlice.covers(actualOffset, length)) {\n                _context3.next = 32;\n                break;\n              }\n              fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n              _context3.next = 36;\n              break;\n            case 32:\n              _context3.next = 34;\n              return this.getSlice(actualOffset, length);\n            case 34:\n              fieldDataSlice = _context3.sent;\n              fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n            case 36:\n              // unpack single values from the array\n              if (typeCount === 1 && arrayFields.indexOf(fieldTag) === -1 && !(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n                value = fieldValues[0];\n              } else {\n                value = fieldValues;\n              }\n\n              // write the tags value to the file directly\n              fileDirectory[fieldTagNames[fieldTag]] = value;\n            case 38:\n              i += entrySize, ++entryCount;\n              _context3.next = 14;\n              break;\n            case 41:\n              geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n              nextIFDByteOffset = dataSlice.readOffset(offset + offsetSize + entrySize * numDirEntries);\n              return _context3.abrupt(\"return\", new ImageFileDirectory(fileDirectory, geoKeyDirectory, nextIFDByteOffset));\n            case 44:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function parseFileDirectoryAt(_x3) {\n        return _parseFileDirectoryAt.apply(this, arguments);\n      }\n      return parseFileDirectoryAt;\n    }())\n  }, {\n    key: \"requestIFD\",\n    value: function () {\n      var _requestIFD = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(index) {\n        var _this3 = this;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              if (!this.ifdRequests[index]) {\n                _context5.next = 4;\n                break;\n              }\n              return _context5.abrupt(\"return\", this.ifdRequests[index]);\n            case 4:\n              if (!(index === 0)) {\n                _context5.next = 9;\n                break;\n              }\n              // special case for index 0\n              this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n              return _context5.abrupt(\"return\", this.ifdRequests[index]);\n            case 9:\n              if (this.ifdRequests[index - 1]) {\n                _context5.next = 19;\n                break;\n              }\n              _context5.prev = 10;\n              this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n              _context5.next = 19;\n              break;\n            case 14:\n              _context5.prev = 14;\n              _context5.t0 = _context5[\"catch\"](10);\n              if (!(_context5.t0 instanceof GeoTIFFImageIndexError)) {\n                _context5.next = 18;\n                break;\n              }\n              throw new GeoTIFFImageIndexError(index);\n            case 18:\n              throw _context5.t0;\n            case 19:\n              // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n              // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n              this.ifdRequests[index] = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n                var previousIfd;\n                return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n                  while (1) switch (_context4.prev = _context4.next) {\n                    case 0:\n                      _context4.next = 2;\n                      return _this3.ifdRequests[index - 1];\n                    case 2:\n                      previousIfd = _context4.sent;\n                      if (!(previousIfd.nextIFDByteOffset === 0)) {\n                        _context4.next = 5;\n                        break;\n                      }\n                      throw new GeoTIFFImageIndexError(index);\n                    case 5:\n                      return _context4.abrupt(\"return\", _this3.parseFileDirectoryAt(previousIfd.nextIFDByteOffset));\n                    case 6:\n                    case \"end\":\n                      return _context4.stop();\n                  }\n                }, _callee4);\n              }))();\n              return _context5.abrupt(\"return\", this.ifdRequests[index]);\n            case 21:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this, [[10, 14]]);\n      }));\n      function requestIFD(_x4) {\n        return _requestIFD.apply(this, arguments);\n      }\n      return requestIFD;\n    }()\n    /**\n     * Get the n-th internal subfile of an image. By default, the first is returned.\n     *\n     * @param {number} [index=0] the index of the image to return.\n     * @returns {Promise<GeoTIFFImage>} the image at the given index\n     */\n  }, {\n    key: \"getImage\",\n    value: (function () {\n      var _getImage = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var index,\n          ifd,\n          _args6 = arguments;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              index = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : 0;\n              _context6.next = 3;\n              return this.requestIFD(index);\n            case 3:\n              ifd = _context6.sent;\n              return _context6.abrupt(\"return\", new GeoTIFFImage(ifd.fileDirectory, ifd.geoKeyDirectory, this.dataView, this.littleEndian, this.cache, this.source));\n            case 5:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function getImage() {\n        return _getImage.apply(this, arguments);\n      }\n      return getImage;\n    }()\n    /**\n     * Returns the count of the internal subfiles.\n     *\n     * @returns {Promise<number>} the number of internal subfile images\n     */\n    )\n  }, {\n    key: \"getImageCount\",\n    value: (function () {\n      var _getImageCount = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var index, hasNext;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              index = 0; // loop until we run out of IFDs\n              hasNext = true;\n            case 2:\n              if (!hasNext) {\n                _context7.next = 18;\n                break;\n              }\n              _context7.prev = 3;\n              _context7.next = 6;\n              return this.requestIFD(index);\n            case 6:\n              ++index;\n              _context7.next = 16;\n              break;\n            case 9:\n              _context7.prev = 9;\n              _context7.t0 = _context7[\"catch\"](3);\n              if (!(_context7.t0 instanceof GeoTIFFImageIndexError)) {\n                _context7.next = 15;\n                break;\n              }\n              hasNext = false;\n              _context7.next = 16;\n              break;\n            case 15:\n              throw _context7.t0;\n            case 16:\n              _context7.next = 2;\n              break;\n            case 18:\n              return _context7.abrupt(\"return\", index);\n            case 19:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this, [[3, 9]]);\n      }));\n      function getImageCount() {\n        return _getImageCount.apply(this, arguments);\n      }\n      return getImageCount;\n    }()\n    /**\n     * Get the values of the COG ghost area as a parsed map.\n     * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n     * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found\n     */\n    )\n  }, {\n    key: \"getGhostValues\",\n    value: (function () {\n      var _getGhostValues = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var _this4 = this;\n        var offset, detectionString, heuristicAreaSize, slice, valuesString, firstLine, metadataSize, fullString;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              offset = this.bigTiff ? 16 : 8;\n              if (!this.ghostValues) {\n                _context8.next = 3;\n                break;\n              }\n              return _context8.abrupt(\"return\", this.ghostValues);\n            case 3:\n              detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n              heuristicAreaSize = detectionString.length + 100;\n              _context8.next = 7;\n              return this.getSlice(offset, heuristicAreaSize);\n            case 7:\n              slice = _context8.sent;\n              if (!(detectionString === getValues(slice, fieldTypes.ASCII, detectionString.length, offset))) {\n                _context8.next = 19;\n                break;\n              }\n              valuesString = getValues(slice, fieldTypes.ASCII, heuristicAreaSize, offset);\n              firstLine = valuesString.split('\\n')[0];\n              metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n              if (!(metadataSize > heuristicAreaSize)) {\n                _context8.next = 16;\n                break;\n              }\n              _context8.next = 15;\n              return this.getSlice(offset, metadataSize);\n            case 15:\n              slice = _context8.sent;\n            case 16:\n              fullString = getValues(slice, fieldTypes.ASCII, metadataSize, offset);\n              this.ghostValues = {};\n              fullString.split('\\n').filter(function (line) {\n                return line.length > 0;\n              }).map(function (line) {\n                return line.split('=');\n              }).forEach(function (_ref2) {\n                var _ref3 = _slicedToArray(_ref2, 2),\n                  key = _ref3[0],\n                  value = _ref3[1];\n                _this4.ghostValues[key] = value;\n              });\n            case 19:\n              return _context8.abrupt(\"return\", this.ghostValues);\n            case 20:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this);\n      }));\n      function getGhostValues() {\n        return _getGhostValues.apply(this, arguments);\n      }\n      return getGhostValues;\n    }()\n    /**\n     * Parse a (Geo)TIFF file from the given source.\n     *\n     * @param {*} source The source of data to parse from.\n     * @param {GeoTIFFOptions} [options] Additional options.\n     * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n     *                               to be aborted\n     */\n    )\n  }, {\n    key: \"close\",\n    value:\n    /**\n     * Closes the underlying file buffer\n     * N.B. After the GeoTIFF has been completely processed it needs\n     * to be closed but only if it has been constructed from a file.\n     */\n    function close() {\n      if (typeof this.source.close === 'function') {\n        return this.source.close();\n      }\n      return false;\n    }\n  }], [{\n    key: \"fromSource\",\n    value: (function () {\n      var _fromSource = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9(source, options, signal) {\n        var headerData, dataView, BOM, littleEndian, magicNumber, bigTiff, offsetByteSize, firstIFDOffset;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              _context9.next = 2;\n              return source.fetch([{\n                offset: 0,\n                length: 1024\n              }], signal);\n            case 2:\n              headerData = _context9.sent[0];\n              dataView = new DataView64(headerData);\n              BOM = dataView.getUint16(0, 0);\n              if (!(BOM === 0x4949)) {\n                _context9.next = 9;\n                break;\n              }\n              littleEndian = true;\n              _context9.next = 14;\n              break;\n            case 9:\n              if (!(BOM === 0x4D4D)) {\n                _context9.next = 13;\n                break;\n              }\n              littleEndian = false;\n              _context9.next = 14;\n              break;\n            case 13:\n              throw new TypeError('Invalid byte order value.');\n            case 14:\n              magicNumber = dataView.getUint16(2, littleEndian);\n              if (!(magicNumber === 42)) {\n                _context9.next = 19;\n                break;\n              }\n              bigTiff = false;\n              _context9.next = 27;\n              break;\n            case 19:\n              if (!(magicNumber === 43)) {\n                _context9.next = 26;\n                break;\n              }\n              bigTiff = true;\n              offsetByteSize = dataView.getUint16(4, littleEndian);\n              if (!(offsetByteSize !== 8)) {\n                _context9.next = 24;\n                break;\n              }\n              throw new Error('Unsupported offset byte-size.');\n            case 24:\n              _context9.next = 27;\n              break;\n            case 26:\n              throw new TypeError('Invalid magic number.');\n            case 27:\n              firstIFDOffset = bigTiff ? dataView.getUint64(8, littleEndian) : dataView.getUint32(4, littleEndian);\n              return _context9.abrupt(\"return\", new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options));\n            case 29:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9);\n      }));\n      function fromSource(_x5, _x6, _x7) {\n        return _fromSource.apply(this, arguments);\n      }\n      return fromSource;\n    }())\n  }]);\n}(GeoTIFFBase);\nexport { GeoTIFF };\nexport default GeoTIFF;\n\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\nvar MultiGeoTIFF = /*#__PURE__*/function (_GeoTIFFBase2) {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  function MultiGeoTIFF(mainFile, overviewFiles) {\n    var _this5;\n    _classCallCheck(this, MultiGeoTIFF);\n    _this5 = _callSuper(this, MultiGeoTIFF);\n    _this5.mainFile = mainFile;\n    _this5.overviewFiles = overviewFiles;\n    _this5.imageFiles = [mainFile].concat(overviewFiles);\n    _this5.fileDirectoriesPerFile = null;\n    _this5.fileDirectoriesPerFileParsing = null;\n    _this5.imageCount = null;\n    return _this5;\n  }\n  _inherits(MultiGeoTIFF, _GeoTIFFBase2);\n  return _createClass(MultiGeoTIFF, [{\n    key: \"parseFileDirectoriesPerFile\",\n    value: function () {\n      var _parseFileDirectoriesPerFile = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var requests;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)].concat(this.overviewFiles.map(function (file) {\n                return file.parseFileDirectoryAt(file.firstIFDOffset);\n              }));\n              _context10.next = 3;\n              return Promise.all(requests);\n            case 3:\n              this.fileDirectoriesPerFile = _context10.sent;\n              return _context10.abrupt(\"return\", this.fileDirectoriesPerFile);\n            case 5:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this);\n      }));\n      function parseFileDirectoriesPerFile() {\n        return _parseFileDirectoriesPerFile.apply(this, arguments);\n      }\n      return parseFileDirectoriesPerFile;\n    }()\n    /**\n     * Get the n-th internal subfile of an image. By default, the first is returned.\n     *\n     * @param {number} [index=0] the index of the image to return.\n     * @returns {Promise<GeoTIFFImage>} the image at the given index\n     */\n  }, {\n    key: \"getImage\",\n    value: (function () {\n      var _getImage2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var index,\n          visited,\n          relativeIndex,\n          i,\n          imageFile,\n          ii,\n          ifd,\n          _args11 = arguments;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              index = _args11.length > 0 && _args11[0] !== undefined ? _args11[0] : 0;\n              _context11.next = 3;\n              return this.getImageCount();\n            case 3:\n              _context11.next = 5;\n              return this.parseFileDirectoriesPerFile();\n            case 5:\n              visited = 0;\n              relativeIndex = 0;\n              i = 0;\n            case 8:\n              if (!(i < this.imageFiles.length)) {\n                _context11.next = 26;\n                break;\n              }\n              imageFile = this.imageFiles[i];\n              ii = 0;\n            case 11:\n              if (!(ii < this.imageCounts[i])) {\n                _context11.next = 22;\n                break;\n              }\n              if (!(index === visited)) {\n                _context11.next = 17;\n                break;\n              }\n              _context11.next = 15;\n              return imageFile.requestIFD(relativeIndex);\n            case 15:\n              ifd = _context11.sent;\n              return _context11.abrupt(\"return\", new GeoTIFFImage(ifd.fileDirectory, ifd.geoKeyDirectory, imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source));\n            case 17:\n              visited++;\n              relativeIndex++;\n            case 19:\n              ii++;\n              _context11.next = 11;\n              break;\n            case 22:\n              relativeIndex = 0;\n            case 23:\n              i++;\n              _context11.next = 8;\n              break;\n            case 26:\n              throw new RangeError('Invalid image index');\n            case 27:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this);\n      }));\n      function getImage() {\n        return _getImage2.apply(this, arguments);\n      }\n      return getImage;\n    }()\n    /**\n     * Returns the count of the internal subfiles.\n     *\n     * @returns {Promise<number>} the number of internal subfile images\n     */\n    )\n  }, {\n    key: \"getImageCount\",\n    value: (function () {\n      var _getImageCount2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        var requests;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              if (!(this.imageCount !== null)) {\n                _context12.next = 2;\n                break;\n              }\n              return _context12.abrupt(\"return\", this.imageCount);\n            case 2:\n              requests = [this.mainFile.getImageCount()].concat(this.overviewFiles.map(function (file) {\n                return file.getImageCount();\n              }));\n              _context12.next = 5;\n              return Promise.all(requests);\n            case 5:\n              this.imageCounts = _context12.sent;\n              this.imageCount = this.imageCounts.reduce(function (count, ifds) {\n                return count + ifds;\n              }, 0);\n              return _context12.abrupt(\"return\", this.imageCount);\n            case 8:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, this);\n      }));\n      function getImageCount() {\n        return _getImageCount2.apply(this, arguments);\n      }\n      return getImageCount;\n    }())\n  }]);\n}(GeoTIFFBase);\nexport { MultiGeoTIFF };\n\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport function fromUrl(_x8) {\n  return _fromUrl.apply(this, arguments);\n}\n\n/**\n * Creates a new GeoTIFF from a custom {@link BaseClient}.\n * @param {BaseClient} client The client.\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nfunction _fromUrl() {\n  _fromUrl = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee13(url) {\n    var options,\n      signal,\n      _args13 = arguments;\n    return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n      while (1) switch (_context13.prev = _context13.next) {\n        case 0:\n          options = _args13.length > 1 && _args13[1] !== undefined ? _args13[1] : {};\n          signal = _args13.length > 2 ? _args13[2] : undefined;\n          return _context13.abrupt(\"return\", GeoTIFF.fromSource(makeRemoteSource(url, options), signal));\n        case 3:\n        case \"end\":\n          return _context13.stop();\n      }\n    }, _callee13);\n  }));\n  return _fromUrl.apply(this, arguments);\n}\nexport function fromCustomClient(_x9) {\n  return _fromCustomClient.apply(this, arguments);\n}\n\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nfunction _fromCustomClient() {\n  _fromCustomClient = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee14(client) {\n    var options,\n      signal,\n      _args14 = arguments;\n    return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n      while (1) switch (_context14.prev = _context14.next) {\n        case 0:\n          options = _args14.length > 1 && _args14[1] !== undefined ? _args14[1] : {};\n          signal = _args14.length > 2 ? _args14[2] : undefined;\n          return _context14.abrupt(\"return\", GeoTIFF.fromSource(makeCustomSource(client, options), signal));\n        case 3:\n        case \"end\":\n          return _context14.stop();\n      }\n    }, _callee14);\n  }));\n  return _fromCustomClient.apply(this, arguments);\n}\nexport function fromArrayBuffer(_x10, _x11) {\n  return _fromArrayBuffer.apply(this, arguments);\n}\n\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nfunction _fromArrayBuffer() {\n  _fromArrayBuffer = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee15(arrayBuffer, signal) {\n    return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n      while (1) switch (_context15.prev = _context15.next) {\n        case 0:\n          return _context15.abrupt(\"return\", GeoTIFF.fromSource(makeBufferSource(arrayBuffer), signal));\n        case 1:\n        case \"end\":\n          return _context15.stop();\n      }\n    }, _callee15);\n  }));\n  return _fromArrayBuffer.apply(this, arguments);\n}\nexport function fromFile(_x12, _x13) {\n  return _fromFile.apply(this, arguments);\n}\n\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nfunction _fromFile() {\n  _fromFile = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee16(path, signal) {\n    return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n      while (1) switch (_context16.prev = _context16.next) {\n        case 0:\n          return _context16.abrupt(\"return\", GeoTIFF.fromSource(makeFileSource(path), signal));\n        case 1:\n        case \"end\":\n          return _context16.stop();\n      }\n    }, _callee16);\n  }));\n  return _fromFile.apply(this, arguments);\n}\nexport function fromBlob(_x14, _x15) {\n  return _fromBlob.apply(this, arguments);\n}\n\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {Object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\nfunction _fromBlob() {\n  _fromBlob = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee17(blob, signal) {\n    return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n      while (1) switch (_context17.prev = _context17.next) {\n        case 0:\n          return _context17.abrupt(\"return\", GeoTIFF.fromSource(makeFileReaderSource(blob), signal));\n        case 1:\n        case \"end\":\n          return _context17.stop();\n      }\n    }, _callee17);\n  }));\n  return _fromBlob.apply(this, arguments);\n}\nexport function fromUrls(_x16) {\n  return _fromUrls.apply(this, arguments);\n}\n\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\nfunction _fromUrls() {\n  _fromUrls = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee18(mainUrl) {\n    var overviewUrls,\n      options,\n      signal,\n      mainFile,\n      overviewFiles,\n      _args18 = arguments;\n    return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n      while (1) switch (_context18.prev = _context18.next) {\n        case 0:\n          overviewUrls = _args18.length > 1 && _args18[1] !== undefined ? _args18[1] : [];\n          options = _args18.length > 2 && _args18[2] !== undefined ? _args18[2] : {};\n          signal = _args18.length > 3 ? _args18[3] : undefined;\n          _context18.next = 5;\n          return GeoTIFF.fromSource(makeRemoteSource(mainUrl, options), signal);\n        case 5:\n          mainFile = _context18.sent;\n          _context18.next = 8;\n          return Promise.all(overviewUrls.map(function (url) {\n            return GeoTIFF.fromSource(makeRemoteSource(url, options));\n          }));\n        case 8:\n          overviewFiles = _context18.sent;\n          return _context18.abrupt(\"return\", new MultiGeoTIFF(mainFile, overviewFiles));\n        case 10:\n        case \"end\":\n          return _context18.stop();\n      }\n    }, _callee18);\n  }));\n  return _fromUrls.apply(this, arguments);\n}\nexport function writeArrayBuffer(values, metadata) {\n  return writeGeotiff(values, metadata);\n}\nexport { Pool };\nexport { GeoTIFFImage };\nexport { BaseClient, BaseResponse };","map":{"version":3,"names":["GeoTIFFImage","DataView64","DataSlice","Pool","makeRemoteSource","makeCustomSource","makeBufferSource","makeFileReaderSource","makeFileSource","BaseClient","BaseResponse","fieldTypes","fieldTagNames","arrayFields","geoKeyNames","writeGeotiff","globals","rgb","getDecoder","addDecoder","setLogger","default","BaseDecoder","getFieldTypeLength","fieldType","BYTE","ASCII","SBYTE","UNDEFINED","SHORT","SSHORT","LONG","SLONG","FLOAT","IFD","RATIONAL","SRATIONAL","DOUBLE","LONG8","SLONG8","IFD8","RangeError","concat","parseGeoKeyDirectory","fileDirectory","rawGeoKeyDirectory","GeoKeyDirectory","geoKeyDirectory","i","key","location","count","offset","value","Error","substring","subarray","getValues","dataSlice","values","readMethod","fieldTypeLength","Uint8Array","readUint8","Int8Array","readInt8","Uint16Array","readUint16","Int16Array","readInt16","Uint32Array","readUint32","Int32Array","readInt32","Array","readUint64","readInt64","Float32Array","readFloat32","Float64Array","readFloat64","call","TextDecoder","decode","ImageFileDirectory","_createClass","nextIFDByteOffset","_classCallCheck","GeoTIFFImageIndexError","_Error","index","_this","_callSuper","_inherits","_wrapNativeSuper","GeoTIFFBase","_readRasters","_asyncToGenerator","_regeneratorRuntime","mark","_callee","options","imageWindow","width","height","resX","resY","bbox","firstImage","usedImage","imageCount","imgBBox","_firstImage$getOrigin","_firstImage$getOrigin2","oX","oY","_firstImage$getResolu","_firstImage$getResolu2","rX","rY","usedBBox","allImages","image","_image$fileDirectory","subfileType","newSubfileType","_i2","_image","imgResX","imgResY","wnd","_firstImage$getOrigin3","_firstImage$getOrigin4","_oX","_oY","_usedImage$getResolut","_usedImage$getResolut2","imageResX","imageResY","_args","arguments","wrap","_callee$","_context","prev","next","length","undefined","window","getImage","sent","getImageCount","getBoundingBox","getOrigin","_slicedToArray","getResolution","SubfileType","NewSubfileType","push","sort","a","b","getWidth","getHeight","abrupt","Math","round","min","max","readRasters","_objectSpread","stop","apply","GeoTIFF","_GeoTIFFBase","source","littleEndian","bigTiff","firstIFDOffset","_this2","cache","ifdRequests","ghostValues","_getSlice","_callee2","size","fallbackSize","_callee2$","_context2","t0","fetch","t1","t2","t3","t4","getSlice","_x","_x2","_parseFileDirectoryAt","_callee3","entrySize","offsetSize","numDirEntries","byteSize","entryCount","fieldTag","typeCount","fieldValues","valueOffset","actualOffset","fieldDataSlice","_callee3$","_context3","covers","readOffset","indexOf","parseFileDirectoryAt","_x3","_requestIFD","_callee5","_this3","_callee5$","_context5","requestIFD","_callee4","previousIfd","_callee4$","_context4","_x4","_getImage","_callee6","ifd","_args6","_callee6$","_context6","dataView","_getImageCount","_callee7","hasNext","_callee7$","_context7","_getGhostValues","_callee8","_this4","detectionString","heuristicAreaSize","slice","valuesString","firstLine","metadataSize","fullString","_callee8$","_context8","split","Number","filter","line","map","forEach","_ref2","_ref3","getGhostValues","close","_fromSource","_callee9","signal","headerData","BOM","magicNumber","offsetByteSize","_callee9$","_context9","getUint16","TypeError","getUint64","getUint32","fromSource","_x5","_x6","_x7","MultiGeoTIFF","_GeoTIFFBase2","mainFile","overviewFiles","_this5","imageFiles","fileDirectoriesPerFile","fileDirectoriesPerFileParsing","_parseFileDirectoriesPerFile","_callee10","requests","_callee10$","_context10","file","Promise","all","parseFileDirectoriesPerFile","_getImage2","_callee11","visited","relativeIndex","imageFile","ii","_args11","_callee11$","_context11","imageCounts","_getImageCount2","_callee12","_callee12$","_context12","reduce","ifds","fromUrl","_x8","_fromUrl","_callee13","url","_args13","_callee13$","_context13","fromCustomClient","_x9","_fromCustomClient","_callee14","client","_args14","_callee14$","_context14","fromArrayBuffer","_x10","_x11","_fromArrayBuffer","_callee15","arrayBuffer","_callee15$","_context15","fromFile","_x12","_x13","_fromFile","_callee16","path","_callee16$","_context16","fromBlob","_x14","_x15","_fromBlob","_callee17","blob","_callee17$","_context17","fromUrls","_x16","_fromUrls","_callee18","mainUrl","overviewUrls","_args18","_callee18$","_context18","writeArrayBuffer","metadata"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/geotiff/dist-module/geotiff.js"],"sourcesContent":["/** @module geotiff */\nimport GeoTIFFImage from './geotiffimage.js';\nimport DataView64 from './dataview64.js';\nimport DataSlice from './dataslice.js';\nimport Pool from './pool.js';\n\nimport { makeRemoteSource, makeCustomSource } from './source/remote.js';\nimport { makeBufferSource } from './source/arraybuffer.js';\nimport { makeFileReaderSource } from './source/filereader.js';\nimport { makeFileSource } from './source/file.js';\nimport { BaseClient, BaseResponse } from './source/client/base.js';\n\nimport { fieldTypes, fieldTagNames, arrayFields, geoKeyNames } from './globals.js';\nimport { writeGeotiff } from './geotiffwriter.js';\nimport * as globals from './globals.js';\nimport * as rgb from './rgb.js';\nimport { getDecoder, addDecoder } from './compression/index.js';\nimport { setLogger } from './logging.js';\n\nexport { globals };\nexport { rgb };\nexport { default as BaseDecoder } from './compression/basedecoder.js';\nexport { getDecoder, addDecoder };\nexport { setLogger };\n\n/**\n * @typedef {Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array}\n * TypedArray\n */\n\n/**\n * @typedef {{ height:number, width: number }} Dimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray & { height: number; width: number}`\n * @typedef {TypedArray & Dimensions} TypedArrayWithDimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray[] & { height: number; width: number}`\n * @typedef {TypedArray[] & Dimensions} TypedArrayArrayWithDimensions\n */\n\n/**\n *  The autogenerated docs are a little confusing here. The effective type is:\n *\n * `(TypedArray | TypedArray[]) & { height: number; width: number}`\n * @typedef {TypedArrayWithDimensions | TypedArrayArrayWithDimensions} ReadRasterResult\n */\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.SBYTE: case fieldTypes.UNDEFINED:\n      return 1;\n    case fieldTypes.SHORT: case fieldTypes.SSHORT:\n      return 2;\n    case fieldTypes.LONG: case fieldTypes.SLONG: case fieldTypes.FLOAT: case fieldTypes.IFD:\n      return 4;\n    case fieldTypes.RATIONAL: case fieldTypes.SRATIONAL: case fieldTypes.DOUBLE:\n    case fieldTypes.LONG8: case fieldTypes.SLONG8: case fieldTypes.IFD8:\n      return 8;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n}\n\nfunction parseGeoKeyDirectory(fileDirectory) {\n  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n\n  const geoKeyDirectory = {};\n  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    const key = geoKeyNames[rawGeoKeyDirectory[i]];\n    const location = (rawGeoKeyDirectory[i + 1])\n      ? (fieldTagNames[rawGeoKeyDirectory[i + 1]]) : null;\n    const count = rawGeoKeyDirectory[i + 2];\n    const offset = rawGeoKeyDirectory[i + 3];\n\n    let value = null;\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(`Could not get value of geoKey '${key}'.`);\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n    geoKeyDirectory[key] = value;\n  }\n  return geoKeyDirectory;\n}\n\nfunction getValues(dataSlice, fieldType, count, offset) {\n  let values = null;\n  let readMethod = null;\n  const fieldTypeLength = getFieldTypeLength(fieldType);\n\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.UNDEFINED:\n      values = new Uint8Array(count); readMethod = dataSlice.readUint8;\n      break;\n    case fieldTypes.SBYTE:\n      values = new Int8Array(count); readMethod = dataSlice.readInt8;\n      break;\n    case fieldTypes.SHORT:\n      values = new Uint16Array(count); readMethod = dataSlice.readUint16;\n      break;\n    case fieldTypes.SSHORT:\n      values = new Int16Array(count); readMethod = dataSlice.readInt16;\n      break;\n    case fieldTypes.LONG: case fieldTypes.IFD:\n      values = new Uint32Array(count); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SLONG:\n      values = new Int32Array(count); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.LONG8: case fieldTypes.IFD8:\n      values = new Array(count); readMethod = dataSlice.readUint64;\n      break;\n    case fieldTypes.SLONG8:\n      values = new Array(count); readMethod = dataSlice.readInt64;\n      break;\n    case fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.FLOAT:\n      values = new Float32Array(count); readMethod = dataSlice.readFloat32;\n      break;\n    case fieldTypes.DOUBLE:\n      values = new Float64Array(count); readMethod = dataSlice.readFloat64;\n      break;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n\n  // normal fields\n  if (!(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n    for (let i = 0; i < count; ++i) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n    }\n  } else { // RATIONAL or SRATIONAL\n    for (let i = 0; i < count; i += 2) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n      values[i + 1] = readMethod.call(\n        dataSlice, offset + ((i * fieldTypeLength) + 4),\n      );\n    }\n  }\n\n  if (fieldType === fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n  return values;\n}\n\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\nclass ImageFileDirectory {\n  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeyDirectory = geoKeyDirectory;\n    this.nextIFDByteOffset = nextIFDByteOffset;\n  }\n}\n\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\nclass GeoTIFFImageIndexError extends Error {\n  constructor(index) {\n    super(`No image at index ${index}`);\n    this.index = index;\n  }\n}\n\nclass GeoTIFFBase {\n  /**\n   * (experimental) Reads raster data from the best fitting image. This function uses\n   * the image with the lowest resolution that is still a higher resolution than the\n   * requested resolution.\n   * When specified, the `bbox` option is translated to the `window` option and the\n   * `resX` and `resY` to `width` and `height` respectively.\n   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n   * image is called and the result returned.\n   * @see GeoTIFFImage.readRasters\n   * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded array(s), with `height` and `width`, as a promise\n   */\n  async readRasters(options = {}) {\n    const { window: imageWindow, width, height } = options;\n    let { resX, resY, bbox } = options;\n\n    const firstImage = await this.getImage();\n    let usedImage = firstImage;\n    const imageCount = await this.getImageCount();\n    const imgBBox = firstImage.getBoundingBox();\n\n    if (imageWindow && bbox) {\n      throw new Error('Both \"bbox\" and \"window\" passed.');\n    }\n\n    // if width/height is passed, transform it to resolution\n    if (width || height) {\n      // if we have an image window (pixel coordinates), transform it to a BBox\n      // using the origin/resolution of the first image.\n      if (imageWindow) {\n        const [oX, oY] = firstImage.getOrigin();\n        const [rX, rY] = firstImage.getResolution();\n\n        bbox = [\n          oX + (imageWindow[0] * rX),\n          oY + (imageWindow[1] * rY),\n          oX + (imageWindow[2] * rX),\n          oY + (imageWindow[3] * rY),\n        ];\n      }\n\n      // if we have a bbox (or calculated one)\n\n      const usedBBox = bbox || imgBBox;\n\n      if (width) {\n        if (resX) {\n          throw new Error('Both width and resX passed');\n        }\n        resX = (usedBBox[2] - usedBBox[0]) / width;\n      }\n      if (height) {\n        if (resY) {\n          throw new Error('Both width and resY passed');\n        }\n        resY = (usedBBox[3] - usedBBox[1]) / height;\n      }\n    }\n\n    // if resolution is set or calculated, try to get the image with the worst acceptable resolution\n    if (resX || resY) {\n      const allImages = [];\n      for (let i = 0; i < imageCount; ++i) {\n        const image = await this.getImage(i);\n        const { SubfileType: subfileType, NewSubfileType: newSubfileType } = image.fileDirectory;\n        if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n          allImages.push(image);\n        }\n      }\n\n      allImages.sort((a, b) => a.getWidth() - b.getWidth());\n      for (let i = 0; i < allImages.length; ++i) {\n        const image = allImages[i];\n        const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();\n        const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();\n\n        usedImage = image;\n        if ((resX && resX > imgResX) || (resY && resY > imgResY)) {\n          break;\n        }\n      }\n    }\n\n    let wnd = imageWindow;\n    if (bbox) {\n      const [oX, oY] = firstImage.getOrigin();\n      const [imageResX, imageResY] = usedImage.getResolution(firstImage);\n\n      wnd = [\n        Math.round((bbox[0] - oX) / imageResX),\n        Math.round((bbox[1] - oY) / imageResY),\n        Math.round((bbox[2] - oX) / imageResX),\n        Math.round((bbox[3] - oY) / imageResY),\n      ];\n      wnd = [\n        Math.min(wnd[0], wnd[2]),\n        Math.min(wnd[1], wnd[3]),\n        Math.max(wnd[0], wnd[2]),\n        Math.max(wnd[1], wnd[3]),\n      ];\n    }\n\n    return usedImage.readRasters({ ...options, window: wnd });\n  }\n}\n\n/**\n * @typedef {Object} GeoTIFFOptions\n * @property {boolean} [cache=false] whether or not decoded tiles shall be cached.\n */\n\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\nclass GeoTIFF extends GeoTIFFBase {\n  /**\n   * @constructor\n   * @param {*} source The datasource to read from.\n   * @param {boolean} littleEndian Whether the image uses little endian.\n   * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {GeoTIFFOptions} [options] further options.\n   */\n  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {\n    super();\n    this.source = source;\n    this.littleEndian = littleEndian;\n    this.bigTiff = bigTiff;\n    this.firstIFDOffset = firstIFDOffset;\n    this.cache = options.cache || false;\n    this.ifdRequests = [];\n    this.ghostValues = null;\n  }\n\n  async getSlice(offset, size) {\n    const fallbackSize = this.bigTiff ? 4048 : 1024;\n    return new DataSlice(\n      (await this.source.fetch([{\n        offset,\n        length: typeof size !== 'undefined' ? size : fallbackSize,\n      }]))[0],\n      offset,\n      this.littleEndian,\n      this.bigTiff,\n    );\n  }\n\n  /**\n   * Instructs to parse an image file directory at the given file offset.\n   * As there is no way to ensure that a location is indeed the start of an IFD,\n   * this function must be called with caution (e.g only using the IFD offsets from\n   * the headers or other IFDs).\n   * @param {number} offset the offset to parse the IFD at\n   * @returns {Promise<ImageFileDirectory>} the parsed IFD\n   */\n  async parseFileDirectoryAt(offset) {\n    const entrySize = this.bigTiff ? 20 : 12;\n    const offsetSize = this.bigTiff ? 8 : 2;\n\n    let dataSlice = await this.getSlice(offset);\n    const numDirEntries = this.bigTiff\n      ? dataSlice.readUint64(offset)\n      : dataSlice.readUint16(offset);\n\n    // if the slice does not cover the whole IFD, request a bigger slice, where the\n    // whole IFD fits: num of entries + n x tag length + offset to next IFD\n    const byteSize = (numDirEntries * entrySize) + (this.bigTiff ? 16 : 6);\n    if (!dataSlice.covers(offset, byteSize)) {\n      dataSlice = await this.getSlice(offset, byteSize);\n    }\n\n    const fileDirectory = {};\n\n    // loop over the IFD and create a file directory object\n    let i = offset + (this.bigTiff ? 8 : 2);\n    for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {\n      const fieldTag = dataSlice.readUint16(i);\n      const fieldType = dataSlice.readUint16(i + 2);\n      const typeCount = this.bigTiff\n        ? dataSlice.readUint64(i + 4)\n        : dataSlice.readUint32(i + 4);\n\n      let fieldValues;\n      let value;\n      const fieldTypeLength = getFieldTypeLength(fieldType);\n      const valueOffset = i + (this.bigTiff ? 12 : 8);\n\n      // check whether the value is directly encoded in the tag or refers to a\n      // different external byte range\n      if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {\n        fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n      } else {\n        // resolve the reference to the actual byte range\n        const actualOffset = dataSlice.readOffset(valueOffset);\n        const length = getFieldTypeLength(fieldType) * typeCount;\n\n        // check, whether we actually cover the referenced byte range; if not,\n        // request a new slice of bytes to read from it\n        if (dataSlice.covers(actualOffset, length)) {\n          fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n        } else {\n          const fieldDataSlice = await this.getSlice(actualOffset, length);\n          fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n        }\n      }\n\n      // unpack single values from the array\n      if (typeCount === 1 && arrayFields.indexOf(fieldTag) === -1\n        && !(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n        value = fieldValues[0];\n      } else {\n        value = fieldValues;\n      }\n\n      // write the tags value to the file directly\n      fileDirectory[fieldTagNames[fieldTag]] = value;\n    }\n    const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n    const nextIFDByteOffset = dataSlice.readOffset(\n      offset + offsetSize + (entrySize * numDirEntries),\n    );\n\n    return new ImageFileDirectory(\n      fileDirectory,\n      geoKeyDirectory,\n      nextIFDByteOffset,\n    );\n  }\n\n  async requestIFD(index) {\n    // see if we already have that IFD index requested.\n    if (this.ifdRequests[index]) {\n      // attach to an already requested IFD\n      return this.ifdRequests[index];\n    } else if (index === 0) {\n      // special case for index 0\n      this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n      return this.ifdRequests[index];\n    } else if (!this.ifdRequests[index - 1]) {\n      // if the previous IFD was not yet loaded, load that one first\n      // this is the recursive call.\n      try {\n        this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n      } catch (e) {\n        // if the previous one already was an index error, rethrow\n        // with the current index\n        if (e instanceof GeoTIFFImageIndexError) {\n          throw new GeoTIFFImageIndexError(index);\n        }\n        // rethrow anything else\n        throw e;\n      }\n    }\n    // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n    // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n    this.ifdRequests[index] = (async () => {\n      const previousIfd = await this.ifdRequests[index - 1];\n      if (previousIfd.nextIFDByteOffset === 0) {\n        throw new GeoTIFFImageIndexError(index);\n      }\n      return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);\n    })();\n    return this.ifdRequests[index];\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    const ifd = await this.requestIFD(index);\n    return new GeoTIFFImage(\n      ifd.fileDirectory, ifd.geoKeyDirectory,\n      this.dataView, this.littleEndian, this.cache, this.source,\n    );\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    let index = 0;\n    // loop until we run out of IFDs\n    let hasNext = true;\n    while (hasNext) {\n      try {\n        await this.requestIFD(index);\n        ++index;\n      } catch (e) {\n        if (e instanceof GeoTIFFImageIndexError) {\n          hasNext = false;\n        } else {\n          throw e;\n        }\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Get the values of the COG ghost area as a parsed map.\n   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n   * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found\n   */\n  async getGhostValues() {\n    const offset = this.bigTiff ? 16 : 8;\n    if (this.ghostValues) {\n      return this.ghostValues;\n    }\n    const detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n    const heuristicAreaSize = detectionString.length + 100;\n    let slice = await this.getSlice(offset, heuristicAreaSize);\n    if (detectionString === getValues(slice, fieldTypes.ASCII, detectionString.length, offset)) {\n      const valuesString = getValues(slice, fieldTypes.ASCII, heuristicAreaSize, offset);\n      const firstLine = valuesString.split('\\n')[0];\n      const metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n      if (metadataSize > heuristicAreaSize) {\n        slice = await this.getSlice(offset, metadataSize);\n      }\n      const fullString = getValues(slice, fieldTypes.ASCII, metadataSize, offset);\n      this.ghostValues = {};\n      fullString\n        .split('\\n')\n        .filter((line) => line.length > 0)\n        .map((line) => line.split('='))\n        .forEach(([key, value]) => {\n          this.ghostValues[key] = value;\n        });\n    }\n    return this.ghostValues;\n  }\n\n  /**\n   * Parse a (Geo)TIFF file from the given source.\n   *\n   * @param {*} source The source of data to parse from.\n   * @param {GeoTIFFOptions} [options] Additional options.\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   */\n  static async fromSource(source, options, signal) {\n    const headerData = (await source.fetch([{ offset: 0, length: 1024 }], signal))[0];\n    const dataView = new DataView64(headerData);\n\n    const BOM = dataView.getUint16(0, 0);\n    let littleEndian;\n    if (BOM === 0x4949) {\n      littleEndian = true;\n    } else if (BOM === 0x4D4D) {\n      littleEndian = false;\n    } else {\n      throw new TypeError('Invalid byte order value.');\n    }\n\n    const magicNumber = dataView.getUint16(2, littleEndian);\n    let bigTiff;\n    if (magicNumber === 42) {\n      bigTiff = false;\n    } else if (magicNumber === 43) {\n      bigTiff = true;\n      const offsetByteSize = dataView.getUint16(4, littleEndian);\n      if (offsetByteSize !== 8) {\n        throw new Error('Unsupported offset byte-size.');\n      }\n    } else {\n      throw new TypeError('Invalid magic number.');\n    }\n\n    const firstIFDOffset = bigTiff\n      ? dataView.getUint64(8, littleEndian)\n      : dataView.getUint32(4, littleEndian);\n    return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);\n  }\n\n  /**\n   * Closes the underlying file buffer\n   * N.B. After the GeoTIFF has been completely processed it needs\n   * to be closed but only if it has been constructed from a file.\n   */\n  close() {\n    if (typeof this.source.close === 'function') {\n      return this.source.close();\n    }\n    return false;\n  }\n}\n\nexport { GeoTIFF };\nexport default GeoTIFF;\n\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\nclass MultiGeoTIFF extends GeoTIFFBase {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  constructor(mainFile, overviewFiles) {\n    super();\n    this.mainFile = mainFile;\n    this.overviewFiles = overviewFiles;\n    this.imageFiles = [mainFile].concat(overviewFiles);\n\n    this.fileDirectoriesPerFile = null;\n    this.fileDirectoriesPerFileParsing = null;\n    this.imageCount = null;\n  }\n\n  async parseFileDirectoriesPerFile() {\n    const requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)]\n      .concat(this.overviewFiles.map((file) => file.parseFileDirectoryAt(file.firstIFDOffset)));\n\n    this.fileDirectoriesPerFile = await Promise.all(requests);\n    return this.fileDirectoriesPerFile;\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    await this.getImageCount();\n    await this.parseFileDirectoriesPerFile();\n    let visited = 0;\n    let relativeIndex = 0;\n    for (let i = 0; i < this.imageFiles.length; i++) {\n      const imageFile = this.imageFiles[i];\n      for (let ii = 0; ii < this.imageCounts[i]; ii++) {\n        if (index === visited) {\n          const ifd = await imageFile.requestIFD(relativeIndex);\n          return new GeoTIFFImage(\n            ifd.fileDirectory, ifd.geoKeyDirectory,\n            imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source,\n          );\n        }\n        visited++;\n        relativeIndex++;\n      }\n      relativeIndex = 0;\n    }\n\n    throw new RangeError('Invalid image index');\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    if (this.imageCount !== null) {\n      return this.imageCount;\n    }\n    const requests = [this.mainFile.getImageCount()]\n      .concat(this.overviewFiles.map((file) => file.getImageCount()));\n    this.imageCounts = await Promise.all(requests);\n    this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);\n    return this.imageCount;\n  }\n}\n\nexport { MultiGeoTIFF };\n\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromUrl(url, options = {}, signal) {\n  return GeoTIFF.fromSource(makeRemoteSource(url, options), signal);\n}\n\n/**\n * Creates a new GeoTIFF from a custom {@link BaseClient}.\n * @param {BaseClient} client The client.\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromCustomClient(client, options = {}, signal) {\n  return GeoTIFF.fromSource(makeCustomSource(client, options), signal);\n}\n\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromArrayBuffer(arrayBuffer, signal) {\n  return GeoTIFF.fromSource(makeBufferSource(arrayBuffer), signal);\n}\n\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromFile(path, signal) {\n  return GeoTIFF.fromSource(makeFileSource(path), signal);\n}\n\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromBlob(blob, signal) {\n  return GeoTIFF.fromSource(makeFileReaderSource(blob), signal);\n}\n\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {Object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\nexport async function fromUrls(mainUrl, overviewUrls = [], options = {}, signal) {\n  const mainFile = await GeoTIFF.fromSource(makeRemoteSource(mainUrl, options), signal);\n  const overviewFiles = await Promise.all(\n    overviewUrls.map((url) => GeoTIFF.fromSource(makeRemoteSource(url, options))),\n  );\n\n  return new MultiGeoTIFF(mainFile, overviewFiles);\n}\n\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\nexport function writeArrayBuffer(values, metadata) {\n  return writeGeotiff(values, metadata);\n}\n\nexport { Pool };\nexport { GeoTIFFImage };\nexport { BaseClient, BaseResponse };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}