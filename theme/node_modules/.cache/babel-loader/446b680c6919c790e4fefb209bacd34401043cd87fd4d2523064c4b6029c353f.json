{"ast":null,"code":"import _callSuper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createForOfIteratorHelper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _defineProperty from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classCallCheck from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.array-buffer.constructor.js\";\nimport \"core-js/modules/es.array-buffer.is-view.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.data-view.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.number.is-integer.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.parse-int.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.string.starts-with.js\";\nimport \"core-js/modules/es.string.substr.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/esnext.iterator.reduce.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/**\n * @module ol/format/WKB\n */\nimport Feature from '../Feature.js';\nimport FeatureFormat, { transformGeometryWithOptions } from './Feature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport { get as getProjection } from '../proj.js';\nimport SimpleGeometry from '../geom/SimpleGeometry.js';\n\n// WKB spec: https://www.ogc.org/standards/sfa\n// EWKB spec: https://raw.githubusercontent.com/postgis/postgis/2.1.0/doc/ZMSgeoms.txt\n\n/**\n * @const\n * @enum {number}\n */\nvar WKBGeometryType = {\n  POINT: 1,\n  LINE_STRING: 2,\n  POLYGON: 3,\n  MULTI_POINT: 4,\n  MULTI_LINE_STRING: 5,\n  MULTI_POLYGON: 6,\n  GEOMETRY_COLLECTION: 7,\n  /*\n  CIRCULAR_STRING: 8,\n  COMPOUND_CURVE: 9,\n  CURVE_POLYGON: 10,\n   MULTI_CURVE: 11,\n  MULTI_SURFACE: 12,\n  CURVE: 13,\n  SURFACE: 14,\n  */\n\n  POLYHEDRAL_SURFACE: 15,\n  TIN: 16,\n  TRIANGLE: 17\n};\nvar WkbReader = /*#__PURE__*/function () {\n  /**\n   * @param {DataView} view source to read\n   */\n  function WkbReader(view) {\n    _classCallCheck(this, WkbReader);\n    /** @private */\n    this.view_ = view;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.pos_ = 0;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.initialized_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.isLittleEndian_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasZ_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasM_ = false;\n\n    /**\n     * @type {number|null}\n     * @private\n     */\n    this.srid_ = null;\n\n    /**\n     * @type {import(\"../geom/Geometry.js\").GeometryLayout}\n     * @private\n     */\n    this.layout_ = 'XY';\n  }\n\n  /**\n   * @return {number} value\n   */\n  return _createClass(WkbReader, [{\n    key: \"readUint8\",\n    value: function readUint8() {\n      return this.view_.getUint8(this.pos_++);\n    }\n\n    /**\n     * @param {boolean} [isLittleEndian] Whether read value as little endian\n     * @return {number} value\n     */\n  }, {\n    key: \"readUint32\",\n    value: function readUint32(isLittleEndian) {\n      return this.view_.getUint32((this.pos_ += 4) - 4, isLittleEndian !== undefined ? isLittleEndian : this.isLittleEndian_);\n    }\n\n    /**\n     * @param {boolean} [isLittleEndian] Whether read value as little endian\n     * @return {number} value\n     */\n  }, {\n    key: \"readDouble\",\n    value: function readDouble(isLittleEndian) {\n      return this.view_.getFloat64((this.pos_ += 8) - 8, isLittleEndian !== undefined ? isLittleEndian : this.isLittleEndian_);\n    }\n\n    /**\n     * @return {import('../coordinate.js').Coordinate} coords for Point\n     */\n  }, {\n    key: \"readPoint\",\n    value: function readPoint() {\n      /** @type import('../coordinate.js').Coordinate */\n      var coords = [];\n      coords.push(this.readDouble());\n      coords.push(this.readDouble());\n      if (this.hasZ_) {\n        coords.push(this.readDouble());\n      }\n      if (this.hasM_) {\n        coords.push(this.readDouble());\n      }\n      return coords;\n    }\n\n    /**\n     * @return {Array<import('../coordinate.js').Coordinate>} coords for LineString / LinearRing\n     */\n  }, {\n    key: \"readLineString\",\n    value: function readLineString() {\n      var numPoints = this.readUint32();\n\n      /** @type Array<import('../coordinate.js').Coordinate> */\n      var coords = [];\n      for (var i = 0; i < numPoints; i++) {\n        coords.push(this.readPoint());\n      }\n      return coords;\n    }\n\n    /**\n     * @return {Array<Array<import('../coordinate.js').Coordinate>>} coords for Polygon like\n     */\n  }, {\n    key: \"readPolygon\",\n    value: function readPolygon() {\n      var numRings = this.readUint32();\n\n      /** @type Array<Array<import('../coordinate.js').Coordinate>> */\n      var rings = [];\n      for (var i = 0; i < numRings; i++) {\n        rings.push(this.readLineString()); // as a LinearRing\n      }\n      return rings;\n    }\n\n    /**\n     * @param {number} [expectedTypeId] Expected WKB Type ID\n     * @return {number} WKB Type ID\n     */\n  }, {\n    key: \"readWkbHeader\",\n    value: function readWkbHeader(expectedTypeId) {\n      var byteOrder = this.readUint8();\n      var isLittleEndian = byteOrder > 0;\n      var wkbType = this.readUint32(isLittleEndian);\n      var wkbTypeThousandth = Math.floor((wkbType & 0x0fffffff) / 1000);\n      var hasZ = Boolean(wkbType & 0x80000000) || wkbTypeThousandth === 1 || wkbTypeThousandth === 3;\n      var hasM = Boolean(wkbType & 0x40000000) || wkbTypeThousandth === 2 || wkbTypeThousandth === 3;\n      var hasSRID = Boolean(wkbType & 0x20000000);\n      var typeId = (wkbType & 0x0fffffff) % 1000; // Assume 1000 is an upper limit for type ID\n      var layout = /** @type {import(\"../geom/Geometry.js\").GeometryLayout} */\n      ['XY', hasZ ? 'Z' : '', hasM ? 'M' : ''].join('');\n      var srid = hasSRID ? this.readUint32(isLittleEndian) : null;\n      if (expectedTypeId !== undefined && expectedTypeId !== typeId) {\n        throw new Error('Unexpected WKB geometry type ' + typeId);\n      }\n      if (this.initialized_) {\n        // sanity checks\n        if (this.isLittleEndian_ !== isLittleEndian) {\n          throw new Error('Inconsistent endian');\n        }\n        if (this.layout_ !== layout) {\n          throw new Error('Inconsistent geometry layout');\n        }\n        if (srid && this.srid_ !== srid) {\n          throw new Error('Inconsistent coordinate system (SRID)');\n        }\n      } else {\n        this.isLittleEndian_ = isLittleEndian;\n        this.hasZ_ = hasZ;\n        this.hasM_ = hasM;\n        this.layout_ = layout;\n        this.srid_ = srid;\n        this.initialized_ = true;\n      }\n      return typeId;\n    }\n\n    /**\n     * @param {number} typeId WKB Type ID\n     * @return {any} values read\n     */\n  }, {\n    key: \"readWkbPayload\",\n    value: function readWkbPayload(typeId) {\n      switch (typeId) {\n        case WKBGeometryType.POINT:\n          return this.readPoint();\n        case WKBGeometryType.LINE_STRING:\n          return this.readLineString();\n        case WKBGeometryType.POLYGON:\n        case WKBGeometryType.TRIANGLE:\n          return this.readPolygon();\n        case WKBGeometryType.MULTI_POINT:\n          return this.readMultiPoint();\n        case WKBGeometryType.MULTI_LINE_STRING:\n          return this.readMultiLineString();\n        case WKBGeometryType.MULTI_POLYGON:\n        case WKBGeometryType.POLYHEDRAL_SURFACE:\n        case WKBGeometryType.TIN:\n          return this.readMultiPolygon();\n        case WKBGeometryType.GEOMETRY_COLLECTION:\n          return this.readGeometryCollection();\n        default:\n          throw new Error('Unsupported WKB geometry type ' + typeId + ' is found');\n      }\n    }\n\n    /**\n     * @param {number} expectedTypeId Expected WKB Type ID\n     * @return {any} values read\n     */\n  }, {\n    key: \"readWkbBlock\",\n    value: function readWkbBlock(expectedTypeId) {\n      return this.readWkbPayload(this.readWkbHeader(expectedTypeId));\n    }\n\n    /**\n     * @param {Function} reader reader function for each item\n     * @param {number} [expectedTypeId] Expected WKB Type ID\n     * @return {any} values read\n     */\n  }, {\n    key: \"readWkbCollection\",\n    value: function readWkbCollection(reader, expectedTypeId) {\n      var num = this.readUint32();\n      var items = [];\n      for (var i = 0; i < num; i++) {\n        var result = reader.call(this, expectedTypeId);\n        if (result) {\n          items.push(result);\n        }\n      }\n      return items;\n    }\n\n    /**\n     * @return {Array<import('../coordinate.js').Coordinate>} coords for MultiPoint\n     */\n  }, {\n    key: \"readMultiPoint\",\n    value: function readMultiPoint() {\n      return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POINT);\n    }\n\n    /**\n     * @return {Array<Array<import('../coordinate.js').Coordinate>>} coords for MultiLineString like\n     */\n  }, {\n    key: \"readMultiLineString\",\n    value: function readMultiLineString() {\n      return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.LINE_STRING);\n    }\n\n    /**\n     * @return {Array<Array<Array<import('../coordinate.js').Coordinate>>>} coords for MultiPolygon like\n     */\n  }, {\n    key: \"readMultiPolygon\",\n    value: function readMultiPolygon() {\n      return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POLYGON);\n    }\n\n    /**\n     * @return {Array<import('../geom/Geometry.js').default>} array of geometries\n     */\n  }, {\n    key: \"readGeometryCollection\",\n    value: function readGeometryCollection() {\n      return this.readWkbCollection(this.readGeometry);\n    }\n\n    /**\n     * @return {import('../geom/Geometry.js').default} geometry\n     */\n  }, {\n    key: \"readGeometry\",\n    value: function readGeometry() {\n      var typeId = this.readWkbHeader();\n      var result = this.readWkbPayload(typeId);\n      switch (typeId) {\n        case WKBGeometryType.POINT:\n          return new Point(/** @type {import('../coordinate.js').Coordinate} */result, this.layout_);\n        case WKBGeometryType.LINE_STRING:\n          return new LineString(/** @type {Array<import('../coordinate.js').Coordinate>} */result, this.layout_);\n        case WKBGeometryType.POLYGON:\n        case WKBGeometryType.TRIANGLE:\n          return new Polygon(/** @type {Array<Array<import('../coordinate.js').Coordinate>>} */\n          result, this.layout_);\n        case WKBGeometryType.MULTI_POINT:\n          return new MultiPoint(/** @type {Array<import('../coordinate.js').Coordinate>} */result, this.layout_);\n        case WKBGeometryType.MULTI_LINE_STRING:\n          return new MultiLineString(/** @type {Array<Array<import('../coordinate.js').Coordinate>>} */\n          result, this.layout_);\n        case WKBGeometryType.MULTI_POLYGON:\n        case WKBGeometryType.POLYHEDRAL_SURFACE:\n        case WKBGeometryType.TIN:\n          return new MultiPolygon(/** @type {Array<Array<Array<import('../coordinate.js').Coordinate>>>} */\n          result, this.layout_);\n        case WKBGeometryType.GEOMETRY_COLLECTION:\n          return new GeometryCollection(/** @type {Array<import('../geom/Geometry.js').default>} */result);\n        default:\n          return null;\n      }\n    }\n\n    /**\n     * @return {number|null} SRID in the EWKB. `null` if not defined.\n     */\n  }, {\n    key: \"getSrid\",\n    value: function getSrid() {\n      return this.srid_;\n    }\n  }]);\n}();\nvar WkbWriter = /*#__PURE__*/function () {\n  /**\n   * @type {Object}\n   * @property {string} [layout] geometryLayout\n   * @property {boolean} [littleEndian=true] littleEndian\n   * @property {boolean} [ewkb=true] Whether writes in EWKB format\n   * @property {Object} [nodata] NoData value for each axes\n   * @param {Object} opts options\n   */\n  function WkbWriter(opts) {\n    _classCallCheck(this, WkbWriter);\n    opts = opts || {};\n\n    /** @type {string} */\n    this.layout_ = opts.layout;\n    this.isLittleEndian_ = opts.littleEndian !== false;\n    this.isEWKB_ = opts.ewkb !== false;\n\n    /** @type {Array<Array<number>>} */\n    this.writeQueue_ = [];\n\n    /**\n     * @type {Object}\n     * @property {number} X NoData value for X\n     * @property {number} Y NoData value for Y\n     * @property {number} Z NoData value for Z\n     * @property {number} M NoData value for M\n     */\n    this.nodata_ = Object.assign({\n      X: 0,\n      Y: 0,\n      Z: 0,\n      M: 0\n    }, opts.nodata);\n  }\n\n  /**\n   * @param {number} value value\n   */\n  return _createClass(WkbWriter, [{\n    key: \"writeUint8\",\n    value: function writeUint8(value) {\n      this.writeQueue_.push([1, value]);\n    }\n\n    /**\n     * @param {number} value value\n     */\n  }, {\n    key: \"writeUint32\",\n    value: function writeUint32(value) {\n      this.writeQueue_.push([4, value]);\n    }\n\n    /**\n     * @param {number} value value\n     */\n  }, {\n    key: \"writeDouble\",\n    value: function writeDouble(value) {\n      this.writeQueue_.push([8, value]);\n    }\n\n    /**\n     * @param {import('../coordinate.js').Coordinate} coords coords\n     * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n     */\n  }, {\n    key: \"writePoint\",\n    value: function writePoint(coords, layout) {\n      /**\n       * @type {Object}\n       * @property {number} X NoData value for X\n       * @property {number} Y NoData value for Y\n       * @property {number} [Z] NoData value for Z\n       * @property {number} [M] NoData value for M\n       */\n      var coordsObj = Object.assign.apply(null, layout.split('').map(function (axis, idx) {\n        return _defineProperty({}, axis, coords[idx]);\n      }));\n      var _iterator = _createForOfIteratorHelper(this.layout_),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var axis = _step.value;\n          this.writeDouble(axis in coordsObj ? coordsObj[axis] : this.nodata_[axis]);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    /**\n     * @param {Array<import('../coordinate.js').Coordinate>} coords coords\n     * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n     */\n  }, {\n    key: \"writeLineString\",\n    value: function writeLineString(coords, layout) {\n      this.writeUint32(coords.length); // numPoints\n      for (var i = 0; i < coords.length; i++) {\n        this.writePoint(coords[i], layout);\n      }\n    }\n\n    /**\n     * @param {Array<Array<import('../coordinate.js').Coordinate>>} rings rings\n     * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n     */\n  }, {\n    key: \"writePolygon\",\n    value: function writePolygon(rings, layout) {\n      this.writeUint32(rings.length); // numRings\n      for (var i = 0; i < rings.length; i++) {\n        this.writeLineString(rings[i], layout); // as a LinearRing\n      }\n    }\n\n    /**\n     * @param {number} wkbType WKB Type ID\n     * @param {number} [srid] SRID\n     */\n  }, {\n    key: \"writeWkbHeader\",\n    value: function writeWkbHeader(wkbType, srid) {\n      wkbType %= 1000; // Assume 1000 is an upper limit for type ID\n      if (this.layout_.includes('Z')) {\n        wkbType += this.isEWKB_ ? 0x80000000 : 1000;\n      }\n      if (this.layout_.includes('M')) {\n        wkbType += this.isEWKB_ ? 0x40000000 : 2000;\n      }\n      if (this.isEWKB_ && Number.isInteger(srid)) {\n        wkbType |= 0x20000000;\n      }\n      this.writeUint8(this.isLittleEndian_ ? 1 : 0);\n      this.writeUint32(wkbType);\n      if (this.isEWKB_ && Number.isInteger(srid)) {\n        this.writeUint32(srid);\n      }\n    }\n\n    /**\n     * @param {Array<import('../coordinate.js').Coordinate>} coords coords\n     * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n     */\n  }, {\n    key: \"writeMultiPoint\",\n    value: function writeMultiPoint(coords, layout) {\n      this.writeUint32(coords.length); // numItems\n      for (var i = 0; i < coords.length; i++) {\n        this.writeWkbHeader(1);\n        this.writePoint(coords[i], layout);\n      }\n    }\n\n    /**\n     * @param {Array<Array<import('../coordinate.js').Coordinate>>} coords coords\n     * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n     */\n  }, {\n    key: \"writeMultiLineString\",\n    value: function writeMultiLineString(coords, layout) {\n      this.writeUint32(coords.length); // numItems\n      for (var i = 0; i < coords.length; i++) {\n        this.writeWkbHeader(2);\n        this.writeLineString(coords[i], layout);\n      }\n    }\n\n    /**\n     * @param {Array<Array<Array<import('../coordinate.js').Coordinate>>>} coords coords\n     * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n     */\n  }, {\n    key: \"writeMultiPolygon\",\n    value: function writeMultiPolygon(coords, layout) {\n      this.writeUint32(coords.length); // numItems\n      for (var i = 0; i < coords.length; i++) {\n        this.writeWkbHeader(3);\n        this.writePolygon(coords[i], layout);\n      }\n    }\n\n    /**\n     * @param {Array<import('../geom/Geometry.js').default>} geometries geometries\n     */\n  }, {\n    key: \"writeGeometryCollection\",\n    value: function writeGeometryCollection(geometries) {\n      this.writeUint32(geometries.length); // numItems\n\n      for (var i = 0; i < geometries.length; i++) {\n        this.writeGeometry(geometries[i]);\n      }\n    }\n\n    /**\n     * @param {import(\"../geom/Geometry.js\").default} geom geometry\n     * @param {import(\"../geom/Geometry.js\").GeometryLayout} [layout] layout\n     * @return {import(\"../geom/Geometry.js\").GeometryLayout} minimum layout made by common axes\n     */\n  }, {\n    key: \"findMinimumLayout\",\n    value: function findMinimumLayout(geom) {\n      var layout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'XYZM';\n      /**\n       * @param {import(\"../geom/Geometry.js\").GeometryLayout} a A\n       * @param {import(\"../geom/Geometry.js\").GeometryLayout} b B\n       * @return {import(\"../geom/Geometry.js\").GeometryLayout} minimum layout made by common axes\n       */\n      var GeometryLayout_min = function GeometryLayout_min(a, b) {\n        if (a === b) {\n          return a;\n        }\n        if (a === 'XYZM') {\n          // anything `b` is minimum\n          return b;\n        }\n        if (b === 'XYZM') {\n          // anything `a` is minimum\n          return a;\n        }\n\n        // otherwise, incompatible\n        return 'XY';\n      };\n      if (geom instanceof SimpleGeometry) {\n        return GeometryLayout_min(geom.getLayout(), layout);\n      }\n      if (geom instanceof GeometryCollection) {\n        var geoms = geom.getGeometriesArray();\n        for (var i = 0; i < geoms.length && layout !== 'XY'; i++) {\n          layout = this.findMinimumLayout(geoms[i], layout);\n        }\n      }\n      return layout;\n    }\n\n    /**\n     * @param {import(\"../geom/Geometry.js\").default} geom geometry\n     * @param {number} [srid] SRID\n     */\n  }, {\n    key: \"writeGeometry\",\n    value: function writeGeometry(geom, srid) {\n      /**\n       * @type {Object<import(\"../geom/Geometry.js\").Type, WKBGeometryType>}\n       */\n      var wkblut = {\n        Point: WKBGeometryType.POINT,\n        LineString: WKBGeometryType.LINE_STRING,\n        Polygon: WKBGeometryType.POLYGON,\n        MultiPoint: WKBGeometryType.MULTI_POINT,\n        MultiLineString: WKBGeometryType.MULTI_LINE_STRING,\n        MultiPolygon: WKBGeometryType.MULTI_POLYGON,\n        GeometryCollection: WKBGeometryType.GEOMETRY_COLLECTION\n      };\n      var geomType = geom.getType();\n      var typeId = wkblut[geomType];\n      if (!typeId) {\n        throw new Error('GeometryType ' + geomType + ' is not supported');\n      }\n\n      // first call of writeGeometry() traverse whole geometries to determine its output layout if not specified on constructor.\n      if (!this.layout_) {\n        this.layout_ = this.findMinimumLayout(geom);\n      }\n      this.writeWkbHeader(typeId, srid);\n      if (geom instanceof SimpleGeometry) {\n        var writerLUT = {\n          Point: this.writePoint,\n          LineString: this.writeLineString,\n          Polygon: this.writePolygon,\n          MultiPoint: this.writeMultiPoint,\n          MultiLineString: this.writeMultiLineString,\n          MultiPolygon: this.writeMultiPolygon\n        };\n        writerLUT[geomType].call(this, geom.getCoordinates(), geom.getLayout());\n      } else if (geom instanceof GeometryCollection) {\n        this.writeGeometryCollection(geom.getGeometriesArray());\n      }\n    }\n  }, {\n    key: \"getBuffer\",\n    value: function getBuffer() {\n      var _this = this;\n      var byteLength = this.writeQueue_.reduce(function (acc, item) {\n        return acc + item[0];\n      }, 0);\n      var buffer = new ArrayBuffer(byteLength);\n      var view = new DataView(buffer);\n      var pos = 0;\n      this.writeQueue_.forEach(function (item) {\n        switch (item[0]) {\n          case 1:\n            view.setUint8(pos, item[1]);\n            break;\n          case 4:\n            view.setUint32(pos, item[1], _this.isLittleEndian_);\n            break;\n          case 8:\n            view.setFloat64(pos, item[1], _this.isLittleEndian_);\n            break;\n          default:\n            break;\n        }\n        pos += item[0];\n      });\n      return buffer;\n    }\n  }]);\n}();\n/**\n * @typedef {Object} Options\n * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into multiple features on reading.\n * @property {boolean} [hex=true] Returns hex string instead of ArrayBuffer for output. This also is used as a hint internally whether it should load contents as text or ArrayBuffer on reading.\n * @property {boolean} [littleEndian=true] Use littleEndian for output.\n * @property {boolean} [ewkb=true] Use EWKB format for output.\n * @property {import(\"../geom/Geometry.js\").GeometryLayout} [geometryLayout=null] Use specific coordinate layout for output features (null: auto detect)\n * @property {number} [nodataZ=0] If the `geometryLayout` doesn't match with geometry to be output, this value is used to fill missing coordinate value of Z.\n * @property {number} [nodataM=0] If the `geometryLayout` doesn't match with geometry to be output, this value is used to fill missing coordinate value of M.\n * @property {number|boolean} [srid=true] SRID for output. Specify integer value to enforce the value as a SRID. Specify `true` to extract from `dataProjection`. `false` to suppress the output. This option only takes effect when `ewkb` is `true`.\n */\n/**\n * @classdesc\n * Geometry format for reading and writing data in the `Well-Known Binary` (WKB) format.\n * Also supports `Extended Well-Known Binary` (EWKB) format, used in PostGIS for example.\n *\n * @api\n */\nvar WKB = /*#__PURE__*/function (_FeatureFormat) {\n  /**\n   * @param {Options} [options] Optional configuration object.\n   */\n  function WKB(options) {\n    var _this2;\n    _classCallCheck(this, WKB);\n    _this2 = _callSuper(this, WKB);\n    options = options ? options : {};\n    _this2.splitCollection = Boolean(options.splitCollection);\n    _this2.viewCache_ = null;\n    _this2.hex_ = options.hex !== false;\n    _this2.littleEndian_ = options.littleEndian !== false;\n    _this2.ewkb_ = options.ewkb !== false;\n    _this2.layout_ = options.geometryLayout; // null for auto detect\n    _this2.nodataZ_ = options.nodataZ || 0;\n    _this2.nodataM_ = options.nodataM || 0;\n    _this2.srid_ = options.srid;\n    return _this2;\n  }\n\n  /**\n   * @return {import(\"./Feature.js\").Type} Format.\n   */\n  _inherits(WKB, _FeatureFormat);\n  return _createClass(WKB, [{\n    key: \"getType\",\n    value: function getType() {\n      return this.hex_ ? 'text' : 'arraybuffer';\n    }\n\n    /**\n     * Read a single feature from a source.\n     *\n     * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n     * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n     * @return {import(\"../Feature.js\").default} Feature.\n     * @api\n     */\n  }, {\n    key: \"readFeature\",\n    value: function readFeature(source, options) {\n      return new Feature({\n        geometry: this.readGeometry(source, options)\n      });\n    }\n\n    /**\n     * Read all features from a source.\n     *\n     * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n     * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n     * @return {Array<import(\"../Feature.js\").default>} Features.\n     * @api\n     */\n  }, {\n    key: \"readFeatures\",\n    value: function readFeatures(source, options) {\n      var geometries = [];\n      var geometry = this.readGeometry(source, options);\n      if (this.splitCollection && geometry instanceof GeometryCollection) {\n        geometries = geometry.getGeometriesArray();\n      } else {\n        geometries = [geometry];\n      }\n      return geometries.map(function (geometry) {\n        return new Feature({\n          geometry: geometry\n        });\n      });\n    }\n\n    /**\n     * Read a single geometry from a source.\n     *\n     * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n     * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n     * @return {import(\"../geom/Geometry.js\").default} Geometry.\n     * @api\n     */\n  }, {\n    key: \"readGeometry\",\n    value: function readGeometry(source, options) {\n      var view = getDataView(source);\n      if (!view) {\n        return null;\n      }\n      var reader = new WkbReader(view);\n      var geometry = reader.readGeometry();\n      this.viewCache_ = view; // cache for internal subsequent call of readProjection()\n      options = this.getReadOptions(source, options);\n      this.viewCache_ = null; // release\n\n      return transformGeometryWithOptions(geometry, false, options);\n    }\n\n    /**\n     * Read the projection from a source.\n     *\n     * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n     * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\n     * @api\n     */\n  }, {\n    key: \"readProjection\",\n    value: function readProjection(source) {\n      var view = this.viewCache_ || getDataView(source);\n      if (!view) {\n        return undefined;\n      }\n      var reader = new WkbReader(view);\n      reader.readWkbHeader();\n      return reader.getSrid() && getProjection('EPSG:' + reader.getSrid()) || undefined;\n    }\n\n    /**\n     * Encode a feature in this format.\n     *\n     * @param {import(\"../Feature.js\").default} feature Feature.\n     * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n     * @return {string|ArrayBuffer} Result.\n     * @api\n     */\n  }, {\n    key: \"writeFeature\",\n    value: function writeFeature(feature, options) {\n      return this.writeGeometry(feature.getGeometry(), options);\n    }\n\n    /**\n     * Encode an array of features in this format.\n     *\n     * @param {Array<import(\"../Feature.js\").default>} features Features.\n     * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n     * @return {string|ArrayBuffer} Result.\n     * @api\n     */\n  }, {\n    key: \"writeFeatures\",\n    value: function writeFeatures(features, options) {\n      return this.writeGeometry(new GeometryCollection(features.map(function (f) {\n        return f.getGeometry();\n      })), options);\n    }\n\n    /**\n     * Write a single geometry in this format.\n     *\n     * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n     * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n     * @return {string|ArrayBuffer} Result.\n     * @api\n     */\n  }, {\n    key: \"writeGeometry\",\n    value: function writeGeometry(geometry, options) {\n      options = this.adaptOptions(options);\n      var writer = new WkbWriter({\n        layout: this.layout_,\n        littleEndian: this.littleEndian_,\n        ewkb: this.ewkb_,\n        nodata: {\n          Z: this.nodataZ_,\n          M: this.nodataM_\n        }\n      });\n\n      // extract SRID from `dataProjection`\n      var srid = Number.isInteger(this.srid_) ? Number(this.srid_) : null;\n      if (this.srid_ !== false && !Number.isInteger(this.srid_)) {\n        var dataProjection = options.dataProjection && getProjection(options.dataProjection);\n        if (dataProjection) {\n          var code = dataProjection.getCode();\n          if (code.startsWith('EPSG:')) {\n            srid = Number(code.substring(5));\n          }\n        }\n      }\n      writer.writeGeometry(transformGeometryWithOptions(geometry, true, options), srid);\n      var buffer = writer.getBuffer();\n      return this.hex_ ? encodeHexString(buffer) : buffer;\n    }\n  }]);\n}(FeatureFormat);\n/**\n * @param {ArrayBuffer} buffer source buffer\n * @return {string} encoded hex string\n */\nfunction encodeHexString(buffer) {\n  var view = new Uint8Array(buffer);\n  return Array.from(view.values()).map(function (x) {\n    return (x < 16 ? '0' : '') + Number(x).toString(16).toUpperCase();\n  }).join('');\n}\n\n/**\n * @param {string} text source text\n * @return {DataView} decoded binary buffer\n */\nfunction decodeHexString(text) {\n  var buffer = new Uint8Array(text.length / 2);\n  for (var i = 0; i < text.length / 2; i++) {\n    buffer[i] = parseInt(text.substr(i * 2, 2), 16);\n  }\n  return new DataView(buffer.buffer);\n}\n\n/**\n * @param {string | ArrayBuffer | ArrayBufferView} source source\n * @return {DataView} data view\n */\nfunction getDataView(source) {\n  if (typeof source === 'string') {\n    return decodeHexString(source);\n  }\n  if (ArrayBuffer.isView(source)) {\n    if (source instanceof DataView) {\n      return source;\n    }\n    return new DataView(source.buffer, source.byteOffset, source.byteLength);\n  }\n  if (source instanceof ArrayBuffer) {\n    return new DataView(source);\n  }\n  return null;\n}\nexport default WKB;","map":{"version":3,"names":["Feature","FeatureFormat","transformGeometryWithOptions","GeometryCollection","LineString","MultiLineString","MultiPoint","MultiPolygon","Point","Polygon","get","getProjection","SimpleGeometry","WKBGeometryType","POINT","LINE_STRING","POLYGON","MULTI_POINT","MULTI_LINE_STRING","MULTI_POLYGON","GEOMETRY_COLLECTION","POLYHEDRAL_SURFACE","TIN","TRIANGLE","WkbReader","view","_classCallCheck","view_","pos_","initialized_","isLittleEndian_","hasZ_","hasM_","srid_","layout_","_createClass","key","value","readUint8","getUint8","readUint32","isLittleEndian","getUint32","undefined","readDouble","getFloat64","readPoint","coords","push","readLineString","numPoints","i","readPolygon","numRings","rings","readWkbHeader","expectedTypeId","byteOrder","wkbType","wkbTypeThousandth","Math","floor","hasZ","Boolean","hasM","hasSRID","typeId","layout","join","srid","Error","readWkbPayload","readMultiPoint","readMultiLineString","readMultiPolygon","readGeometryCollection","readWkbBlock","readWkbCollection","reader","num","items","result","call","readGeometry","getSrid","WkbWriter","opts","littleEndian","isEWKB_","ewkb","writeQueue_","nodata_","Object","assign","X","Y","Z","M","nodata","writeUint8","writeUint32","writeDouble","writePoint","coordsObj","apply","split","map","axis","idx","_defineProperty","_iterator","_createForOfIteratorHelper","_step","s","n","done","err","e","f","writeLineString","length","writePolygon","writeWkbHeader","includes","Number","isInteger","writeMultiPoint","writeMultiLineString","writeMultiPolygon","writeGeometryCollection","geometries","writeGeometry","findMinimumLayout","geom","arguments","GeometryLayout_min","a","b","getLayout","geoms","getGeometriesArray","wkblut","geomType","getType","writerLUT","getCoordinates","getBuffer","_this","byteLength","reduce","acc","item","buffer","ArrayBuffer","DataView","pos","forEach","setUint8","setUint32","setFloat64","WKB","_FeatureFormat","options","_this2","_callSuper","splitCollection","viewCache_","hex_","hex","littleEndian_","ewkb_","geometryLayout","nodataZ_","nodataZ","nodataM_","nodataM","_inherits","readFeature","source","geometry","readFeatures","getDataView","getReadOptions","readProjection","writeFeature","feature","getGeometry","writeFeatures","features","adaptOptions","writer","dataProjection","code","getCode","startsWith","substring","encodeHexString","Uint8Array","Array","from","values","x","toString","toUpperCase","decodeHexString","text","parseInt","substr","isView","byteOffset"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol/format/WKB.js"],"sourcesContent":["/**\n * @module ol/format/WKB\n */\nimport Feature from '../Feature.js';\nimport FeatureFormat, {transformGeometryWithOptions} from './Feature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport {get as getProjection} from '../proj.js';\n\nimport SimpleGeometry from '../geom/SimpleGeometry.js';\n\n// WKB spec: https://www.ogc.org/standards/sfa\n// EWKB spec: https://raw.githubusercontent.com/postgis/postgis/2.1.0/doc/ZMSgeoms.txt\n\n/**\n * @const\n * @enum {number}\n */\nconst WKBGeometryType = {\n  POINT: 1,\n  LINE_STRING: 2,\n  POLYGON: 3,\n  MULTI_POINT: 4,\n  MULTI_LINE_STRING: 5,\n  MULTI_POLYGON: 6,\n  GEOMETRY_COLLECTION: 7,\n\n  /*\n  CIRCULAR_STRING: 8,\n  COMPOUND_CURVE: 9,\n  CURVE_POLYGON: 10,\n\n  MULTI_CURVE: 11,\n  MULTI_SURFACE: 12,\n  CURVE: 13,\n  SURFACE: 14,\n  */\n\n  POLYHEDRAL_SURFACE: 15,\n  TIN: 16,\n  TRIANGLE: 17,\n};\n\nclass WkbReader {\n  /**\n   * @param {DataView} view source to read\n   */\n  constructor(view) {\n    /** @private */\n    this.view_ = view;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.pos_ = 0;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.initialized_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.isLittleEndian_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasZ_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasM_ = false;\n\n    /**\n     * @type {number|null}\n     * @private\n     */\n    this.srid_ = null;\n\n    /**\n     * @type {import(\"../geom/Geometry.js\").GeometryLayout}\n     * @private\n     */\n    this.layout_ = 'XY';\n  }\n\n  /**\n   * @return {number} value\n   */\n  readUint8() {\n    return this.view_.getUint8(this.pos_++);\n  }\n\n  /**\n   * @param {boolean} [isLittleEndian] Whether read value as little endian\n   * @return {number} value\n   */\n  readUint32(isLittleEndian) {\n    return this.view_.getUint32(\n      (this.pos_ += 4) - 4,\n      isLittleEndian !== undefined ? isLittleEndian : this.isLittleEndian_\n    );\n  }\n\n  /**\n   * @param {boolean} [isLittleEndian] Whether read value as little endian\n   * @return {number} value\n   */\n  readDouble(isLittleEndian) {\n    return this.view_.getFloat64(\n      (this.pos_ += 8) - 8,\n      isLittleEndian !== undefined ? isLittleEndian : this.isLittleEndian_\n    );\n  }\n\n  /**\n   * @return {import('../coordinate.js').Coordinate} coords for Point\n   */\n  readPoint() {\n    /** @type import('../coordinate.js').Coordinate */\n    const coords = [];\n\n    coords.push(this.readDouble());\n    coords.push(this.readDouble());\n    if (this.hasZ_) {\n      coords.push(this.readDouble());\n    }\n    if (this.hasM_) {\n      coords.push(this.readDouble());\n    }\n\n    return coords;\n  }\n\n  /**\n   * @return {Array<import('../coordinate.js').Coordinate>} coords for LineString / LinearRing\n   */\n  readLineString() {\n    const numPoints = this.readUint32();\n\n    /** @type Array<import('../coordinate.js').Coordinate> */\n    const coords = [];\n    for (let i = 0; i < numPoints; i++) {\n      coords.push(this.readPoint());\n    }\n\n    return coords;\n  }\n\n  /**\n   * @return {Array<Array<import('../coordinate.js').Coordinate>>} coords for Polygon like\n   */\n  readPolygon() {\n    const numRings = this.readUint32();\n\n    /** @type Array<Array<import('../coordinate.js').Coordinate>> */\n    const rings = [];\n    for (let i = 0; i < numRings; i++) {\n      rings.push(this.readLineString()); // as a LinearRing\n    }\n\n    return rings;\n  }\n\n  /**\n   * @param {number} [expectedTypeId] Expected WKB Type ID\n   * @return {number} WKB Type ID\n   */\n  readWkbHeader(expectedTypeId) {\n    const byteOrder = this.readUint8();\n    const isLittleEndian = byteOrder > 0;\n\n    const wkbType = this.readUint32(isLittleEndian);\n    const wkbTypeThousandth = Math.floor((wkbType & 0x0fffffff) / 1000);\n    const hasZ =\n      Boolean(wkbType & 0x80000000) ||\n      wkbTypeThousandth === 1 ||\n      wkbTypeThousandth === 3;\n    const hasM =\n      Boolean(wkbType & 0x40000000) ||\n      wkbTypeThousandth === 2 ||\n      wkbTypeThousandth === 3;\n    const hasSRID = Boolean(wkbType & 0x20000000);\n    const typeId = (wkbType & 0x0fffffff) % 1000; // Assume 1000 is an upper limit for type ID\n    const layout = /** @type {import(\"../geom/Geometry.js\").GeometryLayout} */ (\n      ['XY', hasZ ? 'Z' : '', hasM ? 'M' : ''].join('')\n    );\n\n    const srid = hasSRID ? this.readUint32(isLittleEndian) : null;\n\n    if (expectedTypeId !== undefined && expectedTypeId !== typeId) {\n      throw new Error('Unexpected WKB geometry type ' + typeId);\n    }\n\n    if (this.initialized_) {\n      // sanity checks\n      if (this.isLittleEndian_ !== isLittleEndian) {\n        throw new Error('Inconsistent endian');\n      }\n      if (this.layout_ !== layout) {\n        throw new Error('Inconsistent geometry layout');\n      }\n      if (srid && this.srid_ !== srid) {\n        throw new Error('Inconsistent coordinate system (SRID)');\n      }\n    } else {\n      this.isLittleEndian_ = isLittleEndian;\n      this.hasZ_ = hasZ;\n      this.hasM_ = hasM;\n      this.layout_ = layout;\n      this.srid_ = srid;\n      this.initialized_ = true;\n    }\n\n    return typeId;\n  }\n\n  /**\n   * @param {number} typeId WKB Type ID\n   * @return {any} values read\n   */\n  readWkbPayload(typeId) {\n    switch (typeId) {\n      case WKBGeometryType.POINT:\n        return this.readPoint();\n\n      case WKBGeometryType.LINE_STRING:\n        return this.readLineString();\n\n      case WKBGeometryType.POLYGON:\n      case WKBGeometryType.TRIANGLE:\n        return this.readPolygon();\n\n      case WKBGeometryType.MULTI_POINT:\n        return this.readMultiPoint();\n\n      case WKBGeometryType.MULTI_LINE_STRING:\n        return this.readMultiLineString();\n\n      case WKBGeometryType.MULTI_POLYGON:\n      case WKBGeometryType.POLYHEDRAL_SURFACE:\n      case WKBGeometryType.TIN:\n        return this.readMultiPolygon();\n\n      case WKBGeometryType.GEOMETRY_COLLECTION:\n        return this.readGeometryCollection();\n\n      default:\n        throw new Error(\n          'Unsupported WKB geometry type ' + typeId + ' is found'\n        );\n    }\n  }\n\n  /**\n   * @param {number} expectedTypeId Expected WKB Type ID\n   * @return {any} values read\n   */\n  readWkbBlock(expectedTypeId) {\n    return this.readWkbPayload(this.readWkbHeader(expectedTypeId));\n  }\n\n  /**\n   * @param {Function} reader reader function for each item\n   * @param {number} [expectedTypeId] Expected WKB Type ID\n   * @return {any} values read\n   */\n  readWkbCollection(reader, expectedTypeId) {\n    const num = this.readUint32();\n\n    const items = [];\n    for (let i = 0; i < num; i++) {\n      const result = reader.call(this, expectedTypeId);\n      if (result) {\n        items.push(result);\n      }\n    }\n\n    return items;\n  }\n\n  /**\n   * @return {Array<import('../coordinate.js').Coordinate>} coords for MultiPoint\n   */\n  readMultiPoint() {\n    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POINT);\n  }\n\n  /**\n   * @return {Array<Array<import('../coordinate.js').Coordinate>>} coords for MultiLineString like\n   */\n  readMultiLineString() {\n    return this.readWkbCollection(\n      this.readWkbBlock,\n      WKBGeometryType.LINE_STRING\n    );\n  }\n\n  /**\n   * @return {Array<Array<Array<import('../coordinate.js').Coordinate>>>} coords for MultiPolygon like\n   */\n  readMultiPolygon() {\n    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POLYGON);\n  }\n\n  /**\n   * @return {Array<import('../geom/Geometry.js').default>} array of geometries\n   */\n  readGeometryCollection() {\n    return this.readWkbCollection(this.readGeometry);\n  }\n\n  /**\n   * @return {import('../geom/Geometry.js').default} geometry\n   */\n  readGeometry() {\n    const typeId = this.readWkbHeader();\n    const result = this.readWkbPayload(typeId);\n\n    switch (typeId) {\n      case WKBGeometryType.POINT:\n        return new Point(\n          /** @type {import('../coordinate.js').Coordinate} */ (result),\n          this.layout_\n        );\n\n      case WKBGeometryType.LINE_STRING:\n        return new LineString(\n          /** @type {Array<import('../coordinate.js').Coordinate>} */ (result),\n          this.layout_\n        );\n\n      case WKBGeometryType.POLYGON:\n      case WKBGeometryType.TRIANGLE:\n        return new Polygon(\n          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ (\n            result\n          ),\n          this.layout_\n        );\n\n      case WKBGeometryType.MULTI_POINT:\n        return new MultiPoint(\n          /** @type {Array<import('../coordinate.js').Coordinate>} */ (result),\n          this.layout_\n        );\n\n      case WKBGeometryType.MULTI_LINE_STRING:\n        return new MultiLineString(\n          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ (\n            result\n          ),\n          this.layout_\n        );\n\n      case WKBGeometryType.MULTI_POLYGON:\n      case WKBGeometryType.POLYHEDRAL_SURFACE:\n      case WKBGeometryType.TIN:\n        return new MultiPolygon(\n          /** @type {Array<Array<Array<import('../coordinate.js').Coordinate>>>} */ (\n            result\n          ),\n          this.layout_\n        );\n\n      case WKBGeometryType.GEOMETRY_COLLECTION:\n        return new GeometryCollection(\n          /** @type {Array<import('../geom/Geometry.js').default>} */ (result)\n        );\n\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * @return {number|null} SRID in the EWKB. `null` if not defined.\n   */\n  getSrid() {\n    return this.srid_;\n  }\n}\n\nclass WkbWriter {\n  /**\n   * @type {Object}\n   * @property {string} [layout] geometryLayout\n   * @property {boolean} [littleEndian=true] littleEndian\n   * @property {boolean} [ewkb=true] Whether writes in EWKB format\n   * @property {Object} [nodata] NoData value for each axes\n   * @param {Object} opts options\n   */\n  constructor(opts) {\n    opts = opts || {};\n\n    /** @type {string} */\n    this.layout_ = opts.layout;\n    this.isLittleEndian_ = opts.littleEndian !== false;\n\n    this.isEWKB_ = opts.ewkb !== false;\n\n    /** @type {Array<Array<number>>} */\n    this.writeQueue_ = [];\n\n    /**\n     * @type {Object}\n     * @property {number} X NoData value for X\n     * @property {number} Y NoData value for Y\n     * @property {number} Z NoData value for Z\n     * @property {number} M NoData value for M\n     */\n    this.nodata_ = Object.assign({X: 0, Y: 0, Z: 0, M: 0}, opts.nodata);\n  }\n\n  /**\n   * @param {number} value value\n   */\n  writeUint8(value) {\n    this.writeQueue_.push([1, value]);\n  }\n\n  /**\n   * @param {number} value value\n   */\n  writeUint32(value) {\n    this.writeQueue_.push([4, value]);\n  }\n\n  /**\n   * @param {number} value value\n   */\n  writeDouble(value) {\n    this.writeQueue_.push([8, value]);\n  }\n\n  /**\n   * @param {import('../coordinate.js').Coordinate} coords coords\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n   */\n  writePoint(coords, layout) {\n    /**\n     * @type {Object}\n     * @property {number} X NoData value for X\n     * @property {number} Y NoData value for Y\n     * @property {number} [Z] NoData value for Z\n     * @property {number} [M] NoData value for M\n     */\n    const coordsObj = Object.assign.apply(\n      null,\n      layout.split('').map((axis, idx) => ({[axis]: coords[idx]}))\n    );\n\n    for (const axis of this.layout_) {\n      this.writeDouble(\n        axis in coordsObj ? coordsObj[axis] : this.nodata_[axis]\n      );\n    }\n  }\n\n  /**\n   * @param {Array<import('../coordinate.js').Coordinate>} coords coords\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n   */\n  writeLineString(coords, layout) {\n    this.writeUint32(coords.length); // numPoints\n    for (let i = 0; i < coords.length; i++) {\n      this.writePoint(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} rings rings\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n   */\n  writePolygon(rings, layout) {\n    this.writeUint32(rings.length); // numRings\n    for (let i = 0; i < rings.length; i++) {\n      this.writeLineString(rings[i], layout); // as a LinearRing\n    }\n  }\n\n  /**\n   * @param {number} wkbType WKB Type ID\n   * @param {number} [srid] SRID\n   */\n  writeWkbHeader(wkbType, srid) {\n    wkbType %= 1000; // Assume 1000 is an upper limit for type ID\n    if (this.layout_.includes('Z')) {\n      wkbType += this.isEWKB_ ? 0x80000000 : 1000;\n    }\n    if (this.layout_.includes('M')) {\n      wkbType += this.isEWKB_ ? 0x40000000 : 2000;\n    }\n    if (this.isEWKB_ && Number.isInteger(srid)) {\n      wkbType |= 0x20000000;\n    }\n\n    this.writeUint8(this.isLittleEndian_ ? 1 : 0);\n    this.writeUint32(wkbType);\n    if (this.isEWKB_ && Number.isInteger(srid)) {\n      this.writeUint32(srid);\n    }\n  }\n\n  /**\n   * @param {Array<import('../coordinate.js').Coordinate>} coords coords\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n   */\n  writeMultiPoint(coords, layout) {\n    this.writeUint32(coords.length); // numItems\n    for (let i = 0; i < coords.length; i++) {\n      this.writeWkbHeader(1);\n      this.writePoint(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} coords coords\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n   */\n  writeMultiLineString(coords, layout) {\n    this.writeUint32(coords.length); // numItems\n    for (let i = 0; i < coords.length; i++) {\n      this.writeWkbHeader(2);\n      this.writeLineString(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<Array<Array<import('../coordinate.js').Coordinate>>>} coords coords\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n   */\n  writeMultiPolygon(coords, layout) {\n    this.writeUint32(coords.length); // numItems\n    for (let i = 0; i < coords.length; i++) {\n      this.writeWkbHeader(3);\n      this.writePolygon(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<import('../geom/Geometry.js').default>} geometries geometries\n   */\n  writeGeometryCollection(geometries) {\n    this.writeUint32(geometries.length); // numItems\n\n    for (let i = 0; i < geometries.length; i++) {\n      this.writeGeometry(geometries[i]);\n    }\n  }\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geom geometry\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} [layout] layout\n   * @return {import(\"../geom/Geometry.js\").GeometryLayout} minimum layout made by common axes\n   */\n  findMinimumLayout(geom, layout = 'XYZM') {\n    /**\n     * @param {import(\"../geom/Geometry.js\").GeometryLayout} a A\n     * @param {import(\"../geom/Geometry.js\").GeometryLayout} b B\n     * @return {import(\"../geom/Geometry.js\").GeometryLayout} minimum layout made by common axes\n     */\n    const GeometryLayout_min = (a, b) => {\n      if (a === b) {\n        return a;\n      }\n\n      if (a === 'XYZM') {\n        // anything `b` is minimum\n        return b;\n      }\n      if (b === 'XYZM') {\n        // anything `a` is minimum\n        return a;\n      }\n\n      // otherwise, incompatible\n      return 'XY';\n    };\n\n    if (geom instanceof SimpleGeometry) {\n      return GeometryLayout_min(geom.getLayout(), layout);\n    }\n\n    if (geom instanceof GeometryCollection) {\n      const geoms = geom.getGeometriesArray();\n      for (let i = 0; i < geoms.length && layout !== 'XY'; i++) {\n        layout = this.findMinimumLayout(geoms[i], layout);\n      }\n    }\n\n    return layout;\n  }\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geom geometry\n   * @param {number} [srid] SRID\n   */\n  writeGeometry(geom, srid) {\n    /**\n     * @type {Object<import(\"../geom/Geometry.js\").Type, WKBGeometryType>}\n     */\n    const wkblut = {\n      Point: WKBGeometryType.POINT,\n      LineString: WKBGeometryType.LINE_STRING,\n      Polygon: WKBGeometryType.POLYGON,\n      MultiPoint: WKBGeometryType.MULTI_POINT,\n      MultiLineString: WKBGeometryType.MULTI_LINE_STRING,\n      MultiPolygon: WKBGeometryType.MULTI_POLYGON,\n      GeometryCollection: WKBGeometryType.GEOMETRY_COLLECTION,\n    };\n    const geomType = geom.getType();\n    const typeId = wkblut[geomType];\n\n    if (!typeId) {\n      throw new Error('GeometryType ' + geomType + ' is not supported');\n    }\n\n    // first call of writeGeometry() traverse whole geometries to determine its output layout if not specified on constructor.\n    if (!this.layout_) {\n      this.layout_ = this.findMinimumLayout(geom);\n    }\n\n    this.writeWkbHeader(typeId, srid);\n\n    if (geom instanceof SimpleGeometry) {\n      const writerLUT = {\n        Point: this.writePoint,\n        LineString: this.writeLineString,\n        Polygon: this.writePolygon,\n        MultiPoint: this.writeMultiPoint,\n        MultiLineString: this.writeMultiLineString,\n        MultiPolygon: this.writeMultiPolygon,\n      };\n      writerLUT[geomType].call(this, geom.getCoordinates(), geom.getLayout());\n    } else if (geom instanceof GeometryCollection) {\n      this.writeGeometryCollection(geom.getGeometriesArray());\n    }\n  }\n\n  getBuffer() {\n    const byteLength = this.writeQueue_.reduce((acc, item) => acc + item[0], 0);\n    const buffer = new ArrayBuffer(byteLength);\n    const view = new DataView(buffer);\n\n    let pos = 0;\n    this.writeQueue_.forEach((item) => {\n      switch (item[0]) {\n        case 1:\n          view.setUint8(pos, item[1]);\n          break;\n        case 4:\n          view.setUint32(pos, item[1], this.isLittleEndian_);\n          break;\n        case 8:\n          view.setFloat64(pos, item[1], this.isLittleEndian_);\n          break;\n        default:\n          break;\n      }\n\n      pos += item[0];\n    });\n\n    return buffer;\n  }\n}\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into multiple features on reading.\n * @property {boolean} [hex=true] Returns hex string instead of ArrayBuffer for output. This also is used as a hint internally whether it should load contents as text or ArrayBuffer on reading.\n * @property {boolean} [littleEndian=true] Use littleEndian for output.\n * @property {boolean} [ewkb=true] Use EWKB format for output.\n * @property {import(\"../geom/Geometry.js\").GeometryLayout} [geometryLayout=null] Use specific coordinate layout for output features (null: auto detect)\n * @property {number} [nodataZ=0] If the `geometryLayout` doesn't match with geometry to be output, this value is used to fill missing coordinate value of Z.\n * @property {number} [nodataM=0] If the `geometryLayout` doesn't match with geometry to be output, this value is used to fill missing coordinate value of M.\n * @property {number|boolean} [srid=true] SRID for output. Specify integer value to enforce the value as a SRID. Specify `true` to extract from `dataProjection`. `false` to suppress the output. This option only takes effect when `ewkb` is `true`.\n */\n\n/**\n * @classdesc\n * Geometry format for reading and writing data in the `Well-Known Binary` (WKB) format.\n * Also supports `Extended Well-Known Binary` (EWKB) format, used in PostGIS for example.\n *\n * @api\n */\nclass WKB extends FeatureFormat {\n  /**\n   * @param {Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    this.splitCollection = Boolean(options.splitCollection);\n\n    this.viewCache_ = null;\n\n    this.hex_ = options.hex !== false;\n    this.littleEndian_ = options.littleEndian !== false;\n    this.ewkb_ = options.ewkb !== false;\n\n    this.layout_ = options.geometryLayout; // null for auto detect\n    this.nodataZ_ = options.nodataZ || 0;\n    this.nodataM_ = options.nodataM || 0;\n\n    this.srid_ = options.srid;\n  }\n\n  /**\n   * @return {import(\"./Feature.js\").Type} Format.\n   */\n  getType() {\n    return this.hex_ ? 'text' : 'arraybuffer';\n  }\n\n  /**\n   * Read a single feature from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   * @api\n   */\n  readFeature(source, options) {\n    return new Feature({\n      geometry: this.readGeometry(source, options),\n    });\n  }\n\n  /**\n   * Read all features from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   * @api\n   */\n  readFeatures(source, options) {\n    let geometries = [];\n    const geometry = this.readGeometry(source, options);\n    if (this.splitCollection && geometry instanceof GeometryCollection) {\n      geometries = geometry.getGeometriesArray();\n    } else {\n      geometries = [geometry];\n    }\n    return geometries.map((geometry) => new Feature({geometry}));\n  }\n\n  /**\n   * Read a single geometry from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   * @api\n   */\n  readGeometry(source, options) {\n    const view = getDataView(source);\n    if (!view) {\n      return null;\n    }\n\n    const reader = new WkbReader(view);\n    const geometry = reader.readGeometry();\n\n    this.viewCache_ = view; // cache for internal subsequent call of readProjection()\n    options = this.getReadOptions(source, options);\n    this.viewCache_ = null; // release\n\n    return transformGeometryWithOptions(geometry, false, options);\n  }\n\n  /**\n   * Read the projection from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\n   * @api\n   */\n  readProjection(source) {\n    const view = this.viewCache_ || getDataView(source);\n    if (!view) {\n      return undefined;\n    }\n\n    const reader = new WkbReader(view);\n    reader.readWkbHeader();\n\n    return (\n      (reader.getSrid() && getProjection('EPSG:' + reader.getSrid())) ||\n      undefined\n    );\n  }\n\n  /**\n   * Encode a feature in this format.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   * @api\n   */\n  writeFeature(feature, options) {\n    return this.writeGeometry(feature.getGeometry(), options);\n  }\n\n  /**\n   * Encode an array of features in this format.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   * @api\n   */\n  writeFeatures(features, options) {\n    return this.writeGeometry(\n      new GeometryCollection(features.map((f) => f.getGeometry())),\n      options\n    );\n  }\n\n  /**\n   * Write a single geometry in this format.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   * @api\n   */\n  writeGeometry(geometry, options) {\n    options = this.adaptOptions(options);\n\n    const writer = new WkbWriter({\n      layout: this.layout_,\n      littleEndian: this.littleEndian_,\n      ewkb: this.ewkb_,\n\n      nodata: {\n        Z: this.nodataZ_,\n        M: this.nodataM_,\n      },\n    });\n\n    // extract SRID from `dataProjection`\n    let srid = Number.isInteger(this.srid_) ? Number(this.srid_) : null;\n    if (this.srid_ !== false && !Number.isInteger(this.srid_)) {\n      const dataProjection =\n        options.dataProjection && getProjection(options.dataProjection);\n      if (dataProjection) {\n        const code = dataProjection.getCode();\n        if (code.startsWith('EPSG:')) {\n          srid = Number(code.substring(5));\n        }\n      }\n    }\n\n    writer.writeGeometry(\n      transformGeometryWithOptions(geometry, true, options),\n      srid\n    );\n    const buffer = writer.getBuffer();\n\n    return this.hex_ ? encodeHexString(buffer) : buffer;\n  }\n}\n\n/**\n * @param {ArrayBuffer} buffer source buffer\n * @return {string} encoded hex string\n */\nfunction encodeHexString(buffer) {\n  const view = new Uint8Array(buffer);\n  return Array.from(view.values())\n    .map((x) => (x < 16 ? '0' : '') + Number(x).toString(16).toUpperCase())\n    .join('');\n}\n\n/**\n * @param {string} text source text\n * @return {DataView} decoded binary buffer\n */\nfunction decodeHexString(text) {\n  const buffer = new Uint8Array(text.length / 2);\n  for (let i = 0; i < text.length / 2; i++) {\n    buffer[i] = parseInt(text.substr(i * 2, 2), 16);\n  }\n  return new DataView(buffer.buffer);\n}\n\n/**\n * @param {string | ArrayBuffer | ArrayBufferView} source source\n * @return {DataView} data view\n */\nfunction getDataView(source) {\n  if (typeof source === 'string') {\n    return decodeHexString(source);\n  }\n  if (ArrayBuffer.isView(source)) {\n    if (source instanceof DataView) {\n      return source;\n    }\n    return new DataView(source.buffer, source.byteOffset, source.byteLength);\n  }\n  if (source instanceof ArrayBuffer) {\n    return new DataView(source);\n  }\n  return null;\n}\n\nexport default WKB;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA,OAAOA,OAAO,MAAM,eAAe;AACnC,OAAOC,aAAa,IAAGC,4BAA4B,QAAO,cAAc;AACxE,OAAOC,kBAAkB,MAAM,+BAA+B;AAC9D,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,eAAe,MAAM,4BAA4B;AACxD,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,OAAO,MAAM,oBAAoB;AACxC,SAAQC,GAAG,IAAIC,aAAa,QAAO,YAAY;AAE/C,OAAOC,cAAc,MAAM,2BAA2B;;AAEtD;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAMC,eAAe,GAAG;EACtBC,KAAK,EAAE,CAAC;EACRC,WAAW,EAAE,CAAC;EACdC,OAAO,EAAE,CAAC;EACVC,WAAW,EAAE,CAAC;EACdC,iBAAiB,EAAE,CAAC;EACpBC,aAAa,EAAE,CAAC;EAChBC,mBAAmB,EAAE,CAAC;EAEtB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAGEC,kBAAkB,EAAE,EAAE;EACtBC,GAAG,EAAE,EAAE;EACPC,QAAQ,EAAE;AACZ,CAAC;AAAC,IAEIC,SAAS;EACb;AACF;AACA;EACE,SAAAA,UAAYC,IAAI,EAAE;IAAAC,eAAA,OAAAF,SAAA;IAChB;IACA,IAAI,CAACG,KAAK,GAAGF,IAAI;;IAEjB;AACJ;AACA;AACA;IACI,IAAI,CAACG,IAAI,GAAG,CAAC;;IAEb;AACJ;AACA;AACA;IACI,IAAI,CAACC,YAAY,GAAG,KAAK;;IAEzB;AACJ;AACA;AACA;IACI,IAAI,CAACC,eAAe,GAAG,KAAK;;IAE5B;AACJ;AACA;AACA;IACI,IAAI,CAACC,KAAK,GAAG,KAAK;;IAElB;AACJ;AACA;AACA;IACI,IAAI,CAACC,KAAK,GAAG,KAAK;;IAElB;AACJ;AACA;AACA;IACI,IAAI,CAACC,KAAK,GAAG,IAAI;;IAEjB;AACJ;AACA;AACA;IACI,IAAI,CAACC,OAAO,GAAG,IAAI;EACrB;;EAEA;AACF;AACA;EAFE,OAAAC,YAAA,CAAAX,SAAA;IAAAY,GAAA;IAAAC,KAAA,EAGA,SAAAC,SAASA,CAAA,EAAG;MACV,OAAO,IAAI,CAACX,KAAK,CAACY,QAAQ,CAAC,IAAI,CAACX,IAAI,EAAE,CAAC;IACzC;;IAEA;AACF;AACA;AACA;EAHE;IAAAQ,GAAA;IAAAC,KAAA,EAIA,SAAAG,UAAUA,CAACC,cAAc,EAAE;MACzB,OAAO,IAAI,CAACd,KAAK,CAACe,SAAS,CACzB,CAAC,IAAI,CAACd,IAAI,IAAI,CAAC,IAAI,CAAC,EACpBa,cAAc,KAAKE,SAAS,GAAGF,cAAc,GAAG,IAAI,CAACX,eACvD,CAAC;IACH;;IAEA;AACF;AACA;AACA;EAHE;IAAAM,GAAA;IAAAC,KAAA,EAIA,SAAAO,UAAUA,CAACH,cAAc,EAAE;MACzB,OAAO,IAAI,CAACd,KAAK,CAACkB,UAAU,CAC1B,CAAC,IAAI,CAACjB,IAAI,IAAI,CAAC,IAAI,CAAC,EACpBa,cAAc,KAAKE,SAAS,GAAGF,cAAc,GAAG,IAAI,CAACX,eACvD,CAAC;IACH;;IAEA;AACF;AACA;EAFE;IAAAM,GAAA;IAAAC,KAAA,EAGA,SAAAS,SAASA,CAAA,EAAG;MACV;MACA,IAAMC,MAAM,GAAG,EAAE;MAEjBA,MAAM,CAACC,IAAI,CAAC,IAAI,CAACJ,UAAU,CAAC,CAAC,CAAC;MAC9BG,MAAM,CAACC,IAAI,CAAC,IAAI,CAACJ,UAAU,CAAC,CAAC,CAAC;MAC9B,IAAI,IAAI,CAACb,KAAK,EAAE;QACdgB,MAAM,CAACC,IAAI,CAAC,IAAI,CAACJ,UAAU,CAAC,CAAC,CAAC;MAChC;MACA,IAAI,IAAI,CAACZ,KAAK,EAAE;QACde,MAAM,CAACC,IAAI,CAAC,IAAI,CAACJ,UAAU,CAAC,CAAC,CAAC;MAChC;MAEA,OAAOG,MAAM;IACf;;IAEA;AACF;AACA;EAFE;IAAAX,GAAA;IAAAC,KAAA,EAGA,SAAAY,cAAcA,CAAA,EAAG;MACf,IAAMC,SAAS,GAAG,IAAI,CAACV,UAAU,CAAC,CAAC;;MAEnC;MACA,IAAMO,MAAM,GAAG,EAAE;MACjB,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,SAAS,EAAEC,CAAC,EAAE,EAAE;QAClCJ,MAAM,CAACC,IAAI,CAAC,IAAI,CAACF,SAAS,CAAC,CAAC,CAAC;MAC/B;MAEA,OAAOC,MAAM;IACf;;IAEA;AACF;AACA;EAFE;IAAAX,GAAA;IAAAC,KAAA,EAGA,SAAAe,WAAWA,CAAA,EAAG;MACZ,IAAMC,QAAQ,GAAG,IAAI,CAACb,UAAU,CAAC,CAAC;;MAElC;MACA,IAAMc,KAAK,GAAG,EAAE;MAChB,KAAK,IAAIH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGE,QAAQ,EAAEF,CAAC,EAAE,EAAE;QACjCG,KAAK,CAACN,IAAI,CAAC,IAAI,CAACC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;MACrC;MAEA,OAAOK,KAAK;IACd;;IAEA;AACF;AACA;AACA;EAHE;IAAAlB,GAAA;IAAAC,KAAA,EAIA,SAAAkB,aAAaA,CAACC,cAAc,EAAE;MAC5B,IAAMC,SAAS,GAAG,IAAI,CAACnB,SAAS,CAAC,CAAC;MAClC,IAAMG,cAAc,GAAGgB,SAAS,GAAG,CAAC;MAEpC,IAAMC,OAAO,GAAG,IAAI,CAAClB,UAAU,CAACC,cAAc,CAAC;MAC/C,IAAMkB,iBAAiB,GAAGC,IAAI,CAACC,KAAK,CAAC,CAACH,OAAO,GAAG,UAAU,IAAI,IAAI,CAAC;MACnE,IAAMI,IAAI,GACRC,OAAO,CAACL,OAAO,GAAG,UAAU,CAAC,IAC7BC,iBAAiB,KAAK,CAAC,IACvBA,iBAAiB,KAAK,CAAC;MACzB,IAAMK,IAAI,GACRD,OAAO,CAACL,OAAO,GAAG,UAAU,CAAC,IAC7BC,iBAAiB,KAAK,CAAC,IACvBA,iBAAiB,KAAK,CAAC;MACzB,IAAMM,OAAO,GAAGF,OAAO,CAACL,OAAO,GAAG,UAAU,CAAC;MAC7C,IAAMQ,MAAM,GAAG,CAACR,OAAO,GAAG,UAAU,IAAI,IAAI,CAAC,CAAC;MAC9C,IAAMS,MAAM,GAAG;MACb,CAAC,IAAI,EAAEL,IAAI,GAAG,GAAG,GAAG,EAAE,EAAEE,IAAI,GAAG,GAAG,GAAG,EAAE,CAAC,CAACI,IAAI,CAAC,EAAE,CACjD;MAED,IAAMC,IAAI,GAAGJ,OAAO,GAAG,IAAI,CAACzB,UAAU,CAACC,cAAc,CAAC,GAAG,IAAI;MAE7D,IAAIe,cAAc,KAAKb,SAAS,IAAIa,cAAc,KAAKU,MAAM,EAAE;QAC7D,MAAM,IAAII,KAAK,CAAC,+BAA+B,GAAGJ,MAAM,CAAC;MAC3D;MAEA,IAAI,IAAI,CAACrC,YAAY,EAAE;QACrB;QACA,IAAI,IAAI,CAACC,eAAe,KAAKW,cAAc,EAAE;UAC3C,MAAM,IAAI6B,KAAK,CAAC,qBAAqB,CAAC;QACxC;QACA,IAAI,IAAI,CAACpC,OAAO,KAAKiC,MAAM,EAAE;UAC3B,MAAM,IAAIG,KAAK,CAAC,8BAA8B,CAAC;QACjD;QACA,IAAID,IAAI,IAAI,IAAI,CAACpC,KAAK,KAAKoC,IAAI,EAAE;UAC/B,MAAM,IAAIC,KAAK,CAAC,uCAAuC,CAAC;QAC1D;MACF,CAAC,MAAM;QACL,IAAI,CAACxC,eAAe,GAAGW,cAAc;QACrC,IAAI,CAACV,KAAK,GAAG+B,IAAI;QACjB,IAAI,CAAC9B,KAAK,GAAGgC,IAAI;QACjB,IAAI,CAAC9B,OAAO,GAAGiC,MAAM;QACrB,IAAI,CAAClC,KAAK,GAAGoC,IAAI;QACjB,IAAI,CAACxC,YAAY,GAAG,IAAI;MAC1B;MAEA,OAAOqC,MAAM;IACf;;IAEA;AACF;AACA;AACA;EAHE;IAAA9B,GAAA;IAAAC,KAAA,EAIA,SAAAkC,cAAcA,CAACL,MAAM,EAAE;MACrB,QAAQA,MAAM;QACZ,KAAKrD,eAAe,CAACC,KAAK;UACxB,OAAO,IAAI,CAACgC,SAAS,CAAC,CAAC;QAEzB,KAAKjC,eAAe,CAACE,WAAW;UAC9B,OAAO,IAAI,CAACkC,cAAc,CAAC,CAAC;QAE9B,KAAKpC,eAAe,CAACG,OAAO;QAC5B,KAAKH,eAAe,CAACU,QAAQ;UAC3B,OAAO,IAAI,CAAC6B,WAAW,CAAC,CAAC;QAE3B,KAAKvC,eAAe,CAACI,WAAW;UAC9B,OAAO,IAAI,CAACuD,cAAc,CAAC,CAAC;QAE9B,KAAK3D,eAAe,CAACK,iBAAiB;UACpC,OAAO,IAAI,CAACuD,mBAAmB,CAAC,CAAC;QAEnC,KAAK5D,eAAe,CAACM,aAAa;QAClC,KAAKN,eAAe,CAACQ,kBAAkB;QACvC,KAAKR,eAAe,CAACS,GAAG;UACtB,OAAO,IAAI,CAACoD,gBAAgB,CAAC,CAAC;QAEhC,KAAK7D,eAAe,CAACO,mBAAmB;UACtC,OAAO,IAAI,CAACuD,sBAAsB,CAAC,CAAC;QAEtC;UACE,MAAM,IAAIL,KAAK,CACb,gCAAgC,GAAGJ,MAAM,GAAG,WAC9C,CAAC;MACL;IACF;;IAEA;AACF;AACA;AACA;EAHE;IAAA9B,GAAA;IAAAC,KAAA,EAIA,SAAAuC,YAAYA,CAACpB,cAAc,EAAE;MAC3B,OAAO,IAAI,CAACe,cAAc,CAAC,IAAI,CAAChB,aAAa,CAACC,cAAc,CAAC,CAAC;IAChE;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAApB,GAAA;IAAAC,KAAA,EAKA,SAAAwC,iBAAiBA,CAACC,MAAM,EAAEtB,cAAc,EAAE;MACxC,IAAMuB,GAAG,GAAG,IAAI,CAACvC,UAAU,CAAC,CAAC;MAE7B,IAAMwC,KAAK,GAAG,EAAE;MAChB,KAAK,IAAI7B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4B,GAAG,EAAE5B,CAAC,EAAE,EAAE;QAC5B,IAAM8B,MAAM,GAAGH,MAAM,CAACI,IAAI,CAAC,IAAI,EAAE1B,cAAc,CAAC;QAChD,IAAIyB,MAAM,EAAE;UACVD,KAAK,CAAChC,IAAI,CAACiC,MAAM,CAAC;QACpB;MACF;MAEA,OAAOD,KAAK;IACd;;IAEA;AACF;AACA;EAFE;IAAA5C,GAAA;IAAAC,KAAA,EAGA,SAAAmC,cAAcA,CAAA,EAAG;MACf,OAAO,IAAI,CAACK,iBAAiB,CAAC,IAAI,CAACD,YAAY,EAAE/D,eAAe,CAACC,KAAK,CAAC;IACzE;;IAEA;AACF;AACA;EAFE;IAAAsB,GAAA;IAAAC,KAAA,EAGA,SAAAoC,mBAAmBA,CAAA,EAAG;MACpB,OAAO,IAAI,CAACI,iBAAiB,CAC3B,IAAI,CAACD,YAAY,EACjB/D,eAAe,CAACE,WAClB,CAAC;IACH;;IAEA;AACF;AACA;EAFE;IAAAqB,GAAA;IAAAC,KAAA,EAGA,SAAAqC,gBAAgBA,CAAA,EAAG;MACjB,OAAO,IAAI,CAACG,iBAAiB,CAAC,IAAI,CAACD,YAAY,EAAE/D,eAAe,CAACG,OAAO,CAAC;IAC3E;;IAEA;AACF;AACA;EAFE;IAAAoB,GAAA;IAAAC,KAAA,EAGA,SAAAsC,sBAAsBA,CAAA,EAAG;MACvB,OAAO,IAAI,CAACE,iBAAiB,CAAC,IAAI,CAACM,YAAY,CAAC;IAClD;;IAEA;AACF;AACA;EAFE;IAAA/C,GAAA;IAAAC,KAAA,EAGA,SAAA8C,YAAYA,CAAA,EAAG;MACb,IAAMjB,MAAM,GAAG,IAAI,CAACX,aAAa,CAAC,CAAC;MACnC,IAAM0B,MAAM,GAAG,IAAI,CAACV,cAAc,CAACL,MAAM,CAAC;MAE1C,QAAQA,MAAM;QACZ,KAAKrD,eAAe,CAACC,KAAK;UACxB,OAAO,IAAIN,KAAK,CACd,oDAAsDyE,MAAM,EAC5D,IAAI,CAAC/C,OACP,CAAC;QAEH,KAAKrB,eAAe,CAACE,WAAW;UAC9B,OAAO,IAAIX,UAAU,CACnB,2DAA6D6E,MAAM,EACnE,IAAI,CAAC/C,OACP,CAAC;QAEH,KAAKrB,eAAe,CAACG,OAAO;QAC5B,KAAKH,eAAe,CAACU,QAAQ;UAC3B,OAAO,IAAId,OAAO,CAChB;UACEwE,MAAM,EAER,IAAI,CAAC/C,OACP,CAAC;QAEH,KAAKrB,eAAe,CAACI,WAAW;UAC9B,OAAO,IAAIX,UAAU,CACnB,2DAA6D2E,MAAM,EACnE,IAAI,CAAC/C,OACP,CAAC;QAEH,KAAKrB,eAAe,CAACK,iBAAiB;UACpC,OAAO,IAAIb,eAAe,CACxB;UACE4E,MAAM,EAER,IAAI,CAAC/C,OACP,CAAC;QAEH,KAAKrB,eAAe,CAACM,aAAa;QAClC,KAAKN,eAAe,CAACQ,kBAAkB;QACvC,KAAKR,eAAe,CAACS,GAAG;UACtB,OAAO,IAAIf,YAAY,CACrB;UACE0E,MAAM,EAER,IAAI,CAAC/C,OACP,CAAC;QAEH,KAAKrB,eAAe,CAACO,mBAAmB;UACtC,OAAO,IAAIjB,kBAAkB,CAC3B,2DAA6D8E,MAC/D,CAAC;QAEH;UACE,OAAO,IAAI;MACf;IACF;;IAEA;AACF;AACA;EAFE;IAAA7C,GAAA;IAAAC,KAAA,EAGA,SAAA+C,OAAOA,CAAA,EAAG;MACR,OAAO,IAAI,CAACnD,KAAK;IACnB;EAAC;AAAA;AAAA,IAGGoD,SAAS;EACb;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAAAA,UAAYC,IAAI,EAAE;IAAA5D,eAAA,OAAA2D,SAAA;IAChBC,IAAI,GAAGA,IAAI,IAAI,CAAC,CAAC;;IAEjB;IACA,IAAI,CAACpD,OAAO,GAAGoD,IAAI,CAACnB,MAAM;IAC1B,IAAI,CAACrC,eAAe,GAAGwD,IAAI,CAACC,YAAY,KAAK,KAAK;IAElD,IAAI,CAACC,OAAO,GAAGF,IAAI,CAACG,IAAI,KAAK,KAAK;;IAElC;IACA,IAAI,CAACC,WAAW,GAAG,EAAE;;IAErB;AACJ;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAACC,OAAO,GAAGC,MAAM,CAACC,MAAM,CAAC;MAACC,CAAC,EAAE,CAAC;MAAEC,CAAC,EAAE,CAAC;MAAEC,CAAC,EAAE,CAAC;MAAEC,CAAC,EAAE;IAAC,CAAC,EAAEX,IAAI,CAACY,MAAM,CAAC;EACrE;;EAEA;AACF;AACA;EAFE,OAAA/D,YAAA,CAAAkD,SAAA;IAAAjD,GAAA;IAAAC,KAAA,EAGA,SAAA8D,UAAUA,CAAC9D,KAAK,EAAE;MAChB,IAAI,CAACqD,WAAW,CAAC1C,IAAI,CAAC,CAAC,CAAC,EAAEX,KAAK,CAAC,CAAC;IACnC;;IAEA;AACF;AACA;EAFE;IAAAD,GAAA;IAAAC,KAAA,EAGA,SAAA+D,WAAWA,CAAC/D,KAAK,EAAE;MACjB,IAAI,CAACqD,WAAW,CAAC1C,IAAI,CAAC,CAAC,CAAC,EAAEX,KAAK,CAAC,CAAC;IACnC;;IAEA;AACF;AACA;EAFE;IAAAD,GAAA;IAAAC,KAAA,EAGA,SAAAgE,WAAWA,CAAChE,KAAK,EAAE;MACjB,IAAI,CAACqD,WAAW,CAAC1C,IAAI,CAAC,CAAC,CAAC,EAAEX,KAAK,CAAC,CAAC;IACnC;;IAEA;AACF;AACA;AACA;EAHE;IAAAD,GAAA;IAAAC,KAAA,EAIA,SAAAiE,UAAUA,CAACvD,MAAM,EAAEoB,MAAM,EAAE;MACzB;AACJ;AACA;AACA;AACA;AACA;AACA;MACI,IAAMoC,SAAS,GAAGX,MAAM,CAACC,MAAM,CAACW,KAAK,CACnC,IAAI,EACJrC,MAAM,CAACsC,KAAK,CAAC,EAAE,CAAC,CAACC,GAAG,CAAC,UAACC,IAAI,EAAEC,GAAG;QAAA,OAAAC,eAAA,KAAQF,IAAI,EAAG5D,MAAM,CAAC6D,GAAG,CAAC;MAAA,CAAE,CAC7D,CAAC;MAAC,IAAAE,SAAA,GAAAC,0BAAA,CAEiB,IAAI,CAAC7E,OAAO;QAAA8E,KAAA;MAAA;QAA/B,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAAiC;UAAA,IAAtBR,IAAI,GAAAK,KAAA,CAAA3E,KAAA;UACb,IAAI,CAACgE,WAAW,CACdM,IAAI,IAAIJ,SAAS,GAAGA,SAAS,CAACI,IAAI,CAAC,GAAG,IAAI,CAAChB,OAAO,CAACgB,IAAI,CACzD,CAAC;QACH;MAAC,SAAAS,GAAA;QAAAN,SAAA,CAAAO,CAAA,CAAAD,GAAA;MAAA;QAAAN,SAAA,CAAAQ,CAAA;MAAA;IACH;;IAEA;AACF;AACA;AACA;EAHE;IAAAlF,GAAA;IAAAC,KAAA,EAIA,SAAAkF,eAAeA,CAACxE,MAAM,EAAEoB,MAAM,EAAE;MAC9B,IAAI,CAACiC,WAAW,CAACrD,MAAM,CAACyE,MAAM,CAAC,CAAC,CAAC;MACjC,KAAK,IAAIrE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,MAAM,CAACyE,MAAM,EAAErE,CAAC,EAAE,EAAE;QACtC,IAAI,CAACmD,UAAU,CAACvD,MAAM,CAACI,CAAC,CAAC,EAAEgB,MAAM,CAAC;MACpC;IACF;;IAEA;AACF;AACA;AACA;EAHE;IAAA/B,GAAA;IAAAC,KAAA,EAIA,SAAAoF,YAAYA,CAACnE,KAAK,EAAEa,MAAM,EAAE;MAC1B,IAAI,CAACiC,WAAW,CAAC9C,KAAK,CAACkE,MAAM,CAAC,CAAC,CAAC;MAChC,KAAK,IAAIrE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGG,KAAK,CAACkE,MAAM,EAAErE,CAAC,EAAE,EAAE;QACrC,IAAI,CAACoE,eAAe,CAACjE,KAAK,CAACH,CAAC,CAAC,EAAEgB,MAAM,CAAC,CAAC,CAAC;MAC1C;IACF;;IAEA;AACF;AACA;AACA;EAHE;IAAA/B,GAAA;IAAAC,KAAA,EAIA,SAAAqF,cAAcA,CAAChE,OAAO,EAAEW,IAAI,EAAE;MAC5BX,OAAO,IAAI,IAAI,CAAC,CAAC;MACjB,IAAI,IAAI,CAACxB,OAAO,CAACyF,QAAQ,CAAC,GAAG,CAAC,EAAE;QAC9BjE,OAAO,IAAI,IAAI,CAAC8B,OAAO,GAAG,UAAU,GAAG,IAAI;MAC7C;MACA,IAAI,IAAI,CAACtD,OAAO,CAACyF,QAAQ,CAAC,GAAG,CAAC,EAAE;QAC9BjE,OAAO,IAAI,IAAI,CAAC8B,OAAO,GAAG,UAAU,GAAG,IAAI;MAC7C;MACA,IAAI,IAAI,CAACA,OAAO,IAAIoC,MAAM,CAACC,SAAS,CAACxD,IAAI,CAAC,EAAE;QAC1CX,OAAO,IAAI,UAAU;MACvB;MAEA,IAAI,CAACyC,UAAU,CAAC,IAAI,CAACrE,eAAe,GAAG,CAAC,GAAG,CAAC,CAAC;MAC7C,IAAI,CAACsE,WAAW,CAAC1C,OAAO,CAAC;MACzB,IAAI,IAAI,CAAC8B,OAAO,IAAIoC,MAAM,CAACC,SAAS,CAACxD,IAAI,CAAC,EAAE;QAC1C,IAAI,CAAC+B,WAAW,CAAC/B,IAAI,CAAC;MACxB;IACF;;IAEA;AACF;AACA;AACA;EAHE;IAAAjC,GAAA;IAAAC,KAAA,EAIA,SAAAyF,eAAeA,CAAC/E,MAAM,EAAEoB,MAAM,EAAE;MAC9B,IAAI,CAACiC,WAAW,CAACrD,MAAM,CAACyE,MAAM,CAAC,CAAC,CAAC;MACjC,KAAK,IAAIrE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,MAAM,CAACyE,MAAM,EAAErE,CAAC,EAAE,EAAE;QACtC,IAAI,CAACuE,cAAc,CAAC,CAAC,CAAC;QACtB,IAAI,CAACpB,UAAU,CAACvD,MAAM,CAACI,CAAC,CAAC,EAAEgB,MAAM,CAAC;MACpC;IACF;;IAEA;AACF;AACA;AACA;EAHE;IAAA/B,GAAA;IAAAC,KAAA,EAIA,SAAA0F,oBAAoBA,CAAChF,MAAM,EAAEoB,MAAM,EAAE;MACnC,IAAI,CAACiC,WAAW,CAACrD,MAAM,CAACyE,MAAM,CAAC,CAAC,CAAC;MACjC,KAAK,IAAIrE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,MAAM,CAACyE,MAAM,EAAErE,CAAC,EAAE,EAAE;QACtC,IAAI,CAACuE,cAAc,CAAC,CAAC,CAAC;QACtB,IAAI,CAACH,eAAe,CAACxE,MAAM,CAACI,CAAC,CAAC,EAAEgB,MAAM,CAAC;MACzC;IACF;;IAEA;AACF;AACA;AACA;EAHE;IAAA/B,GAAA;IAAAC,KAAA,EAIA,SAAA2F,iBAAiBA,CAACjF,MAAM,EAAEoB,MAAM,EAAE;MAChC,IAAI,CAACiC,WAAW,CAACrD,MAAM,CAACyE,MAAM,CAAC,CAAC,CAAC;MACjC,KAAK,IAAIrE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,MAAM,CAACyE,MAAM,EAAErE,CAAC,EAAE,EAAE;QACtC,IAAI,CAACuE,cAAc,CAAC,CAAC,CAAC;QACtB,IAAI,CAACD,YAAY,CAAC1E,MAAM,CAACI,CAAC,CAAC,EAAEgB,MAAM,CAAC;MACtC;IACF;;IAEA;AACF;AACA;EAFE;IAAA/B,GAAA;IAAAC,KAAA,EAGA,SAAA4F,uBAAuBA,CAACC,UAAU,EAAE;MAClC,IAAI,CAAC9B,WAAW,CAAC8B,UAAU,CAACV,MAAM,CAAC,CAAC,CAAC;;MAErC,KAAK,IAAIrE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+E,UAAU,CAACV,MAAM,EAAErE,CAAC,EAAE,EAAE;QAC1C,IAAI,CAACgF,aAAa,CAACD,UAAU,CAAC/E,CAAC,CAAC,CAAC;MACnC;IACF;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAAf,GAAA;IAAAC,KAAA,EAKA,SAAA+F,iBAAiBA,CAACC,IAAI,EAAmB;MAAA,IAAjBlE,MAAM,GAAAmE,SAAA,CAAAd,MAAA,QAAAc,SAAA,QAAA3F,SAAA,GAAA2F,SAAA,MAAG,MAAM;MACrC;AACJ;AACA;AACA;AACA;MACI,IAAMC,kBAAkB,GAAG,SAArBA,kBAAkBA,CAAIC,CAAC,EAAEC,CAAC,EAAK;QACnC,IAAID,CAAC,KAAKC,CAAC,EAAE;UACX,OAAOD,CAAC;QACV;QAEA,IAAIA,CAAC,KAAK,MAAM,EAAE;UAChB;UACA,OAAOC,CAAC;QACV;QACA,IAAIA,CAAC,KAAK,MAAM,EAAE;UAChB;UACA,OAAOD,CAAC;QACV;;QAEA;QACA,OAAO,IAAI;MACb,CAAC;MAED,IAAIH,IAAI,YAAYzH,cAAc,EAAE;QAClC,OAAO2H,kBAAkB,CAACF,IAAI,CAACK,SAAS,CAAC,CAAC,EAAEvE,MAAM,CAAC;MACrD;MAEA,IAAIkE,IAAI,YAAYlI,kBAAkB,EAAE;QACtC,IAAMwI,KAAK,GAAGN,IAAI,CAACO,kBAAkB,CAAC,CAAC;QACvC,KAAK,IAAIzF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwF,KAAK,CAACnB,MAAM,IAAIrD,MAAM,KAAK,IAAI,EAAEhB,CAAC,EAAE,EAAE;UACxDgB,MAAM,GAAG,IAAI,CAACiE,iBAAiB,CAACO,KAAK,CAACxF,CAAC,CAAC,EAAEgB,MAAM,CAAC;QACnD;MACF;MAEA,OAAOA,MAAM;IACf;;IAEA;AACF;AACA;AACA;EAHE;IAAA/B,GAAA;IAAAC,KAAA,EAIA,SAAA8F,aAAaA,CAACE,IAAI,EAAEhE,IAAI,EAAE;MACxB;AACJ;AACA;MACI,IAAMwE,MAAM,GAAG;QACbrI,KAAK,EAAEK,eAAe,CAACC,KAAK;QAC5BV,UAAU,EAAES,eAAe,CAACE,WAAW;QACvCN,OAAO,EAAEI,eAAe,CAACG,OAAO;QAChCV,UAAU,EAAEO,eAAe,CAACI,WAAW;QACvCZ,eAAe,EAAEQ,eAAe,CAACK,iBAAiB;QAClDX,YAAY,EAAEM,eAAe,CAACM,aAAa;QAC3ChB,kBAAkB,EAAEU,eAAe,CAACO;MACtC,CAAC;MACD,IAAM0H,QAAQ,GAAGT,IAAI,CAACU,OAAO,CAAC,CAAC;MAC/B,IAAM7E,MAAM,GAAG2E,MAAM,CAACC,QAAQ,CAAC;MAE/B,IAAI,CAAC5E,MAAM,EAAE;QACX,MAAM,IAAII,KAAK,CAAC,eAAe,GAAGwE,QAAQ,GAAG,mBAAmB,CAAC;MACnE;;MAEA;MACA,IAAI,CAAC,IAAI,CAAC5G,OAAO,EAAE;QACjB,IAAI,CAACA,OAAO,GAAG,IAAI,CAACkG,iBAAiB,CAACC,IAAI,CAAC;MAC7C;MAEA,IAAI,CAACX,cAAc,CAACxD,MAAM,EAAEG,IAAI,CAAC;MAEjC,IAAIgE,IAAI,YAAYzH,cAAc,EAAE;QAClC,IAAMoI,SAAS,GAAG;UAChBxI,KAAK,EAAE,IAAI,CAAC8F,UAAU;UACtBlG,UAAU,EAAE,IAAI,CAACmH,eAAe;UAChC9G,OAAO,EAAE,IAAI,CAACgH,YAAY;UAC1BnH,UAAU,EAAE,IAAI,CAACwH,eAAe;UAChCzH,eAAe,EAAE,IAAI,CAAC0H,oBAAoB;UAC1CxH,YAAY,EAAE,IAAI,CAACyH;QACrB,CAAC;QACDgB,SAAS,CAACF,QAAQ,CAAC,CAAC5D,IAAI,CAAC,IAAI,EAAEmD,IAAI,CAACY,cAAc,CAAC,CAAC,EAAEZ,IAAI,CAACK,SAAS,CAAC,CAAC,CAAC;MACzE,CAAC,MAAM,IAAIL,IAAI,YAAYlI,kBAAkB,EAAE;QAC7C,IAAI,CAAC8H,uBAAuB,CAACI,IAAI,CAACO,kBAAkB,CAAC,CAAC,CAAC;MACzD;IACF;EAAC;IAAAxG,GAAA;IAAAC,KAAA,EAED,SAAA6G,SAASA,CAAA,EAAG;MAAA,IAAAC,KAAA;MACV,IAAMC,UAAU,GAAG,IAAI,CAAC1D,WAAW,CAAC2D,MAAM,CAAC,UAACC,GAAG,EAAEC,IAAI;QAAA,OAAKD,GAAG,GAAGC,IAAI,CAAC,CAAC,CAAC;MAAA,GAAE,CAAC,CAAC;MAC3E,IAAMC,MAAM,GAAG,IAAIC,WAAW,CAACL,UAAU,CAAC;MAC1C,IAAM3H,IAAI,GAAG,IAAIiI,QAAQ,CAACF,MAAM,CAAC;MAEjC,IAAIG,GAAG,GAAG,CAAC;MACX,IAAI,CAACjE,WAAW,CAACkE,OAAO,CAAC,UAACL,IAAI,EAAK;QACjC,QAAQA,IAAI,CAAC,CAAC,CAAC;UACb,KAAK,CAAC;YACJ9H,IAAI,CAACoI,QAAQ,CAACF,GAAG,EAAEJ,IAAI,CAAC,CAAC,CAAC,CAAC;YAC3B;UACF,KAAK,CAAC;YACJ9H,IAAI,CAACqI,SAAS,CAACH,GAAG,EAAEJ,IAAI,CAAC,CAAC,CAAC,EAAEJ,KAAI,CAACrH,eAAe,CAAC;YAClD;UACF,KAAK,CAAC;YACJL,IAAI,CAACsI,UAAU,CAACJ,GAAG,EAAEJ,IAAI,CAAC,CAAC,CAAC,EAAEJ,KAAI,CAACrH,eAAe,CAAC;YACnD;UACF;YACE;QACJ;QAEA6H,GAAG,IAAIJ,IAAI,CAAC,CAAC,CAAC;MAChB,CAAC,CAAC;MAEF,OAAOC,MAAM;IACf;EAAC;AAAA;AAGH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AANA,IAOMQ,GAAG,0BAAAC,cAAA;EACP;AACF;AACA;EACE,SAAAD,IAAYE,OAAO,EAAE;IAAA,IAAAC,MAAA;IAAAzI,eAAA,OAAAsI,GAAA;IACnBG,MAAA,GAAAC,UAAA,OAAAJ,GAAA;IAEAE,OAAO,GAAGA,OAAO,GAAGA,OAAO,GAAG,CAAC,CAAC;IAEhCC,MAAA,CAAKE,eAAe,GAAGtG,OAAO,CAACmG,OAAO,CAACG,eAAe,CAAC;IAEvDF,MAAA,CAAKG,UAAU,GAAG,IAAI;IAEtBH,MAAA,CAAKI,IAAI,GAAGL,OAAO,CAACM,GAAG,KAAK,KAAK;IACjCL,MAAA,CAAKM,aAAa,GAAGP,OAAO,CAAC3E,YAAY,KAAK,KAAK;IACnD4E,MAAA,CAAKO,KAAK,GAAGR,OAAO,CAACzE,IAAI,KAAK,KAAK;IAEnC0E,MAAA,CAAKjI,OAAO,GAAGgI,OAAO,CAACS,cAAc,CAAC,CAAC;IACvCR,MAAA,CAAKS,QAAQ,GAAGV,OAAO,CAACW,OAAO,IAAI,CAAC;IACpCV,MAAA,CAAKW,QAAQ,GAAGZ,OAAO,CAACa,OAAO,IAAI,CAAC;IAEpCZ,MAAA,CAAKlI,KAAK,GAAGiI,OAAO,CAAC7F,IAAI;IAAC,OAAA8F,MAAA;EAC5B;;EAEA;AACF;AACA;EAFEa,SAAA,CAAAhB,GAAA,EAAAC,cAAA;EAAA,OAAA9H,YAAA,CAAA6H,GAAA;IAAA5H,GAAA;IAAAC,KAAA,EAGA,SAAA0G,OAAOA,CAAA,EAAG;MACR,OAAO,IAAI,CAACwB,IAAI,GAAG,MAAM,GAAG,aAAa;IAC3C;;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EAPE;IAAAnI,GAAA;IAAAC,KAAA,EAQA,SAAA4I,WAAWA,CAACC,MAAM,EAAEhB,OAAO,EAAE;MAC3B,OAAO,IAAIlK,OAAO,CAAC;QACjBmL,QAAQ,EAAE,IAAI,CAAChG,YAAY,CAAC+F,MAAM,EAAEhB,OAAO;MAC7C,CAAC,CAAC;IACJ;;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EAPE;IAAA9H,GAAA;IAAAC,KAAA,EAQA,SAAA+I,YAAYA,CAACF,MAAM,EAAEhB,OAAO,EAAE;MAC5B,IAAIhC,UAAU,GAAG,EAAE;MACnB,IAAMiD,QAAQ,GAAG,IAAI,CAAChG,YAAY,CAAC+F,MAAM,EAAEhB,OAAO,CAAC;MACnD,IAAI,IAAI,CAACG,eAAe,IAAIc,QAAQ,YAAYhL,kBAAkB,EAAE;QAClE+H,UAAU,GAAGiD,QAAQ,CAACvC,kBAAkB,CAAC,CAAC;MAC5C,CAAC,MAAM;QACLV,UAAU,GAAG,CAACiD,QAAQ,CAAC;MACzB;MACA,OAAOjD,UAAU,CAACxB,GAAG,CAAC,UAACyE,QAAQ;QAAA,OAAK,IAAInL,OAAO,CAAC;UAACmL,QAAQ,EAARA;QAAQ,CAAC,CAAC;MAAA,EAAC;IAC9D;;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EAPE;IAAA/I,GAAA;IAAAC,KAAA,EAQA,SAAA8C,YAAYA,CAAC+F,MAAM,EAAEhB,OAAO,EAAE;MAC5B,IAAMzI,IAAI,GAAG4J,WAAW,CAACH,MAAM,CAAC;MAChC,IAAI,CAACzJ,IAAI,EAAE;QACT,OAAO,IAAI;MACb;MAEA,IAAMqD,MAAM,GAAG,IAAItD,SAAS,CAACC,IAAI,CAAC;MAClC,IAAM0J,QAAQ,GAAGrG,MAAM,CAACK,YAAY,CAAC,CAAC;MAEtC,IAAI,CAACmF,UAAU,GAAG7I,IAAI,CAAC,CAAC;MACxByI,OAAO,GAAG,IAAI,CAACoB,cAAc,CAACJ,MAAM,EAAEhB,OAAO,CAAC;MAC9C,IAAI,CAACI,UAAU,GAAG,IAAI,CAAC,CAAC;;MAExB,OAAOpK,4BAA4B,CAACiL,QAAQ,EAAE,KAAK,EAAEjB,OAAO,CAAC;IAC/D;;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;EANE;IAAA9H,GAAA;IAAAC,KAAA,EAOA,SAAAkJ,cAAcA,CAACL,MAAM,EAAE;MACrB,IAAMzJ,IAAI,GAAG,IAAI,CAAC6I,UAAU,IAAIe,WAAW,CAACH,MAAM,CAAC;MACnD,IAAI,CAACzJ,IAAI,EAAE;QACT,OAAOkB,SAAS;MAClB;MAEA,IAAMmC,MAAM,GAAG,IAAItD,SAAS,CAACC,IAAI,CAAC;MAClCqD,MAAM,CAACvB,aAAa,CAAC,CAAC;MAEtB,OACGuB,MAAM,CAACM,OAAO,CAAC,CAAC,IAAIzE,aAAa,CAAC,OAAO,GAAGmE,MAAM,CAACM,OAAO,CAAC,CAAC,CAAC,IAC9DzC,SAAS;IAEb;;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EAPE;IAAAP,GAAA;IAAAC,KAAA,EAQA,SAAAmJ,YAAYA,CAACC,OAAO,EAAEvB,OAAO,EAAE;MAC7B,OAAO,IAAI,CAAC/B,aAAa,CAACsD,OAAO,CAACC,WAAW,CAAC,CAAC,EAAExB,OAAO,CAAC;IAC3D;;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EAPE;IAAA9H,GAAA;IAAAC,KAAA,EAQA,SAAAsJ,aAAaA,CAACC,QAAQ,EAAE1B,OAAO,EAAE;MAC/B,OAAO,IAAI,CAAC/B,aAAa,CACvB,IAAIhI,kBAAkB,CAACyL,QAAQ,CAAClF,GAAG,CAAC,UAACY,CAAC;QAAA,OAAKA,CAAC,CAACoE,WAAW,CAAC,CAAC;MAAA,EAAC,CAAC,EAC5DxB,OACF,CAAC;IACH;;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EAPE;IAAA9H,GAAA;IAAAC,KAAA,EAQA,SAAA8F,aAAaA,CAACgD,QAAQ,EAAEjB,OAAO,EAAE;MAC/BA,OAAO,GAAG,IAAI,CAAC2B,YAAY,CAAC3B,OAAO,CAAC;MAEpC,IAAM4B,MAAM,GAAG,IAAIzG,SAAS,CAAC;QAC3BlB,MAAM,EAAE,IAAI,CAACjC,OAAO;QACpBqD,YAAY,EAAE,IAAI,CAACkF,aAAa;QAChChF,IAAI,EAAE,IAAI,CAACiF,KAAK;QAEhBxE,MAAM,EAAE;UACNF,CAAC,EAAE,IAAI,CAAC4E,QAAQ;UAChB3E,CAAC,EAAE,IAAI,CAAC6E;QACV;MACF,CAAC,CAAC;;MAEF;MACA,IAAIzG,IAAI,GAAGuD,MAAM,CAACC,SAAS,CAAC,IAAI,CAAC5F,KAAK,CAAC,GAAG2F,MAAM,CAAC,IAAI,CAAC3F,KAAK,CAAC,GAAG,IAAI;MACnE,IAAI,IAAI,CAACA,KAAK,KAAK,KAAK,IAAI,CAAC2F,MAAM,CAACC,SAAS,CAAC,IAAI,CAAC5F,KAAK,CAAC,EAAE;QACzD,IAAM8J,cAAc,GAClB7B,OAAO,CAAC6B,cAAc,IAAIpL,aAAa,CAACuJ,OAAO,CAAC6B,cAAc,CAAC;QACjE,IAAIA,cAAc,EAAE;UAClB,IAAMC,IAAI,GAAGD,cAAc,CAACE,OAAO,CAAC,CAAC;UACrC,IAAID,IAAI,CAACE,UAAU,CAAC,OAAO,CAAC,EAAE;YAC5B7H,IAAI,GAAGuD,MAAM,CAACoE,IAAI,CAACG,SAAS,CAAC,CAAC,CAAC,CAAC;UAClC;QACF;MACF;MAEAL,MAAM,CAAC3D,aAAa,CAClBjI,4BAA4B,CAACiL,QAAQ,EAAE,IAAI,EAAEjB,OAAO,CAAC,EACrD7F,IACF,CAAC;MACD,IAAMmF,MAAM,GAAGsC,MAAM,CAAC5C,SAAS,CAAC,CAAC;MAEjC,OAAO,IAAI,CAACqB,IAAI,GAAG6B,eAAe,CAAC5C,MAAM,CAAC,GAAGA,MAAM;IACrD;EAAC;AAAA,EAnLevJ,aAAa;AAsL/B;AACA;AACA;AACA;AACA,SAASmM,eAAeA,CAAC5C,MAAM,EAAE;EAC/B,IAAM/H,IAAI,GAAG,IAAI4K,UAAU,CAAC7C,MAAM,CAAC;EACnC,OAAO8C,KAAK,CAACC,IAAI,CAAC9K,IAAI,CAAC+K,MAAM,CAAC,CAAC,CAAC,CAC7B9F,GAAG,CAAC,UAAC+F,CAAC;IAAA,OAAK,CAACA,CAAC,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,IAAI7E,MAAM,CAAC6E,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,WAAW,CAAC,CAAC;EAAA,EAAC,CACtEvI,IAAI,CAAC,EAAE,CAAC;AACb;;AAEA;AACA;AACA;AACA;AACA,SAASwI,eAAeA,CAACC,IAAI,EAAE;EAC7B,IAAMrD,MAAM,GAAG,IAAI6C,UAAU,CAACQ,IAAI,CAACrF,MAAM,GAAG,CAAC,CAAC;EAC9C,KAAK,IAAIrE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0J,IAAI,CAACrF,MAAM,GAAG,CAAC,EAAErE,CAAC,EAAE,EAAE;IACxCqG,MAAM,CAACrG,CAAC,CAAC,GAAG2J,QAAQ,CAACD,IAAI,CAACE,MAAM,CAAC5J,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC;EACjD;EACA,OAAO,IAAIuG,QAAQ,CAACF,MAAM,CAACA,MAAM,CAAC;AACpC;;AAEA;AACA;AACA;AACA;AACA,SAAS6B,WAAWA,CAACH,MAAM,EAAE;EAC3B,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE;IAC9B,OAAO0B,eAAe,CAAC1B,MAAM,CAAC;EAChC;EACA,IAAIzB,WAAW,CAACuD,MAAM,CAAC9B,MAAM,CAAC,EAAE;IAC9B,IAAIA,MAAM,YAAYxB,QAAQ,EAAE;MAC9B,OAAOwB,MAAM;IACf;IACA,OAAO,IAAIxB,QAAQ,CAACwB,MAAM,CAAC1B,MAAM,EAAE0B,MAAM,CAAC+B,UAAU,EAAE/B,MAAM,CAAC9B,UAAU,CAAC;EAC1E;EACA,IAAI8B,MAAM,YAAYzB,WAAW,EAAE;IACjC,OAAO,IAAIC,QAAQ,CAACwB,MAAM,CAAC;EAC7B;EACA,OAAO,IAAI;AACb;AAEA,eAAelB,GAAG","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}