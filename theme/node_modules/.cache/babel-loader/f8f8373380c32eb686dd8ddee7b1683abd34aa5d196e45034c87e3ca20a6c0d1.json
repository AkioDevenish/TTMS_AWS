{"ast":null,"code":"import _classCallCheck from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _callSuper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _superPropGet from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/superPropGet.js\";\nimport _inherits from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/esnext.iterator.reduce.js\";\nimport \"core-js/modules/esnext.iterator.some.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\n/**\n * @module ol/source/VectorTile\n */\n\nimport EventType from '../events/EventType.js';\nimport Tile from '../VectorTile.js';\nimport TileCache from '../TileCache.js';\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport TileState from '../TileState.js';\nimport UrlTile from './UrlTile.js';\nimport VectorRenderTile from '../VectorRenderTile.js';\nimport { DEFAULT_MAX_ZOOM } from '../tilegrid/common.js';\nimport { buffer as bufferExtent, getIntersection, intersects } from '../extent.js';\nimport { createXYZ, extentFromProjection } from '../tilegrid.js';\nimport { fromKey, getCacheKeyForTileKey, getKeyZXY } from '../tilecoord.js';\nimport { isEmpty } from '../obj.js';\nimport { loadFeaturesXhr } from '../featureloader.js';\nimport { toSize } from '../size.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least twice the number of tiles in the viewport.\n * @property {import(\"../extent.js\").Extent} [extent] Extent.\n * @property {import(\"../format/Feature.js\").default} [format] Feature format for tiles. Used and required by the default.\n * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this\n * to `false` (e.g. for sources with polygons that represent administrative\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n * stroke operations.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection of the tile grid.\n * @property {import(\"./Source.js\").State} [state] Source state.\n * @property {typeof import(\"../VectorTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/VectorTile~VectorTile}.\n * @property {number} [maxZoom=22] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=512] Optional tile size. Not used if `tileGrid` is provided.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction]\n * Optional function to load a tile given a URL. Could look like this for pbf tiles:\n * ```js\n * function(tile, url) {\n *   tile.setLoader(function(extent, resolution, projection) {\n *     fetch(url).then(function(response) {\n *       response.arrayBuffer().then(function(data) {\n *         const format = tile.getFormat() // ol/format/MVT configured as source format\n *         const features = format.readFeatures(data, {\n *           extent: extent,\n *           featureProjection: projection\n *         });\n *         tile.setFeatures(features);\n *       });\n *     });\n *   });\n * }\n * ```\n * If you do not need extent, resolution and projection to get the features for a tile (e.g.\n * for GeoJSON tiles), your `tileLoadFunction` does not need a `setLoader()` call. Only make sure\n * to call `setFeatures()` on the tile:\n * ```js\n * const format = new GeoJSON({featureProjection: map.getView().getProjection()});\n * async function tileLoadFunction(tile, url) {\n *   const response = await fetch(url);\n *   const data = await response.json();\n *   tile.setFeatures(format.readFeatures(data));\n * }\n * ```\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {number} [transition] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * When set to `false`, only one world\n * will be rendered. When set to `true`, tiles will be wrapped horizontally to\n * render multiple worlds.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=1]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Class for layer sources providing vector data divided into a tile grid, to be\n * used with {@link module:ol/layer/VectorTile~VectorTileLayer}. Although this source receives tiles\n * with vector features from the server, it is not meant for feature editing.\n * Features are optimized for rendering, their geometries are clipped at or near\n * tile boundaries and simplified for a view resolution. See\n * {@link module:ol/source/Vector~VectorSource} for vector sources that are suitable for feature\n * editing.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\nvar VectorTile = /*#__PURE__*/function (_UrlTile) {\n  /**\n   * @param {!Options} options Vector tile options.\n   */\n  function VectorTile(options) {\n    var _this;\n    _classCallCheck(this, VectorTile);\n    var projection = options.projection || 'EPSG:3857';\n    var extent = options.extent || extentFromProjection(projection);\n    var tileGrid = options.tileGrid || createXYZ({\n      extent: extent,\n      maxResolution: options.maxResolution,\n      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 22,\n      minZoom: options.minZoom,\n      tileSize: options.tileSize || 512\n    });\n    _this = _callSuper(this, VectorTile, [{\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      cacheSize: options.cacheSize,\n      interpolate: true,\n      opaque: false,\n      projection: projection,\n      state: options.state,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultLoadFunction,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX === undefined ? true : options.wrapX,\n      transition: options.transition,\n      zDirection: options.zDirection === undefined ? 1 : options.zDirection\n    }]);\n\n    /**\n     * @private\n     * @type {import(\"../format/Feature.js\").default|null}\n     */\n    _this.format_ = options.format ? options.format : null;\n\n    /**\n     * @private\n     * @type {TileCache}\n     */\n    _this.sourceTileCache = new TileCache(_this.tileCache.highWaterMark);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;\n\n    /**\n     * @protected\n     * @type {typeof import(\"../VectorTile.js\").default}\n     */\n    _this.tileClass = options.tileClass ? options.tileClass : Tile;\n\n    /**\n     * @private\n     * @type {Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n    _this.tileGrids_ = {};\n    return _this;\n  }\n\n  /**\n   * Get features whose bounding box intersects the provided extent. Only features for cached\n   * tiles for the last rendered zoom level are available in the source. So this method is only\n   * suitable for requesting tiles for extents that are currently rendered.\n   *\n   * Features are returned in random tile order and as they are included in the tiles. This means\n   * they can be clipped, duplicated across tiles, and simplified to the render resolution.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n   * @api\n   */\n  _inherits(VectorTile, _UrlTile);\n  return _createClass(VectorTile, [{\n    key: \"getFeaturesInExtent\",\n    value: function getFeaturesInExtent(extent) {\n      var features = [];\n      var tileCache = this.tileCache;\n      if (tileCache.getCount() === 0) {\n        return features;\n      }\n      var z = fromKey(tileCache.peekFirstKey())[0];\n      var tileGrid = this.tileGrid;\n      tileCache.forEach(function (tile) {\n        if (tile.tileCoord[0] !== z || tile.getState() !== TileState.LOADED) {\n          return;\n        }\n        var sourceTiles = tile.getSourceTiles();\n        for (var i = 0, ii = sourceTiles.length; i < ii; ++i) {\n          var sourceTile = sourceTiles[i];\n          var tileCoord = sourceTile.tileCoord;\n          if (intersects(extent, tileGrid.getTileCoordExtent(tileCoord))) {\n            var tileFeatures = sourceTile.getFeatures();\n            if (tileFeatures) {\n              for (var j = 0, jj = tileFeatures.length; j < jj; ++j) {\n                var candidate = tileFeatures[j];\n                var geometry = candidate.getGeometry();\n                if (intersects(extent, geometry.getExtent())) {\n                  features.push(candidate);\n                }\n              }\n            }\n          }\n        }\n      });\n      return features;\n    }\n\n    /**\n     * @return {boolean} The source can have overlapping geometries.\n     */\n  }, {\n    key: \"getOverlaps\",\n    value: function getOverlaps() {\n      return this.overlaps_;\n    }\n\n    /**\n     * clear {@link module:ol/TileCache~TileCache} and delete all source tiles\n     * @api\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.tileCache.clear();\n      this.sourceTileCache.clear();\n    }\n\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @param {!Object<string, boolean>} usedTiles Used tiles.\n     */\n  }, {\n    key: \"expireCache\",\n    value: function expireCache(projection, usedTiles) {\n      var tileCache = this.getTileCacheForProjection(projection);\n      var usedSourceTiles = Object.keys(usedTiles).reduce(function (acc, key) {\n        var cacheKey = getCacheKeyForTileKey(key);\n        var tile = tileCache.peek(cacheKey);\n        if (tile) {\n          var sourceTiles = tile.sourceTiles;\n          for (var i = 0, ii = sourceTiles.length; i < ii; ++i) {\n            acc[sourceTiles[i].getKey()] = true;\n          }\n        }\n        return acc;\n      }, {});\n      _superPropGet(VectorTile, \"expireCache\", this, 3)([projection, usedTiles]);\n      this.sourceTileCache.expireCache(usedSourceTiles);\n    }\n\n    /**\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../proj/Projection\").default} projection Projection.\n     * @param {VectorRenderTile} tile Vector image tile.\n     * @return {Array<import(\"../VectorTile\").default>} Tile keys.\n     */\n  }, {\n    key: \"getSourceTiles\",\n    value: function getSourceTiles(pixelRatio, projection, tile) {\n      var _this2 = this;\n      if (tile.getState() === TileState.IDLE) {\n        tile.setState(TileState.LOADING);\n        var urlTileCoord = tile.wrappedTileCoord;\n        var tileGrid = this.getTileGridForProjection(projection);\n        var extent = tileGrid.getTileCoordExtent(urlTileCoord);\n        var z = urlTileCoord[0];\n        var resolution = tileGrid.getResolution(z);\n        // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n        bufferExtent(extent, -resolution, extent);\n        var sourceTileGrid = this.tileGrid;\n        var sourceExtent = sourceTileGrid.getExtent();\n        if (sourceExtent) {\n          getIntersection(extent, sourceExtent, extent);\n        }\n        var sourceZ = sourceTileGrid.getZForResolution(resolution, this.zDirection);\n        sourceTileGrid.forEachTileCoord(extent, sourceZ, function (sourceTileCoord) {\n          var tileUrl = _this2.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n          var sourceTile = _this2.sourceTileCache.containsKey(tileUrl) ? _this2.sourceTileCache.get(tileUrl) : new _this2.tileClass(sourceTileCoord, tileUrl ? TileState.IDLE : TileState.EMPTY, tileUrl, _this2.format_, _this2.tileLoadFunction);\n          tile.sourceTiles.push(sourceTile);\n          var sourceTileState = sourceTile.getState();\n          if (sourceTileState < TileState.LOADED) {\n            var _listenChange = function listenChange(event) {\n              _this2.handleTileChange(event);\n              var state = sourceTile.getState();\n              if (state === TileState.LOADED || state === TileState.ERROR) {\n                var sourceTileKey = sourceTile.getKey();\n                if (sourceTileKey in tile.errorTileKeys) {\n                  if (sourceTile.getState() === TileState.LOADED) {\n                    delete tile.errorTileKeys[sourceTileKey];\n                  }\n                } else {\n                  tile.loadingSourceTiles--;\n                }\n                if (state === TileState.ERROR) {\n                  tile.errorTileKeys[sourceTileKey] = true;\n                } else {\n                  sourceTile.removeEventListener(EventType.CHANGE, _listenChange);\n                }\n                if (tile.loadingSourceTiles === 0) {\n                  tile.setState(isEmpty(tile.errorTileKeys) ? TileState.LOADED : TileState.ERROR);\n                }\n              }\n            };\n            sourceTile.addEventListener(EventType.CHANGE, _listenChange);\n            tile.loadingSourceTiles++;\n          }\n          if (sourceTileState === TileState.IDLE) {\n            sourceTile.extent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n            sourceTile.projection = projection;\n            sourceTile.resolution = sourceTileGrid.getResolution(sourceTileCoord[0]);\n            _this2.sourceTileCache.set(tileUrl, sourceTile);\n            sourceTile.load();\n          }\n        });\n        if (!tile.loadingSourceTiles) {\n          tile.setState(tile.sourceTiles.some(function (sourceTile) {\n            return sourceTile.getState() === TileState.ERROR;\n          }) ? TileState.ERROR : TileState.LOADED);\n        }\n      }\n      return tile.sourceTiles;\n    }\n\n    /**\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {!VectorRenderTile} Tile.\n     */\n  }, {\n    key: \"getTile\",\n    value: function getTile(z, x, y, pixelRatio, projection) {\n      var _this3 = this;\n      var coordKey = getKeyZXY(z, x, y);\n      var key = this.getKey();\n      var tile;\n      if (this.tileCache.containsKey(coordKey)) {\n        tile = this.tileCache.get(coordKey);\n        if (tile.key === key) {\n          return tile;\n        }\n      }\n      var tileCoord = [z, x, y];\n      var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);\n      var sourceExtent = this.getTileGrid().getExtent();\n      var tileGrid = this.getTileGridForProjection(projection);\n      if (urlTileCoord && sourceExtent) {\n        var tileExtent = tileGrid.getTileCoordExtent(urlTileCoord);\n        // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n        bufferExtent(tileExtent, -tileGrid.getResolution(z), tileExtent);\n        if (!intersects(sourceExtent, tileExtent)) {\n          urlTileCoord = null;\n        }\n      }\n      var empty = true;\n      if (urlTileCoord !== null) {\n        var sourceTileGrid = this.tileGrid;\n        var resolution = tileGrid.getResolution(z);\n        var sourceZ = sourceTileGrid.getZForResolution(resolution, 1);\n        // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n        var extent = tileGrid.getTileCoordExtent(urlTileCoord);\n        bufferExtent(extent, -resolution, extent);\n        sourceTileGrid.forEachTileCoord(extent, sourceZ, function (sourceTileCoord) {\n          empty = empty && !_this3.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n        });\n      }\n      var newTile = new VectorRenderTile(tileCoord, empty ? TileState.EMPTY : TileState.IDLE, urlTileCoord, this.getSourceTiles.bind(this, pixelRatio, projection));\n      newTile.key = key;\n      if (tile) {\n        newTile.interimTile = tile;\n        newTile.refreshInterimChain();\n        this.tileCache.replace(coordKey, newTile);\n      } else {\n        this.tileCache.set(coordKey, newTile);\n      }\n      return newTile;\n    }\n\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n     */\n  }, {\n    key: \"getTileGridForProjection\",\n    value: function getTileGridForProjection(projection) {\n      var code = projection.getCode();\n      var tileGrid = this.tileGrids_[code];\n      if (!tileGrid) {\n        // A tile grid that matches the tile size of the source tile grid is more\n        // likely to have 1:1 relationships between source tiles and rendered tiles.\n        var sourceTileGrid = this.tileGrid;\n        var resolutions = sourceTileGrid.getResolutions().slice();\n        var origins = resolutions.map(function (resolution, z) {\n          return sourceTileGrid.getOrigin(z);\n        });\n        var tileSizes = resolutions.map(function (resolution, z) {\n          return sourceTileGrid.getTileSize(z);\n        });\n        var length = DEFAULT_MAX_ZOOM + 1;\n        for (var z = resolutions.length; z < length; ++z) {\n          resolutions.push(resolutions[z - 1] / 2);\n          origins.push(origins[z - 1]);\n          tileSizes.push(tileSizes[z - 1]);\n        }\n        tileGrid = new TileGrid({\n          extent: sourceTileGrid.getExtent(),\n          origins: origins,\n          resolutions: resolutions,\n          tileSizes: tileSizes\n        });\n        this.tileGrids_[code] = tileGrid;\n      }\n      return tileGrid;\n    }\n\n    /**\n     * Get the tile pixel ratio for this source.\n     * @param {number} pixelRatio Pixel ratio.\n     * @return {number} Tile pixel ratio.\n     */\n  }, {\n    key: \"getTilePixelRatio\",\n    value: function getTilePixelRatio(pixelRatio) {\n      return pixelRatio;\n    }\n\n    /**\n     * @param {number} z Z.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {import(\"../size.js\").Size} Tile size.\n     */\n  }, {\n    key: \"getTilePixelSize\",\n    value: function getTilePixelSize(z, pixelRatio, projection) {\n      var tileGrid = this.getTileGridForProjection(projection);\n      var tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n      return [Math.round(tileSize[0] * pixelRatio), Math.round(tileSize[1] * pixelRatio)];\n    }\n\n    /**\n     * Increases the cache size if needed\n     * @param {number} tileCount Minimum number of tiles needed.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     */\n  }, {\n    key: \"updateCacheSize\",\n    value: function updateCacheSize(tileCount, projection) {\n      _superPropGet(VectorTile, \"updateCacheSize\", this, 3)([tileCount * 2, projection]);\n      this.sourceTileCache.highWaterMark = this.getTileCacheForProjection(projection).highWaterMark;\n    }\n  }]);\n}(UrlTile);\nexport default VectorTile;\n\n/**\n * Sets the loader for a tile.\n * @param {import(\"../VectorTile.js\").default} tile Vector tile.\n * @param {string} url URL.\n */\nexport function defaultLoadFunction(tile, url) {\n  tile.setLoader(\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  function (extent, resolution, projection) {\n    loadFeaturesXhr(url, tile.getFormat(), extent, resolution, projection, tile.onLoad.bind(tile), tile.onError.bind(tile));\n  });\n}","map":{"version":3,"names":["EventType","Tile","TileCache","TileGrid","TileState","UrlTile","VectorRenderTile","DEFAULT_MAX_ZOOM","buffer","bufferExtent","getIntersection","intersects","createXYZ","extentFromProjection","fromKey","getCacheKeyForTileKey","getKeyZXY","isEmpty","loadFeaturesXhr","toSize","VectorTile","_UrlTile","options","_this","_classCallCheck","projection","extent","tileGrid","maxResolution","maxZoom","undefined","minZoom","tileSize","_callSuper","attributions","attributionsCollapsible","cacheSize","interpolate","opaque","state","tileLoadFunction","defaultLoadFunction","tileUrlFunction","url","urls","wrapX","transition","zDirection","format_","format","sourceTileCache","tileCache","highWaterMark","overlaps_","overlaps","tileClass","tileGrids_","_inherits","_createClass","key","value","getFeaturesInExtent","features","getCount","z","peekFirstKey","forEach","tile","tileCoord","getState","LOADED","sourceTiles","getSourceTiles","i","ii","length","sourceTile","getTileCoordExtent","tileFeatures","getFeatures","j","jj","candidate","geometry","getGeometry","getExtent","push","getOverlaps","clear","expireCache","usedTiles","getTileCacheForProjection","usedSourceTiles","Object","keys","reduce","acc","cacheKey","peek","getKey","_superPropGet","pixelRatio","_this2","IDLE","setState","LOADING","urlTileCoord","wrappedTileCoord","getTileGridForProjection","resolution","getResolution","sourceTileGrid","sourceExtent","sourceZ","getZForResolution","forEachTileCoord","sourceTileCoord","tileUrl","containsKey","get","EMPTY","sourceTileState","listenChange","event","handleTileChange","ERROR","sourceTileKey","errorTileKeys","loadingSourceTiles","removeEventListener","CHANGE","addEventListener","set","load","some","getTile","x","y","_this3","coordKey","getTileCoordForTileUrlFunction","getTileGrid","tileExtent","empty","newTile","bind","interimTile","refreshInterimChain","replace","code","getCode","resolutions","getResolutions","slice","origins","map","getOrigin","tileSizes","getTileSize","getTilePixelRatio","getTilePixelSize","tmpSize","Math","round","updateCacheSize","tileCount","setLoader","getFormat","onLoad","onError"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol/source/VectorTile.js"],"sourcesContent":["/**\n * @module ol/source/VectorTile\n */\n\nimport EventType from '../events/EventType.js';\nimport Tile from '../VectorTile.js';\nimport TileCache from '../TileCache.js';\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport TileState from '../TileState.js';\nimport UrlTile from './UrlTile.js';\nimport VectorRenderTile from '../VectorRenderTile.js';\nimport {DEFAULT_MAX_ZOOM} from '../tilegrid/common.js';\nimport {\n  buffer as bufferExtent,\n  getIntersection,\n  intersects,\n} from '../extent.js';\nimport {createXYZ, extentFromProjection} from '../tilegrid.js';\nimport {fromKey, getCacheKeyForTileKey, getKeyZXY} from '../tilecoord.js';\nimport {isEmpty} from '../obj.js';\nimport {loadFeaturesXhr} from '../featureloader.js';\nimport {toSize} from '../size.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least twice the number of tiles in the viewport.\n * @property {import(\"../extent.js\").Extent} [extent] Extent.\n * @property {import(\"../format/Feature.js\").default} [format] Feature format for tiles. Used and required by the default.\n * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this\n * to `false` (e.g. for sources with polygons that represent administrative\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n * stroke operations.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection of the tile grid.\n * @property {import(\"./Source.js\").State} [state] Source state.\n * @property {typeof import(\"../VectorTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/VectorTile~VectorTile}.\n * @property {number} [maxZoom=22] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=512] Optional tile size. Not used if `tileGrid` is provided.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction]\n * Optional function to load a tile given a URL. Could look like this for pbf tiles:\n * ```js\n * function(tile, url) {\n *   tile.setLoader(function(extent, resolution, projection) {\n *     fetch(url).then(function(response) {\n *       response.arrayBuffer().then(function(data) {\n *         const format = tile.getFormat() // ol/format/MVT configured as source format\n *         const features = format.readFeatures(data, {\n *           extent: extent,\n *           featureProjection: projection\n *         });\n *         tile.setFeatures(features);\n *       });\n *     });\n *   });\n * }\n * ```\n * If you do not need extent, resolution and projection to get the features for a tile (e.g.\n * for GeoJSON tiles), your `tileLoadFunction` does not need a `setLoader()` call. Only make sure\n * to call `setFeatures()` on the tile:\n * ```js\n * const format = new GeoJSON({featureProjection: map.getView().getProjection()});\n * async function tileLoadFunction(tile, url) {\n *   const response = await fetch(url);\n *   const data = await response.json();\n *   tile.setFeatures(format.readFeatures(data));\n * }\n * ```\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {number} [transition] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * When set to `false`, only one world\n * will be rendered. When set to `true`, tiles will be wrapped horizontally to\n * render multiple worlds.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=1]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Class for layer sources providing vector data divided into a tile grid, to be\n * used with {@link module:ol/layer/VectorTile~VectorTileLayer}. Although this source receives tiles\n * with vector features from the server, it is not meant for feature editing.\n * Features are optimized for rendering, their geometries are clipped at or near\n * tile boundaries and simplified for a view resolution. See\n * {@link module:ol/source/Vector~VectorSource} for vector sources that are suitable for feature\n * editing.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\nclass VectorTile extends UrlTile {\n  /**\n   * @param {!Options} options Vector tile options.\n   */\n  constructor(options) {\n    const projection = options.projection || 'EPSG:3857';\n\n    const extent = options.extent || extentFromProjection(projection);\n\n    const tileGrid =\n      options.tileGrid ||\n      createXYZ({\n        extent: extent,\n        maxResolution: options.maxResolution,\n        maxZoom: options.maxZoom !== undefined ? options.maxZoom : 22,\n        minZoom: options.minZoom,\n        tileSize: options.tileSize || 512,\n      });\n\n    super({\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      cacheSize: options.cacheSize,\n      interpolate: true,\n      opaque: false,\n      projection: projection,\n      state: options.state,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction\n        ? options.tileLoadFunction\n        : defaultLoadFunction,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX === undefined ? true : options.wrapX,\n      transition: options.transition,\n      zDirection: options.zDirection === undefined ? 1 : options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {import(\"../format/Feature.js\").default|null}\n     */\n    this.format_ = options.format ? options.format : null;\n\n    /**\n     * @private\n     * @type {TileCache}\n     */\n    this.sourceTileCache = new TileCache(this.tileCache.highWaterMark);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;\n\n    /**\n     * @protected\n     * @type {typeof import(\"../VectorTile.js\").default}\n     */\n    this.tileClass = options.tileClass ? options.tileClass : Tile;\n\n    /**\n     * @private\n     * @type {Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n    this.tileGrids_ = {};\n  }\n\n  /**\n   * Get features whose bounding box intersects the provided extent. Only features for cached\n   * tiles for the last rendered zoom level are available in the source. So this method is only\n   * suitable for requesting tiles for extents that are currently rendered.\n   *\n   * Features are returned in random tile order and as they are included in the tiles. This means\n   * they can be clipped, duplicated across tiles, and simplified to the render resolution.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n   * @api\n   */\n  getFeaturesInExtent(extent) {\n    const features = [];\n    const tileCache = this.tileCache;\n    if (tileCache.getCount() === 0) {\n      return features;\n    }\n    const z = fromKey(tileCache.peekFirstKey())[0];\n    const tileGrid = this.tileGrid;\n    tileCache.forEach(function (tile) {\n      if (tile.tileCoord[0] !== z || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n      const sourceTiles = tile.getSourceTiles();\n      for (let i = 0, ii = sourceTiles.length; i < ii; ++i) {\n        const sourceTile = sourceTiles[i];\n        const tileCoord = sourceTile.tileCoord;\n        if (intersects(extent, tileGrid.getTileCoordExtent(tileCoord))) {\n          const tileFeatures = sourceTile.getFeatures();\n          if (tileFeatures) {\n            for (let j = 0, jj = tileFeatures.length; j < jj; ++j) {\n              const candidate = tileFeatures[j];\n              const geometry = candidate.getGeometry();\n              if (intersects(extent, geometry.getExtent())) {\n                features.push(candidate);\n              }\n            }\n          }\n        }\n      }\n    });\n    return features;\n  }\n\n  /**\n   * @return {boolean} The source can have overlapping geometries.\n   */\n  getOverlaps() {\n    return this.overlaps_;\n  }\n\n  /**\n   * clear {@link module:ol/TileCache~TileCache} and delete all source tiles\n   * @api\n   */\n  clear() {\n    this.tileCache.clear();\n    this.sourceTileCache.clear();\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n  expireCache(projection, usedTiles) {\n    const tileCache = this.getTileCacheForProjection(projection);\n    const usedSourceTiles = Object.keys(usedTiles).reduce((acc, key) => {\n      const cacheKey = getCacheKeyForTileKey(key);\n      const tile = tileCache.peek(cacheKey);\n      if (tile) {\n        const sourceTiles = tile.sourceTiles;\n        for (let i = 0, ii = sourceTiles.length; i < ii; ++i) {\n          acc[sourceTiles[i].getKey()] = true;\n        }\n      }\n      return acc;\n    }, {});\n    super.expireCache(projection, usedTiles);\n    this.sourceTileCache.expireCache(usedSourceTiles);\n  }\n\n  /**\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection\").default} projection Projection.\n   * @param {VectorRenderTile} tile Vector image tile.\n   * @return {Array<import(\"../VectorTile\").default>} Tile keys.\n   */\n  getSourceTiles(pixelRatio, projection, tile) {\n    if (tile.getState() === TileState.IDLE) {\n      tile.setState(TileState.LOADING);\n      const urlTileCoord = tile.wrappedTileCoord;\n      const tileGrid = this.getTileGridForProjection(projection);\n      const extent = tileGrid.getTileCoordExtent(urlTileCoord);\n      const z = urlTileCoord[0];\n      const resolution = tileGrid.getResolution(z);\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n      bufferExtent(extent, -resolution, extent);\n      const sourceTileGrid = this.tileGrid;\n      const sourceExtent = sourceTileGrid.getExtent();\n      if (sourceExtent) {\n        getIntersection(extent, sourceExtent, extent);\n      }\n      const sourceZ = sourceTileGrid.getZForResolution(\n        resolution,\n        this.zDirection\n      );\n\n      sourceTileGrid.forEachTileCoord(extent, sourceZ, (sourceTileCoord) => {\n        const tileUrl = this.tileUrlFunction(\n          sourceTileCoord,\n          pixelRatio,\n          projection\n        );\n        const sourceTile = this.sourceTileCache.containsKey(tileUrl)\n          ? this.sourceTileCache.get(tileUrl)\n          : new this.tileClass(\n              sourceTileCoord,\n              tileUrl ? TileState.IDLE : TileState.EMPTY,\n              tileUrl,\n              this.format_,\n              this.tileLoadFunction\n            );\n        tile.sourceTiles.push(sourceTile);\n        const sourceTileState = sourceTile.getState();\n        if (sourceTileState < TileState.LOADED) {\n          const listenChange = (event) => {\n            this.handleTileChange(event);\n            const state = sourceTile.getState();\n            if (state === TileState.LOADED || state === TileState.ERROR) {\n              const sourceTileKey = sourceTile.getKey();\n              if (sourceTileKey in tile.errorTileKeys) {\n                if (sourceTile.getState() === TileState.LOADED) {\n                  delete tile.errorTileKeys[sourceTileKey];\n                }\n              } else {\n                tile.loadingSourceTiles--;\n              }\n              if (state === TileState.ERROR) {\n                tile.errorTileKeys[sourceTileKey] = true;\n              } else {\n                sourceTile.removeEventListener(EventType.CHANGE, listenChange);\n              }\n              if (tile.loadingSourceTiles === 0) {\n                tile.setState(\n                  isEmpty(tile.errorTileKeys)\n                    ? TileState.LOADED\n                    : TileState.ERROR\n                );\n              }\n            }\n          };\n          sourceTile.addEventListener(EventType.CHANGE, listenChange);\n          tile.loadingSourceTiles++;\n        }\n        if (sourceTileState === TileState.IDLE) {\n          sourceTile.extent =\n            sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n          sourceTile.projection = projection;\n          sourceTile.resolution = sourceTileGrid.getResolution(\n            sourceTileCoord[0]\n          );\n          this.sourceTileCache.set(tileUrl, sourceTile);\n          sourceTile.load();\n        }\n      });\n      if (!tile.loadingSourceTiles) {\n        tile.setState(\n          tile.sourceTiles.some(\n            (sourceTile) => sourceTile.getState() === TileState.ERROR\n          )\n            ? TileState.ERROR\n            : TileState.LOADED\n        );\n      }\n    }\n\n    return tile.sourceTiles;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!VectorRenderTile} Tile.\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const coordKey = getKeyZXY(z, x, y);\n    const key = this.getKey();\n    let tile;\n    if (this.tileCache.containsKey(coordKey)) {\n      tile = this.tileCache.get(coordKey);\n      if (tile.key === key) {\n        return tile;\n      }\n    }\n    const tileCoord = [z, x, y];\n    let urlTileCoord = this.getTileCoordForTileUrlFunction(\n      tileCoord,\n      projection\n    );\n    const sourceExtent = this.getTileGrid().getExtent();\n    const tileGrid = this.getTileGridForProjection(projection);\n    if (urlTileCoord && sourceExtent) {\n      const tileExtent = tileGrid.getTileCoordExtent(urlTileCoord);\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n      bufferExtent(tileExtent, -tileGrid.getResolution(z), tileExtent);\n      if (!intersects(sourceExtent, tileExtent)) {\n        urlTileCoord = null;\n      }\n    }\n    let empty = true;\n    if (urlTileCoord !== null) {\n      const sourceTileGrid = this.tileGrid;\n      const resolution = tileGrid.getResolution(z);\n      const sourceZ = sourceTileGrid.getZForResolution(resolution, 1);\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n      const extent = tileGrid.getTileCoordExtent(urlTileCoord);\n      bufferExtent(extent, -resolution, extent);\n      sourceTileGrid.forEachTileCoord(extent, sourceZ, (sourceTileCoord) => {\n        empty =\n          empty &&\n          !this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n      });\n    }\n    const newTile = new VectorRenderTile(\n      tileCoord,\n      empty ? TileState.EMPTY : TileState.IDLE,\n      urlTileCoord,\n      this.getSourceTiles.bind(this, pixelRatio, projection)\n    );\n\n    newTile.key = key;\n    if (tile) {\n      newTile.interimTile = tile;\n      newTile.refreshInterimChain();\n      this.tileCache.replace(coordKey, newTile);\n    } else {\n      this.tileCache.set(coordKey, newTile);\n    }\n    return newTile;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   */\n  getTileGridForProjection(projection) {\n    const code = projection.getCode();\n    let tileGrid = this.tileGrids_[code];\n    if (!tileGrid) {\n      // A tile grid that matches the tile size of the source tile grid is more\n      // likely to have 1:1 relationships between source tiles and rendered tiles.\n      const sourceTileGrid = this.tileGrid;\n      const resolutions = sourceTileGrid.getResolutions().slice();\n      const origins = resolutions.map(function (resolution, z) {\n        return sourceTileGrid.getOrigin(z);\n      });\n      const tileSizes = resolutions.map(function (resolution, z) {\n        return sourceTileGrid.getTileSize(z);\n      });\n      const length = DEFAULT_MAX_ZOOM + 1;\n      for (let z = resolutions.length; z < length; ++z) {\n        resolutions.push(resolutions[z - 1] / 2);\n        origins.push(origins[z - 1]);\n        tileSizes.push(tileSizes[z - 1]);\n      }\n      tileGrid = new TileGrid({\n        extent: sourceTileGrid.getExtent(),\n        origins: origins,\n        resolutions: resolutions,\n        tileSizes: tileSizes,\n      });\n      this.tileGrids_[code] = tileGrid;\n    }\n    return tileGrid;\n  }\n\n  /**\n   * Get the tile pixel ratio for this source.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   */\n  getTilePixelRatio(pixelRatio) {\n    return pixelRatio;\n  }\n\n  /**\n   * @param {number} z Z.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../size.js\").Size} Tile size.\n   */\n  getTilePixelSize(z, pixelRatio, projection) {\n    const tileGrid = this.getTileGridForProjection(projection);\n    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n    return [\n      Math.round(tileSize[0] * pixelRatio),\n      Math.round(tileSize[1] * pixelRatio),\n    ];\n  }\n\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  updateCacheSize(tileCount, projection) {\n    super.updateCacheSize(tileCount * 2, projection);\n    this.sourceTileCache.highWaterMark =\n      this.getTileCacheForProjection(projection).highWaterMark;\n  }\n}\n\nexport default VectorTile;\n\n/**\n * Sets the loader for a tile.\n * @param {import(\"../VectorTile.js\").default} tile Vector tile.\n * @param {string} url URL.\n */\nexport function defaultLoadFunction(tile, url) {\n  tile.setLoader(\n    /**\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} resolution Resolution.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     */\n    function (extent, resolution, projection) {\n      loadFeaturesXhr(\n        url,\n        tile.getFormat(),\n        extent,\n        resolution,\n        projection,\n        tile.onLoad.bind(tile),\n        tile.onError.bind(tile)\n      );\n    }\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}