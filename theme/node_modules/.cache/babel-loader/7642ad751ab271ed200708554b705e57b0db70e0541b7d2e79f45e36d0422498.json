{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.parse-int.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport { getDistance as ol_sphere_getDistance } from 'ol/sphere.js';\nimport { transform as ol_proj_transform } from 'ol/proj.js';\n\n/** Compute great circle bearing of two points.\r\n * @See http://www.movable-type.co.uk/scripts/latlong.html for the original code\r\n * @param {ol.coordinate} origin origin in lonlat\r\n * @param {ol.coordinate} destination destination in lonlat\r\n * @return {number} bearing angle in radian\r\n */\nvar ol_sphere_greatCircleBearing = function ol_sphere_greatCircleBearing(origin, destination) {\n  var toRad = Math.PI / 180;\n  var ori = [origin[0] * toRad, origin[1] * toRad];\n  var dest = [destination[0] * toRad, destination[1] * toRad];\n  var bearing = Math.atan2(Math.sin(dest[0] - ori[0]) * Math.cos(dest[1]), Math.cos(ori[1]) * Math.sin(dest[1]) - Math.sin(ori[1]) * Math.cos(dest[1]) * Math.cos(dest[0] - ori[0]));\n  return bearing;\n};\nexport { ol_sphere_greatCircleBearing as greatCircleBearing };\n\n/** \r\n * Computes the destination point given an initial point, a distance and a bearing\r\n * @See http://www.movable-type.co.uk/scripts/latlong.html for the original code\r\n * @param {ol.coordinate} origin stating point in lonlat coords\r\n * @param {number} distance\r\n * @param {number} bearing bearing angle in radian\r\n * @param {*} options\r\n *  @param {booelan} normalize normalize longitude beetween -180/180, deafulet true\r\n *  @param {number|undefined} options.radius sphere radius, default 6371008.8\r\n */\nvar ol_sphere_computeDestinationPoint = function ol_sphere_computeDestinationPoint(origin, distance, bearing, options) {\n  options = options || {};\n  var toRad = Math.PI / 180;\n  var radius = options.radius || 6371008.8;\n  var phi1 = origin[1] * toRad;\n  var lambda1 = origin[0] * toRad;\n  var delta = distance / radius;\n  var phi2 = Math.asin(Math.sin(phi1) * Math.cos(delta) + Math.cos(phi1) * Math.sin(delta) * Math.cos(bearing));\n  var lambda2 = lambda1 + Math.atan2(Math.sin(bearing) * Math.sin(delta) * Math.cos(phi1), Math.cos(delta) - Math.sin(phi1) * Math.sin(phi2));\n  var lon = lambda2 / toRad;\n  // normalise to >=-180 and <=180° \n  if (options.normalize !== false && (lon < -180 || lon > 180)) {\n    lon = lon * 540 % 360 - 180;\n  }\n  return [lon, phi2 / toRad];\n};\nexport { ol_sphere_computeDestinationPoint as computeDestinationPoint };\n\n/** Calculate a track along the great circle given an origin and a destination\r\n * @param {ol.coordinate} origin origin in lonlat\r\n * @param {ol.coordinate} destination destination in lonlat\r\n * @param {number} distance distance between point along the track in meter, default 1km (1000)\r\n * @param {number|undefined} radius sphere radius, default 6371008.8\r\n * @return {Array<ol.coordinate>}\r\n */\nvar ol_sphere_greatCircleTrack = function ol_sphere_greatCircleTrack(origin, destination, options) {\n  options = options || {};\n  var bearing = ol_sphere_greatCircleBearing(origin, destination);\n  var dist = ol_sphere_getDistance(origin, destination, options.radius);\n  var distance = options.distance || 1000;\n  var d = distance;\n  var geom = [origin];\n  while (d < dist) {\n    geom.push(ol_sphere_computeDestinationPoint(origin, d, bearing, {\n      radius: options.radius,\n      normalize: false\n    }));\n    d += distance;\n  }\n  var pt = ol_sphere_computeDestinationPoint(origin, dist, bearing, {\n    radius: options.radius,\n    normalize: false\n  });\n  if (Math.abs(pt[0] - destination[0]) > 1) {\n    if (pt[0] > destination[0]) destination[0] += 360;else destination[0] -= 360;\n  }\n  geom.push(destination);\n  return geom;\n};\nexport { ol_sphere_greatCircleTrack as greatCircleTrack };\n\n/** Get map scale factor\r\n * @param {ol_Map} map\r\n * @param {number} [dpi=96] dpi, default 96\r\n * @return {number}\r\n */\nvar ol_sphere_getMapScale = function ol_sphere_getMapScale(map, dpi) {\n  var view = map.getView();\n  var proj = view.getProjection();\n  var center = view.getCenter();\n  var px = map.getPixelFromCoordinate(center);\n  px[1] += 1;\n  var coord = map.getCoordinateFromPixel(px);\n  var d = ol_sphere_getDistance(ol_proj_transform(center, proj, 'EPSG:4326'), ol_proj_transform(coord, proj, 'EPSG:4326'));\n  d *= (dpi || 96) / .0254;\n  return d;\n};\nexport { ol_sphere_getMapScale as getMapScale };\n\n/** Set map scale factor\r\n * @param {ol_Map} map\r\n * @param {number|string} scale the scale factor or a scale string as 1/xxx\r\n * @param {number} [dpi=96] dpi, default 96\r\n * @return {number} scale factor\r\n */\nvar ol_sphere_setMapScale = function ol_sphere_setMapScale(map, scale, dpi) {\n  if (map && scale) {\n    var fac = scale;\n    if (typeof scale === 'string') {\n      scale = scale.replace(':', '/').split('/');\n      fac = scale[1];\n      if (!fac) fac = scale[0] || '';\n      fac = fac.replace(/[^\\d]/g, '');\n      fac = parseInt(fac);\n      if (scale[1]) {\n        var num = parseInt(scale[0]);\n        if (num) fac /= num;\n      }\n    }\n    if (!fac) return;\n    // Calculate new resolution\n    var view = map.getView();\n    var proj = view.getProjection();\n    var center = view.getCenter();\n    var px = map.getPixelFromCoordinate(center);\n    px[1] += 1;\n    var coord = map.getCoordinateFromPixel(px);\n    var d = ol_sphere_getDistance(ol_proj_transform(center, proj, 'EPSG:4326'), ol_proj_transform(coord, proj, 'EPSG:4326'));\n    d *= (dpi || 96) / .0254;\n    view.setResolution(view.getResolution() * fac / d);\n    return fac;\n  }\n};\nexport { ol_sphere_setMapScale as setMapScale };","map":{"version":3,"names":["getDistance","ol_sphere_getDistance","transform","ol_proj_transform","ol_sphere_greatCircleBearing","origin","destination","toRad","Math","PI","ori","dest","bearing","atan2","sin","cos","greatCircleBearing","ol_sphere_computeDestinationPoint","distance","options","radius","phi1","lambda1","delta","phi2","asin","lambda2","lon","normalize","computeDestinationPoint","ol_sphere_greatCircleTrack","dist","d","geom","push","pt","abs","greatCircleTrack","ol_sphere_getMapScale","map","dpi","view","getView","proj","getProjection","center","getCenter","px","getPixelFromCoordinate","coord","getCoordinateFromPixel","getMapScale","ol_sphere_setMapScale","scale","fac","replace","split","parseInt","num","setResolution","getResolution","setMapScale"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol-ext/geom/sphere.js"],"sourcesContent":["import {getDistance as ol_sphere_getDistance} from 'ol/sphere.js'\r\nimport {transform as ol_proj_transform} from 'ol/proj.js'\r\n\r\n/** Compute great circle bearing of two points.\r\n * @See http://www.movable-type.co.uk/scripts/latlong.html for the original code\r\n * @param {ol.coordinate} origin origin in lonlat\r\n * @param {ol.coordinate} destination destination in lonlat\r\n * @return {number} bearing angle in radian\r\n */\r\nvar ol_sphere_greatCircleBearing = function(origin, destination) {\r\n  var toRad = Math.PI/180;\r\n  var ori = [ origin[0]*toRad, origin[1]*toRad ];\r\n  var dest = [ destination[0]*toRad, destination[1]*toRad ];\r\n\r\n  var bearing = Math.atan2(\r\n    Math.sin(dest[0] - ori[0]) * Math.cos(dest[1]),\r\n    Math.cos(ori[1]) * Math.sin(dest[1]) - Math.sin(ori[1]) * Math.cos(dest[1]) * Math.cos(dest[0] - ori[0])\r\n  );\r\n  return bearing;\r\n};\r\n\r\nexport {ol_sphere_greatCircleBearing as greatCircleBearing}\r\n\r\n/** \r\n * Computes the destination point given an initial point, a distance and a bearing\r\n * @See http://www.movable-type.co.uk/scripts/latlong.html for the original code\r\n * @param {ol.coordinate} origin stating point in lonlat coords\r\n * @param {number} distance\r\n * @param {number} bearing bearing angle in radian\r\n * @param {*} options\r\n *  @param {booelan} normalize normalize longitude beetween -180/180, deafulet true\r\n *  @param {number|undefined} options.radius sphere radius, default 6371008.8\r\n */\r\nvar ol_sphere_computeDestinationPoint = function(origin, distance, bearing, options) {\r\n  options = options || {};\r\n  var toRad = Math.PI/180;\r\n  var radius = options.radius || 6371008.8;\r\n\r\n  var phi1 = origin[1] * toRad;\r\n  var lambda1 = origin[0] * toRad;\r\n  var delta = distance / radius;\r\n\r\n  var phi2 = Math.asin(\r\n    Math.sin(phi1) * Math.cos(delta) +\r\n    Math.cos(phi1) * Math.sin(delta) * Math.cos(bearing)\r\n  );\r\n\r\n  var lambda2 = lambda1 +\r\n    Math.atan2(\r\n      Math.sin(bearing) * Math.sin(delta) * Math.cos(phi1),\r\n      Math.cos(delta) - Math.sin(phi1) * Math.sin(phi2)\r\n    );\r\n\r\n  var lon = lambda2 / toRad;\r\n  // normalise to >=-180 and <=180° \r\n  if (options.normalize!==false && (lon < -180 || lon > 180)) {\r\n    lon = ((lon * 540) % 360) - 180;\r\n  }\r\n\r\n  return [ lon, phi2 / toRad ];\r\n};\r\n\r\nexport {ol_sphere_computeDestinationPoint as computeDestinationPoint}\r\n\r\n/** Calculate a track along the great circle given an origin and a destination\r\n * @param {ol.coordinate} origin origin in lonlat\r\n * @param {ol.coordinate} destination destination in lonlat\r\n * @param {number} distance distance between point along the track in meter, default 1km (1000)\r\n * @param {number|undefined} radius sphere radius, default 6371008.8\r\n * @return {Array<ol.coordinate>}\r\n */\r\nvar ol_sphere_greatCircleTrack = function(origin, destination, options) {\r\n  options = options || {};\r\n  var bearing = ol_sphere_greatCircleBearing(origin, destination);\r\n  var dist = ol_sphere_getDistance(origin, destination, options.radius);\r\n  var distance = options.distance || 1000;\r\n  var d = distance;\r\n  var geom = [origin];\r\n  while (d < dist) {\r\n    geom.push(ol_sphere_computeDestinationPoint(origin, d, bearing, { radius: options.radius, normalize: false }));\r\n    d += distance;\r\n  }\r\n  var pt = ol_sphere_computeDestinationPoint(origin, dist, bearing, { radius: options.radius, normalize: false });\r\n  if (Math.abs(pt[0]-destination[0]) > 1) {\r\n    if (pt[0] > destination[0]) destination[0] += 360;\r\n    else destination[0] -= 360;\r\n  } \r\n  geom.push(destination);\r\n  return geom;\r\n};\r\n\r\nexport {ol_sphere_greatCircleTrack as greatCircleTrack}\r\n\r\n/** Get map scale factor\r\n * @param {ol_Map} map\r\n * @param {number} [dpi=96] dpi, default 96\r\n * @return {number}\r\n */\r\nvar ol_sphere_getMapScale = function (map, dpi) {\r\n  var view = map.getView();\r\n  var proj = view.getProjection();\r\n  var center = view.getCenter();\r\n  var px = map.getPixelFromCoordinate(center);\r\n  px[1] += 1;\r\n  var coord = map.getCoordinateFromPixel(px);\r\n  var d = ol_sphere_getDistance(\r\n    ol_proj_transform(center, proj, 'EPSG:4326'),\r\n    ol_proj_transform(coord, proj, 'EPSG:4326'));\r\n  d *= (dpi||96) /.0254\r\n  return d;\r\n};\r\nexport {ol_sphere_getMapScale as getMapScale}\r\n\r\n/** Set map scale factor\r\n * @param {ol_Map} map\r\n * @param {number|string} scale the scale factor or a scale string as 1/xxx\r\n * @param {number} [dpi=96] dpi, default 96\r\n * @return {number} scale factor\r\n */\r\nvar ol_sphere_setMapScale = function (map, scale, dpi) {\r\n  if (map && scale) {\r\n    var fac = scale;\r\n    if (typeof(scale)==='string') {\r\n      scale = scale.replace(':','/').split('/');\r\n      fac = scale[1];\r\n      if (!fac) fac = scale[0] || '';\r\n      fac = fac.replace(/[^\\d]/g,'');\r\n      fac = parseInt(fac);\r\n      if (scale[1]) {\r\n        var num = parseInt(scale[0]);\r\n        if (num) fac /= num;\r\n      }\r\n    }\r\n    if (!fac) return;\r\n    // Calculate new resolution\r\n    var view = map.getView();\r\n    var proj = view.getProjection();\r\n    var center = view.getCenter();\r\n    var px = map.getPixelFromCoordinate(center);\r\n    px[1] += 1;\r\n    var coord = map.getCoordinateFromPixel(px);\r\n    var d = ol_sphere_getDistance(\r\n      ol_proj_transform(center, proj, 'EPSG:4326'),\r\n      ol_proj_transform(coord, proj, 'EPSG:4326'));\r\n    d *= (dpi || 96) /.0254\r\n    view.setResolution(view.getResolution()*fac/d);\r\n    return fac;\r\n  }\r\n};\r\nexport {ol_sphere_setMapScale as setMapScale}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}