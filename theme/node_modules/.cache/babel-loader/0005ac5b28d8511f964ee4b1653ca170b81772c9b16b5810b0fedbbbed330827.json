{"ast":null,"code":"import \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.array-buffer.constructor.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.data-view.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.reduce.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/**\n * @module ol/render/webgl/renderinstructions\n */\nimport { apply as applyTransform } from '../../transform.js';\nimport { transform2D } from '../../geom/flat/transform.js';\n\n/**\n * @param {Float32Array} renderInstructions Render instructions\n * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes\n * @param {import(\"./MixedGeometryBatch.js\").GeometryBatchItem} batchEntry Batch item\n * @param {number} currentIndex Current index\n * @return {number} The amount of values pushed\n */\nfunction pushCustomAttributesInRenderInstructions(renderInstructions, customAttributes, batchEntry, currentIndex) {\n  var shift = 0;\n  for (var key in customAttributes) {\n    var _value$;\n    var attr = customAttributes[key];\n    var value = attr.callback.call(batchEntry, batchEntry.feature);\n    renderInstructions[currentIndex + shift++] = (_value$ = value[0]) !== null && _value$ !== void 0 ? _value$ : value;\n    if (!attr.size || attr.size === 1) {\n      continue;\n    }\n    renderInstructions[currentIndex + shift++] = value[1];\n    if (attr.size < 3) {\n      continue;\n    }\n    renderInstructions[currentIndex + shift++] = value[2];\n    if (attr.size < 4) {\n      continue;\n    }\n    renderInstructions[currentIndex + shift++] = value[3];\n  }\n  return shift;\n}\n\n/**\n * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes\n * @return {number} Cumulated size of all attributes\n */\nexport function getCustomAttributesSize(customAttributes) {\n  return Object.keys(customAttributes).reduce(function (prev, curr) {\n    return prev + (customAttributes[curr].size || 1);\n  }, 0);\n}\n\n/**\n * Render instructions for lines are structured like so:\n * [ x0, y0, customAttr0, ... , xN, yN, customAttrN ]\n * @param {import(\"./MixedGeometryBatch.js\").PointGeometryBatch} batch Point geometry batch\n * @param {Float32Array} renderInstructions Render instructions\n * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes\n * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n * @return {Float32Array} Generated render instructions\n */\nexport function generatePointRenderInstructions(batch, renderInstructions, customAttributes, transform) {\n  // here we anticipate the amount of render instructions for points:\n  // 2 instructions per vertex for position (x and y)\n  // + 1 instruction per vertex per custom attributes\n  var totalInstructionsCount = (2 + getCustomAttributesSize(customAttributes)) * batch.geometriesCount;\n  if (!renderInstructions || renderInstructions.length !== totalInstructionsCount) {\n    renderInstructions = new Float32Array(totalInstructionsCount);\n  }\n\n  // loop on features to fill the render instructions\n  var tmpCoords = [];\n  var renderIndex = 0;\n  for (var featureUid in batch.entries) {\n    var batchEntry = batch.entries[featureUid];\n    for (var i = 0, ii = batchEntry.flatCoordss.length; i < ii; i++) {\n      tmpCoords[0] = batchEntry.flatCoordss[i][0];\n      tmpCoords[1] = batchEntry.flatCoordss[i][1];\n      applyTransform(transform, tmpCoords);\n      renderInstructions[renderIndex++] = tmpCoords[0];\n      renderInstructions[renderIndex++] = tmpCoords[1];\n      renderIndex += pushCustomAttributesInRenderInstructions(renderInstructions, customAttributes, batchEntry, renderIndex);\n    }\n  }\n  return renderInstructions;\n}\n\n/**\n * Render instructions for lines are structured like so:\n * [ customAttr0, ... , customAttrN, numberOfVertices0, x0, y0, ... , xN, yN, numberOfVertices1, ... ]\n * @param {import(\"./MixedGeometryBatch.js\").LineStringGeometryBatch} batch Line String geometry batch\n * @param {Float32Array} renderInstructions Render instructions\n * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes\n * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n * @return {Float32Array} Generated render instructions\n */\nexport function generateLineStringRenderInstructions(batch, renderInstructions, customAttributes, transform) {\n  // here we anticipate the amount of render instructions for lines:\n  // 2 instructions per vertex for position (x and y)\n  // + 1 instruction per line per custom attributes\n  // + 1 instruction per line (for vertices count)\n  var totalInstructionsCount = 2 * batch.verticesCount + (1 + getCustomAttributesSize(customAttributes)) * batch.geometriesCount;\n  if (!renderInstructions || renderInstructions.length !== totalInstructionsCount) {\n    renderInstructions = new Float32Array(totalInstructionsCount);\n  }\n\n  // loop on features to fill the render instructions\n  var flatCoords = [];\n  var renderIndex = 0;\n  for (var featureUid in batch.entries) {\n    var batchEntry = batch.entries[featureUid];\n    for (var i = 0, ii = batchEntry.flatCoordss.length; i < ii; i++) {\n      flatCoords.length = batchEntry.flatCoordss[i].length;\n      transform2D(batchEntry.flatCoordss[i], 0, flatCoords.length, 2, transform, flatCoords);\n      renderIndex += pushCustomAttributesInRenderInstructions(renderInstructions, customAttributes, batchEntry, renderIndex);\n\n      // vertices count\n      renderInstructions[renderIndex++] = flatCoords.length / 2;\n\n      // looping on points for positions\n      for (var j = 0, jj = flatCoords.length; j < jj; j += 2) {\n        renderInstructions[renderIndex++] = flatCoords[j];\n        renderInstructions[renderIndex++] = flatCoords[j + 1];\n      }\n    }\n  }\n  return renderInstructions;\n}\n\n/**\n * Render instructions for polygons are structured like so:\n * [ customAttr0, ..., customAttrN, numberOfRings, numberOfVerticesInRing0, ..., numberOfVerticesInRingN, x0, y0, ..., xN, yN, numberOfRings,... ]\n * @param {import(\"./MixedGeometryBatch.js\").PolygonGeometryBatch} batch Polygon geometry batch\n * @param {Float32Array} renderInstructions Render instructions\n * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes\n * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n * @return {Float32Array} Generated render instructions\n */\nexport function generatePolygonRenderInstructions(batch, renderInstructions, customAttributes, transform) {\n  // here we anticipate the amount of render instructions for polygons:\n  // 2 instructions per vertex for position (x and y)\n  // + 1 instruction per polygon per custom attributes\n  // + 1 instruction per polygon (for vertices count in polygon)\n  // + 1 instruction per ring (for vertices count in ring)\n  var totalInstructionsCount = 2 * batch.verticesCount + (1 + getCustomAttributesSize(customAttributes)) * batch.geometriesCount + batch.ringsCount;\n  if (!renderInstructions || renderInstructions.length !== totalInstructionsCount) {\n    renderInstructions = new Float32Array(totalInstructionsCount);\n  }\n\n  // loop on features to fill the render instructions\n  var flatCoords = [];\n  var renderIndex = 0;\n  for (var featureUid in batch.entries) {\n    var batchEntry = batch.entries[featureUid];\n    for (var i = 0, ii = batchEntry.flatCoordss.length; i < ii; i++) {\n      flatCoords.length = batchEntry.flatCoordss[i].length;\n      transform2D(batchEntry.flatCoordss[i], 0, flatCoords.length, 2, transform, flatCoords);\n      renderIndex += pushCustomAttributesInRenderInstructions(renderInstructions, customAttributes, batchEntry, renderIndex);\n\n      // ring count\n      renderInstructions[renderIndex++] = batchEntry.ringsVerticesCounts[i].length;\n\n      // vertices count in each ring\n      for (var j = 0, jj = batchEntry.ringsVerticesCounts[i].length; j < jj; j++) {\n        renderInstructions[renderIndex++] = batchEntry.ringsVerticesCounts[i][j];\n      }\n\n      // looping on points for positions\n      for (var _j = 0, _jj = flatCoords.length; _j < _jj; _j += 2) {\n        renderInstructions[renderIndex++] = flatCoords[_j];\n        renderInstructions[renderIndex++] = flatCoords[_j + 1];\n      }\n    }\n  }\n  return renderInstructions;\n}","map":{"version":3,"names":["apply","applyTransform","transform2D","pushCustomAttributesInRenderInstructions","renderInstructions","customAttributes","batchEntry","currentIndex","shift","key","_value$","attr","value","callback","call","feature","size","getCustomAttributesSize","Object","keys","reduce","prev","curr","generatePointRenderInstructions","batch","transform","totalInstructionsCount","geometriesCount","length","Float32Array","tmpCoords","renderIndex","featureUid","entries","i","ii","flatCoordss","generateLineStringRenderInstructions","verticesCount","flatCoords","j","jj","generatePolygonRenderInstructions","ringsCount","ringsVerticesCounts"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol/render/webgl/renderinstructions.js"],"sourcesContent":["/**\n * @module ol/render/webgl/renderinstructions\n */\nimport {apply as applyTransform} from '../../transform.js';\nimport {transform2D} from '../../geom/flat/transform.js';\n\n/**\n * @param {Float32Array} renderInstructions Render instructions\n * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes\n * @param {import(\"./MixedGeometryBatch.js\").GeometryBatchItem} batchEntry Batch item\n * @param {number} currentIndex Current index\n * @return {number} The amount of values pushed\n */\nfunction pushCustomAttributesInRenderInstructions(\n  renderInstructions,\n  customAttributes,\n  batchEntry,\n  currentIndex\n) {\n  let shift = 0;\n  for (const key in customAttributes) {\n    const attr = customAttributes[key];\n    const value = attr.callback.call(batchEntry, batchEntry.feature);\n    renderInstructions[currentIndex + shift++] = value[0] ?? value;\n    if (!attr.size || attr.size === 1) {\n      continue;\n    }\n    renderInstructions[currentIndex + shift++] = value[1];\n    if (attr.size < 3) {\n      continue;\n    }\n    renderInstructions[currentIndex + shift++] = value[2];\n    if (attr.size < 4) {\n      continue;\n    }\n    renderInstructions[currentIndex + shift++] = value[3];\n  }\n  return shift;\n}\n\n/**\n * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes\n * @return {number} Cumulated size of all attributes\n */\nexport function getCustomAttributesSize(customAttributes) {\n  return Object.keys(customAttributes).reduce(\n    (prev, curr) => prev + (customAttributes[curr].size || 1),\n    0\n  );\n}\n\n/**\n * Render instructions for lines are structured like so:\n * [ x0, y0, customAttr0, ... , xN, yN, customAttrN ]\n * @param {import(\"./MixedGeometryBatch.js\").PointGeometryBatch} batch Point geometry batch\n * @param {Float32Array} renderInstructions Render instructions\n * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes\n * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n * @return {Float32Array} Generated render instructions\n */\nexport function generatePointRenderInstructions(\n  batch,\n  renderInstructions,\n  customAttributes,\n  transform\n) {\n  // here we anticipate the amount of render instructions for points:\n  // 2 instructions per vertex for position (x and y)\n  // + 1 instruction per vertex per custom attributes\n  const totalInstructionsCount =\n    (2 + getCustomAttributesSize(customAttributes)) * batch.geometriesCount;\n  if (\n    !renderInstructions ||\n    renderInstructions.length !== totalInstructionsCount\n  ) {\n    renderInstructions = new Float32Array(totalInstructionsCount);\n  }\n\n  // loop on features to fill the render instructions\n  const tmpCoords = [];\n  let renderIndex = 0;\n  for (const featureUid in batch.entries) {\n    const batchEntry = batch.entries[featureUid];\n    for (let i = 0, ii = batchEntry.flatCoordss.length; i < ii; i++) {\n      tmpCoords[0] = batchEntry.flatCoordss[i][0];\n      tmpCoords[1] = batchEntry.flatCoordss[i][1];\n      applyTransform(transform, tmpCoords);\n\n      renderInstructions[renderIndex++] = tmpCoords[0];\n      renderInstructions[renderIndex++] = tmpCoords[1];\n      renderIndex += pushCustomAttributesInRenderInstructions(\n        renderInstructions,\n        customAttributes,\n        batchEntry,\n        renderIndex\n      );\n    }\n  }\n  return renderInstructions;\n}\n\n/**\n * Render instructions for lines are structured like so:\n * [ customAttr0, ... , customAttrN, numberOfVertices0, x0, y0, ... , xN, yN, numberOfVertices1, ... ]\n * @param {import(\"./MixedGeometryBatch.js\").LineStringGeometryBatch} batch Line String geometry batch\n * @param {Float32Array} renderInstructions Render instructions\n * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes\n * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n * @return {Float32Array} Generated render instructions\n */\nexport function generateLineStringRenderInstructions(\n  batch,\n  renderInstructions,\n  customAttributes,\n  transform\n) {\n  // here we anticipate the amount of render instructions for lines:\n  // 2 instructions per vertex for position (x and y)\n  // + 1 instruction per line per custom attributes\n  // + 1 instruction per line (for vertices count)\n  const totalInstructionsCount =\n    2 * batch.verticesCount +\n    (1 + getCustomAttributesSize(customAttributes)) * batch.geometriesCount;\n  if (\n    !renderInstructions ||\n    renderInstructions.length !== totalInstructionsCount\n  ) {\n    renderInstructions = new Float32Array(totalInstructionsCount);\n  }\n\n  // loop on features to fill the render instructions\n  const flatCoords = [];\n  let renderIndex = 0;\n  for (const featureUid in batch.entries) {\n    const batchEntry = batch.entries[featureUid];\n    for (let i = 0, ii = batchEntry.flatCoordss.length; i < ii; i++) {\n      flatCoords.length = batchEntry.flatCoordss[i].length;\n      transform2D(\n        batchEntry.flatCoordss[i],\n        0,\n        flatCoords.length,\n        2,\n        transform,\n        flatCoords\n      );\n      renderIndex += pushCustomAttributesInRenderInstructions(\n        renderInstructions,\n        customAttributes,\n        batchEntry,\n        renderIndex\n      );\n\n      // vertices count\n      renderInstructions[renderIndex++] = flatCoords.length / 2;\n\n      // looping on points for positions\n      for (let j = 0, jj = flatCoords.length; j < jj; j += 2) {\n        renderInstructions[renderIndex++] = flatCoords[j];\n        renderInstructions[renderIndex++] = flatCoords[j + 1];\n      }\n    }\n  }\n  return renderInstructions;\n}\n\n/**\n * Render instructions for polygons are structured like so:\n * [ customAttr0, ..., customAttrN, numberOfRings, numberOfVerticesInRing0, ..., numberOfVerticesInRingN, x0, y0, ..., xN, yN, numberOfRings,... ]\n * @param {import(\"./MixedGeometryBatch.js\").PolygonGeometryBatch} batch Polygon geometry batch\n * @param {Float32Array} renderInstructions Render instructions\n * @param {import('./VectorStyleRenderer.js').AttributeDefinitions} customAttributes Custom attributes\n * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n * @return {Float32Array} Generated render instructions\n */\nexport function generatePolygonRenderInstructions(\n  batch,\n  renderInstructions,\n  customAttributes,\n  transform\n) {\n  // here we anticipate the amount of render instructions for polygons:\n  // 2 instructions per vertex for position (x and y)\n  // + 1 instruction per polygon per custom attributes\n  // + 1 instruction per polygon (for vertices count in polygon)\n  // + 1 instruction per ring (for vertices count in ring)\n  const totalInstructionsCount =\n    2 * batch.verticesCount +\n    (1 + getCustomAttributesSize(customAttributes)) * batch.geometriesCount +\n    batch.ringsCount;\n  if (\n    !renderInstructions ||\n    renderInstructions.length !== totalInstructionsCount\n  ) {\n    renderInstructions = new Float32Array(totalInstructionsCount);\n  }\n\n  // loop on features to fill the render instructions\n  const flatCoords = [];\n  let renderIndex = 0;\n  for (const featureUid in batch.entries) {\n    const batchEntry = batch.entries[featureUid];\n    for (let i = 0, ii = batchEntry.flatCoordss.length; i < ii; i++) {\n      flatCoords.length = batchEntry.flatCoordss[i].length;\n      transform2D(\n        batchEntry.flatCoordss[i],\n        0,\n        flatCoords.length,\n        2,\n        transform,\n        flatCoords\n      );\n      renderIndex += pushCustomAttributesInRenderInstructions(\n        renderInstructions,\n        customAttributes,\n        batchEntry,\n        renderIndex\n      );\n\n      // ring count\n      renderInstructions[renderIndex++] =\n        batchEntry.ringsVerticesCounts[i].length;\n\n      // vertices count in each ring\n      for (\n        let j = 0, jj = batchEntry.ringsVerticesCounts[i].length;\n        j < jj;\n        j++\n      ) {\n        renderInstructions[renderIndex++] =\n          batchEntry.ringsVerticesCounts[i][j];\n      }\n\n      // looping on points for positions\n      for (let j = 0, jj = flatCoords.length; j < jj; j += 2) {\n        renderInstructions[renderIndex++] = flatCoords[j];\n        renderInstructions[renderIndex++] = flatCoords[j + 1];\n      }\n    }\n  }\n  return renderInstructions;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}