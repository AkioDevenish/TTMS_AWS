{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.filter.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/**\n * @module ol/render/webgl/MixedGeometryBatch\n */\nimport RenderFeature from '../../render/Feature.js';\nimport { getUid } from '../../util.js';\nimport { inflateEnds } from '../../geom/flat/orient.js';\n\n/**\n * @typedef {import(\"../../Feature.js\").default} Feature\n */\n/**\n * @typedef {import(\"../../geom/Geometry.js\").Type} GeometryType\n */\n\n/**\n * @typedef {Object} GeometryBatchItem Object that holds a reference to a feature as well as the raw coordinates of its various geometries\n * @property {Feature|RenderFeature} feature Feature\n * @property {Array<Array<number>>} flatCoordss Array of flat coordinates arrays, one for each geometry related to the feature\n * @property {number} [verticesCount] Only defined for linestring and polygon batches\n * @property {number} [ringsCount] Only defined for polygon batches\n * @property {Array<Array<number>>} [ringsVerticesCounts] Array of vertices counts in each ring for each geometry; only defined for polygons batches\n * @property {number} [ref] The reference in the global batch (used for hit detection)\n */\n\n/**\n * @typedef {PointGeometryBatch|LineStringGeometryBatch|PolygonGeometryBatch} GeometryBatch\n */\n\n/**\n * @typedef {Object} PolygonGeometryBatch A geometry batch specific to polygons\n * @property {Object<string, GeometryBatchItem>} entries Dictionary of all entries in the batch with associated computed values.\n * One entry corresponds to one feature. Key is feature uid.\n * @property {number} geometriesCount Amount of geometries in the batch.\n * @property {number} verticesCount Amount of vertices from geometries in the batch.\n * @property {number} ringsCount How many outer and inner rings in this batch.\n */\n\n/**\n * @typedef {Object} LineStringGeometryBatch A geometry batch specific to lines\n * @property {Object<string, GeometryBatchItem>} entries Dictionary of all entries in the batch with associated computed values.\n * One entry corresponds to one feature. Key is feature uid.\n * @property {number} geometriesCount Amount of geometries in the batch.\n * @property {number} verticesCount Amount of vertices from geometries in the batch.\n */\n\n/**\n * @typedef {Object} PointGeometryBatch A geometry batch specific to points\n * @property {Object<string, GeometryBatchItem>} entries Dictionary of all entries in the batch with associated computed values.\n * One entry corresponds to one feature. Key is feature uid.\n * @property {number} geometriesCount Amount of geometries in the batch.\n */\n\n/**\n * @classdesc This class is used to group several geometries of various types together for faster rendering.\n * Three inner batches are maintained for polygons, lines and points. Each time a feature is added, changed or removed\n * from the batch, these inner batches are modified accordingly in order to keep them up-to-date.\n *\n * A feature can be present in several inner batches, for example a polygon geometry will be present in the polygon batch\n * and its linear rings will be present in the line batch. Multi geometries are also broken down into individual geometries\n * and added to the corresponding batches in a recursive manner.\n *\n * Corresponding {@link module:ol/render/webgl/BatchRenderer} instances are then used to generate the render instructions\n * and WebGL buffers (vertices and indices) for each inner batches; render instructions are stored on the inner batches,\n * alongside the transform used to convert world coords to screen coords at the time these instructions were generated.\n * The resulting WebGL buffers are stored on the batches as well.\n *\n * An important aspect of geometry batches is that there is no guarantee that render instructions and WebGL buffers\n * are synchronized, i.e. render instructions can describe a new state while WebGL buffers might not have been written yet.\n * This is why two world-to-screen transforms are stored on each batch: one for the render instructions and one for\n * the WebGL buffers.\n */\nvar MixedGeometryBatch = /*#__PURE__*/function () {\n  function MixedGeometryBatch() {\n    _classCallCheck(this, MixedGeometryBatch);\n    this.globalCounter_ = 0;\n    /**\n     * Refs are used as keys for hit detection.\n     * @type {Map<number, Feature|RenderFeature>}\n     * @private\n     */\n    this.refToFeature_ = new Map();\n\n    /**\n     * Features are split in \"entries\", which are individual geometries. We use the following map to share a single ref for all those entries.\n     * @type {Map<string, number>}\n     * @private\n     */\n    this.uidToRef_ = new Map();\n\n    /**\n     * The precision in WebGL shaders is limited.\n     * To keep the refs as small as possible we maintain an array of returned references.\n     * @type {Array<number>}\n     * @private\n     */\n    this.freeGlobalRef_ = [];\n\n    /**\n     * @type {PolygonGeometryBatch}\n     */\n    this.polygonBatch = {\n      entries: {},\n      geometriesCount: 0,\n      verticesCount: 0,\n      ringsCount: 0\n    };\n\n    /**\n     * @type {PointGeometryBatch}\n     */\n    this.pointBatch = {\n      entries: {},\n      geometriesCount: 0\n    };\n\n    /**\n     * @type {LineStringGeometryBatch}\n     */\n    this.lineStringBatch = {\n      entries: {},\n      geometriesCount: 0,\n      verticesCount: 0\n    };\n  }\n\n  /**\n   * @param {Array<Feature|RenderFeature>} features Array of features to add to the batch\n   * @param {import(\"../../proj.js\").TransformFunction} [projectionTransform] Projection transform.\n   */\n  return _createClass(MixedGeometryBatch, [{\n    key: \"addFeatures\",\n    value: function addFeatures(features, projectionTransform) {\n      for (var i = 0; i < features.length; i++) {\n        this.addFeature(features[i], projectionTransform);\n      }\n    }\n\n    /**\n     * @param {Feature|RenderFeature} feature Feature to add to the batch\n     * @param {import(\"../../proj.js\").TransformFunction} [projectionTransform] Projection transform.\n     */\n  }, {\n    key: \"addFeature\",\n    value: function addFeature(feature, projectionTransform) {\n      var geometry = feature.getGeometry();\n      if (!geometry) {\n        return;\n      }\n      if (projectionTransform) {\n        geometry = geometry.clone();\n        geometry.applyTransform(projectionTransform);\n      }\n      this.addGeometry_(geometry, feature);\n    }\n\n    /**\n     * @param {Feature|RenderFeature} feature Feature\n     * @return {GeometryBatchItem|void} the cleared entry\n     * @private\n     */\n  }, {\n    key: \"clearFeatureEntryInPointBatch_\",\n    value: function clearFeatureEntryInPointBatch_(feature) {\n      var entry = this.pointBatch.entries[getUid(feature)];\n      if (!entry) {\n        return;\n      }\n      this.pointBatch.geometriesCount -= entry.flatCoordss.length;\n      delete this.pointBatch.entries[getUid(feature)];\n      return entry;\n    }\n\n    /**\n     * @param {Feature|RenderFeature} feature Feature\n     * @return {GeometryBatchItem|void} the cleared entry\n     * @private\n     */\n  }, {\n    key: \"clearFeatureEntryInLineStringBatch_\",\n    value: function clearFeatureEntryInLineStringBatch_(feature) {\n      var entry = this.lineStringBatch.entries[getUid(feature)];\n      if (!entry) {\n        return;\n      }\n      this.lineStringBatch.verticesCount -= entry.verticesCount;\n      this.lineStringBatch.geometriesCount -= entry.flatCoordss.length;\n      delete this.lineStringBatch.entries[getUid(feature)];\n      return entry;\n    }\n\n    /**\n     * @param {Feature|RenderFeature} feature Feature\n     * @return {GeometryBatchItem|void} the cleared entry\n     * @private\n     */\n  }, {\n    key: \"clearFeatureEntryInPolygonBatch_\",\n    value: function clearFeatureEntryInPolygonBatch_(feature) {\n      var entry = this.polygonBatch.entries[getUid(feature)];\n      if (!entry) {\n        return;\n      }\n      this.polygonBatch.verticesCount -= entry.verticesCount;\n      this.polygonBatch.ringsCount -= entry.ringsCount;\n      this.polygonBatch.geometriesCount -= entry.flatCoordss.length;\n      delete this.polygonBatch.entries[getUid(feature)];\n      return entry;\n    }\n\n    /**\n     * @param {import(\"../../geom.js\").Geometry|RenderFeature} geometry Geometry\n     * @param {Feature|RenderFeature} feature Feature\n     * @private\n     */\n  }, {\n    key: \"addGeometry_\",\n    value: function addGeometry_(geometry, feature) {\n      var type = geometry.getType();\n      switch (type) {\n        case 'GeometryCollection':\n          {\n            var geometries = /** @type {import(\"../../geom.js\").GeometryCollection} */geometry.getGeometriesArray();\n            var _iterator = _createForOfIteratorHelper(geometries),\n              _step;\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var _geometry = _step.value;\n                this.addGeometry_(_geometry, feature);\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n            break;\n          }\n        case 'MultiPolygon':\n          {\n            var multiPolygonGeom = /** @type {import(\"../../geom.js\").MultiPolygon} */geometry;\n            this.addCoordinates_(type, multiPolygonGeom.getFlatCoordinates(), multiPolygonGeom.getEndss(), feature, getUid(feature), multiPolygonGeom.getStride());\n            break;\n          }\n        case 'MultiLineString':\n          {\n            var multiLineGeom = /** @type {import(\"../../geom.js\").MultiLineString|RenderFeature} */\n            geometry;\n            this.addCoordinates_(type, multiLineGeom.getFlatCoordinates(), multiLineGeom.getEnds(), feature, getUid(feature), multiLineGeom.getStride());\n            break;\n          }\n        case 'MultiPoint':\n          {\n            var multiPointGeom = /** @type {import(\"../../geom.js\").MultiPoint|RenderFeature} */\n            geometry;\n            this.addCoordinates_(type, multiPointGeom.getFlatCoordinates(), null, feature, getUid(feature), multiPointGeom.getStride());\n            break;\n          }\n        case 'Polygon':\n          {\n            var polygonGeom = /** @type {import(\"../../geom.js\").Polygon|RenderFeature} */\n            geometry;\n            this.addCoordinates_(type, polygonGeom.getFlatCoordinates(), polygonGeom.getEnds(), feature, getUid(feature), polygonGeom.getStride());\n            break;\n          }\n        case 'Point':\n          {\n            var pointGeom = /** @type {import(\"../../geom.js\").Point} */\n            geometry;\n            this.addCoordinates_(type, pointGeom.getFlatCoordinates(), null, feature, getUid(feature), pointGeom.getStride());\n            break;\n          }\n        case 'LineString':\n        case 'LinearRing':\n          {\n            var lineGeom = /** @type {import(\"../../geom.js\").LineString} */\n            geometry;\n            this.addCoordinates_(type, lineGeom.getFlatCoordinates(), null, feature, getUid(feature), lineGeom.getStride());\n            break;\n          }\n        default:\n        // pass\n      }\n    }\n\n    /**\n     * @param {GeometryType} type Geometry type\n     * @param {Array<number>} flatCoords Flat coordinates\n     * @param {Array<number> | Array<Array<number>> | null} ends Coordinate ends\n     * @param {Feature|RenderFeature} feature Feature\n     * @param {string} featureUid Feature uid\n     * @param {number} stride Stride\n     * @private\n     */\n  }, {\n    key: \"addCoordinates_\",\n    value: function addCoordinates_(type, flatCoords, ends, feature, featureUid, stride) {\n      var _this = this;\n      /** @type {number} */\n      var verticesCount;\n      switch (type) {\n        case 'MultiPolygon':\n          {\n            var multiPolygonEndss = /** @type {Array<Array<number>>} */ends;\n            var _loop = function _loop() {\n              var polygonEnds = multiPolygonEndss[i];\n              var prevPolygonEnds = i > 0 ? multiPolygonEndss[i - 1] : null;\n              var startIndex = prevPolygonEnds ? prevPolygonEnds[prevPolygonEnds.length - 1] : 0;\n              var endIndex = polygonEnds[polygonEnds.length - 1];\n              polygonEnds = startIndex > 0 ? polygonEnds.map(function (end) {\n                return end - startIndex;\n              }) : polygonEnds;\n              _this.addCoordinates_('Polygon', flatCoords.slice(startIndex, endIndex), polygonEnds, feature, featureUid, stride);\n            };\n            for (var i = 0, ii = multiPolygonEndss.length; i < ii; i++) {\n              _loop();\n            }\n            break;\n          }\n        case 'MultiLineString':\n          {\n            var multiLineEnds = /** @type {Array<number>} */ends;\n            for (var _i = 0, _ii = multiLineEnds.length; _i < _ii; _i++) {\n              var startIndex = _i > 0 ? multiLineEnds[_i - 1] : 0;\n              this.addCoordinates_('LineString', flatCoords.slice(startIndex, multiLineEnds[_i]), null, feature, featureUid, stride);\n            }\n            break;\n          }\n        case 'MultiPoint':\n          for (var _i2 = 0, _ii2 = flatCoords.length; _i2 < _ii2; _i2 += stride) {\n            this.addCoordinates_('Point', flatCoords.slice(_i2, _i2 + 2), null, feature, featureUid, null);\n          }\n          break;\n        case 'Polygon':\n          {\n            var polygonEnds = /** @type {Array<number>} */ends;\n            if (feature instanceof RenderFeature) {\n              var multiPolygonEnds = inflateEnds(flatCoords, polygonEnds);\n              if (multiPolygonEnds.length > 1) {\n                this.addCoordinates_('MultiPolygon', flatCoords, multiPolygonEnds, feature, featureUid, stride);\n                return;\n              }\n            }\n            if (!this.polygonBatch.entries[featureUid]) {\n              this.polygonBatch.entries[featureUid] = this.addRefToEntry_(featureUid, {\n                feature: feature,\n                flatCoordss: [],\n                verticesCount: 0,\n                ringsCount: 0,\n                ringsVerticesCounts: []\n              });\n            }\n            verticesCount = flatCoords.length / stride;\n            var ringsCount = ends.length;\n            var ringsVerticesCount = ends.map(function (end, ind, arr) {\n              return ind > 0 ? (end - arr[ind - 1]) / stride : end / stride;\n            });\n            this.polygonBatch.verticesCount += verticesCount;\n            this.polygonBatch.ringsCount += ringsCount;\n            this.polygonBatch.geometriesCount++;\n            this.polygonBatch.entries[featureUid].flatCoordss.push(getFlatCoordinatesXY(flatCoords, stride));\n            this.polygonBatch.entries[featureUid].ringsVerticesCounts.push(ringsVerticesCount);\n            this.polygonBatch.entries[featureUid].verticesCount += verticesCount;\n            this.polygonBatch.entries[featureUid].ringsCount += ringsCount;\n            for (var _i3 = 0, _ii3 = polygonEnds.length; _i3 < _ii3; _i3++) {\n              var _startIndex = _i3 > 0 ? polygonEnds[_i3 - 1] : 0;\n              this.addCoordinates_('LinearRing', flatCoords.slice(_startIndex, polygonEnds[_i3]), null, feature, featureUid, stride);\n            }\n            break;\n          }\n        case 'Point':\n          if (!this.pointBatch.entries[featureUid]) {\n            this.pointBatch.entries[featureUid] = this.addRefToEntry_(featureUid, {\n              feature: feature,\n              flatCoordss: []\n            });\n          }\n          this.pointBatch.geometriesCount++;\n          this.pointBatch.entries[featureUid].flatCoordss.push(flatCoords);\n          break;\n        case 'LineString':\n        case 'LinearRing':\n          if (!this.lineStringBatch.entries[featureUid]) {\n            this.lineStringBatch.entries[featureUid] = this.addRefToEntry_(featureUid, {\n              feature: feature,\n              flatCoordss: [],\n              verticesCount: 0\n            });\n          }\n          verticesCount = flatCoords.length / stride;\n          this.lineStringBatch.verticesCount += verticesCount;\n          this.lineStringBatch.geometriesCount++;\n          this.lineStringBatch.entries[featureUid].flatCoordss.push(getFlatCoordinatesXY(flatCoords, stride));\n          this.lineStringBatch.entries[featureUid].verticesCount += verticesCount;\n          break;\n        default:\n        // pass\n      }\n    }\n\n    /**\n     * @param {string} featureUid Feature uid\n     * @param {GeometryBatchItem} entry The entry to add\n     * @return {GeometryBatchItem} the added entry\n     * @private\n     */\n  }, {\n    key: \"addRefToEntry_\",\n    value: function addRefToEntry_(featureUid, entry) {\n      var currentRef = this.uidToRef_.get(featureUid);\n\n      // the ref starts at 1 to distinguish from white color (no feature)\n      var ref = currentRef || this.freeGlobalRef_.pop() || ++this.globalCounter_;\n      entry.ref = ref;\n      if (!currentRef) {\n        this.refToFeature_.set(ref, entry.feature);\n        this.uidToRef_.set(featureUid, ref);\n      }\n      return entry;\n    }\n\n    /**\n     * Return a ref to the pool of available refs.\n     * @param {number} ref the ref to return\n     * @param {string} featureUid the feature uid\n     * @private\n     */\n  }, {\n    key: \"returnRef_\",\n    value: function returnRef_(ref, featureUid) {\n      if (!ref) {\n        throw new Error('This feature has no ref: ' + featureUid);\n      }\n      this.refToFeature_[\"delete\"](ref);\n      this.uidToRef_[\"delete\"](featureUid);\n      this.freeGlobalRef_.push(ref);\n    }\n\n    /**\n     * @param {Feature|RenderFeature} feature Feature\n     */\n  }, {\n    key: \"changeFeature\",\n    value: function changeFeature(feature) {\n      this.removeFeature(feature);\n      var geometry = feature.getGeometry();\n      if (!geometry) {\n        return;\n      }\n      this.addGeometry_(geometry, feature);\n    }\n\n    /**\n     * @param {Feature|RenderFeature} feature Feature\n     */\n  }, {\n    key: \"removeFeature\",\n    value: function removeFeature(feature) {\n      var entry;\n      entry = this.clearFeatureEntryInPointBatch_(feature) || entry;\n      entry = this.clearFeatureEntryInPolygonBatch_(feature) || entry;\n      entry = this.clearFeatureEntryInLineStringBatch_(feature) || entry;\n      if (entry) {\n        this.returnRef_(entry.ref, getUid(entry.feature));\n      }\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.polygonBatch.entries = {};\n      this.polygonBatch.geometriesCount = 0;\n      this.polygonBatch.verticesCount = 0;\n      this.polygonBatch.ringsCount = 0;\n      this.lineStringBatch.entries = {};\n      this.lineStringBatch.geometriesCount = 0;\n      this.lineStringBatch.verticesCount = 0;\n      this.pointBatch.entries = {};\n      this.pointBatch.geometriesCount = 0;\n      this.globalCounter_ = 0;\n      this.freeGlobalRef_ = [];\n      this.refToFeature_.clear();\n      this.uidToRef_.clear();\n    }\n\n    /**\n     * Resolve the feature associated to a ref.\n     * @param {number} ref Hit detected ref\n     * @return {Feature|RenderFeature} feature\n     */\n  }, {\n    key: \"getFeatureFromRef\",\n    value: function getFeatureFromRef(ref) {\n      return this.refToFeature_.get(ref);\n    }\n  }]);\n}();\n/**\n * @param {Array<number>} flatCoords Flat coords\n * @param {number} stride Stride\n * @return {Array<number>} Flat coords with only XY components\n */\nfunction getFlatCoordinatesXY(flatCoords, stride) {\n  if (stride === 2) {\n    return flatCoords;\n  }\n  return flatCoords.filter(function (v, i) {\n    return i % stride < 2;\n  });\n}\nexport default MixedGeometryBatch;","map":{"version":3,"names":["RenderFeature","getUid","inflateEnds","MixedGeometryBatch","_classCallCheck","globalCounter_","refToFeature_","Map","uidToRef_","freeGlobalRef_","polygonBatch","entries","geometriesCount","verticesCount","ringsCount","pointBatch","lineStringBatch","_createClass","key","value","addFeatures","features","projectionTransform","i","length","addFeature","feature","geometry","getGeometry","clone","applyTransform","addGeometry_","clearFeatureEntryInPointBatch_","entry","flatCoordss","clearFeatureEntryInLineStringBatch_","clearFeatureEntryInPolygonBatch_","type","getType","geometries","getGeometriesArray","_iterator","_createForOfIteratorHelper","_step","s","n","done","err","e","f","multiPolygonGeom","addCoordinates_","getFlatCoordinates","getEndss","getStride","multiLineGeom","getEnds","multiPointGeom","polygonGeom","pointGeom","lineGeom","flatCoords","ends","featureUid","stride","_this","multiPolygonEndss","_loop","polygonEnds","prevPolygonEnds","startIndex","endIndex","map","end","slice","ii","multiLineEnds","multiPolygonEnds","addRefToEntry_","ringsVerticesCounts","ringsVerticesCount","ind","arr","push","getFlatCoordinatesXY","currentRef","get","ref","pop","set","returnRef_","Error","changeFeature","removeFeature","clear","getFeatureFromRef","filter","v"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol/render/webgl/MixedGeometryBatch.js"],"sourcesContent":["/**\n * @module ol/render/webgl/MixedGeometryBatch\n */\nimport RenderFeature from '../../render/Feature.js';\nimport {getUid} from '../../util.js';\nimport {inflateEnds} from '../../geom/flat/orient.js';\n\n/**\n * @typedef {import(\"../../Feature.js\").default} Feature\n */\n/**\n * @typedef {import(\"../../geom/Geometry.js\").Type} GeometryType\n */\n\n/**\n * @typedef {Object} GeometryBatchItem Object that holds a reference to a feature as well as the raw coordinates of its various geometries\n * @property {Feature|RenderFeature} feature Feature\n * @property {Array<Array<number>>} flatCoordss Array of flat coordinates arrays, one for each geometry related to the feature\n * @property {number} [verticesCount] Only defined for linestring and polygon batches\n * @property {number} [ringsCount] Only defined for polygon batches\n * @property {Array<Array<number>>} [ringsVerticesCounts] Array of vertices counts in each ring for each geometry; only defined for polygons batches\n * @property {number} [ref] The reference in the global batch (used for hit detection)\n */\n\n/**\n * @typedef {PointGeometryBatch|LineStringGeometryBatch|PolygonGeometryBatch} GeometryBatch\n */\n\n/**\n * @typedef {Object} PolygonGeometryBatch A geometry batch specific to polygons\n * @property {Object<string, GeometryBatchItem>} entries Dictionary of all entries in the batch with associated computed values.\n * One entry corresponds to one feature. Key is feature uid.\n * @property {number} geometriesCount Amount of geometries in the batch.\n * @property {number} verticesCount Amount of vertices from geometries in the batch.\n * @property {number} ringsCount How many outer and inner rings in this batch.\n */\n\n/**\n * @typedef {Object} LineStringGeometryBatch A geometry batch specific to lines\n * @property {Object<string, GeometryBatchItem>} entries Dictionary of all entries in the batch with associated computed values.\n * One entry corresponds to one feature. Key is feature uid.\n * @property {number} geometriesCount Amount of geometries in the batch.\n * @property {number} verticesCount Amount of vertices from geometries in the batch.\n */\n\n/**\n * @typedef {Object} PointGeometryBatch A geometry batch specific to points\n * @property {Object<string, GeometryBatchItem>} entries Dictionary of all entries in the batch with associated computed values.\n * One entry corresponds to one feature. Key is feature uid.\n * @property {number} geometriesCount Amount of geometries in the batch.\n */\n\n/**\n * @classdesc This class is used to group several geometries of various types together for faster rendering.\n * Three inner batches are maintained for polygons, lines and points. Each time a feature is added, changed or removed\n * from the batch, these inner batches are modified accordingly in order to keep them up-to-date.\n *\n * A feature can be present in several inner batches, for example a polygon geometry will be present in the polygon batch\n * and its linear rings will be present in the line batch. Multi geometries are also broken down into individual geometries\n * and added to the corresponding batches in a recursive manner.\n *\n * Corresponding {@link module:ol/render/webgl/BatchRenderer} instances are then used to generate the render instructions\n * and WebGL buffers (vertices and indices) for each inner batches; render instructions are stored on the inner batches,\n * alongside the transform used to convert world coords to screen coords at the time these instructions were generated.\n * The resulting WebGL buffers are stored on the batches as well.\n *\n * An important aspect of geometry batches is that there is no guarantee that render instructions and WebGL buffers\n * are synchronized, i.e. render instructions can describe a new state while WebGL buffers might not have been written yet.\n * This is why two world-to-screen transforms are stored on each batch: one for the render instructions and one for\n * the WebGL buffers.\n */\nclass MixedGeometryBatch {\n  constructor() {\n    this.globalCounter_ = 0;\n    /**\n     * Refs are used as keys for hit detection.\n     * @type {Map<number, Feature|RenderFeature>}\n     * @private\n     */\n    this.refToFeature_ = new Map();\n\n    /**\n     * Features are split in \"entries\", which are individual geometries. We use the following map to share a single ref for all those entries.\n     * @type {Map<string, number>}\n     * @private\n     */\n    this.uidToRef_ = new Map();\n\n    /**\n     * The precision in WebGL shaders is limited.\n     * To keep the refs as small as possible we maintain an array of returned references.\n     * @type {Array<number>}\n     * @private\n     */\n    this.freeGlobalRef_ = [];\n\n    /**\n     * @type {PolygonGeometryBatch}\n     */\n    this.polygonBatch = {\n      entries: {},\n      geometriesCount: 0,\n      verticesCount: 0,\n      ringsCount: 0,\n    };\n\n    /**\n     * @type {PointGeometryBatch}\n     */\n    this.pointBatch = {\n      entries: {},\n      geometriesCount: 0,\n    };\n\n    /**\n     * @type {LineStringGeometryBatch}\n     */\n    this.lineStringBatch = {\n      entries: {},\n      geometriesCount: 0,\n      verticesCount: 0,\n    };\n  }\n\n  /**\n   * @param {Array<Feature|RenderFeature>} features Array of features to add to the batch\n   * @param {import(\"../../proj.js\").TransformFunction} [projectionTransform] Projection transform.\n   */\n  addFeatures(features, projectionTransform) {\n    for (let i = 0; i < features.length; i++) {\n      this.addFeature(features[i], projectionTransform);\n    }\n  }\n\n  /**\n   * @param {Feature|RenderFeature} feature Feature to add to the batch\n   * @param {import(\"../../proj.js\").TransformFunction} [projectionTransform] Projection transform.\n   */\n  addFeature(feature, projectionTransform) {\n    let geometry = feature.getGeometry();\n    if (!geometry) {\n      return;\n    }\n    if (projectionTransform) {\n      geometry = geometry.clone();\n      geometry.applyTransform(projectionTransform);\n    }\n    this.addGeometry_(geometry, feature);\n  }\n\n  /**\n   * @param {Feature|RenderFeature} feature Feature\n   * @return {GeometryBatchItem|void} the cleared entry\n   * @private\n   */\n  clearFeatureEntryInPointBatch_(feature) {\n    const entry = this.pointBatch.entries[getUid(feature)];\n    if (!entry) {\n      return;\n    }\n    this.pointBatch.geometriesCount -= entry.flatCoordss.length;\n    delete this.pointBatch.entries[getUid(feature)];\n    return entry;\n  }\n\n  /**\n   * @param {Feature|RenderFeature} feature Feature\n   * @return {GeometryBatchItem|void} the cleared entry\n   * @private\n   */\n  clearFeatureEntryInLineStringBatch_(feature) {\n    const entry = this.lineStringBatch.entries[getUid(feature)];\n    if (!entry) {\n      return;\n    }\n    this.lineStringBatch.verticesCount -= entry.verticesCount;\n    this.lineStringBatch.geometriesCount -= entry.flatCoordss.length;\n    delete this.lineStringBatch.entries[getUid(feature)];\n    return entry;\n  }\n\n  /**\n   * @param {Feature|RenderFeature} feature Feature\n   * @return {GeometryBatchItem|void} the cleared entry\n   * @private\n   */\n  clearFeatureEntryInPolygonBatch_(feature) {\n    const entry = this.polygonBatch.entries[getUid(feature)];\n    if (!entry) {\n      return;\n    }\n    this.polygonBatch.verticesCount -= entry.verticesCount;\n    this.polygonBatch.ringsCount -= entry.ringsCount;\n    this.polygonBatch.geometriesCount -= entry.flatCoordss.length;\n    delete this.polygonBatch.entries[getUid(feature)];\n    return entry;\n  }\n\n  /**\n   * @param {import(\"../../geom.js\").Geometry|RenderFeature} geometry Geometry\n   * @param {Feature|RenderFeature} feature Feature\n   * @private\n   */\n  addGeometry_(geometry, feature) {\n    const type = geometry.getType();\n    switch (type) {\n      case 'GeometryCollection': {\n        const geometries =\n          /** @type {import(\"../../geom.js\").GeometryCollection} */ (\n            geometry\n          ).getGeometriesArray();\n        for (const geometry of geometries) {\n          this.addGeometry_(geometry, feature);\n        }\n        break;\n      }\n      case 'MultiPolygon': {\n        const multiPolygonGeom =\n          /** @type {import(\"../../geom.js\").MultiPolygon} */ (geometry);\n        this.addCoordinates_(\n          type,\n          multiPolygonGeom.getFlatCoordinates(),\n          multiPolygonGeom.getEndss(),\n          feature,\n          getUid(feature),\n          multiPolygonGeom.getStride()\n        );\n        break;\n      }\n      case 'MultiLineString': {\n        const multiLineGeom =\n          /** @type {import(\"../../geom.js\").MultiLineString|RenderFeature} */ (\n            geometry\n          );\n        this.addCoordinates_(\n          type,\n          multiLineGeom.getFlatCoordinates(),\n          multiLineGeom.getEnds(),\n          feature,\n          getUid(feature),\n          multiLineGeom.getStride()\n        );\n        break;\n      }\n      case 'MultiPoint': {\n        const multiPointGeom =\n          /** @type {import(\"../../geom.js\").MultiPoint|RenderFeature} */ (\n            geometry\n          );\n        this.addCoordinates_(\n          type,\n          multiPointGeom.getFlatCoordinates(),\n          null,\n          feature,\n          getUid(feature),\n          multiPointGeom.getStride()\n        );\n        break;\n      }\n      case 'Polygon': {\n        const polygonGeom =\n          /** @type {import(\"../../geom.js\").Polygon|RenderFeature} */ (\n            geometry\n          );\n        this.addCoordinates_(\n          type,\n          polygonGeom.getFlatCoordinates(),\n          polygonGeom.getEnds(),\n          feature,\n          getUid(feature),\n          polygonGeom.getStride()\n        );\n        break;\n      }\n      case 'Point': {\n        const pointGeom = /** @type {import(\"../../geom.js\").Point} */ (\n          geometry\n        );\n        this.addCoordinates_(\n          type,\n          pointGeom.getFlatCoordinates(),\n          null,\n          feature,\n          getUid(feature),\n          pointGeom.getStride()\n        );\n        break;\n      }\n      case 'LineString':\n      case 'LinearRing': {\n        const lineGeom = /** @type {import(\"../../geom.js\").LineString} */ (\n          geometry\n        );\n        this.addCoordinates_(\n          type,\n          lineGeom.getFlatCoordinates(),\n          null,\n          feature,\n          getUid(feature),\n          lineGeom.getStride()\n        );\n        break;\n      }\n      default:\n      // pass\n    }\n  }\n\n  /**\n   * @param {GeometryType} type Geometry type\n   * @param {Array<number>} flatCoords Flat coordinates\n   * @param {Array<number> | Array<Array<number>> | null} ends Coordinate ends\n   * @param {Feature|RenderFeature} feature Feature\n   * @param {string} featureUid Feature uid\n   * @param {number} stride Stride\n   * @private\n   */\n  addCoordinates_(type, flatCoords, ends, feature, featureUid, stride) {\n    /** @type {number} */\n    let verticesCount;\n    switch (type) {\n      case 'MultiPolygon': {\n        const multiPolygonEndss = /** @type {Array<Array<number>>} */ (ends);\n        for (let i = 0, ii = multiPolygonEndss.length; i < ii; i++) {\n          let polygonEnds = multiPolygonEndss[i];\n          const prevPolygonEnds = i > 0 ? multiPolygonEndss[i - 1] : null;\n          const startIndex = prevPolygonEnds\n            ? prevPolygonEnds[prevPolygonEnds.length - 1]\n            : 0;\n          const endIndex = polygonEnds[polygonEnds.length - 1];\n          polygonEnds =\n            startIndex > 0\n              ? polygonEnds.map((end) => end - startIndex)\n              : polygonEnds;\n          this.addCoordinates_(\n            'Polygon',\n            flatCoords.slice(startIndex, endIndex),\n            polygonEnds,\n            feature,\n            featureUid,\n            stride\n          );\n        }\n        break;\n      }\n      case 'MultiLineString': {\n        const multiLineEnds = /** @type {Array<number>} */ (ends);\n        for (let i = 0, ii = multiLineEnds.length; i < ii; i++) {\n          const startIndex = i > 0 ? multiLineEnds[i - 1] : 0;\n          this.addCoordinates_(\n            'LineString',\n            flatCoords.slice(startIndex, multiLineEnds[i]),\n            null,\n            feature,\n            featureUid,\n            stride\n          );\n        }\n        break;\n      }\n      case 'MultiPoint':\n        for (let i = 0, ii = flatCoords.length; i < ii; i += stride) {\n          this.addCoordinates_(\n            'Point',\n            flatCoords.slice(i, i + 2),\n            null,\n            feature,\n            featureUid,\n            null\n          );\n        }\n        break;\n      case 'Polygon': {\n        const polygonEnds = /** @type {Array<number>} */ (ends);\n        if (feature instanceof RenderFeature) {\n          const multiPolygonEnds = inflateEnds(flatCoords, polygonEnds);\n          if (multiPolygonEnds.length > 1) {\n            this.addCoordinates_(\n              'MultiPolygon',\n              flatCoords,\n              multiPolygonEnds,\n              feature,\n              featureUid,\n              stride\n            );\n            return;\n          }\n        }\n        if (!this.polygonBatch.entries[featureUid]) {\n          this.polygonBatch.entries[featureUid] = this.addRefToEntry_(\n            featureUid,\n            {\n              feature: feature,\n              flatCoordss: [],\n              verticesCount: 0,\n              ringsCount: 0,\n              ringsVerticesCounts: [],\n            }\n          );\n        }\n        verticesCount = flatCoords.length / stride;\n        const ringsCount = ends.length;\n        const ringsVerticesCount = ends.map((end, ind, arr) =>\n          ind > 0 ? (end - arr[ind - 1]) / stride : end / stride\n        );\n        this.polygonBatch.verticesCount += verticesCount;\n        this.polygonBatch.ringsCount += ringsCount;\n        this.polygonBatch.geometriesCount++;\n        this.polygonBatch.entries[featureUid].flatCoordss.push(\n          getFlatCoordinatesXY(flatCoords, stride)\n        );\n        this.polygonBatch.entries[featureUid].ringsVerticesCounts.push(\n          ringsVerticesCount\n        );\n        this.polygonBatch.entries[featureUid].verticesCount += verticesCount;\n        this.polygonBatch.entries[featureUid].ringsCount += ringsCount;\n        for (let i = 0, ii = polygonEnds.length; i < ii; i++) {\n          const startIndex = i > 0 ? polygonEnds[i - 1] : 0;\n          this.addCoordinates_(\n            'LinearRing',\n            flatCoords.slice(startIndex, polygonEnds[i]),\n            null,\n            feature,\n            featureUid,\n            stride\n          );\n        }\n        break;\n      }\n      case 'Point':\n        if (!this.pointBatch.entries[featureUid]) {\n          this.pointBatch.entries[featureUid] = this.addRefToEntry_(\n            featureUid,\n            {\n              feature: feature,\n              flatCoordss: [],\n            }\n          );\n        }\n        this.pointBatch.geometriesCount++;\n        this.pointBatch.entries[featureUid].flatCoordss.push(flatCoords);\n        break;\n      case 'LineString':\n      case 'LinearRing':\n        if (!this.lineStringBatch.entries[featureUid]) {\n          this.lineStringBatch.entries[featureUid] = this.addRefToEntry_(\n            featureUid,\n            {\n              feature: feature,\n              flatCoordss: [],\n              verticesCount: 0,\n            }\n          );\n        }\n        verticesCount = flatCoords.length / stride;\n        this.lineStringBatch.verticesCount += verticesCount;\n        this.lineStringBatch.geometriesCount++;\n        this.lineStringBatch.entries[featureUid].flatCoordss.push(\n          getFlatCoordinatesXY(flatCoords, stride)\n        );\n        this.lineStringBatch.entries[featureUid].verticesCount += verticesCount;\n        break;\n      default:\n      // pass\n    }\n  }\n\n  /**\n   * @param {string} featureUid Feature uid\n   * @param {GeometryBatchItem} entry The entry to add\n   * @return {GeometryBatchItem} the added entry\n   * @private\n   */\n  addRefToEntry_(featureUid, entry) {\n    const currentRef = this.uidToRef_.get(featureUid);\n\n    // the ref starts at 1 to distinguish from white color (no feature)\n    const ref =\n      currentRef || this.freeGlobalRef_.pop() || ++this.globalCounter_;\n    entry.ref = ref;\n    if (!currentRef) {\n      this.refToFeature_.set(ref, entry.feature);\n      this.uidToRef_.set(featureUid, ref);\n    }\n    return entry;\n  }\n\n  /**\n   * Return a ref to the pool of available refs.\n   * @param {number} ref the ref to return\n   * @param {string} featureUid the feature uid\n   * @private\n   */\n  returnRef_(ref, featureUid) {\n    if (!ref) {\n      throw new Error('This feature has no ref: ' + featureUid);\n    }\n    this.refToFeature_.delete(ref);\n    this.uidToRef_.delete(featureUid);\n    this.freeGlobalRef_.push(ref);\n  }\n\n  /**\n   * @param {Feature|RenderFeature} feature Feature\n   */\n  changeFeature(feature) {\n    this.removeFeature(feature);\n    const geometry = feature.getGeometry();\n    if (!geometry) {\n      return;\n    }\n    this.addGeometry_(geometry, feature);\n  }\n\n  /**\n   * @param {Feature|RenderFeature} feature Feature\n   */\n  removeFeature(feature) {\n    let entry;\n    entry = this.clearFeatureEntryInPointBatch_(feature) || entry;\n    entry = this.clearFeatureEntryInPolygonBatch_(feature) || entry;\n    entry = this.clearFeatureEntryInLineStringBatch_(feature) || entry;\n    if (entry) {\n      this.returnRef_(entry.ref, getUid(entry.feature));\n    }\n  }\n\n  clear() {\n    this.polygonBatch.entries = {};\n    this.polygonBatch.geometriesCount = 0;\n    this.polygonBatch.verticesCount = 0;\n    this.polygonBatch.ringsCount = 0;\n    this.lineStringBatch.entries = {};\n    this.lineStringBatch.geometriesCount = 0;\n    this.lineStringBatch.verticesCount = 0;\n    this.pointBatch.entries = {};\n    this.pointBatch.geometriesCount = 0;\n    this.globalCounter_ = 0;\n    this.freeGlobalRef_ = [];\n    this.refToFeature_.clear();\n    this.uidToRef_.clear();\n  }\n\n  /**\n   * Resolve the feature associated to a ref.\n   * @param {number} ref Hit detected ref\n   * @return {Feature|RenderFeature} feature\n   */\n  getFeatureFromRef(ref) {\n    return this.refToFeature_.get(ref);\n  }\n}\n\n/**\n * @param {Array<number>} flatCoords Flat coords\n * @param {number} stride Stride\n * @return {Array<number>} Flat coords with only XY components\n */\nfunction getFlatCoordinatesXY(flatCoords, stride) {\n  if (stride === 2) {\n    return flatCoords;\n  }\n  return flatCoords.filter((v, i) => i % stride < 2);\n}\n\nexport default MixedGeometryBatch;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}