{"ast":null,"code":"import _classCallCheck from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _callSuper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.parse-int.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.string.trim.js\";\n/**\n * @module ol/format/IGC\n */\nimport Feature from '../Feature.js';\nimport LineString from '../geom/LineString.js';\nimport TextFeature from './TextFeature.js';\nimport { get as getProjection } from '../proj.js';\nimport { transformGeometryWithOptions } from './Feature.js';\n\n/**\n * @typedef {'barometric' | 'gps' | 'none'} IGCZ\n * IGC altitude/z. One of 'barometric', 'gps', 'none'.\n */\n\n/**\n * @const\n * @type {RegExp}\n */\nvar B_RECORD_RE = /^B(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{5})([NS])(\\d{3})(\\d{5})([EW])([AV])(\\d{5})(\\d{5})/;\n\n/**\n * @const\n * @type {RegExp}\n */\nvar H_RECORD_RE = /^H.([A-Z]{3}).*?:(.*)/;\n\n/**\n * @const\n * @type {RegExp}\n */\nvar HFDTE_RECORD_RE = /^HFDTE(\\d{2})(\\d{2})(\\d{2})/;\n\n/**\n * A regular expression matching the newline characters `\\r\\n`, `\\r` and `\\n`.\n *\n * @const\n * @type {RegExp}\n */\nvar NEWLINE_RE = /\\r\\n|\\r|\\n/;\n\n/**\n * @typedef {Object} Options\n * @property {IGCZ} [altitudeMode='none'] Altitude mode. Possible\n * values are `'barometric'`, `'gps'`, and `'none'`.\n */\n\n/**\n * @classdesc\n * Feature format for `*.igc` flight recording files.\n *\n * As IGC sources contain a single feature,\n * {@link module:ol/format/IGC~IGC#readFeatures} will return the feature in an\n * array\n *\n * @api\n */\nvar IGC = /*#__PURE__*/function (_TextFeature) {\n  /**\n   * @param {Options} [options] Options.\n   */\n  function IGC(options) {\n    var _this;\n    _classCallCheck(this, IGC);\n    _this = _callSuper(this, IGC);\n    options = options ? options : {};\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    _this.dataProjection = getProjection('EPSG:4326');\n\n    /**\n     * @private\n     * @type {IGCZ}\n     */\n    _this.altitudeMode_ = options.altitudeMode ? options.altitudeMode : 'none';\n    return _this;\n  }\n\n  /**\n   * @protected\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  _inherits(IGC, _TextFeature);\n  return _createClass(IGC, [{\n    key: \"readFeatureFromText\",\n    value: function readFeatureFromText(text, options) {\n      var altitudeMode = this.altitudeMode_;\n      var lines = text.split(NEWLINE_RE);\n      /** @type {Object<string, string>} */\n      var properties = {};\n      var flatCoordinates = [];\n      var year = 2000;\n      var month = 0;\n      var day = 1;\n      var lastDateTime = -1;\n      var i, ii;\n      for (i = 0, ii = lines.length; i < ii; ++i) {\n        var line = lines[i];\n        var m = void 0;\n        if (line.charAt(0) == 'B') {\n          m = B_RECORD_RE.exec(line);\n          if (m) {\n            var hour = parseInt(m[1], 10);\n            var minute = parseInt(m[2], 10);\n            var second = parseInt(m[3], 10);\n            var y = parseInt(m[4], 10) + parseInt(m[5], 10) / 60000;\n            if (m[6] == 'S') {\n              y = -y;\n            }\n            var x = parseInt(m[7], 10) + parseInt(m[8], 10) / 60000;\n            if (m[9] == 'W') {\n              x = -x;\n            }\n            flatCoordinates.push(x, y);\n            if (altitudeMode != 'none') {\n              var z = void 0;\n              if (altitudeMode == 'gps') {\n                z = parseInt(m[11], 10);\n              } else if (altitudeMode == 'barometric') {\n                z = parseInt(m[12], 10);\n              } else {\n                z = 0;\n              }\n              flatCoordinates.push(z);\n            }\n            var dateTime = Date.UTC(year, month, day, hour, minute, second);\n            // Detect UTC midnight wrap around.\n            if (dateTime < lastDateTime) {\n              dateTime = Date.UTC(year, month, day + 1, hour, minute, second);\n            }\n            flatCoordinates.push(dateTime / 1000);\n            lastDateTime = dateTime;\n          }\n        } else if (line.charAt(0) == 'H') {\n          m = HFDTE_RECORD_RE.exec(line);\n          if (m) {\n            day = parseInt(m[1], 10);\n            month = parseInt(m[2], 10) - 1;\n            year = 2000 + parseInt(m[3], 10);\n          } else {\n            m = H_RECORD_RE.exec(line);\n            if (m) {\n              properties[m[1]] = m[2].trim();\n            }\n          }\n        }\n      }\n      if (flatCoordinates.length === 0) {\n        return null;\n      }\n      var layout = altitudeMode == 'none' ? 'XYM' : 'XYZM';\n      var lineString = new LineString(flatCoordinates, layout);\n      var feature = new Feature(transformGeometryWithOptions(lineString, false, options));\n      feature.setProperties(properties, true);\n      return feature;\n    }\n\n    /**\n     * @param {string} text Text.\n     * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n     * @protected\n     * @return {Array<Feature>} Features.\n     */\n  }, {\n    key: \"readFeaturesFromText\",\n    value: function readFeaturesFromText(text, options) {\n      var feature = this.readFeatureFromText(text, options);\n      if (feature) {\n        return [feature];\n      }\n      return [];\n    }\n  }]);\n}(TextFeature);\nexport default IGC;","map":{"version":3,"names":["Feature","LineString","TextFeature","get","getProjection","transformGeometryWithOptions","B_RECORD_RE","H_RECORD_RE","HFDTE_RECORD_RE","NEWLINE_RE","IGC","_TextFeature","options","_this","_classCallCheck","_callSuper","dataProjection","altitudeMode_","altitudeMode","_inherits","_createClass","key","value","readFeatureFromText","text","lines","split","properties","flatCoordinates","year","month","day","lastDateTime","i","ii","length","line","m","charAt","exec","hour","parseInt","minute","second","y","x","push","z","dateTime","Date","UTC","trim","layout","lineString","feature","setProperties","readFeaturesFromText"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol/format/IGC.js"],"sourcesContent":["/**\n * @module ol/format/IGC\n */\nimport Feature from '../Feature.js';\nimport LineString from '../geom/LineString.js';\nimport TextFeature from './TextFeature.js';\nimport {get as getProjection} from '../proj.js';\nimport {transformGeometryWithOptions} from './Feature.js';\n\n/**\n * @typedef {'barometric' | 'gps' | 'none'} IGCZ\n * IGC altitude/z. One of 'barometric', 'gps', 'none'.\n */\n\n/**\n * @const\n * @type {RegExp}\n */\nconst B_RECORD_RE =\n  /^B(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{5})([NS])(\\d{3})(\\d{5})([EW])([AV])(\\d{5})(\\d{5})/;\n\n/**\n * @const\n * @type {RegExp}\n */\nconst H_RECORD_RE = /^H.([A-Z]{3}).*?:(.*)/;\n\n/**\n * @const\n * @type {RegExp}\n */\nconst HFDTE_RECORD_RE = /^HFDTE(\\d{2})(\\d{2})(\\d{2})/;\n\n/**\n * A regular expression matching the newline characters `\\r\\n`, `\\r` and `\\n`.\n *\n * @const\n * @type {RegExp}\n */\nconst NEWLINE_RE = /\\r\\n|\\r|\\n/;\n\n/**\n * @typedef {Object} Options\n * @property {IGCZ} [altitudeMode='none'] Altitude mode. Possible\n * values are `'barometric'`, `'gps'`, and `'none'`.\n */\n\n/**\n * @classdesc\n * Feature format for `*.igc` flight recording files.\n *\n * As IGC sources contain a single feature,\n * {@link module:ol/format/IGC~IGC#readFeatures} will return the feature in an\n * array\n *\n * @api\n */\nclass IGC extends TextFeature {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.dataProjection = getProjection('EPSG:4326');\n\n    /**\n     * @private\n     * @type {IGCZ}\n     */\n    this.altitudeMode_ = options.altitudeMode ? options.altitudeMode : 'none';\n  }\n\n  /**\n   * @protected\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromText(text, options) {\n    const altitudeMode = this.altitudeMode_;\n    const lines = text.split(NEWLINE_RE);\n    /** @type {Object<string, string>} */\n    const properties = {};\n    const flatCoordinates = [];\n    let year = 2000;\n    let month = 0;\n    let day = 1;\n    let lastDateTime = -1;\n    let i, ii;\n    for (i = 0, ii = lines.length; i < ii; ++i) {\n      const line = lines[i];\n      let m;\n      if (line.charAt(0) == 'B') {\n        m = B_RECORD_RE.exec(line);\n        if (m) {\n          const hour = parseInt(m[1], 10);\n          const minute = parseInt(m[2], 10);\n          const second = parseInt(m[3], 10);\n          let y = parseInt(m[4], 10) + parseInt(m[5], 10) / 60000;\n          if (m[6] == 'S') {\n            y = -y;\n          }\n          let x = parseInt(m[7], 10) + parseInt(m[8], 10) / 60000;\n          if (m[9] == 'W') {\n            x = -x;\n          }\n          flatCoordinates.push(x, y);\n          if (altitudeMode != 'none') {\n            let z;\n            if (altitudeMode == 'gps') {\n              z = parseInt(m[11], 10);\n            } else if (altitudeMode == 'barometric') {\n              z = parseInt(m[12], 10);\n            } else {\n              z = 0;\n            }\n            flatCoordinates.push(z);\n          }\n          let dateTime = Date.UTC(year, month, day, hour, minute, second);\n          // Detect UTC midnight wrap around.\n          if (dateTime < lastDateTime) {\n            dateTime = Date.UTC(year, month, day + 1, hour, minute, second);\n          }\n          flatCoordinates.push(dateTime / 1000);\n          lastDateTime = dateTime;\n        }\n      } else if (line.charAt(0) == 'H') {\n        m = HFDTE_RECORD_RE.exec(line);\n        if (m) {\n          day = parseInt(m[1], 10);\n          month = parseInt(m[2], 10) - 1;\n          year = 2000 + parseInt(m[3], 10);\n        } else {\n          m = H_RECORD_RE.exec(line);\n          if (m) {\n            properties[m[1]] = m[2].trim();\n          }\n        }\n      }\n    }\n    if (flatCoordinates.length === 0) {\n      return null;\n    }\n    const layout = altitudeMode == 'none' ? 'XYM' : 'XYZM';\n    const lineString = new LineString(flatCoordinates, layout);\n    const feature = new Feature(\n      transformGeometryWithOptions(lineString, false, options)\n    );\n    feature.setProperties(properties, true);\n    return feature;\n  }\n\n  /**\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<Feature>} Features.\n   */\n  readFeaturesFromText(text, options) {\n    const feature = this.readFeatureFromText(text, options);\n    if (feature) {\n      return [feature];\n    }\n    return [];\n  }\n}\n\nexport default IGC;\n"],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA,OAAOA,OAAO,MAAM,eAAe;AACnC,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,WAAW,MAAM,kBAAkB;AAC1C,SAAQC,GAAG,IAAIC,aAAa,QAAO,YAAY;AAC/C,SAAQC,4BAA4B,QAAO,cAAc;;AAEzD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAMC,WAAW,GACf,qFAAqF;;AAEvF;AACA;AACA;AACA;AACA,IAAMC,WAAW,GAAG,uBAAuB;;AAE3C;AACA;AACA;AACA;AACA,IAAMC,eAAe,GAAG,6BAA6B;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA,IAAMC,UAAU,GAAG,YAAY;;AAE/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA,IAUMC,GAAG,0BAAAC,YAAA;EACP;AACF;AACA;EACE,SAAAD,IAAYE,OAAO,EAAE;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAJ,GAAA;IACnBG,KAAA,GAAAE,UAAA,OAAAL,GAAA;IAEAE,OAAO,GAAGA,OAAO,GAAGA,OAAO,GAAG,CAAC,CAAC;;IAEhC;AACJ;AACA;IACIC,KAAA,CAAKG,cAAc,GAAGZ,aAAa,CAAC,WAAW,CAAC;;IAEhD;AACJ;AACA;AACA;IACIS,KAAA,CAAKI,aAAa,GAAGL,OAAO,CAACM,YAAY,GAAGN,OAAO,CAACM,YAAY,GAAG,MAAM;IAAC,OAAAL,KAAA;EAC5E;;EAEA;AACF;AACA;AACA;AACA;AACA;EALEM,SAAA,CAAAT,GAAA,EAAAC,YAAA;EAAA,OAAAS,YAAA,CAAAV,GAAA;IAAAW,GAAA;IAAAC,KAAA,EAMA,SAAAC,mBAAmBA,CAACC,IAAI,EAAEZ,OAAO,EAAE;MACjC,IAAMM,YAAY,GAAG,IAAI,CAACD,aAAa;MACvC,IAAMQ,KAAK,GAAGD,IAAI,CAACE,KAAK,CAACjB,UAAU,CAAC;MACpC;MACA,IAAMkB,UAAU,GAAG,CAAC,CAAC;MACrB,IAAMC,eAAe,GAAG,EAAE;MAC1B,IAAIC,IAAI,GAAG,IAAI;MACf,IAAIC,KAAK,GAAG,CAAC;MACb,IAAIC,GAAG,GAAG,CAAC;MACX,IAAIC,YAAY,GAAG,CAAC,CAAC;MACrB,IAAIC,CAAC,EAAEC,EAAE;MACT,KAAKD,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGT,KAAK,CAACU,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAE,EAAED,CAAC,EAAE;QAC1C,IAAMG,IAAI,GAAGX,KAAK,CAACQ,CAAC,CAAC;QACrB,IAAII,CAAC;QACL,IAAID,IAAI,CAACE,MAAM,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE;UACzBD,CAAC,GAAG/B,WAAW,CAACiC,IAAI,CAACH,IAAI,CAAC;UAC1B,IAAIC,CAAC,EAAE;YACL,IAAMG,IAAI,GAAGC,QAAQ,CAACJ,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;YAC/B,IAAMK,MAAM,GAAGD,QAAQ,CAACJ,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;YACjC,IAAMM,MAAM,GAAGF,QAAQ,CAACJ,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;YACjC,IAAIO,CAAC,GAAGH,QAAQ,CAACJ,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,GAAGI,QAAQ,CAACJ,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,KAAK;YACvD,IAAIA,CAAC,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE;cACfO,CAAC,GAAG,CAACA,CAAC;YACR;YACA,IAAIC,CAAC,GAAGJ,QAAQ,CAACJ,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,GAAGI,QAAQ,CAACJ,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,KAAK;YACvD,IAAIA,CAAC,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE;cACfQ,CAAC,GAAG,CAACA,CAAC;YACR;YACAjB,eAAe,CAACkB,IAAI,CAACD,CAAC,EAAED,CAAC,CAAC;YAC1B,IAAI1B,YAAY,IAAI,MAAM,EAAE;cAC1B,IAAI6B,CAAC;cACL,IAAI7B,YAAY,IAAI,KAAK,EAAE;gBACzB6B,CAAC,GAAGN,QAAQ,CAACJ,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;cACzB,CAAC,MAAM,IAAInB,YAAY,IAAI,YAAY,EAAE;gBACvC6B,CAAC,GAAGN,QAAQ,CAACJ,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;cACzB,CAAC,MAAM;gBACLU,CAAC,GAAG,CAAC;cACP;cACAnB,eAAe,CAACkB,IAAI,CAACC,CAAC,CAAC;YACzB;YACA,IAAIC,QAAQ,GAAGC,IAAI,CAACC,GAAG,CAACrB,IAAI,EAAEC,KAAK,EAAEC,GAAG,EAAES,IAAI,EAAEE,MAAM,EAAEC,MAAM,CAAC;YAC/D;YACA,IAAIK,QAAQ,GAAGhB,YAAY,EAAE;cAC3BgB,QAAQ,GAAGC,IAAI,CAACC,GAAG,CAACrB,IAAI,EAAEC,KAAK,EAAEC,GAAG,GAAG,CAAC,EAAES,IAAI,EAAEE,MAAM,EAAEC,MAAM,CAAC;YACjE;YACAf,eAAe,CAACkB,IAAI,CAACE,QAAQ,GAAG,IAAI,CAAC;YACrChB,YAAY,GAAGgB,QAAQ;UACzB;QACF,CAAC,MAAM,IAAIZ,IAAI,CAACE,MAAM,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE;UAChCD,CAAC,GAAG7B,eAAe,CAAC+B,IAAI,CAACH,IAAI,CAAC;UAC9B,IAAIC,CAAC,EAAE;YACLN,GAAG,GAAGU,QAAQ,CAACJ,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;YACxBP,KAAK,GAAGW,QAAQ,CAACJ,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC;YAC9BR,IAAI,GAAG,IAAI,GAAGY,QAAQ,CAACJ,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;UAClC,CAAC,MAAM;YACLA,CAAC,GAAG9B,WAAW,CAACgC,IAAI,CAACH,IAAI,CAAC;YAC1B,IAAIC,CAAC,EAAE;cACLV,UAAU,CAACU,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGA,CAAC,CAAC,CAAC,CAAC,CAACc,IAAI,CAAC,CAAC;YAChC;UACF;QACF;MACF;MACA,IAAIvB,eAAe,CAACO,MAAM,KAAK,CAAC,EAAE;QAChC,OAAO,IAAI;MACb;MACA,IAAMiB,MAAM,GAAGlC,YAAY,IAAI,MAAM,GAAG,KAAK,GAAG,MAAM;MACtD,IAAMmC,UAAU,GAAG,IAAIpD,UAAU,CAAC2B,eAAe,EAAEwB,MAAM,CAAC;MAC1D,IAAME,OAAO,GAAG,IAAItD,OAAO,CACzBK,4BAA4B,CAACgD,UAAU,EAAE,KAAK,EAAEzC,OAAO,CACzD,CAAC;MACD0C,OAAO,CAACC,aAAa,CAAC5B,UAAU,EAAE,IAAI,CAAC;MACvC,OAAO2B,OAAO;IAChB;;IAEA;AACF;AACA;AACA;AACA;AACA;EALE;IAAAjC,GAAA;IAAAC,KAAA,EAMA,SAAAkC,oBAAoBA,CAAChC,IAAI,EAAEZ,OAAO,EAAE;MAClC,IAAM0C,OAAO,GAAG,IAAI,CAAC/B,mBAAmB,CAACC,IAAI,EAAEZ,OAAO,CAAC;MACvD,IAAI0C,OAAO,EAAE;QACX,OAAO,CAACA,OAAO,CAAC;MAClB;MACA,OAAO,EAAE;IACX;EAAC;AAAA,EAjHepD,WAAW;AAoH7B,eAAeQ,GAAG","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}