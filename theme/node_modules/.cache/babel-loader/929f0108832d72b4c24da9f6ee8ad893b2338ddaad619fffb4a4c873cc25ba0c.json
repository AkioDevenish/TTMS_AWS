{"ast":null,"code":"import _classCallCheck from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _callSuper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _superPropGet from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/superPropGet.js\";\nimport _inherits from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\n/**\n * @module ol/source/DataTile\n */\nimport DataTile from '../DataTile.js';\nimport EventType from '../events/EventType.js';\nimport ReprojDataTile from '../reproj/DataTile.js';\nimport TileCache from '../TileCache.js';\nimport TileEventType from './TileEventType.js';\nimport TileSource, { TileSourceEvent } from './Tile.js';\nimport TileState from '../TileState.js';\nimport { createXYZ, extentFromProjection, getForProjection as _getTileGridForProjection } from '../tilegrid.js';\nimport { equivalent, get as getProjection } from '../proj.js';\nimport { getKeyZXY } from '../tilecoord.js';\nimport { getUid } from '../util.js';\nimport { toPromise } from '../functions.js';\nimport { toSize } from '../size.js';\n\n/**\n * Data tile loading function.  The function is called with z, x, and y tile coordinates and\n * returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\n * @typedef {function(number, number, number) : (import(\"../DataTile.js\").Data|Promise<import(\"../DataTile.js\").Data>)} Loader\n */\n\n/**\n * @typedef {Object} Options\n * @property {Loader} [loader] Data loader.  Called with z, x, and y tile coordinates.\n * Returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\n * For loaders that generate images, the promise should not resolve until the image is loaded.\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The pixel width and height of the source tiles.\n * This may be different than the rendered pixel size if a `tileGrid` is provided.\n * @property {number} [gutter=0] The size in pixels of the gutter around data tiles to ignore.\n * This allows artifacts of rendering at tile edges to be ignored.\n * Supported data should be wider and taller than the tile size by a value of `2 x gutter`.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Tile projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {import(\"./Source.js\").State} [state] The source state.\n * @property {boolean} [wrapX=false] Render tiles beyond the antimeridian.\n * @property {number} [transition] Transition time when fading in new tiles (in milliseconds).\n * @property {number} [bandCount=4] Number of bands represented in the data.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n */\n\n/**\n * @classdesc\n * A source for typed array data tiles.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\nvar DataTileSource = /*#__PURE__*/function (_TileSource) {\n  /**\n   * @param {Options} options DataTile source options.\n   */\n  function DataTileSource(options) {\n    var _this;\n    _classCallCheck(this, DataTileSource);\n    var projection = options.projection === undefined ? 'EPSG:3857' : options.projection;\n    var tileGrid = options.tileGrid;\n    if (tileGrid === undefined && projection) {\n      tileGrid = createXYZ({\n        extent: extentFromProjection(projection),\n        maxResolution: options.maxResolution,\n        maxZoom: options.maxZoom,\n        minZoom: options.minZoom,\n        tileSize: options.tileSize\n      });\n    }\n    _this = _callSuper(this, DataTileSource, [{\n      cacheSize: 0.1,\n      // don't cache on the source\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      projection: projection,\n      tileGrid: tileGrid,\n      opaque: options.opaque,\n      state: options.state,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      interpolate: options.interpolate\n    }]);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.gutter_ = options.gutter !== undefined ? options.gutter : 0;\n\n    /**\n     * @private\n     * @type {import('../size.js').Size|null}\n     */\n    _this.tileSize_ = options.tileSize ? toSize(options.tileSize) : null;\n\n    /**\n     * @private\n     * @type {Array<import('../size.js').Size>|null}\n     */\n    _this.tileSizes_ = null;\n\n    /**\n     * @private\n     * @type {!Object<string, boolean>}\n     */\n    _this.tileLoadingKeys_ = {};\n\n    /**\n     * @private\n     */\n    _this.loader_ = options.loader;\n    _this.handleTileChange_ = _this.handleTileChange_.bind(_this);\n\n    /**\n     * @type {number}\n     */\n    _this.bandCount = options.bandCount === undefined ? 4 : options.bandCount; // assume RGBA if undefined\n\n    /**\n     * @private\n     * @type {!Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n    _this.tileGridForProjection_ = {};\n\n    /**\n     * @private\n     * @type {!Object<string, import(\"../TileCache.js\").default>}\n     */\n    _this.tileCacheForProjection_ = {};\n    return _this;\n  }\n\n  /**\n   * Set the source tile sizes.  The length of the array is expected to match the number of\n   * levels in the tile grid.\n   * @protected\n   * @param {Array<import('../size.js').Size>} tileSizes An array of tile sizes.\n   */\n  _inherits(DataTileSource, _TileSource);\n  return _createClass(DataTileSource, [{\n    key: \"setTileSizes\",\n    value: function setTileSizes(tileSizes) {\n      this.tileSizes_ = tileSizes;\n    }\n\n    /**\n     * Get the source tile size at the given zoom level.  This may be different than the rendered tile\n     * size.\n     * @protected\n     * @param {number} z Tile zoom level.\n     * @return {import('../size.js').Size} The source tile size.\n     */\n  }, {\n    key: \"getTileSize\",\n    value: function getTileSize(z) {\n      if (this.tileSizes_) {\n        return this.tileSizes_[z];\n      }\n      if (this.tileSize_) {\n        return this.tileSize_;\n      }\n      var tileGrid = this.getTileGrid();\n      return tileGrid ? toSize(tileGrid.getTileSize(z)) : [256, 256];\n    }\n\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {number} Gutter.\n     */\n  }, {\n    key: \"getGutterForProjection\",\n    value: function getGutterForProjection(projection) {\n      var thisProj = this.getProjection();\n      if (!thisProj || equivalent(thisProj, projection)) {\n        return this.gutter_;\n      }\n      return 0;\n    }\n\n    /**\n     * @param {Loader} loader The data loader.\n     * @protected\n     */\n  }, {\n    key: \"setLoader\",\n    value: function setLoader(loader) {\n      this.loader_ = loader;\n    }\n\n    /**\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @param {import(\"../proj/Projection.js\").default} targetProj The output projection.\n     * @param {import(\"../proj/Projection.js\").default} sourceProj The input projection.\n     * @return {!DataTile} Tile.\n     */\n  }, {\n    key: \"getReprojTile_\",\n    value: function getReprojTile_(z, x, y, targetProj, sourceProj) {\n      var _this2 = this;\n      var cache = this.getTileCacheForProjection(targetProj);\n      var tileCoordKey = getKeyZXY(z, x, y);\n      if (cache.containsKey(tileCoordKey)) {\n        var tile = cache.get(tileCoordKey);\n        if (tile && tile.key == this.getKey()) {\n          return tile;\n        }\n      }\n      var tileGrid = this.getTileGrid();\n      var reprojTilePixelRatio = Math.max.apply(null, tileGrid.getResolutions().map(function (r, z) {\n        var tileSize = toSize(tileGrid.getTileSize(z));\n        var textureSize = _this2.getTileSize(z);\n        return Math.max(textureSize[0] / tileSize[0], textureSize[1] / tileSize[1]);\n      }));\n      var sourceTileGrid = this.getTileGridForProjection(sourceProj);\n      var targetTileGrid = this.getTileGridForProjection(targetProj);\n      var tileCoord = [z, x, y];\n      var wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, targetProj);\n      var options = Object.assign({\n        sourceProj: sourceProj,\n        sourceTileGrid: sourceTileGrid,\n        targetProj: targetProj,\n        targetTileGrid: targetTileGrid,\n        tileCoord: tileCoord,\n        wrappedTileCoord: wrappedTileCoord,\n        pixelRatio: reprojTilePixelRatio,\n        gutter: this.getGutterForProjection(sourceProj),\n        getTileFunction: function getTileFunction(z, x, y, pixelRatio) {\n          return _this2.getTile(z, x, y, pixelRatio, sourceProj);\n        }\n      }, this.tileOptions);\n      var newTile = new ReprojDataTile(options);\n      newTile.key = this.getKey();\n      return newTile;\n    }\n\n    /**\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {!DataTile} Tile.\n     */\n  }, {\n    key: \"getTile\",\n    value: function getTile(z, x, y, pixelRatio, projection) {\n      var sourceProjection = this.getProjection();\n      if (sourceProjection && projection && !equivalent(sourceProjection, projection)) {\n        return this.getReprojTile_(z, x, y, projection, sourceProjection);\n      }\n      var size = this.getTileSize(z);\n      var tileCoordKey = getKeyZXY(z, x, y);\n      if (this.tileCache.containsKey(tileCoordKey)) {\n        return this.tileCache.get(tileCoordKey);\n      }\n      var sourceLoader = this.loader_;\n      function loader() {\n        return toPromise(function () {\n          return sourceLoader(z, x, y);\n        });\n      }\n      var options = Object.assign({\n        tileCoord: [z, x, y],\n        loader: loader,\n        size: size\n      }, this.tileOptions);\n      var tile = new DataTile(options);\n      tile.key = this.getKey();\n      tile.addEventListener(EventType.CHANGE, this.handleTileChange_);\n      this.tileCache.set(tileCoordKey, tile);\n      return tile;\n    }\n\n    /**\n     * Handle tile change events.\n     * @param {import(\"../events/Event.js\").default} event Event.\n     */\n  }, {\n    key: \"handleTileChange_\",\n    value: function handleTileChange_(event) {\n      var tile = /** @type {import(\"../Tile.js\").default} */event.target;\n      var uid = getUid(tile);\n      var tileState = tile.getState();\n      var type;\n      if (tileState == TileState.LOADING) {\n        this.tileLoadingKeys_[uid] = true;\n        type = TileEventType.TILELOADSTART;\n      } else if (uid in this.tileLoadingKeys_) {\n        delete this.tileLoadingKeys_[uid];\n        type = tileState == TileState.ERROR ? TileEventType.TILELOADERROR : tileState == TileState.LOADED ? TileEventType.TILELOADEND : undefined;\n      }\n      if (type) {\n        this.dispatchEvent(new TileSourceEvent(type, tile));\n      }\n    }\n\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n     */\n  }, {\n    key: \"getTileGridForProjection\",\n    value: function getTileGridForProjection(projection) {\n      var thisProj = this.getProjection();\n      if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {\n        return this.tileGrid;\n      }\n      var projKey = getUid(projection);\n      if (!(projKey in this.tileGridForProjection_)) {\n        this.tileGridForProjection_[projKey] = _getTileGridForProjection(projection);\n      }\n      return this.tileGridForProjection_[projKey];\n    }\n\n    /**\n     * Sets the tile grid to use when reprojecting the tiles to the given\n     * projection instead of the default tile grid for the projection.\n     *\n     * This can be useful when the default tile grid cannot be created\n     * (e.g. projection has no extent defined) or\n     * for optimization reasons (custom tile size, resolutions, ...).\n     *\n     * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\n     * @param {import(\"../tilegrid/TileGrid.js\").default} tilegrid Tile grid to use for the projection.\n     * @api\n     */\n  }, {\n    key: \"setTileGridForProjection\",\n    value: function setTileGridForProjection(projection, tilegrid) {\n      var proj = getProjection(projection);\n      if (proj) {\n        var projKey = getUid(proj);\n        if (!(projKey in this.tileGridForProjection_)) {\n          this.tileGridForProjection_[projKey] = tilegrid;\n        }\n      }\n    }\n\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {import(\"../TileCache.js\").default} Tile cache.\n     */\n  }, {\n    key: \"getTileCacheForProjection\",\n    value: function getTileCacheForProjection(projection) {\n      var thisProj = this.getProjection();\n      if (!thisProj || equivalent(thisProj, projection)) {\n        return this.tileCache;\n      }\n      var projKey = getUid(projection);\n      if (!(projKey in this.tileCacheForProjection_)) {\n        this.tileCacheForProjection_[projKey] = new TileCache(0.1); // don't cache\n      }\n      return this.tileCacheForProjection_[projKey];\n    }\n\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @param {!Object<string, boolean>} usedTiles Used tiles.\n     */\n  }, {\n    key: \"expireCache\",\n    value: function expireCache(projection, usedTiles) {\n      var usedTileCache = this.getTileCacheForProjection(projection);\n      this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});\n      for (var id in this.tileCacheForProjection_) {\n        var tileCache = this.tileCacheForProjection_[id];\n        tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});\n      }\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      _superPropGet(DataTileSource, \"clear\", this, 3)([]);\n      for (var id in this.tileCacheForProjection_) {\n        this.tileCacheForProjection_[id].clear();\n      }\n    }\n  }]);\n}(TileSource);\nexport default DataTileSource;","map":{"version":3,"names":["DataTile","EventType","ReprojDataTile","TileCache","TileEventType","TileSource","TileSourceEvent","TileState","createXYZ","extentFromProjection","getForProjection","getTileGridForProjection","equivalent","get","getProjection","getKeyZXY","getUid","toPromise","toSize","DataTileSource","_TileSource","options","_this","_classCallCheck","projection","undefined","tileGrid","extent","maxResolution","maxZoom","minZoom","tileSize","_callSuper","cacheSize","attributions","attributionsCollapsible","opaque","state","wrapX","transition","interpolate","gutter_","gutter","tileSize_","tileSizes_","tileLoadingKeys_","loader_","loader","handleTileChange_","bind","bandCount","tileGridForProjection_","tileCacheForProjection_","_inherits","_createClass","key","value","setTileSizes","tileSizes","getTileSize","z","getTileGrid","getGutterForProjection","thisProj","setLoader","getReprojTile_","x","y","targetProj","sourceProj","_this2","cache","getTileCacheForProjection","tileCoordKey","containsKey","tile","getKey","reprojTilePixelRatio","Math","max","apply","getResolutions","map","r","textureSize","sourceTileGrid","targetTileGrid","tileCoord","wrappedTileCoord","getTileCoordForTileUrlFunction","Object","assign","pixelRatio","getTileFunction","getTile","tileOptions","newTile","sourceProjection","size","tileCache","sourceLoader","addEventListener","CHANGE","set","event","target","uid","tileState","getState","type","LOADING","TILELOADSTART","ERROR","TILELOADERROR","LOADED","TILELOADEND","dispatchEvent","projKey","setTileGridForProjection","tilegrid","proj","expireCache","usedTiles","usedTileCache","id","clear","_superPropGet"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol/source/DataTile.js"],"sourcesContent":["/**\n * @module ol/source/DataTile\n */\nimport DataTile from '../DataTile.js';\nimport EventType from '../events/EventType.js';\nimport ReprojDataTile from '../reproj/DataTile.js';\nimport TileCache from '../TileCache.js';\nimport TileEventType from './TileEventType.js';\nimport TileSource, {TileSourceEvent} from './Tile.js';\nimport TileState from '../TileState.js';\nimport {\n  createXYZ,\n  extentFromProjection,\n  getForProjection as getTileGridForProjection,\n} from '../tilegrid.js';\nimport {equivalent, get as getProjection} from '../proj.js';\nimport {getKeyZXY} from '../tilecoord.js';\nimport {getUid} from '../util.js';\nimport {toPromise} from '../functions.js';\nimport {toSize} from '../size.js';\n\n/**\n * Data tile loading function.  The function is called with z, x, and y tile coordinates and\n * returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\n * @typedef {function(number, number, number) : (import(\"../DataTile.js\").Data|Promise<import(\"../DataTile.js\").Data>)} Loader\n */\n\n/**\n * @typedef {Object} Options\n * @property {Loader} [loader] Data loader.  Called with z, x, and y tile coordinates.\n * Returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\n * For loaders that generate images, the promise should not resolve until the image is loaded.\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The pixel width and height of the source tiles.\n * This may be different than the rendered pixel size if a `tileGrid` is provided.\n * @property {number} [gutter=0] The size in pixels of the gutter around data tiles to ignore.\n * This allows artifacts of rendering at tile edges to be ignored.\n * Supported data should be wider and taller than the tile size by a value of `2 x gutter`.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Tile projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {import(\"./Source.js\").State} [state] The source state.\n * @property {boolean} [wrapX=false] Render tiles beyond the antimeridian.\n * @property {number} [transition] Transition time when fading in new tiles (in milliseconds).\n * @property {number} [bandCount=4] Number of bands represented in the data.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n */\n\n/**\n * @classdesc\n * A source for typed array data tiles.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\nclass DataTileSource extends TileSource {\n  /**\n   * @param {Options} options DataTile source options.\n   */\n  constructor(options) {\n    const projection =\n      options.projection === undefined ? 'EPSG:3857' : options.projection;\n\n    let tileGrid = options.tileGrid;\n    if (tileGrid === undefined && projection) {\n      tileGrid = createXYZ({\n        extent: extentFromProjection(projection),\n        maxResolution: options.maxResolution,\n        maxZoom: options.maxZoom,\n        minZoom: options.minZoom,\n        tileSize: options.tileSize,\n      });\n    }\n\n    super({\n      cacheSize: 0.1, // don't cache on the source\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      projection: projection,\n      tileGrid: tileGrid,\n      opaque: options.opaque,\n      state: options.state,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      interpolate: options.interpolate,\n    });\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = options.gutter !== undefined ? options.gutter : 0;\n\n    /**\n     * @private\n     * @type {import('../size.js').Size|null}\n     */\n    this.tileSize_ = options.tileSize ? toSize(options.tileSize) : null;\n\n    /**\n     * @private\n     * @type {Array<import('../size.js').Size>|null}\n     */\n    this.tileSizes_ = null;\n\n    /**\n     * @private\n     * @type {!Object<string, boolean>}\n     */\n    this.tileLoadingKeys_ = {};\n\n    /**\n     * @private\n     */\n    this.loader_ = options.loader;\n\n    this.handleTileChange_ = this.handleTileChange_.bind(this);\n\n    /**\n     * @type {number}\n     */\n    this.bandCount = options.bandCount === undefined ? 4 : options.bandCount; // assume RGBA if undefined\n\n    /**\n     * @private\n     * @type {!Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n    this.tileGridForProjection_ = {};\n\n    /**\n     * @private\n     * @type {!Object<string, import(\"../TileCache.js\").default>}\n     */\n    this.tileCacheForProjection_ = {};\n  }\n\n  /**\n   * Set the source tile sizes.  The length of the array is expected to match the number of\n   * levels in the tile grid.\n   * @protected\n   * @param {Array<import('../size.js').Size>} tileSizes An array of tile sizes.\n   */\n  setTileSizes(tileSizes) {\n    this.tileSizes_ = tileSizes;\n  }\n\n  /**\n   * Get the source tile size at the given zoom level.  This may be different than the rendered tile\n   * size.\n   * @protected\n   * @param {number} z Tile zoom level.\n   * @return {import('../size.js').Size} The source tile size.\n   */\n  getTileSize(z) {\n    if (this.tileSizes_) {\n      return this.tileSizes_[z];\n    }\n    if (this.tileSize_) {\n      return this.tileSize_;\n    }\n    const tileGrid = this.getTileGrid();\n    return tileGrid ? toSize(tileGrid.getTileSize(z)) : [256, 256];\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {number} Gutter.\n   */\n  getGutterForProjection(projection) {\n    const thisProj = this.getProjection();\n    if (!thisProj || equivalent(thisProj, projection)) {\n      return this.gutter_;\n    }\n\n    return 0;\n  }\n\n  /**\n   * @param {Loader} loader The data loader.\n   * @protected\n   */\n  setLoader(loader) {\n    this.loader_ = loader;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../proj/Projection.js\").default} targetProj The output projection.\n   * @param {import(\"../proj/Projection.js\").default} sourceProj The input projection.\n   * @return {!DataTile} Tile.\n   */\n  getReprojTile_(z, x, y, targetProj, sourceProj) {\n    const cache = this.getTileCacheForProjection(targetProj);\n    const tileCoordKey = getKeyZXY(z, x, y);\n    if (cache.containsKey(tileCoordKey)) {\n      const tile = cache.get(tileCoordKey);\n      if (tile && tile.key == this.getKey()) {\n        return tile;\n      }\n    }\n\n    const tileGrid = this.getTileGrid();\n    const reprojTilePixelRatio = Math.max.apply(\n      null,\n      tileGrid.getResolutions().map((r, z) => {\n        const tileSize = toSize(tileGrid.getTileSize(z));\n        const textureSize = this.getTileSize(z);\n        return Math.max(\n          textureSize[0] / tileSize[0],\n          textureSize[1] / tileSize[1]\n        );\n      })\n    );\n\n    const sourceTileGrid = this.getTileGridForProjection(sourceProj);\n    const targetTileGrid = this.getTileGridForProjection(targetProj);\n    const tileCoord = [z, x, y];\n    const wrappedTileCoord = this.getTileCoordForTileUrlFunction(\n      tileCoord,\n      targetProj\n    );\n\n    const options = Object.assign(\n      {\n        sourceProj,\n        sourceTileGrid,\n        targetProj,\n        targetTileGrid,\n        tileCoord,\n        wrappedTileCoord,\n        pixelRatio: reprojTilePixelRatio,\n        gutter: this.getGutterForProjection(sourceProj),\n        getTileFunction: (z, x, y, pixelRatio) =>\n          this.getTile(z, x, y, pixelRatio, sourceProj),\n      },\n      this.tileOptions\n    );\n    const newTile = new ReprojDataTile(options);\n    newTile.key = this.getKey();\n    return newTile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!DataTile} Tile.\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const sourceProjection = this.getProjection();\n    if (\n      sourceProjection &&\n      projection &&\n      !equivalent(sourceProjection, projection)\n    ) {\n      return this.getReprojTile_(z, x, y, projection, sourceProjection);\n    }\n\n    const size = this.getTileSize(z);\n    const tileCoordKey = getKeyZXY(z, x, y);\n    if (this.tileCache.containsKey(tileCoordKey)) {\n      return this.tileCache.get(tileCoordKey);\n    }\n\n    const sourceLoader = this.loader_;\n\n    function loader() {\n      return toPromise(function () {\n        return sourceLoader(z, x, y);\n      });\n    }\n\n    const options = Object.assign(\n      {\n        tileCoord: [z, x, y],\n        loader: loader,\n        size: size,\n      },\n      this.tileOptions\n    );\n\n    const tile = new DataTile(options);\n    tile.key = this.getKey();\n    tile.addEventListener(EventType.CHANGE, this.handleTileChange_);\n\n    this.tileCache.set(tileCoordKey, tile);\n    return tile;\n  }\n\n  /**\n   * Handle tile change events.\n   * @param {import(\"../events/Event.js\").default} event Event.\n   */\n  handleTileChange_(event) {\n    const tile = /** @type {import(\"../Tile.js\").default} */ (event.target);\n    const uid = getUid(tile);\n    const tileState = tile.getState();\n    let type;\n    if (tileState == TileState.LOADING) {\n      this.tileLoadingKeys_[uid] = true;\n      type = TileEventType.TILELOADSTART;\n    } else if (uid in this.tileLoadingKeys_) {\n      delete this.tileLoadingKeys_[uid];\n      type =\n        tileState == TileState.ERROR\n          ? TileEventType.TILELOADERROR\n          : tileState == TileState.LOADED\n          ? TileEventType.TILELOADEND\n          : undefined;\n    }\n    if (type) {\n      this.dispatchEvent(new TileSourceEvent(type, tile));\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   */\n  getTileGridForProjection(projection) {\n    const thisProj = this.getProjection();\n    if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {\n      return this.tileGrid;\n    }\n\n    const projKey = getUid(projection);\n    if (!(projKey in this.tileGridForProjection_)) {\n      this.tileGridForProjection_[projKey] =\n        getTileGridForProjection(projection);\n    }\n    return this.tileGridForProjection_[projKey];\n  }\n\n  /**\n   * Sets the tile grid to use when reprojecting the tiles to the given\n   * projection instead of the default tile grid for the projection.\n   *\n   * This can be useful when the default tile grid cannot be created\n   * (e.g. projection has no extent defined) or\n   * for optimization reasons (custom tile size, resolutions, ...).\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tilegrid Tile grid to use for the projection.\n   * @api\n   */\n  setTileGridForProjection(projection, tilegrid) {\n    const proj = getProjection(projection);\n    if (proj) {\n      const projKey = getUid(proj);\n      if (!(projKey in this.tileGridForProjection_)) {\n        this.tileGridForProjection_[projKey] = tilegrid;\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../TileCache.js\").default} Tile cache.\n   */\n  getTileCacheForProjection(projection) {\n    const thisProj = this.getProjection();\n    if (!thisProj || equivalent(thisProj, projection)) {\n      return this.tileCache;\n    }\n\n    const projKey = getUid(projection);\n    if (!(projKey in this.tileCacheForProjection_)) {\n      this.tileCacheForProjection_[projKey] = new TileCache(0.1); // don't cache\n    }\n    return this.tileCacheForProjection_[projKey];\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n  expireCache(projection, usedTiles) {\n    const usedTileCache = this.getTileCacheForProjection(projection);\n\n    this.tileCache.expireCache(\n      this.tileCache == usedTileCache ? usedTiles : {}\n    );\n    for (const id in this.tileCacheForProjection_) {\n      const tileCache = this.tileCacheForProjection_[id];\n      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});\n    }\n  }\n\n  clear() {\n    super.clear();\n    for (const id in this.tileCacheForProjection_) {\n      this.tileCacheForProjection_[id].clear();\n    }\n  }\n}\n\nexport default DataTileSource;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}