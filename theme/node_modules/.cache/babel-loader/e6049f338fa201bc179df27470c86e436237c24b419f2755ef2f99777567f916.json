{"ast":null,"code":"import _classCallCheck from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _callSuper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.string.replace.js\";\n/**\n * @module ol/format/WMSGetFeatureInfo\n */\nimport GML2 from './GML2.js';\nimport XMLFeature from './XMLFeature.js';\nimport { extend } from '../array.js';\nimport { makeArrayPusher, makeStructureNS, pushParseAndPop } from '../xml.js';\n\n/**\n * @typedef {Object} Options\n * @property {Array<string>} [layers] If set, only features of the given layers will be returned by the format when read.\n */\n\n/**\n * @const\n * @type {string}\n */\nvar featureIdentifier = '_feature';\n\n/**\n * @const\n * @type {string}\n */\nvar layerIdentifier = '_layer';\n\n/**\n * @classdesc\n * Format for reading WMSGetFeatureInfo format. It uses\n * {@link module:ol/format/GML2~GML2} to read features.\n *\n * @api\n */\nvar WMSGetFeatureInfo = /*#__PURE__*/function (_XMLFeature) {\n  /**\n   * @param {Options} [options] Options.\n   */\n  function WMSGetFeatureInfo(options) {\n    var _this;\n    _classCallCheck(this, WMSGetFeatureInfo);\n    _this = _callSuper(this, WMSGetFeatureInfo);\n    options = options ? options : {};\n\n    /**\n     * @private\n     * @type {string}\n     */\n    _this.featureNS_ = 'http://mapserver.gis.umn.edu/mapserver';\n\n    /**\n     * @private\n     * @type {GML2}\n     */\n    _this.gmlFormat_ = new GML2();\n\n    /**\n     * @private\n     * @type {Array<string>|null}\n     */\n    _this.layers_ = options.layers ? options.layers : null;\n    return _this;\n  }\n\n  /**\n   * @return {Array<string>|null} layers\n   */\n  _inherits(WMSGetFeatureInfo, _XMLFeature);\n  return _createClass(WMSGetFeatureInfo, [{\n    key: \"getLayers\",\n    value: function getLayers() {\n      return this.layers_;\n    }\n\n    /**\n     * @param {Array<string>|null} layers Layers to parse.\n     */\n  }, {\n    key: \"setLayers\",\n    value: function setLayers(layers) {\n      this.layers_ = layers;\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {Array<import(\"../Feature.js\").default>} Features.\n     * @private\n     */\n  }, {\n    key: \"readFeatures_\",\n    value: function readFeatures_(node, objectStack) {\n      node.setAttribute('namespaceURI', this.featureNS_);\n      var localName = node.localName;\n      /** @type {Array<import(\"../Feature.js\").default>} */\n      var features = [];\n      if (node.childNodes.length === 0) {\n        return features;\n      }\n      if (localName == 'msGMLOutput') {\n        for (var i = 0, ii = node.childNodes.length; i < ii; i++) {\n          var layer = node.childNodes[i];\n          if (layer.nodeType !== Node.ELEMENT_NODE) {\n            continue;\n          }\n          var layerElement = /** @type {Element} */layer;\n          var context = objectStack[0];\n          var toRemove = layerIdentifier;\n          var layerName = layerElement.localName.replace(toRemove, '');\n          if (this.layers_ && !this.layers_.includes(layerName)) {\n            continue;\n          }\n          var featureType = layerName + featureIdentifier;\n          context['featureType'] = featureType;\n          context['featureNS'] = this.featureNS_;\n\n          /** @type {Object<string, import(\"../xml.js\").Parser>} */\n          var parsers = {};\n          parsers[featureType] = makeArrayPusher(this.gmlFormat_.readFeatureElement, this.gmlFormat_);\n          var parsersNS = makeStructureNS([context['featureNS'], null], parsers);\n          layerElement.setAttribute('namespaceURI', this.featureNS_);\n          var layerFeatures = pushParseAndPop([],\n          // @ts-ignore\n          parsersNS, layerElement, objectStack, this.gmlFormat_);\n          if (layerFeatures) {\n            extend(features, layerFeatures);\n          }\n        }\n      }\n      if (localName == 'FeatureCollection') {\n        var gmlFeatures = pushParseAndPop([], this.gmlFormat_.FEATURE_COLLECTION_PARSERS, node, [{}], this.gmlFormat_);\n        if (gmlFeatures) {\n          features = gmlFeatures;\n        }\n      }\n      return features;\n    }\n\n    /**\n     * @protected\n     * @param {Element} node Node.\n     * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n     * @return {Array<import(\"../Feature.js\").default>} Features.\n     */\n  }, {\n    key: \"readFeaturesFromNode\",\n    value: function readFeaturesFromNode(node, options) {\n      var internalOptions = {};\n      if (options) {\n        Object.assign(internalOptions, this.getReadOptions(node, options));\n      }\n      return this.readFeatures_(node, [internalOptions]);\n    }\n  }]);\n}(XMLFeature);\nexport default WMSGetFeatureInfo;","map":{"version":3,"names":["GML2","XMLFeature","extend","makeArrayPusher","makeStructureNS","pushParseAndPop","featureIdentifier","layerIdentifier","WMSGetFeatureInfo","_XMLFeature","options","_this","_classCallCheck","_callSuper","featureNS_","gmlFormat_","layers_","layers","_inherits","_createClass","key","value","getLayers","setLayers","readFeatures_","node","objectStack","setAttribute","localName","features","childNodes","length","i","ii","layer","nodeType","Node","ELEMENT_NODE","layerElement","context","toRemove","layerName","replace","includes","featureType","parsers","readFeatureElement","parsersNS","layerFeatures","gmlFeatures","FEATURE_COLLECTION_PARSERS","readFeaturesFromNode","internalOptions","Object","assign","getReadOptions"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol/format/WMSGetFeatureInfo.js"],"sourcesContent":["/**\n * @module ol/format/WMSGetFeatureInfo\n */\nimport GML2 from './GML2.js';\nimport XMLFeature from './XMLFeature.js';\nimport {extend} from '../array.js';\nimport {makeArrayPusher, makeStructureNS, pushParseAndPop} from '../xml.js';\n\n/**\n * @typedef {Object} Options\n * @property {Array<string>} [layers] If set, only features of the given layers will be returned by the format when read.\n */\n\n/**\n * @const\n * @type {string}\n */\nconst featureIdentifier = '_feature';\n\n/**\n * @const\n * @type {string}\n */\nconst layerIdentifier = '_layer';\n\n/**\n * @classdesc\n * Format for reading WMSGetFeatureInfo format. It uses\n * {@link module:ol/format/GML2~GML2} to read features.\n *\n * @api\n */\nclass WMSGetFeatureInfo extends XMLFeature {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.featureNS_ = 'http://mapserver.gis.umn.edu/mapserver';\n\n    /**\n     * @private\n     * @type {GML2}\n     */\n    this.gmlFormat_ = new GML2();\n\n    /**\n     * @private\n     * @type {Array<string>|null}\n     */\n    this.layers_ = options.layers ? options.layers : null;\n  }\n\n  /**\n   * @return {Array<string>|null} layers\n   */\n  getLayers() {\n    return this.layers_;\n  }\n\n  /**\n   * @param {Array<string>|null} layers Layers to parse.\n   */\n  setLayers(layers) {\n    this.layers_ = layers;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   * @private\n   */\n  readFeatures_(node, objectStack) {\n    node.setAttribute('namespaceURI', this.featureNS_);\n    const localName = node.localName;\n    /** @type {Array<import(\"../Feature.js\").default>} */\n    let features = [];\n    if (node.childNodes.length === 0) {\n      return features;\n    }\n    if (localName == 'msGMLOutput') {\n      for (let i = 0, ii = node.childNodes.length; i < ii; i++) {\n        const layer = node.childNodes[i];\n        if (layer.nodeType !== Node.ELEMENT_NODE) {\n          continue;\n        }\n\n        const layerElement = /** @type {Element} */ (layer);\n        const context = objectStack[0];\n\n        const toRemove = layerIdentifier;\n        const layerName = layerElement.localName.replace(toRemove, '');\n\n        if (this.layers_ && !this.layers_.includes(layerName)) {\n          continue;\n        }\n\n        const featureType = layerName + featureIdentifier;\n\n        context['featureType'] = featureType;\n        context['featureNS'] = this.featureNS_;\n\n        /** @type {Object<string, import(\"../xml.js\").Parser>} */\n        const parsers = {};\n        parsers[featureType] = makeArrayPusher(\n          this.gmlFormat_.readFeatureElement,\n          this.gmlFormat_\n        );\n        const parsersNS = makeStructureNS(\n          [context['featureNS'], null],\n          parsers\n        );\n        layerElement.setAttribute('namespaceURI', this.featureNS_);\n        const layerFeatures = pushParseAndPop(\n          [],\n          // @ts-ignore\n          parsersNS,\n          layerElement,\n          objectStack,\n          this.gmlFormat_\n        );\n        if (layerFeatures) {\n          extend(features, layerFeatures);\n        }\n      }\n    }\n    if (localName == 'FeatureCollection') {\n      const gmlFeatures = pushParseAndPop(\n        [],\n        this.gmlFormat_.FEATURE_COLLECTION_PARSERS,\n        node,\n        [{}],\n        this.gmlFormat_\n      );\n      if (gmlFeatures) {\n        features = gmlFeatures;\n      }\n    }\n    return features;\n  }\n\n  /**\n   * @protected\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromNode(node, options) {\n    const internalOptions = {};\n    if (options) {\n      Object.assign(internalOptions, this.getReadOptions(node, options));\n    }\n    return this.readFeatures_(node, [internalOptions]);\n  }\n}\n\nexport default WMSGetFeatureInfo;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}