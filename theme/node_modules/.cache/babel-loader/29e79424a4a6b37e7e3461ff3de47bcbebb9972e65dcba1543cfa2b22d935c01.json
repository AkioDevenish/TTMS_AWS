{"ast":null,"code":"import _defineProperty from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _toArray from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/toArray.js\";\nimport _slicedToArray from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nvar _compilers;\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array-buffer.constructor.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.data-view.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.date.to-json.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\n/**\n * @module ol/expr/gpu\n */\nimport PaletteTexture from '../webgl/PaletteTexture.js';\nimport { BooleanType, CallExpression, ColorType, NoneType, NumberArrayType, NumberType, Ops, StringType, isType, overlapsType, parse, typeName } from './expression.js';\nimport { Uniforms } from '../renderer/webgl/TileLayer.js';\nimport { asArray } from '../color.js';\n\n/**\n * @param {string} operator Operator\n * @param {CompilationContext} context Compilation context\n * @return {string} A function name based on the operator, unique in the given context\n */\nfunction computeOperatorFunctionName(operator, context) {\n  return \"operator_\".concat(operator, \"_\").concat(Object.keys(context.functions).length);\n}\n\n/**\n * Will return the number as a float with a dot separator, which is required by GLSL.\n * @param {number} v Numerical value.\n * @return {string} The value as string.\n */\nexport function numberToGlsl(v) {\n  var s = v.toString();\n  return s.includes('.') ? s : s + '.0';\n}\n\n/**\n * Will return the number array as a float with a dot separator, concatenated with ', '.\n * @param {Array<number>} array Numerical values array.\n * @return {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.\n */\nexport function arrayToGlsl(array) {\n  if (array.length < 2 || array.length > 4) {\n    throw new Error('`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.');\n  }\n  return \"vec\".concat(array.length, \"(\").concat(array.map(numberToGlsl).join(', '), \")\");\n}\n\n/**\n * Will normalize and converts to string a `vec4` color array compatible with GLSL.\n * @param {string|import(\"../color.js\").Color} color Color either in string format or [r, g, b, a] array format,\n * with RGB components in the 0..255 range and the alpha component in the 0..1 range.\n * Note that the final array will always have 4 components.\n * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\n */\nexport function colorToGlsl(color) {\n  var array = asArray(color);\n  var alpha = array.length > 3 ? array[3] : 1;\n  // all components are premultiplied with alpha value\n  return arrayToGlsl([array[0] / 255 * alpha, array[1] / 255 * alpha, array[2] / 255 * alpha, alpha]);\n}\n\n/** @type {Object<string, number>} */\nvar stringToFloatMap = {};\nvar stringToFloatCounter = 0;\n\n/**\n * Returns a stable equivalent number for the string literal.\n * @param {string} string String literal value\n * @return {number} Number equivalent\n */\nexport function getStringNumberEquivalent(string) {\n  if (!(string in stringToFloatMap)) {\n    stringToFloatMap[string] = stringToFloatCounter++;\n  }\n  return stringToFloatMap[string];\n}\n\n/**\n * Returns a stable equivalent number for the string literal, for use in shaders. This number is then\n * converted to be a GLSL-compatible string.\n * Note: with a float precision of `mediump`, the amount of unique strings supported is 16,777,216\n * @param {string} string String literal value\n * @return {string} GLSL-compatible string containing a number\n */\nexport function stringToGlsl(string) {\n  return numberToGlsl(getStringNumberEquivalent(string));\n}\n\n/**\n * Get the uniform name given a variable name.\n * @param {string} variableName The variable name.\n * @return {string} The uniform name.\n */\nexport function uniformNameForVariable(variableName) {\n  return 'u_var_' + variableName;\n}\n\n/**\n * @typedef {import('./expression.js').ParsingContext} ParsingContext\n */\n/**\n *\n * @typedef {import(\"./expression.js\").Expression} Expression\n */\n/**\n *\n * @typedef {import(\"./expression.js\").LiteralExpression} LiteralExpression\n */\n\n/**\n * @typedef {Object} CompilationContextProperty\n * @property {string} name Name\n * @property {number} type Resolved property type\n * @property {function(import(\"../Feature.js\").FeatureLike): *} [evaluator] Function used for evaluating the value;\n */\n\n/**\n * @typedef {Object} CompilationContextVariable\n * @property {string} name Name\n * @property {number} type Resolved variable type\n * @property {function(Object): *} [evaluator] Function used for evaluating the value; argument is the style variables object\n */\n\n/**\n * @typedef {Object} CompilationContext\n * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader\n * @property {Object<string, CompilationContextProperty>} properties The values for properties used in 'get' expressions.\n * @property {Object<string, CompilationContextVariable>} variables The values for variables used in 'var' expressions.\n * @property {Object<string, string>} functions Lookup of functions used by the style.\n * @property {number} [bandCount] Number of bands per pixel.\n * @property {Array<PaletteTexture>} [paletteTextures] List of palettes used by the style.\n * @property {import(\"../style/webgl.js\").WebGLStyle} style Literal style.\n */\n\n/**\n * @return {CompilationContext} A new compilation context.\n */\nexport function newCompilationContext() {\n  return {\n    inFragmentShader: false,\n    variables: {},\n    properties: {},\n    functions: {},\n    bandCount: 0,\n    style: {}\n  };\n}\nvar GET_BAND_VALUE_FUNC = 'getBandValue';\nexport var PALETTE_TEXTURE_ARRAY = 'u_paletteTextures';\n\n/**\n * @typedef {string} CompiledExpression\n */\n\n/**\n * @typedef {function(CompilationContext, CallExpression, number): string} Compiler\n * Third argument is the expected value types\n */\n\n/**\n * @param {import('./expression.js').EncodedExpression} encoded The encoded expression.\n * @param {number} type The expected type.\n * @param {import('./expression.js').ParsingContext} parsingContext The parsing context.\n * @param {CompilationContext} compilationContext An existing compilation context\n * @return {CompiledExpression} The compiled expression.\n */\nexport function buildExpression(encoded, type, parsingContext, compilationContext) {\n  var expression = parse(encoded, parsingContext, type);\n  if (isType(expression.type, NoneType)) {\n    throw new Error(\"No matching type was found\");\n  }\n  if (!overlapsType(type, expression.type)) {\n    var expected = typeName(type);\n    var actual = typeName(expression.type);\n    throw new Error(\"Expected expression to be of type \".concat(expected, \", got \").concat(actual));\n  }\n  return compile(expression, type, compilationContext);\n}\n\n/**\n * @param {function(Array<CompiledExpression>, CompilationContext): string} output Function that takes in parsed arguments and returns a string\n * @return {function(CompilationContext, import(\"./expression.js\").CallExpression, number): string} Compiler for the call expression\n */\nfunction createCompiler(output) {\n  return function (context, expression, type) {\n    var length = expression.args.length;\n    var args = new Array(length);\n    for (var i = 0; i < length; ++i) {\n      args[i] = compile(expression.args[i], type, context);\n    }\n    return output(args, context);\n  };\n}\n\n/**\n * @type {Object<string, Compiler>}\n */\nvar compilers = (_compilers = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_compilers, Ops.Get, function (context, expression) {\n  var firstArg = /** @type {LiteralExpression} */expression.args[0];\n  var propName = /** @type {string} */firstArg.value;\n  var isExisting = propName in context.properties;\n  if (!isExisting) {\n    context.properties[propName] = {\n      name: propName,\n      type: expression.type\n    };\n  }\n  var prefix = context.inFragmentShader ? 'v_prop_' : 'a_prop_';\n  return prefix + propName;\n}), Ops.GeometryType, function (context, expression, type) {\n  var propName = 'geometryType';\n  var _computeType = function computeType(geometry) {\n    var type = geometry.getType();\n    switch (type) {\n      case 'Point':\n      case 'LineString':\n      case 'Polygon':\n        return type;\n      case 'MultiPoint':\n      case 'MultiLineString':\n      case 'MultiPolygon':\n        return type.substring(5);\n      case 'Circle':\n        return 'Polygon';\n      case 'GeometryCollection':\n        return _computeType(geometry.getGeometries()[0]);\n      default:\n    }\n  };\n  var isExisting = propName in context.properties;\n  if (!isExisting) {\n    context.properties[propName] = {\n      name: propName,\n      type: StringType,\n      evaluator: function evaluator(feature) {\n        return _computeType(feature.getGeometry());\n      }\n    };\n  }\n  var prefix = context.inFragmentShader ? 'v_prop_' : 'a_prop_';\n  return prefix + propName;\n}), Ops.Var, function (context, expression) {\n  var firstArg = /** @type {LiteralExpression} */expression.args[0];\n  var varName = /** @type {string} */firstArg.value;\n  var isExisting = varName in context.variables;\n  if (!isExisting) {\n    context.variables[varName] = {\n      name: varName,\n      type: expression.type\n    };\n  }\n  return uniformNameForVariable(varName);\n}), Ops.Resolution, function () {\n  return 'u_resolution';\n}), Ops.Zoom, function () {\n  return 'u_zoom';\n}), Ops.Time, function () {\n  return 'u_time';\n}), Ops.Any, createCompiler(function (compiledArgs) {\n  return \"(\".concat(compiledArgs.join(\" || \"), \")\");\n})), Ops.All, createCompiler(function (compiledArgs) {\n  return \"(\".concat(compiledArgs.join(\" && \"), \")\");\n})), Ops.Not, createCompiler(function (_ref) {\n  var _ref2 = _slicedToArray(_ref, 1),\n    value = _ref2[0];\n  return \"(!\".concat(value, \")\");\n})), Ops.Equal, createCompiler(function (_ref3) {\n  var _ref4 = _slicedToArray(_ref3, 2),\n    firstValue = _ref4[0],\n    secondValue = _ref4[1];\n  return \"(\".concat(firstValue, \" == \").concat(secondValue, \")\");\n})), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_compilers, Ops.NotEqual, createCompiler(function (_ref5) {\n  var _ref6 = _slicedToArray(_ref5, 2),\n    firstValue = _ref6[0],\n    secondValue = _ref6[1];\n  return \"(\".concat(firstValue, \" != \").concat(secondValue, \")\");\n})), Ops.GreaterThan, createCompiler(function (_ref7) {\n  var _ref8 = _slicedToArray(_ref7, 2),\n    firstValue = _ref8[0],\n    secondValue = _ref8[1];\n  return \"(\".concat(firstValue, \" > \").concat(secondValue, \")\");\n})), Ops.GreaterThanOrEqualTo, createCompiler(function (_ref9) {\n  var _ref10 = _slicedToArray(_ref9, 2),\n    firstValue = _ref10[0],\n    secondValue = _ref10[1];\n  return \"(\".concat(firstValue, \" >= \").concat(secondValue, \")\");\n})), Ops.LessThan, createCompiler(function (_ref11) {\n  var _ref12 = _slicedToArray(_ref11, 2),\n    firstValue = _ref12[0],\n    secondValue = _ref12[1];\n  return \"(\".concat(firstValue, \" < \").concat(secondValue, \")\");\n})), Ops.LessThanOrEqualTo, createCompiler(function (_ref13) {\n  var _ref14 = _slicedToArray(_ref13, 2),\n    firstValue = _ref14[0],\n    secondValue = _ref14[1];\n  return \"(\".concat(firstValue, \" <= \").concat(secondValue, \")\");\n})), Ops.Multiply, createCompiler(function (compiledArgs) {\n  return \"(\".concat(compiledArgs.join(' * '), \")\");\n})), Ops.Divide, createCompiler(function (_ref15) {\n  var _ref16 = _slicedToArray(_ref15, 2),\n    firstValue = _ref16[0],\n    secondValue = _ref16[1];\n  return \"(\".concat(firstValue, \" / \").concat(secondValue, \")\");\n})), Ops.Add, createCompiler(function (compiledArgs) {\n  return \"(\".concat(compiledArgs.join(' + '), \")\");\n})), Ops.Subtract, createCompiler(function (_ref17) {\n  var _ref18 = _slicedToArray(_ref17, 2),\n    firstValue = _ref18[0],\n    secondValue = _ref18[1];\n  return \"(\".concat(firstValue, \" - \").concat(secondValue, \")\");\n})), Ops.Clamp, createCompiler(function (_ref19) {\n  var _ref20 = _slicedToArray(_ref19, 3),\n    value = _ref20[0],\n    min = _ref20[1],\n    max = _ref20[2];\n  return \"clamp(\".concat(value, \", \").concat(min, \", \").concat(max, \")\");\n})), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_compilers, Ops.Mod, createCompiler(function (_ref21) {\n  var _ref22 = _slicedToArray(_ref21, 2),\n    value = _ref22[0],\n    modulo = _ref22[1];\n  return \"mod(\".concat(value, \", \").concat(modulo, \")\");\n})), Ops.Pow, createCompiler(function (_ref23) {\n  var _ref24 = _slicedToArray(_ref23, 2),\n    value = _ref24[0],\n    power = _ref24[1];\n  return \"pow(\".concat(value, \", \").concat(power, \")\");\n})), Ops.Abs, createCompiler(function (_ref25) {\n  var _ref26 = _slicedToArray(_ref25, 1),\n    value = _ref26[0];\n  return \"abs(\".concat(value, \")\");\n})), Ops.Floor, createCompiler(function (_ref27) {\n  var _ref28 = _slicedToArray(_ref27, 1),\n    value = _ref28[0];\n  return \"floor(\".concat(value, \")\");\n})), Ops.Ceil, createCompiler(function (_ref29) {\n  var _ref30 = _slicedToArray(_ref29, 1),\n    value = _ref30[0];\n  return \"ceil(\".concat(value, \")\");\n})), Ops.Round, createCompiler(function (_ref31) {\n  var _ref32 = _slicedToArray(_ref31, 1),\n    value = _ref32[0];\n  return \"floor(\".concat(value, \" + 0.5)\");\n})), Ops.Sin, createCompiler(function (_ref33) {\n  var _ref34 = _slicedToArray(_ref33, 1),\n    value = _ref34[0];\n  return \"sin(\".concat(value, \")\");\n})), Ops.Cos, createCompiler(function (_ref35) {\n  var _ref36 = _slicedToArray(_ref35, 1),\n    value = _ref36[0];\n  return \"cos(\".concat(value, \")\");\n})), Ops.Atan, createCompiler(function (_ref37) {\n  var _ref38 = _slicedToArray(_ref37, 2),\n    firstValue = _ref38[0],\n    secondValue = _ref38[1];\n  return secondValue !== undefined ? \"atan(\".concat(firstValue, \", \").concat(secondValue, \")\") : \"atan(\".concat(firstValue, \")\");\n})), Ops.Sqrt, createCompiler(function (_ref39) {\n  var _ref40 = _slicedToArray(_ref39, 1),\n    value = _ref40[0];\n  return \"sqrt(\".concat(value, \")\");\n})), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_compilers, Ops.Match, createCompiler(function (compiledArgs) {\n  var input = compiledArgs[0];\n  var fallback = compiledArgs[compiledArgs.length - 1];\n  var result = null;\n  for (var i = compiledArgs.length - 3; i >= 1; i -= 2) {\n    var match = compiledArgs[i];\n    var output = compiledArgs[i + 1];\n    result = \"(\".concat(input, \" == \").concat(match, \" ? \").concat(output, \" : \").concat(result || fallback, \")\");\n  }\n  return result;\n})), Ops.Between, createCompiler(function (_ref41) {\n  var _ref42 = _slicedToArray(_ref41, 3),\n    value = _ref42[0],\n    min = _ref42[1],\n    max = _ref42[2];\n  return \"(\".concat(value, \" >= \").concat(min, \" && \").concat(value, \" <= \").concat(max, \")\");\n})), Ops.Interpolate, createCompiler(function (_ref43) {\n  var _ref44 = _toArray(_ref43),\n    exponent = _ref44[0],\n    input = _ref44[1],\n    compiledArgs = _ref44.slice(2);\n  var result = '';\n  for (var i = 0; i < compiledArgs.length - 2; i += 2) {\n    var stop1 = compiledArgs[i];\n    var output1 = result || compiledArgs[i + 1];\n    var stop2 = compiledArgs[i + 2];\n    var output2 = compiledArgs[i + 3];\n    var ratio = void 0;\n    if (exponent === numberToGlsl(1)) {\n      ratio = \"(\".concat(input, \" - \").concat(stop1, \") / (\").concat(stop2, \" - \").concat(stop1, \")\");\n    } else {\n      ratio = \"(pow(\".concat(exponent, \", (\").concat(input, \" - \").concat(stop1, \")) - 1.0) / (pow(\").concat(exponent, \", (\").concat(stop2, \" - \").concat(stop1, \")) - 1.0)\");\n    }\n    result = \"mix(\".concat(output1, \", \").concat(output2, \", clamp(\").concat(ratio, \", 0.0, 1.0))\");\n  }\n  return result;\n})), Ops.Case, createCompiler(function (compiledArgs) {\n  var fallback = compiledArgs[compiledArgs.length - 1];\n  var result = null;\n  for (var i = compiledArgs.length - 3; i >= 0; i -= 2) {\n    var condition = compiledArgs[i];\n    var output = compiledArgs[i + 1];\n    result = \"(\".concat(condition, \" ? \").concat(output, \" : \").concat(result || fallback, \")\");\n  }\n  return result;\n})), Ops.In, createCompiler(function (_ref45, context) {\n  var _ref46 = _toArray(_ref45),\n    needle = _ref46[0],\n    haystack = _ref46.slice(1);\n  var funcName = computeOperatorFunctionName('in', context);\n  var tests = [];\n  for (var i = 0; i < haystack.length; i += 1) {\n    tests.push(\"  if (inputValue == \".concat(haystack[i], \") { return true; }\"));\n  }\n  context.functions[funcName] = \"bool \".concat(funcName, \"(float inputValue) {\\n\").concat(tests.join('\\n'), \"\\n  return false;\\n}\");\n  return \"\".concat(funcName, \"(\").concat(needle, \")\");\n})), Ops.Array, createCompiler(function (args) {\n  return \"vec\".concat(args.length, \"(\").concat(args.join(', '), \")\");\n})), Ops.Color, createCompiler(function (compiledArgs) {\n  var rgb = compiledArgs.slice(0, 3).map(function (color) {\n    return \"\".concat(color, \" / 255.0\");\n  });\n  if (compiledArgs.length === 3) {\n    return \"vec4(\".concat(rgb.join(', '), \", 1.0)\");\n  }\n  var alpha = compiledArgs[3];\n  return \"(\".concat(alpha, \" * vec4(\").concat(rgb.join(', '), \", 1.0))\");\n})), Ops.Band, createCompiler(function (_ref47, context) {\n  var _ref48 = _slicedToArray(_ref47, 3),\n    band = _ref48[0],\n    xOffset = _ref48[1],\n    yOffset = _ref48[2];\n  if (!(GET_BAND_VALUE_FUNC in context.functions)) {\n    var ifBlocks = '';\n    var bandCount = context.bandCount || 1;\n    for (var i = 0; i < bandCount; i++) {\n      var colorIndex = Math.floor(i / 4);\n      var bandIndex = i % 4;\n      if (i === bandCount - 1 && bandIndex === 1) {\n        // LUMINANCE_ALPHA - band 1 assigned to rgb and band 2 assigned to alpha\n        bandIndex = 3;\n      }\n      var textureName = \"\".concat(Uniforms.TILE_TEXTURE_ARRAY, \"[\").concat(colorIndex, \"]\");\n      ifBlocks += \"  if (band == \".concat(i + 1, \".0) {\\n    return texture2D(\").concat(textureName, \", v_textureCoord + vec2(dx, dy))[\").concat(bandIndex, \"];\\n  }\\n\");\n    }\n    context.functions[GET_BAND_VALUE_FUNC] = \"float getBandValue(float band, float xOffset, float yOffset) {\\n  float dx = xOffset / \".concat(Uniforms.TEXTURE_PIXEL_WIDTH, \";\\n  float dy = yOffset / \").concat(Uniforms.TEXTURE_PIXEL_HEIGHT, \";\\n\").concat(ifBlocks, \"\\n}\");\n  }\n  return \"\".concat(GET_BAND_VALUE_FUNC, \"(\").concat(band, \", \").concat(xOffset !== null && xOffset !== void 0 ? xOffset : '0.0', \", \").concat(yOffset !== null && yOffset !== void 0 ? yOffset : '0.0', \")\");\n})), Ops.Palette, function (context, expression) {\n  var _expression$args = _toArray(expression.args),\n    index = _expression$args[0],\n    colors = _expression$args.slice(1);\n  var numColors = colors.length;\n  var palette = new Uint8Array(numColors * 4);\n  for (var i = 0; i < colors.length; i++) {\n    var parsedValue = /** @type {string | Array<number>} */\n    /** @type {LiteralExpression} */colors[i].value;\n    var color = asArray(parsedValue);\n    var offset = i * 4;\n    palette[offset] = color[0];\n    palette[offset + 1] = color[1];\n    palette[offset + 2] = color[2];\n    palette[offset + 3] = color[3] * 255;\n  }\n  if (!context.paletteTextures) {\n    context.paletteTextures = [];\n  }\n  var paletteName = \"\".concat(PALETTE_TEXTURE_ARRAY, \"[\").concat(context.paletteTextures.length, \"]\");\n  var paletteTexture = new PaletteTexture(paletteName, palette);\n  context.paletteTextures.push(paletteTexture);\n  var compiledIndex = compile(index, NumberType, context);\n  return \"texture2D(\".concat(paletteName, \", vec2((\").concat(compiledIndex, \" + 0.5) / \").concat(numColors, \".0, 0.5))\");\n}));\n\n/**\n * @param {Expression} expression The expression.\n * @param {number} returnType The expected return type.\n * @param {CompilationContext} context The compilation context.\n * @return {CompiledExpression} The compiled expression\n */\nfunction compile(expression, returnType, context) {\n  // operator\n  if (expression instanceof CallExpression) {\n    var compiler = compilers[expression.operator];\n    if (compiler === undefined) {\n      throw new Error(\"No compiler defined for this operator: \".concat(JSON.stringify(expression.operator)));\n    }\n    return compiler(context, expression, returnType);\n  }\n  if ((expression.type & NumberType) > 0) {\n    return numberToGlsl(/** @type {number} */expression.value);\n  }\n  if ((expression.type & BooleanType) > 0) {\n    return expression.value.toString();\n  }\n  if ((expression.type & StringType) > 0) {\n    return stringToGlsl(expression.value.toString());\n  }\n  if ((expression.type & ColorType) > 0) {\n    return colorToGlsl(/** @type {Array<number> | string} */expression.value);\n  }\n  if ((expression.type & NumberArrayType) > 0) {\n    return arrayToGlsl(/** @type {Array<number>} */expression.value);\n  }\n  throw new Error(\"Unexpected expression \".concat(expression.value, \" (expected type \").concat(typeName(returnType), \")\"));\n}","map":{"version":3,"names":["PaletteTexture","BooleanType","CallExpression","ColorType","NoneType","NumberArrayType","NumberType","Ops","StringType","isType","overlapsType","parse","typeName","Uniforms","asArray","computeOperatorFunctionName","operator","context","concat","Object","keys","functions","length","numberToGlsl","v","s","toString","includes","arrayToGlsl","array","Error","map","join","colorToGlsl","color","alpha","stringToFloatMap","stringToFloatCounter","getStringNumberEquivalent","string","stringToGlsl","uniformNameForVariable","variableName","newCompilationContext","inFragmentShader","variables","properties","bandCount","style","GET_BAND_VALUE_FUNC","PALETTE_TEXTURE_ARRAY","buildExpression","encoded","type","parsingContext","compilationContext","expression","expected","actual","compile","createCompiler","output","args","Array","i","compilers","_compilers","_defineProperty","Get","firstArg","propName","value","isExisting","name","prefix","GeometryType","computeType","geometry","getType","substring","getGeometries","evaluator","feature","getGeometry","Var","varName","Resolution","Zoom","Time","Any","compiledArgs","All","Not","_ref","_ref2","_slicedToArray","Equal","_ref3","_ref4","firstValue","secondValue","NotEqual","_ref5","_ref6","GreaterThan","_ref7","_ref8","GreaterThanOrEqualTo","_ref9","_ref10","LessThan","_ref11","_ref12","LessThanOrEqualTo","_ref13","_ref14","Multiply","Divide","_ref15","_ref16","Add","Subtract","_ref17","_ref18","Clamp","_ref19","_ref20","min","max","Mod","_ref21","_ref22","modulo","Pow","_ref23","_ref24","power","Abs","_ref25","_ref26","Floor","_ref27","_ref28","Ceil","_ref29","_ref30","Round","_ref31","_ref32","Sin","_ref33","_ref34","Cos","_ref35","_ref36","Atan","_ref37","_ref38","undefined","Sqrt","_ref39","_ref40","Match","input","fallback","result","match","Between","_ref41","_ref42","Interpolate","_ref43","_ref44","_toArray","exponent","slice","stop1","output1","stop2","output2","ratio","Case","condition","In","_ref45","_ref46","needle","haystack","funcName","tests","push","Color","rgb","Band","_ref47","_ref48","band","xOffset","yOffset","ifBlocks","colorIndex","Math","floor","bandIndex","textureName","TILE_TEXTURE_ARRAY","TEXTURE_PIXEL_WIDTH","TEXTURE_PIXEL_HEIGHT","Palette","_expression$args","index","colors","numColors","palette","Uint8Array","parsedValue","offset","paletteTextures","paletteName","paletteTexture","compiledIndex","returnType","compiler","JSON","stringify"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol/expr/gpu.js"],"sourcesContent":["/**\n * @module ol/expr/gpu\n */\nimport PaletteTexture from '../webgl/PaletteTexture.js';\nimport {\n  BooleanType,\n  CallExpression,\n  ColorType,\n  NoneType,\n  NumberArrayType,\n  NumberType,\n  Ops,\n  StringType,\n  isType,\n  overlapsType,\n  parse,\n  typeName,\n} from './expression.js';\nimport {Uniforms} from '../renderer/webgl/TileLayer.js';\nimport {asArray} from '../color.js';\n\n/**\n * @param {string} operator Operator\n * @param {CompilationContext} context Compilation context\n * @return {string} A function name based on the operator, unique in the given context\n */\nfunction computeOperatorFunctionName(operator, context) {\n  return `operator_${operator}_${Object.keys(context.functions).length}`;\n}\n\n/**\n * Will return the number as a float with a dot separator, which is required by GLSL.\n * @param {number} v Numerical value.\n * @return {string} The value as string.\n */\nexport function numberToGlsl(v) {\n  const s = v.toString();\n  return s.includes('.') ? s : s + '.0';\n}\n\n/**\n * Will return the number array as a float with a dot separator, concatenated with ', '.\n * @param {Array<number>} array Numerical values array.\n * @return {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.\n */\nexport function arrayToGlsl(array) {\n  if (array.length < 2 || array.length > 4) {\n    throw new Error(\n      '`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.'\n    );\n  }\n  return `vec${array.length}(${array.map(numberToGlsl).join(', ')})`;\n}\n\n/**\n * Will normalize and converts to string a `vec4` color array compatible with GLSL.\n * @param {string|import(\"../color.js\").Color} color Color either in string format or [r, g, b, a] array format,\n * with RGB components in the 0..255 range and the alpha component in the 0..1 range.\n * Note that the final array will always have 4 components.\n * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\n */\nexport function colorToGlsl(color) {\n  const array = asArray(color);\n  const alpha = array.length > 3 ? array[3] : 1;\n  // all components are premultiplied with alpha value\n  return arrayToGlsl([\n    (array[0] / 255) * alpha,\n    (array[1] / 255) * alpha,\n    (array[2] / 255) * alpha,\n    alpha,\n  ]);\n}\n\n/** @type {Object<string, number>} */\nconst stringToFloatMap = {};\nlet stringToFloatCounter = 0;\n\n/**\n * Returns a stable equivalent number for the string literal.\n * @param {string} string String literal value\n * @return {number} Number equivalent\n */\nexport function getStringNumberEquivalent(string) {\n  if (!(string in stringToFloatMap)) {\n    stringToFloatMap[string] = stringToFloatCounter++;\n  }\n  return stringToFloatMap[string];\n}\n\n/**\n * Returns a stable equivalent number for the string literal, for use in shaders. This number is then\n * converted to be a GLSL-compatible string.\n * Note: with a float precision of `mediump`, the amount of unique strings supported is 16,777,216\n * @param {string} string String literal value\n * @return {string} GLSL-compatible string containing a number\n */\nexport function stringToGlsl(string) {\n  return numberToGlsl(getStringNumberEquivalent(string));\n}\n\n/**\n * Get the uniform name given a variable name.\n * @param {string} variableName The variable name.\n * @return {string} The uniform name.\n */\nexport function uniformNameForVariable(variableName) {\n  return 'u_var_' + variableName;\n}\n\n/**\n * @typedef {import('./expression.js').ParsingContext} ParsingContext\n */\n/**\n *\n * @typedef {import(\"./expression.js\").Expression} Expression\n */\n/**\n *\n * @typedef {import(\"./expression.js\").LiteralExpression} LiteralExpression\n */\n\n/**\n * @typedef {Object} CompilationContextProperty\n * @property {string} name Name\n * @property {number} type Resolved property type\n * @property {function(import(\"../Feature.js\").FeatureLike): *} [evaluator] Function used for evaluating the value;\n */\n\n/**\n * @typedef {Object} CompilationContextVariable\n * @property {string} name Name\n * @property {number} type Resolved variable type\n * @property {function(Object): *} [evaluator] Function used for evaluating the value; argument is the style variables object\n */\n\n/**\n * @typedef {Object} CompilationContext\n * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader\n * @property {Object<string, CompilationContextProperty>} properties The values for properties used in 'get' expressions.\n * @property {Object<string, CompilationContextVariable>} variables The values for variables used in 'var' expressions.\n * @property {Object<string, string>} functions Lookup of functions used by the style.\n * @property {number} [bandCount] Number of bands per pixel.\n * @property {Array<PaletteTexture>} [paletteTextures] List of palettes used by the style.\n * @property {import(\"../style/webgl.js\").WebGLStyle} style Literal style.\n */\n\n/**\n * @return {CompilationContext} A new compilation context.\n */\nexport function newCompilationContext() {\n  return {\n    inFragmentShader: false,\n    variables: {},\n    properties: {},\n    functions: {},\n    bandCount: 0,\n    style: {},\n  };\n}\n\nconst GET_BAND_VALUE_FUNC = 'getBandValue';\n\nexport const PALETTE_TEXTURE_ARRAY = 'u_paletteTextures';\n\n/**\n * @typedef {string} CompiledExpression\n */\n\n/**\n * @typedef {function(CompilationContext, CallExpression, number): string} Compiler\n * Third argument is the expected value types\n */\n\n/**\n * @param {import('./expression.js').EncodedExpression} encoded The encoded expression.\n * @param {number} type The expected type.\n * @param {import('./expression.js').ParsingContext} parsingContext The parsing context.\n * @param {CompilationContext} compilationContext An existing compilation context\n * @return {CompiledExpression} The compiled expression.\n */\nexport function buildExpression(\n  encoded,\n  type,\n  parsingContext,\n  compilationContext\n) {\n  const expression = parse(encoded, parsingContext, type);\n  if (isType(expression.type, NoneType)) {\n    throw new Error(`No matching type was found`);\n  }\n  if (!overlapsType(type, expression.type)) {\n    const expected = typeName(type);\n    const actual = typeName(expression.type);\n    throw new Error(\n      `Expected expression to be of type ${expected}, got ${actual}`\n    );\n  }\n  return compile(expression, type, compilationContext);\n}\n\n/**\n * @param {function(Array<CompiledExpression>, CompilationContext): string} output Function that takes in parsed arguments and returns a string\n * @return {function(CompilationContext, import(\"./expression.js\").CallExpression, number): string} Compiler for the call expression\n */\nfunction createCompiler(output) {\n  return (context, expression, type) => {\n    const length = expression.args.length;\n    const args = new Array(length);\n    for (let i = 0; i < length; ++i) {\n      args[i] = compile(expression.args[i], type, context);\n    }\n    return output(args, context);\n  };\n}\n\n/**\n * @type {Object<string, Compiler>}\n */\nconst compilers = {\n  [Ops.Get]: (context, expression) => {\n    const firstArg = /** @type {LiteralExpression} */ (expression.args[0]);\n    const propName = /** @type {string} */ (firstArg.value);\n    const isExisting = propName in context.properties;\n    if (!isExisting) {\n      context.properties[propName] = {\n        name: propName,\n        type: expression.type,\n      };\n    }\n    const prefix = context.inFragmentShader ? 'v_prop_' : 'a_prop_';\n    return prefix + propName;\n  },\n  [Ops.GeometryType]: (context, expression, type) => {\n    const propName = 'geometryType';\n    const computeType = (geometry) => {\n      const type = geometry.getType();\n      switch (type) {\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n          return type;\n        case 'MultiPoint':\n        case 'MultiLineString':\n        case 'MultiPolygon':\n          return type.substring(5);\n        case 'Circle':\n          return 'Polygon';\n        case 'GeometryCollection':\n          return computeType(geometry.getGeometries()[0]);\n        default:\n      }\n    };\n    const isExisting = propName in context.properties;\n    if (!isExisting) {\n      context.properties[propName] = {\n        name: propName,\n        type: StringType,\n        evaluator: (feature) => {\n          return computeType(feature.getGeometry());\n        },\n      };\n    }\n    const prefix = context.inFragmentShader ? 'v_prop_' : 'a_prop_';\n    return prefix + propName;\n  },\n  [Ops.Var]: (context, expression) => {\n    const firstArg = /** @type {LiteralExpression} */ (expression.args[0]);\n    const varName = /** @type {string} */ (firstArg.value);\n    const isExisting = varName in context.variables;\n    if (!isExisting) {\n      context.variables[varName] = {\n        name: varName,\n        type: expression.type,\n      };\n    }\n    return uniformNameForVariable(varName);\n  },\n  [Ops.Resolution]: () => 'u_resolution',\n  [Ops.Zoom]: () => 'u_zoom',\n  [Ops.Time]: () => 'u_time',\n  [Ops.Any]: createCompiler((compiledArgs) => `(${compiledArgs.join(` || `)})`),\n  [Ops.All]: createCompiler((compiledArgs) => `(${compiledArgs.join(` && `)})`),\n  [Ops.Not]: createCompiler(([value]) => `(!${value})`),\n  [Ops.Equal]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} == ${secondValue})`\n  ),\n  [Ops.NotEqual]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} != ${secondValue})`\n  ),\n  [Ops.GreaterThan]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} > ${secondValue})`\n  ),\n  [Ops.GreaterThanOrEqualTo]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} >= ${secondValue})`\n  ),\n  [Ops.LessThan]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} < ${secondValue})`\n  ),\n  [Ops.LessThanOrEqualTo]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} <= ${secondValue})`\n  ),\n  [Ops.Multiply]: createCompiler(\n    (compiledArgs) => `(${compiledArgs.join(' * ')})`\n  ),\n  [Ops.Divide]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} / ${secondValue})`\n  ),\n  [Ops.Add]: createCompiler((compiledArgs) => `(${compiledArgs.join(' + ')})`),\n  [Ops.Subtract]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} - ${secondValue})`\n  ),\n  [Ops.Clamp]: createCompiler(\n    ([value, min, max]) => `clamp(${value}, ${min}, ${max})`\n  ),\n  [Ops.Mod]: createCompiler(([value, modulo]) => `mod(${value}, ${modulo})`),\n  [Ops.Pow]: createCompiler(([value, power]) => `pow(${value}, ${power})`),\n  [Ops.Abs]: createCompiler(([value]) => `abs(${value})`),\n  [Ops.Floor]: createCompiler(([value]) => `floor(${value})`),\n  [Ops.Ceil]: createCompiler(([value]) => `ceil(${value})`),\n  [Ops.Round]: createCompiler(([value]) => `floor(${value} + 0.5)`),\n  [Ops.Sin]: createCompiler(([value]) => `sin(${value})`),\n  [Ops.Cos]: createCompiler(([value]) => `cos(${value})`),\n  [Ops.Atan]: createCompiler(([firstValue, secondValue]) => {\n    return secondValue !== undefined\n      ? `atan(${firstValue}, ${secondValue})`\n      : `atan(${firstValue})`;\n  }),\n  [Ops.Sqrt]: createCompiler(([value]) => `sqrt(${value})`),\n  [Ops.Match]: createCompiler((compiledArgs) => {\n    const input = compiledArgs[0];\n    const fallback = compiledArgs[compiledArgs.length - 1];\n    let result = null;\n    for (let i = compiledArgs.length - 3; i >= 1; i -= 2) {\n      const match = compiledArgs[i];\n      const output = compiledArgs[i + 1];\n      result = `(${input} == ${match} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  }),\n  [Ops.Between]: createCompiler(\n    ([value, min, max]) => `(${value} >= ${min} && ${value} <= ${max})`\n  ),\n  [Ops.Interpolate]: createCompiler(([exponent, input, ...compiledArgs]) => {\n    let result = '';\n    for (let i = 0; i < compiledArgs.length - 2; i += 2) {\n      const stop1 = compiledArgs[i];\n      const output1 = result || compiledArgs[i + 1];\n      const stop2 = compiledArgs[i + 2];\n      const output2 = compiledArgs[i + 3];\n      let ratio;\n      if (exponent === numberToGlsl(1)) {\n        ratio = `(${input} - ${stop1}) / (${stop2} - ${stop1})`;\n      } else {\n        ratio = `(pow(${exponent}, (${input} - ${stop1})) - 1.0) / (pow(${exponent}, (${stop2} - ${stop1})) - 1.0)`;\n      }\n      result = `mix(${output1}, ${output2}, clamp(${ratio}, 0.0, 1.0))`;\n    }\n    return result;\n  }),\n  [Ops.Case]: createCompiler((compiledArgs) => {\n    const fallback = compiledArgs[compiledArgs.length - 1];\n    let result = null;\n    for (let i = compiledArgs.length - 3; i >= 0; i -= 2) {\n      const condition = compiledArgs[i];\n      const output = compiledArgs[i + 1];\n      result = `(${condition} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  }),\n  [Ops.In]: createCompiler(([needle, ...haystack], context) => {\n    const funcName = computeOperatorFunctionName('in', context);\n    const tests = [];\n    for (let i = 0; i < haystack.length; i += 1) {\n      tests.push(`  if (inputValue == ${haystack[i]}) { return true; }`);\n    }\n    context.functions[funcName] = `bool ${funcName}(float inputValue) {\n${tests.join('\\n')}\n  return false;\n}`;\n    return `${funcName}(${needle})`;\n  }),\n  [Ops.Array]: createCompiler(\n    (args) => `vec${args.length}(${args.join(', ')})`\n  ),\n  [Ops.Color]: createCompiler((compiledArgs) => {\n    const rgb = compiledArgs.slice(0, 3).map((color) => `${color} / 255.0`);\n    if (compiledArgs.length === 3) {\n      return `vec4(${rgb.join(', ')}, 1.0)`;\n    }\n    const alpha = compiledArgs[3];\n    return `(${alpha} * vec4(${rgb.join(', ')}, 1.0))`;\n  }),\n  [Ops.Band]: createCompiler(([band, xOffset, yOffset], context) => {\n    if (!(GET_BAND_VALUE_FUNC in context.functions)) {\n      let ifBlocks = '';\n      const bandCount = context.bandCount || 1;\n      for (let i = 0; i < bandCount; i++) {\n        const colorIndex = Math.floor(i / 4);\n        let bandIndex = i % 4;\n        if (i === bandCount - 1 && bandIndex === 1) {\n          // LUMINANCE_ALPHA - band 1 assigned to rgb and band 2 assigned to alpha\n          bandIndex = 3;\n        }\n        const textureName = `${Uniforms.TILE_TEXTURE_ARRAY}[${colorIndex}]`;\n        ifBlocks += `  if (band == ${i + 1}.0) {\n    return texture2D(${textureName}, v_textureCoord + vec2(dx, dy))[${bandIndex}];\n  }\n`;\n      }\n\n      context.functions[\n        GET_BAND_VALUE_FUNC\n      ] = `float getBandValue(float band, float xOffset, float yOffset) {\n  float dx = xOffset / ${Uniforms.TEXTURE_PIXEL_WIDTH};\n  float dy = yOffset / ${Uniforms.TEXTURE_PIXEL_HEIGHT};\n${ifBlocks}\n}`;\n    }\n\n    return `${GET_BAND_VALUE_FUNC}(${band}, ${xOffset ?? '0.0'}, ${\n      yOffset ?? '0.0'\n    })`;\n  }),\n  [Ops.Palette]: (context, expression) => {\n    const [index, ...colors] = expression.args;\n    const numColors = colors.length;\n    const palette = new Uint8Array(numColors * 4);\n    for (let i = 0; i < colors.length; i++) {\n      const parsedValue = /** @type {string | Array<number>} */ (\n        /** @type {LiteralExpression} */ (colors[i]).value\n      );\n      const color = asArray(parsedValue);\n      const offset = i * 4;\n      palette[offset] = color[0];\n      palette[offset + 1] = color[1];\n      palette[offset + 2] = color[2];\n      palette[offset + 3] = color[3] * 255;\n    }\n    if (!context.paletteTextures) {\n      context.paletteTextures = [];\n    }\n    const paletteName = `${PALETTE_TEXTURE_ARRAY}[${context.paletteTextures.length}]`;\n    const paletteTexture = new PaletteTexture(paletteName, palette);\n    context.paletteTextures.push(paletteTexture);\n    const compiledIndex = compile(index, NumberType, context);\n    return `texture2D(${paletteName}, vec2((${compiledIndex} + 0.5) / ${numColors}.0, 0.5))`;\n  },\n  // TODO: unimplemented\n  // Ops.Number\n  // Ops.String\n  // Ops.Concat\n};\n\n/**\n * @param {Expression} expression The expression.\n * @param {number} returnType The expected return type.\n * @param {CompilationContext} context The compilation context.\n * @return {CompiledExpression} The compiled expression\n */\nfunction compile(expression, returnType, context) {\n  // operator\n  if (expression instanceof CallExpression) {\n    const compiler = compilers[expression.operator];\n    if (compiler === undefined) {\n      throw new Error(\n        `No compiler defined for this operator: ${JSON.stringify(\n          expression.operator\n        )}`\n      );\n    }\n    return compiler(context, expression, returnType);\n  }\n\n  if ((expression.type & NumberType) > 0) {\n    return numberToGlsl(/** @type {number} */ (expression.value));\n  }\n\n  if ((expression.type & BooleanType) > 0) {\n    return expression.value.toString();\n  }\n\n  if ((expression.type & StringType) > 0) {\n    return stringToGlsl(expression.value.toString());\n  }\n\n  if ((expression.type & ColorType) > 0) {\n    return colorToGlsl(\n      /** @type {Array<number> | string} */ (expression.value)\n    );\n  }\n\n  if ((expression.type & NumberArrayType) > 0) {\n    return arrayToGlsl(/** @type {Array<number>} */ (expression.value));\n  }\n\n  throw new Error(\n    `Unexpected expression ${expression.value} (expected type ${typeName(\n      returnType\n    )})`\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}