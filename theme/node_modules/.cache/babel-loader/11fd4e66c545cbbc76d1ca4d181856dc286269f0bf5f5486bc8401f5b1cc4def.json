{"ast":null,"code":"import _slicedToArray from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _callSuper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _superPropGet from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/superPropGet.js\";\nimport _inherits from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.object.values.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\n/**\n * @module ol/interaction/Snap\n */\nimport CollectionEventType from '../CollectionEventType.js';\nimport EventType from '../events/EventType.js';\nimport PointerInteraction from './Pointer.js';\nimport RBush from '../structs/RBush.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport { FALSE, TRUE } from '../functions.js';\nimport { SnapEvent, SnapEventType } from '../events/SnapEvent.js';\nimport { boundingExtent, buffer, createEmpty } from '../extent.js';\nimport { closestOnCircle, closestOnSegment, squaredDistance } from '../coordinate.js';\nimport { fromCircle } from '../geom/Polygon.js';\nimport { fromUserCoordinate, getUserProjection, toUserCoordinate, toUserExtent } from '../proj.js';\nimport { getUid } from '../util.js';\nimport { listen, unlistenByKey } from '../events.js';\n\n/**\n * @typedef {Object} Result\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex Vertex.\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel VertexPixel.\n * @property {import(\"../Feature.js\").default|null} feature Feature.\n * @property {Array<import(\"../coordinate.js\").Coordinate>|null} segment Segment, or `null` if snapped to a vertex.\n */\n\n/**\n * @typedef {Object} SegmentData\n * @property {import(\"../Feature.js\").default} feature Feature.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment Segment.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n */\n\n/**\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n * @return {import(\"../Feature.js\").default|null} Feature.\n */\nfunction getFeatureFromEvent(evt) {\n  if (/** @type {import(\"../source/Vector.js\").VectorSourceEvent} */evt.feature) {\n    return /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */evt.feature;\n  }\n  if (/** @type {import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} */evt.element) {\n    return /** @type {import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} */evt.element;\n  }\n  return null;\n}\nvar tempSegment = [];\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'snap', SnapEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'snap', Return>} SnapOnSignature\n */\n\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector~VectorSource} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap.js';\n *\n *     const snap = new Snap({\n *       source: source\n *     });\n *\n *     map.addInteraction(snap);\n *\n * @fires SnapEvent\n * @api\n */\nvar Snap = /*#__PURE__*/function (_PointerInteraction) {\n  /**\n   * @param {Options} [options] Options.\n   */\n  function Snap(options) {\n    var _this;\n    _classCallCheck(this, Snap);\n    options = options ? options : {};\n    var pointerOptions = /** @type {import(\"./Pointer.js\").Options} */\n    options;\n    if (!pointerOptions.handleDownEvent) {\n      pointerOptions.handleDownEvent = TRUE;\n    }\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n    _this = _callSuper(this, Snap, [pointerOptions]);\n\n    /***\n     * @type {SnapOnSignature<import(\"../events\").EventsKey>}\n     */\n    _this.on;\n\n    /***\n     * @type {SnapOnSignature<import(\"../events\").EventsKey>}\n     */\n    _this.once;\n\n    /***\n     * @type {SnapOnSignature<void>}\n     */\n    _this.un;\n\n    /**\n     * @type {import(\"../source/Vector.js\").default|null}\n     * @private\n     */\n    _this.source_ = options.source ? options.source : null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.edge_ = options.edge !== undefined ? options.edge : true;\n\n    /**\n     * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|null}\n     * @private\n     */\n    _this.features_ = options.features ? options.features : null;\n\n    /**\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    _this.featuresListenerKeys_ = [];\n\n    /**\n     * @type {Object<string, import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    _this.featureChangeListenerKeys_ = {};\n\n    /**\n     * Extents are preserved so indexed segment can be quickly removed\n     * when its feature geometry changes\n     * @type {Object<string, import(\"../extent.js\").Extent>}\n     * @private\n     */\n    _this.indexedFeaturesExtents_ = {};\n\n    /**\n     * If a feature geometry changes while a pointer drag|move event occurs, the\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\n     * event fired.\n     * @type {!Object<string, import(\"../Feature.js\").default>}\n     * @private\n     */\n    _this.pendingFeatures_ = {};\n\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n\n    /**\n     * Segment RTree for each layer\n     * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n     * @private\n     */\n    _this.rBush_ = new RBush();\n\n    /**\n     * @const\n     * @private\n     * @type {Object<string, function(Array<Array<import('../coordinate.js').Coordinate>>, import(\"../geom/Geometry.js\").default): void>}\n     */\n    _this.GEOMETRY_SEGMENTERS_ = {\n      'Point': _this.segmentPointGeometry_.bind(_this),\n      'LineString': _this.segmentLineStringGeometry_.bind(_this),\n      'LinearRing': _this.segmentLineStringGeometry_.bind(_this),\n      'Polygon': _this.segmentPolygonGeometry_.bind(_this),\n      'MultiPoint': _this.segmentMultiPointGeometry_.bind(_this),\n      'MultiLineString': _this.segmentMultiLineStringGeometry_.bind(_this),\n      'MultiPolygon': _this.segmentMultiPolygonGeometry_.bind(_this),\n      'GeometryCollection': _this.segmentGeometryCollectionGeometry_.bind(_this),\n      'Circle': _this.segmentCircleGeometry_.bind(_this)\n    };\n    return _this;\n  }\n\n  /**\n   * Add a feature to the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {boolean} [register] Whether to listen to the feature change or not\n   *     Defaults to `true`.\n   * @api\n   */\n  _inherits(Snap, _PointerInteraction);\n  return _createClass(Snap, [{\n    key: \"addFeature\",\n    value: function addFeature(feature, register) {\n      register = register !== undefined ? register : true;\n      var feature_uid = getUid(feature);\n      var geometry = feature.getGeometry();\n      if (geometry) {\n        var segmenter = this.GEOMETRY_SEGMENTERS_[geometry.getType()];\n        if (segmenter) {\n          this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(createEmpty());\n          var segments = /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */[];\n          segmenter(segments, geometry);\n          if (segments.length === 1) {\n            this.rBush_.insert(boundingExtent(segments[0]), {\n              feature: feature,\n              segment: segments[0]\n            });\n          } else if (segments.length > 1) {\n            var extents = segments.map(function (s) {\n              return boundingExtent(s);\n            });\n            var segmentsData = segments.map(function (segment) {\n              return {\n                feature: feature,\n                segment: segment\n              };\n            });\n            this.rBush_.load(extents, segmentsData);\n          }\n        }\n      }\n      if (register) {\n        this.featureChangeListenerKeys_[feature_uid] = listen(feature, EventType.CHANGE, this.handleFeatureChange_, this);\n      }\n    }\n\n    /**\n     * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n     * @private\n     */\n  }, {\n    key: \"getFeatures_\",\n    value: function getFeatures_() {\n      /** @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} */\n      var features;\n      if (this.features_) {\n        features = this.features_;\n      } else if (this.source_) {\n        features = this.source_.getFeatures();\n      }\n      return features;\n    }\n\n    /**\n     * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\n     * @return {boolean} `false` to stop event propagation.\n     * @api\n     */\n  }, {\n    key: \"handleEvent\",\n    value: function handleEvent(evt) {\n      var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n      if (result) {\n        evt.coordinate = result.vertex.slice(0, 2);\n        evt.pixel = result.vertexPixel;\n        this.dispatchEvent(new SnapEvent(SnapEventType.SNAP, {\n          vertex: evt.coordinate,\n          vertexPixel: evt.pixel,\n          feature: result.feature,\n          segment: result.segment\n        }));\n      }\n      return _superPropGet(Snap, \"handleEvent\", this, 3)([evt]);\n    }\n\n    /**\n     * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n     * @private\n     */\n  }, {\n    key: \"handleFeatureAdd_\",\n    value: function handleFeatureAdd_(evt) {\n      var feature = getFeatureFromEvent(evt);\n      if (feature) {\n        this.addFeature(feature);\n      }\n    }\n\n    /**\n     * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n     * @private\n     */\n  }, {\n    key: \"handleFeatureRemove_\",\n    value: function handleFeatureRemove_(evt) {\n      var feature = getFeatureFromEvent(evt);\n      if (feature) {\n        this.removeFeature(feature);\n      }\n    }\n\n    /**\n     * @param {import(\"../events/Event.js\").default} evt Event.\n     * @private\n     */\n  }, {\n    key: \"handleFeatureChange_\",\n    value: function handleFeatureChange_(evt) {\n      var feature = /** @type {import(\"../Feature.js\").default} */evt.target;\n      if (this.handlingDownUpSequence) {\n        var uid = getUid(feature);\n        if (!(uid in this.pendingFeatures_)) {\n          this.pendingFeatures_[uid] = feature;\n        }\n      } else {\n        this.updateFeature_(feature);\n      }\n    }\n\n    /**\n     * Handle pointer up events.\n     * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n     * @return {boolean} If the event was consumed.\n     */\n  }, {\n    key: \"handleUpEvent\",\n    value: function handleUpEvent(evt) {\n      var featuresToUpdate = Object.values(this.pendingFeatures_);\n      if (featuresToUpdate.length) {\n        featuresToUpdate.forEach(this.updateFeature_.bind(this));\n        this.pendingFeatures_ = {};\n      }\n      return false;\n    }\n\n    /**\n     * Remove a feature from the collection of features that we may snap to.\n     * @param {import(\"../Feature.js\").default} feature Feature\n     * @param {boolean} [unlisten] Whether to unlisten to the feature change\n     *     or not. Defaults to `true`.\n     * @api\n     */\n  }, {\n    key: \"removeFeature\",\n    value: function removeFeature(feature, unlisten) {\n      var unregister = unlisten !== undefined ? unlisten : true;\n      var feature_uid = getUid(feature);\n      var extent = this.indexedFeaturesExtents_[feature_uid];\n      if (extent) {\n        var rBush = this.rBush_;\n        var nodesToRemove = [];\n        rBush.forEachInExtent(extent, function (node) {\n          if (feature === node.feature) {\n            nodesToRemove.push(node);\n          }\n        });\n        for (var i = nodesToRemove.length - 1; i >= 0; --i) {\n          rBush.remove(nodesToRemove[i]);\n        }\n      }\n      if (unregister) {\n        unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n        delete this.featureChangeListenerKeys_[feature_uid];\n      }\n    }\n\n    /**\n     * Remove the interaction from its current map and attach it to the new map.\n     * Subclasses may set up event handlers to get notified about changes to\n     * the map here.\n     * @param {import(\"../Map.js\").default} map Map.\n     */\n  }, {\n    key: \"setMap\",\n    value: function setMap(map) {\n      var _this2 = this;\n      var currentMap = this.getMap();\n      var keys = this.featuresListenerKeys_;\n      var features = /** @type {Array<import(\"../Feature.js\").default>} */\n      this.getFeatures_();\n      if (currentMap) {\n        keys.forEach(unlistenByKey);\n        keys.length = 0;\n        this.rBush_.clear();\n        Object.values(this.featureChangeListenerKeys_).forEach(unlistenByKey);\n        this.featureChangeListenerKeys_ = {};\n      }\n      _superPropGet(Snap, \"setMap\", this, 3)([map]);\n      if (map) {\n        if (this.features_) {\n          keys.push(listen(this.features_, CollectionEventType.ADD, this.handleFeatureAdd_, this), listen(this.features_, CollectionEventType.REMOVE, this.handleFeatureRemove_, this));\n        } else if (this.source_) {\n          keys.push(listen(this.source_, VectorEventType.ADDFEATURE, this.handleFeatureAdd_, this), listen(this.source_, VectorEventType.REMOVEFEATURE, this.handleFeatureRemove_, this));\n        }\n        features.forEach(function (feature) {\n          return _this2.addFeature(feature);\n        });\n      }\n    }\n\n    /**\n     * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n     * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n     * @param {import(\"../Map.js\").default} map Map.\n     * @return {Result|null} Snap result\n     */\n  }, {\n    key: \"snapTo\",\n    value: function snapTo(pixel, pixelCoordinate, map) {\n      var projection = map.getView().getProjection();\n      var projectedCoordinate = fromUserCoordinate(pixelCoordinate, projection);\n      var box = toUserExtent(buffer(boundingExtent([projectedCoordinate]), map.getView().getResolution() * this.pixelTolerance_), projection);\n      var segments = this.rBush_.getInExtent(box);\n      var segmentsLength = segments.length;\n      if (segmentsLength === 0) {\n        return null;\n      }\n      var closestVertex;\n      var minSquaredDistance = Infinity;\n      var closestFeature;\n      var closestSegment = null;\n      var squaredPixelTolerance = this.pixelTolerance_ * this.pixelTolerance_;\n      var getResult = function getResult() {\n        if (closestVertex) {\n          var vertexPixel = map.getPixelFromCoordinate(closestVertex);\n          var squaredPixelDistance = squaredDistance(pixel, vertexPixel);\n          if (squaredPixelDistance <= squaredPixelTolerance) {\n            return {\n              vertex: closestVertex,\n              vertexPixel: [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])],\n              feature: closestFeature,\n              segment: closestSegment\n            };\n          }\n        }\n        return null;\n      };\n      if (this.vertex_) {\n        var _loop = function _loop() {\n          var segmentData = segments[i];\n          if (segmentData.feature.getGeometry().getType() !== 'Circle') {\n            segmentData.segment.forEach(function (vertex) {\n              var tempVertexCoord = fromUserCoordinate(vertex, projection);\n              var delta = squaredDistance(projectedCoordinate, tempVertexCoord);\n              if (delta < minSquaredDistance) {\n                closestVertex = vertex;\n                minSquaredDistance = delta;\n                closestFeature = segmentData.feature;\n              }\n            });\n          }\n        };\n        for (var i = 0; i < segmentsLength; ++i) {\n          _loop();\n        }\n        var result = getResult();\n        if (result) {\n          return result;\n        }\n      }\n      if (this.edge_) {\n        for (var _i = 0; _i < segmentsLength; ++_i) {\n          var vertex = null;\n          var segmentData = segments[_i];\n          if (segmentData.feature.getGeometry().getType() === 'Circle') {\n            var circleGeometry = segmentData.feature.getGeometry();\n            var userProjection = getUserProjection();\n            if (userProjection) {\n              circleGeometry = circleGeometry.clone().transform(userProjection, projection);\n            }\n            vertex = closestOnCircle(projectedCoordinate, /** @type {import(\"../geom/Circle.js\").default} */circleGeometry);\n          } else {\n            var _segmentData$segment = _slicedToArray(segmentData.segment, 2),\n              segmentStart = _segmentData$segment[0],\n              segmentEnd = _segmentData$segment[1];\n            // points have only one coordinate\n            if (segmentEnd) {\n              tempSegment[0] = fromUserCoordinate(segmentStart, projection);\n              tempSegment[1] = fromUserCoordinate(segmentEnd, projection);\n              vertex = closestOnSegment(projectedCoordinate, tempSegment);\n            }\n          }\n          if (vertex) {\n            var delta = squaredDistance(projectedCoordinate, vertex);\n            if (delta < minSquaredDistance) {\n              closestVertex = toUserCoordinate(vertex, projection);\n              closestSegment = segmentData.feature.getGeometry().getType() === 'Circle' ? null : segmentData.segment;\n              minSquaredDistance = delta;\n            }\n          }\n        }\n        var _result = getResult();\n        if (_result) {\n          return _result;\n        }\n      }\n      return null;\n    }\n\n    /**\n     * @param {import(\"../Feature.js\").default} feature Feature\n     * @private\n     */\n  }, {\n    key: \"updateFeature_\",\n    value: function updateFeature_(feature) {\n      this.removeFeature(feature, false);\n      this.addFeature(feature, false);\n    }\n\n    /**\n     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n     * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n     * @private\n     */\n  }, {\n    key: \"segmentCircleGeometry_\",\n    value: function segmentCircleGeometry_(segments, geometry) {\n      var projection = this.getMap().getView().getProjection();\n      var circleGeometry = geometry;\n      var userProjection = getUserProjection();\n      if (userProjection) {\n        circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */\n        circleGeometry.clone().transform(userProjection, projection);\n      }\n      var polygon = fromCircle(circleGeometry);\n      if (userProjection) {\n        polygon.transform(projection, userProjection);\n      }\n      var coordinates = polygon.getCoordinates()[0];\n      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n\n    /**\n     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n     * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n     * @private\n     */\n  }, {\n    key: \"segmentGeometryCollectionGeometry_\",\n    value: function segmentGeometryCollectionGeometry_(segments, geometry) {\n      var geometries = geometry.getGeometriesArray();\n      for (var i = 0; i < geometries.length; ++i) {\n        var segmenter = this.GEOMETRY_SEGMENTERS_[geometries[i].getType()];\n        if (segmenter) {\n          segmenter(segments, geometries[i]);\n        }\n      }\n    }\n\n    /**\n     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n     * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n     * @private\n     */\n  }, {\n    key: \"segmentLineStringGeometry_\",\n    value: function segmentLineStringGeometry_(segments, geometry) {\n      var coordinates = geometry.getCoordinates();\n      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n\n    /**\n     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n     * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n     * @private\n     */\n  }, {\n    key: \"segmentMultiLineStringGeometry_\",\n    value: function segmentMultiLineStringGeometry_(segments, geometry) {\n      var lines = geometry.getCoordinates();\n      for (var j = 0, jj = lines.length; j < jj; ++j) {\n        var coordinates = lines[j];\n        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          segments.push(coordinates.slice(i, i + 2));\n        }\n      }\n    }\n\n    /**\n     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n     * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n     * @private\n     */\n  }, {\n    key: \"segmentMultiPointGeometry_\",\n    value: function segmentMultiPointGeometry_(segments, geometry) {\n      geometry.getCoordinates().forEach(function (point) {\n        segments.push([point]);\n      });\n    }\n\n    /**\n     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n     * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n     * @private\n     */\n  }, {\n    key: \"segmentMultiPolygonGeometry_\",\n    value: function segmentMultiPolygonGeometry_(segments, geometry) {\n      var polygons = geometry.getCoordinates();\n      for (var k = 0, kk = polygons.length; k < kk; ++k) {\n        var rings = polygons[k];\n        for (var j = 0, jj = rings.length; j < jj; ++j) {\n          var coordinates = rings[j];\n          for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n            segments.push(coordinates.slice(i, i + 2));\n          }\n        }\n      }\n    }\n\n    /**\n     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n     * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n     * @private\n     */\n  }, {\n    key: \"segmentPointGeometry_\",\n    value: function segmentPointGeometry_(segments, geometry) {\n      segments.push([geometry.getCoordinates()]);\n    }\n\n    /**\n     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n     * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n     * @private\n     */\n  }, {\n    key: \"segmentPolygonGeometry_\",\n    value: function segmentPolygonGeometry_(segments, geometry) {\n      var rings = geometry.getCoordinates();\n      for (var j = 0, jj = rings.length; j < jj; ++j) {\n        var coordinates = rings[j];\n        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          segments.push(coordinates.slice(i, i + 2));\n        }\n      }\n    }\n  }]);\n}(PointerInteraction);\nexport default Snap;","map":{"version":3,"names":["CollectionEventType","EventType","PointerInteraction","RBush","VectorEventType","FALSE","TRUE","SnapEvent","SnapEventType","boundingExtent","buffer","createEmpty","closestOnCircle","closestOnSegment","squaredDistance","fromCircle","fromUserCoordinate","getUserProjection","toUserCoordinate","toUserExtent","getUid","listen","unlistenByKey","getFeatureFromEvent","evt","feature","element","tempSegment","Snap","_PointerInteraction","options","_this","_classCallCheck","pointerOptions","handleDownEvent","stopDown","_callSuper","on","once","un","source_","source","vertex_","vertex","undefined","edge_","edge","features_","features","featuresListenerKeys_","featureChangeListenerKeys_","indexedFeaturesExtents_","pendingFeatures_","pixelTolerance_","pixelTolerance","rBush_","GEOMETRY_SEGMENTERS_","segmentPointGeometry_","bind","segmentLineStringGeometry_","segmentPolygonGeometry_","segmentMultiPointGeometry_","segmentMultiLineStringGeometry_","segmentMultiPolygonGeometry_","segmentGeometryCollectionGeometry_","segmentCircleGeometry_","_inherits","_createClass","key","value","addFeature","register","feature_uid","geometry","getGeometry","segmenter","getType","getExtent","segments","length","insert","segment","extents","map","s","segmentsData","load","CHANGE","handleFeatureChange_","getFeatures_","getFeatures","handleEvent","result","snapTo","pixel","coordinate","slice","vertexPixel","dispatchEvent","SNAP","_superPropGet","handleFeatureAdd_","handleFeatureRemove_","removeFeature","target","handlingDownUpSequence","uid","updateFeature_","handleUpEvent","featuresToUpdate","Object","values","forEach","unlisten","unregister","extent","rBush","nodesToRemove","forEachInExtent","node","push","i","remove","setMap","_this2","currentMap","getMap","keys","clear","ADD","REMOVE","ADDFEATURE","REMOVEFEATURE","pixelCoordinate","projection","getView","getProjection","projectedCoordinate","box","getResolution","getInExtent","segmentsLength","closestVertex","minSquaredDistance","Infinity","closestFeature","closestSegment","squaredPixelTolerance","getResult","getPixelFromCoordinate","squaredPixelDistance","Math","round","_loop","segmentData","tempVertexCoord","delta","circleGeometry","userProjection","clone","transform","_segmentData$segment","_slicedToArray","segmentStart","segmentEnd","polygon","coordinates","getCoordinates","ii","geometries","getGeometriesArray","lines","j","jj","point","polygons","k","kk","rings"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol/interaction/Snap.js"],"sourcesContent":["/**\n * @module ol/interaction/Snap\n */\nimport CollectionEventType from '../CollectionEventType.js';\nimport EventType from '../events/EventType.js';\nimport PointerInteraction from './Pointer.js';\nimport RBush from '../structs/RBush.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport {FALSE, TRUE} from '../functions.js';\nimport {SnapEvent, SnapEventType} from '../events/SnapEvent.js';\nimport {boundingExtent, buffer, createEmpty} from '../extent.js';\nimport {\n  closestOnCircle,\n  closestOnSegment,\n  squaredDistance,\n} from '../coordinate.js';\nimport {fromCircle} from '../geom/Polygon.js';\nimport {\n  fromUserCoordinate,\n  getUserProjection,\n  toUserCoordinate,\n  toUserExtent,\n} from '../proj.js';\nimport {getUid} from '../util.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {Object} Result\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex Vertex.\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel VertexPixel.\n * @property {import(\"../Feature.js\").default|null} feature Feature.\n * @property {Array<import(\"../coordinate.js\").Coordinate>|null} segment Segment, or `null` if snapped to a vertex.\n */\n\n/**\n * @typedef {Object} SegmentData\n * @property {import(\"../Feature.js\").default} feature Feature.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment Segment.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n */\n\n/**\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n * @return {import(\"../Feature.js\").default|null} Feature.\n */\nfunction getFeatureFromEvent(evt) {\n  if (\n    /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt).feature\n  ) {\n    return /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt)\n      .feature;\n  }\n  if (\n    /** @type {import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} */ (\n      evt\n    ).element\n  ) {\n    return /** @type {import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} */ (\n      evt\n    ).element;\n  }\n  return null;\n}\n\nconst tempSegment = [];\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'snap', SnapEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'snap', Return>} SnapOnSignature\n */\n\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector~VectorSource} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap.js';\n *\n *     const snap = new Snap({\n *       source: source\n *     });\n *\n *     map.addInteraction(snap);\n *\n * @fires SnapEvent\n * @api\n */\nclass Snap extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\n      options\n    );\n\n    if (!pointerOptions.handleDownEvent) {\n      pointerOptions.handleDownEvent = TRUE;\n    }\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /***\n     * @type {SnapOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {SnapOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {SnapOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {import(\"../source/Vector.js\").default|null}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.edge_ = options.edge !== undefined ? options.edge : true;\n\n    /**\n     * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|null}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n\n    /**\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featuresListenerKeys_ = [];\n\n    /**\n     * @type {Object<string, import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featureChangeListenerKeys_ = {};\n\n    /**\n     * Extents are preserved so indexed segment can be quickly removed\n     * when its feature geometry changes\n     * @type {Object<string, import(\"../extent.js\").Extent>}\n     * @private\n     */\n    this.indexedFeaturesExtents_ = {};\n\n    /**\n     * If a feature geometry changes while a pointer drag|move event occurs, the\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\n     * event fired.\n     * @type {!Object<string, import(\"../Feature.js\").default>}\n     * @private\n     */\n    this.pendingFeatures_ = {};\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.pixelTolerance_ =\n      options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n\n    /**\n     * Segment RTree for each layer\n     * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n     * @private\n     */\n    this.rBush_ = new RBush();\n\n    /**\n     * @const\n     * @private\n     * @type {Object<string, function(Array<Array<import('../coordinate.js').Coordinate>>, import(\"../geom/Geometry.js\").default): void>}\n     */\n    this.GEOMETRY_SEGMENTERS_ = {\n      'Point': this.segmentPointGeometry_.bind(this),\n      'LineString': this.segmentLineStringGeometry_.bind(this),\n      'LinearRing': this.segmentLineStringGeometry_.bind(this),\n      'Polygon': this.segmentPolygonGeometry_.bind(this),\n      'MultiPoint': this.segmentMultiPointGeometry_.bind(this),\n      'MultiLineString': this.segmentMultiLineStringGeometry_.bind(this),\n      'MultiPolygon': this.segmentMultiPolygonGeometry_.bind(this),\n      'GeometryCollection': this.segmentGeometryCollectionGeometry_.bind(this),\n      'Circle': this.segmentCircleGeometry_.bind(this),\n    };\n  }\n\n  /**\n   * Add a feature to the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {boolean} [register] Whether to listen to the feature change or not\n   *     Defaults to `true`.\n   * @api\n   */\n  addFeature(feature, register) {\n    register = register !== undefined ? register : true;\n    const feature_uid = getUid(feature);\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      const segmenter = this.GEOMETRY_SEGMENTERS_[geometry.getType()];\n      if (segmenter) {\n        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(\n          createEmpty()\n        );\n        const segments =\n          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ ([]);\n        segmenter(segments, geometry);\n        if (segments.length === 1) {\n          this.rBush_.insert(boundingExtent(segments[0]), {\n            feature: feature,\n            segment: segments[0],\n          });\n        } else if (segments.length > 1) {\n          const extents = segments.map((s) => boundingExtent(s));\n          const segmentsData = segments.map((segment) => ({\n            feature: feature,\n            segment: segment,\n          }));\n          this.rBush_.load(extents, segmentsData);\n        }\n      }\n    }\n\n    if (register) {\n      this.featureChangeListenerKeys_[feature_uid] = listen(\n        feature,\n        EventType.CHANGE,\n        this.handleFeatureChange_,\n        this\n      );\n    }\n  }\n\n  /**\n   * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n   * @private\n   */\n  getFeatures_() {\n    /** @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} */\n    let features;\n    if (this.features_) {\n      features = this.features_;\n    } else if (this.source_) {\n      features = this.source_.getFeatures();\n    }\n    return features;\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @api\n   */\n  handleEvent(evt) {\n    const result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n    if (result) {\n      evt.coordinate = result.vertex.slice(0, 2);\n      evt.pixel = result.vertexPixel;\n      this.dispatchEvent(\n        new SnapEvent(SnapEventType.SNAP, {\n          vertex: evt.coordinate,\n          vertexPixel: evt.pixel,\n          feature: result.feature,\n          segment: result.segment,\n        })\n      );\n    }\n    return super.handleEvent(evt);\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n   * @private\n   */\n  handleFeatureAdd_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    if (feature) {\n      this.addFeature(feature);\n    }\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n   * @private\n   */\n  handleFeatureRemove_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    if (feature) {\n      this.removeFeature(feature);\n    }\n  }\n\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   * @private\n   */\n  handleFeatureChange_(evt) {\n    const feature = /** @type {import(\"../Feature.js\").default} */ (evt.target);\n    if (this.handlingDownUpSequence) {\n      const uid = getUid(feature);\n      if (!(uid in this.pendingFeatures_)) {\n        this.pendingFeatures_[uid] = feature;\n      }\n    } else {\n      this.updateFeature_(feature);\n    }\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(evt) {\n    const featuresToUpdate = Object.values(this.pendingFeatures_);\n    if (featuresToUpdate.length) {\n      featuresToUpdate.forEach(this.updateFeature_.bind(this));\n      this.pendingFeatures_ = {};\n    }\n    return false;\n  }\n\n  /**\n   * Remove a feature from the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {boolean} [unlisten] Whether to unlisten to the feature change\n   *     or not. Defaults to `true`.\n   * @api\n   */\n  removeFeature(feature, unlisten) {\n    const unregister = unlisten !== undefined ? unlisten : true;\n    const feature_uid = getUid(feature);\n    const extent = this.indexedFeaturesExtents_[feature_uid];\n    if (extent) {\n      const rBush = this.rBush_;\n      const nodesToRemove = [];\n      rBush.forEachInExtent(extent, function (node) {\n        if (feature === node.feature) {\n          nodesToRemove.push(node);\n        }\n      });\n      for (let i = nodesToRemove.length - 1; i >= 0; --i) {\n        rBush.remove(nodesToRemove[i]);\n      }\n    }\n\n    if (unregister) {\n      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n      delete this.featureChangeListenerKeys_[feature_uid];\n    }\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  setMap(map) {\n    const currentMap = this.getMap();\n    const keys = this.featuresListenerKeys_;\n    const features = /** @type {Array<import(\"../Feature.js\").default>} */ (\n      this.getFeatures_()\n    );\n\n    if (currentMap) {\n      keys.forEach(unlistenByKey);\n      keys.length = 0;\n      this.rBush_.clear();\n      Object.values(this.featureChangeListenerKeys_).forEach(unlistenByKey);\n      this.featureChangeListenerKeys_ = {};\n    }\n    super.setMap(map);\n\n    if (map) {\n      if (this.features_) {\n        keys.push(\n          listen(\n            this.features_,\n            CollectionEventType.ADD,\n            this.handleFeatureAdd_,\n            this\n          ),\n          listen(\n            this.features_,\n            CollectionEventType.REMOVE,\n            this.handleFeatureRemove_,\n            this\n          )\n        );\n      } else if (this.source_) {\n        keys.push(\n          listen(\n            this.source_,\n            VectorEventType.ADDFEATURE,\n            this.handleFeatureAdd_,\n            this\n          ),\n          listen(\n            this.source_,\n            VectorEventType.REMOVEFEATURE,\n            this.handleFeatureRemove_,\n            this\n          )\n        );\n      }\n      features.forEach((feature) => this.addFeature(feature));\n    }\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n   * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n   * @param {import(\"../Map.js\").default} map Map.\n   * @return {Result|null} Snap result\n   */\n  snapTo(pixel, pixelCoordinate, map) {\n    const projection = map.getView().getProjection();\n    const projectedCoordinate = fromUserCoordinate(pixelCoordinate, projection);\n\n    const box = toUserExtent(\n      buffer(\n        boundingExtent([projectedCoordinate]),\n        map.getView().getResolution() * this.pixelTolerance_\n      ),\n      projection\n    );\n\n    const segments = this.rBush_.getInExtent(box);\n    const segmentsLength = segments.length;\n    if (segmentsLength === 0) {\n      return null;\n    }\n\n    let closestVertex;\n    let minSquaredDistance = Infinity;\n    let closestFeature;\n    let closestSegment = null;\n\n    const squaredPixelTolerance = this.pixelTolerance_ * this.pixelTolerance_;\n    const getResult = () => {\n      if (closestVertex) {\n        const vertexPixel = map.getPixelFromCoordinate(closestVertex);\n        const squaredPixelDistance = squaredDistance(pixel, vertexPixel);\n        if (squaredPixelDistance <= squaredPixelTolerance) {\n          return {\n            vertex: closestVertex,\n            vertexPixel: [\n              Math.round(vertexPixel[0]),\n              Math.round(vertexPixel[1]),\n            ],\n            feature: closestFeature,\n            segment: closestSegment,\n          };\n        }\n      }\n      return null;\n    };\n\n    if (this.vertex_) {\n      for (let i = 0; i < segmentsLength; ++i) {\n        const segmentData = segments[i];\n        if (segmentData.feature.getGeometry().getType() !== 'Circle') {\n          segmentData.segment.forEach((vertex) => {\n            const tempVertexCoord = fromUserCoordinate(vertex, projection);\n            const delta = squaredDistance(projectedCoordinate, tempVertexCoord);\n            if (delta < minSquaredDistance) {\n              closestVertex = vertex;\n              minSquaredDistance = delta;\n              closestFeature = segmentData.feature;\n            }\n          });\n        }\n      }\n      const result = getResult();\n      if (result) {\n        return result;\n      }\n    }\n\n    if (this.edge_) {\n      for (let i = 0; i < segmentsLength; ++i) {\n        let vertex = null;\n        const segmentData = segments[i];\n        if (segmentData.feature.getGeometry().getType() === 'Circle') {\n          let circleGeometry = segmentData.feature.getGeometry();\n          const userProjection = getUserProjection();\n          if (userProjection) {\n            circleGeometry = circleGeometry\n              .clone()\n              .transform(userProjection, projection);\n          }\n          vertex = closestOnCircle(\n            projectedCoordinate,\n            /** @type {import(\"../geom/Circle.js\").default} */ (circleGeometry)\n          );\n        } else {\n          const [segmentStart, segmentEnd] = segmentData.segment;\n          // points have only one coordinate\n          if (segmentEnd) {\n            tempSegment[0] = fromUserCoordinate(segmentStart, projection);\n            tempSegment[1] = fromUserCoordinate(segmentEnd, projection);\n            vertex = closestOnSegment(projectedCoordinate, tempSegment);\n          }\n        }\n        if (vertex) {\n          const delta = squaredDistance(projectedCoordinate, vertex);\n          if (delta < minSquaredDistance) {\n            closestVertex = toUserCoordinate(vertex, projection);\n            closestSegment =\n              segmentData.feature.getGeometry().getType() === 'Circle'\n                ? null\n                : segmentData.segment;\n            minSquaredDistance = delta;\n          }\n        }\n      }\n\n      const result = getResult();\n      if (result) {\n        return result;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @private\n   */\n  updateFeature_(feature) {\n    this.removeFeature(feature, false);\n    this.addFeature(feature, false);\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentCircleGeometry_(segments, geometry) {\n    const projection = this.getMap().getView().getProjection();\n    let circleGeometry = geometry;\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */ (\n        circleGeometry.clone().transform(userProjection, projection)\n      );\n    }\n    const polygon = fromCircle(circleGeometry);\n    if (userProjection) {\n      polygon.transform(projection, userProjection);\n    }\n    const coordinates = polygon.getCoordinates()[0];\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentGeometryCollectionGeometry_(segments, geometry) {\n    const geometries = geometry.getGeometriesArray();\n    for (let i = 0; i < geometries.length; ++i) {\n      const segmenter = this.GEOMETRY_SEGMENTERS_[geometries[i].getType()];\n      if (segmenter) {\n        segmenter(segments, geometries[i]);\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentLineStringGeometry_(segments, geometry) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiLineStringGeometry_(segments, geometry) {\n    const lines = geometry.getCoordinates();\n    for (let j = 0, jj = lines.length; j < jj; ++j) {\n      const coordinates = lines[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiPointGeometry_(segments, geometry) {\n    geometry.getCoordinates().forEach((point) => {\n      segments.push([point]);\n    });\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiPolygonGeometry_(segments, geometry) {\n    const polygons = geometry.getCoordinates();\n    for (let k = 0, kk = polygons.length; k < kk; ++k) {\n      const rings = polygons[k];\n      for (let j = 0, jj = rings.length; j < jj; ++j) {\n        const coordinates = rings[j];\n        for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          segments.push(coordinates.slice(i, i + 2));\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentPointGeometry_(segments, geometry) {\n    segments.push([geometry.getCoordinates()]);\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentPolygonGeometry_(segments, geometry) {\n    const rings = geometry.getCoordinates();\n    for (let j = 0, jj = rings.length; j < jj; ++j) {\n      const coordinates = rings[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  }\n}\n\nexport default Snap;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}