{"ast":null,"code":"import _classCallCheck from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _possibleConstructorReturn from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\";\nimport _callSuper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _superPropGet from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/superPropGet.js\";\nimport _inherits from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.timers.js\";\n/**\n * @module ol/reproj/Tile\n */\nimport { ERROR_THRESHOLD } from './common.js';\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport { calculateSourceExtentResolution, canvasPool, render as renderReprojected } from '../reproj.js';\nimport { clamp } from '../math.js';\nimport { getArea, getIntersection } from '../extent.js';\nimport { listen, unlistenByKey } from '../events.js';\nimport { releaseCanvas } from '../dom.js';\n\n/**\n * @typedef {function(number, number, number, number) : (import(\"../ImageTile.js\").default)} FunctionType\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nvar ReprojTile = /*#__PURE__*/function (_Tile) {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number} [errorThreshold] Acceptable reprojection error (in px).\n   * @param {boolean} [renderEdges] Render reprojection edges.\n   * @param {import(\"../Tile.js\").Options} [options] Tile options.\n   */\n  function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, errorThreshold, renderEdges, options) {\n    var _this;\n    _classCallCheck(this, ReprojTile);\n    _this = _callSuper(this, ReprojTile, [tileCoord, TileState.IDLE, options]);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.gutter_ = gutter;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    _this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    _this.sourceTileGrid_ = sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    _this.targetTileGrid_ = targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<import(\"../ImageTile.js\").default>}\n     */\n    _this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    _this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.sourceZ_ = 0;\n    var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);\n    var maxTargetExtent = _this.targetTileGrid_.getExtent();\n    var maxSourceExtent = _this.sourceTileGrid_.getExtent();\n    var limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      _this.state = TileState.EMPTY;\n      return _possibleConstructorReturn(_this);\n    }\n    var sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n    var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);\n    var sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      _this.state = TileState.EMPTY;\n      return _possibleConstructorReturn(_this);\n    }\n    var errorThresholdInPixels = errorThreshold !== undefined ? errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    _this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);\n    if (_this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      _this.state = TileState.EMPTY;\n      return _possibleConstructorReturn(_this);\n    }\n    _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    var sourceExtent = _this.triangulation_.calculateSourceExtent();\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n        sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n    if (!getArea(sourceExtent)) {\n      _this.state = TileState.EMPTY;\n    } else {\n      var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);\n      for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          var tile = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);\n          if (tile) {\n            _this.sourceTiles_.push(tile);\n          }\n        }\n      }\n      if (_this.sourceTiles_.length === 0) {\n        _this.state = TileState.EMPTY;\n      }\n    }\n    return _this;\n  }\n\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  _inherits(ReprojTile, _Tile);\n  return _createClass(ReprojTile, [{\n    key: \"getImage\",\n    value: function getImage() {\n      return this.canvas_;\n    }\n\n    /**\n     * @private\n     */\n  }, {\n    key: \"reproject_\",\n    value: function reproject_() {\n      var _this2 = this;\n      var sources = [];\n      this.sourceTiles_.forEach(function (tile) {\n        if (tile && tile.getState() == TileState.LOADED) {\n          sources.push({\n            extent: _this2.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n            image: tile.getImage()\n          });\n        }\n      });\n      this.sourceTiles_.length = 0;\n      if (sources.length === 0) {\n        this.state = TileState.ERROR;\n      } else {\n        var z = this.wrappedTileCoord_[0];\n        var size = this.targetTileGrid_.getTileSize(z);\n        var width = typeof size === 'number' ? size : size[0];\n        var height = typeof size === 'number' ? size : size[1];\n        var targetResolution = this.targetTileGrid_.getResolution(z);\n        var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n        var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n        this.canvas_ = renderReprojected(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.interpolate);\n        this.state = TileState.LOADED;\n      }\n      this.changed();\n    }\n\n    /**\n     * Load not yet loaded URI.\n     */\n  }, {\n    key: \"load\",\n    value: function load() {\n      var _this3 = this;\n      if (this.state == TileState.IDLE) {\n        this.state = TileState.LOADING;\n        this.changed();\n        var leftToLoad = 0;\n        this.sourcesListenerKeys_ = [];\n        this.sourceTiles_.forEach(function (tile) {\n          var state = tile.getState();\n          if (state == TileState.IDLE || state == TileState.LOADING) {\n            leftToLoad++;\n            var sourceListenKey = listen(tile, EventType.CHANGE, function (e) {\n              var state = tile.getState();\n              if (state == TileState.LOADED || state == TileState.ERROR || state == TileState.EMPTY) {\n                unlistenByKey(sourceListenKey);\n                leftToLoad--;\n                if (leftToLoad === 0) {\n                  this.unlistenSources_();\n                  this.reproject_();\n                }\n              }\n            }, _this3);\n            _this3.sourcesListenerKeys_.push(sourceListenKey);\n          }\n        });\n        if (leftToLoad === 0) {\n          setTimeout(this.reproject_.bind(this), 0);\n        } else {\n          this.sourceTiles_.forEach(function (tile, i, arr) {\n            var state = tile.getState();\n            if (state == TileState.IDLE) {\n              tile.load();\n            }\n          });\n        }\n      }\n    }\n\n    /**\n     * @private\n     */\n  }, {\n    key: \"unlistenSources_\",\n    value: function unlistenSources_() {\n      this.sourcesListenerKeys_.forEach(unlistenByKey);\n      this.sourcesListenerKeys_ = null;\n    }\n\n    /**\n     * Remove from the cache due to expiry\n     */\n  }, {\n    key: \"release\",\n    value: function release() {\n      if (this.canvas_) {\n        releaseCanvas(this.canvas_.getContext('2d'));\n        canvasPool.push(this.canvas_);\n        this.canvas_ = null;\n      }\n      _superPropGet(ReprojTile, \"release\", this, 3)([]);\n    }\n  }]);\n}(Tile);\nexport default ReprojTile;","map":{"version":3,"names":["ERROR_THRESHOLD","EventType","Tile","TileState","Triangulation","calculateSourceExtentResolution","canvasPool","render","renderReprojected","clamp","getArea","getIntersection","listen","unlistenByKey","releaseCanvas","ReprojTile","_Tile","sourceProj","sourceTileGrid","targetProj","targetTileGrid","tileCoord","wrappedTileCoord","pixelRatio","gutter","getTileFunction","errorThreshold","renderEdges","options","_this","_classCallCheck","_callSuper","IDLE","renderEdges_","undefined","pixelRatio_","gutter_","canvas_","sourceTileGrid_","targetTileGrid_","wrappedTileCoord_","sourceTiles_","sourcesListenerKeys_","sourceZ_","targetExtent","getTileCoordExtent","maxTargetExtent","getExtent","maxSourceExtent","limitedTargetExtent","state","EMPTY","_possibleConstructorReturn","sourceProjExtent","targetResolution","getResolution","sourceResolution","isFinite","errorThresholdInPixels","triangulation_","getTriangles","length","getZForResolution","sourceExtent","calculateSourceExtent","canWrapX","sourceRange","getTileRangeForExtentAndZ","srcX","minX","maxX","srcY","minY","maxY","tile","push","_inherits","_createClass","key","value","getImage","reproject_","_this2","sources","forEach","getState","LOADED","extent","image","ERROR","z","size","getTileSize","width","height","interpolate","changed","load","_this3","LOADING","leftToLoad","sourceListenKey","CHANGE","e","unlistenSources_","setTimeout","bind","i","arr","release","getContext","_superPropGet"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol/reproj/Tile.js"],"sourcesContent":["/**\n * @module ol/reproj/Tile\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport {\n  calculateSourceExtentResolution,\n  canvasPool,\n  render as renderReprojected,\n} from '../reproj.js';\nimport {clamp} from '../math.js';\nimport {getArea, getIntersection} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {releaseCanvas} from '../dom.js';\n\n/**\n * @typedef {function(number, number, number, number) : (import(\"../ImageTile.js\").default)} FunctionType\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nclass ReprojTile extends Tile {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number} [errorThreshold] Acceptable reprojection error (in px).\n   * @param {boolean} [renderEdges] Render reprojection edges.\n   * @param {import(\"../Tile.js\").Options} [options] Tile options.\n   */\n  constructor(\n    sourceProj,\n    sourceTileGrid,\n    targetProj,\n    targetTileGrid,\n    tileCoord,\n    wrappedTileCoord,\n    pixelRatio,\n    gutter,\n    getTileFunction,\n    errorThreshold,\n    renderEdges,\n    options\n  ) {\n    super(tileCoord, TileState.IDLE, options);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = gutter;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<import(\"../ImageTile.js\").default>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    const targetExtent = targetTileGrid.getTileCoordExtent(\n      this.wrappedTileCoord_\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = targetTileGrid.getResolution(\n      this.wrappedTileCoord_[0]\n    );\n\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      errorThreshold !== undefined ? errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3]\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3]\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\n        sourceExtent,\n        this.sourceZ_\n      );\n\n      for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n          if (tile) {\n            this.sourceTiles_.push(tile);\n          }\n        }\n      }\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  getImage() {\n    return this.canvas_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const sources = [];\n    this.sourceTiles_.forEach((tile) => {\n      if (tile && tile.getState() == TileState.LOADED) {\n        sources.push({\n          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n          image: tile.getImage(),\n        });\n      }\n    });\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const width = typeof size === 'number' ? size : size[0];\n      const height = typeof size === 'number' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(\n        this.sourceZ_\n      );\n\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_\n      );\n\n      this.canvas_ = renderReprojected(\n        width,\n        height,\n        this.pixelRatio_,\n        sourceResolution,\n        this.sourceTileGrid_.getExtent(),\n        targetResolution,\n        targetExtent,\n        this.triangulation_,\n        sources,\n        this.gutter_,\n        this.renderEdges_,\n        this.interpolate\n      );\n\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   */\n  load() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n\n      let leftToLoad = 0;\n\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach((tile) => {\n        const state = tile.getState();\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad++;\n\n          const sourceListenKey = listen(\n            tile,\n            EventType.CHANGE,\n            function (e) {\n              const state = tile.getState();\n              if (\n                state == TileState.LOADED ||\n                state == TileState.ERROR ||\n                state == TileState.EMPTY\n              ) {\n                unlistenByKey(sourceListenKey);\n                leftToLoad--;\n                if (leftToLoad === 0) {\n                  this.unlistenSources_();\n                  this.reproject_();\n                }\n              }\n            },\n            this\n          );\n          this.sourcesListenerKeys_.push(sourceListenKey);\n        }\n      });\n\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      } else {\n        this.sourceTiles_.forEach(function (tile, i, arr) {\n          const state = tile.getState();\n          if (state == TileState.IDLE) {\n            tile.load();\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n\n  /**\n   * Remove from the cache due to expiry\n   */\n  release() {\n    if (this.canvas_) {\n      releaseCanvas(this.canvas_.getContext('2d'));\n      canvasPool.push(this.canvas_);\n      this.canvas_ = null;\n    }\n    super.release();\n  }\n}\n\nexport default ReprojTile;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}