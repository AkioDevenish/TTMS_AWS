{"ast":null,"code":"import _classCallCheck from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _callSuper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.string.includes.js\";\n/**\n * @module ol/format/GMLBase\n */\n// FIXME Envelopes should not be treated as geometries! readEnvelope_ is part\n// of GEOMETRY_PARSERS_ and methods using GEOMETRY_PARSERS_ do not expect\n// envelopes/extents, only geometries!\nimport Feature from '../Feature.js';\nimport Geometry from '../geom/Geometry.js';\nimport LineString from '../geom/LineString.js';\nimport LinearRing from '../geom/LinearRing.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport XMLFeature from './XMLFeature.js';\nimport { extend } from '../array.js';\nimport { getAllTextContent, getAttributeNS, makeArrayPusher, makeReplacer, parseNode, pushParseAndPop } from '../xml.js';\nimport { get as getProjection } from '../proj.js';\nimport { transformExtentWithOptions, transformGeometryWithOptions } from './Feature.js';\n\n/**\n * @const\n * @type {string}\n */\nexport var GMLNS = 'http://www.opengis.net/gml';\n\n/**\n * A regular expression that matches if a string only contains whitespace\n * characters. It will e.g. match `''`, `' '`, `'\\n'` etc.\n *\n * @const\n * @type {RegExp}\n */\nvar ONLY_WHITESPACE_RE = /^\\s*$/;\n\n/**\n * @typedef {Object} Options\n * @property {Object<string, string>|string} [featureNS] Feature\n * namespace. If not defined will be derived from GML. If multiple\n * feature types have been configured which come from different feature\n * namespaces, this will be an object with the keys being the prefixes used\n * in the entries of featureType array. The values of the object will be the\n * feature namespaces themselves. So for instance there might be a featureType\n * item `topp:states` in the `featureType` array and then there will be a key\n * `topp` in the featureNS object with value `http://www.openplans.org/topp`.\n * @property {Array<string>|string} [featureType] Feature type(s) to parse.\n * If multiple feature types need to be configured\n * which come from different feature namespaces, `featureNS` will be an object\n * with the keys being the prefixes used in the entries of featureType array.\n * The values of the object will be the feature namespaces themselves.\n * So for instance there might be a featureType item `topp:states` and then\n * there will be a key named `topp` in the featureNS object with value\n * `http://www.openplans.org/topp`.\n * @property {string} [srsName] srsName to use when writing geometries.\n * @property {boolean} [surface=false] Write gml:Surface instead of gml:Polygon\n * elements. This also affects the elements in multi-part geometries.\n * @property {boolean} [curve=false] Write gml:Curve instead of gml:LineString\n * elements. This also affects the elements in multi-part geometries.\n * @property {boolean} [multiCurve=true] Write gml:MultiCurve instead of gml:MultiLineString.\n * Since the latter is deprecated in GML 3.\n * @property {boolean} [multiSurface=true] Write gml:multiSurface instead of\n * gml:MultiPolygon. Since the latter is deprecated in GML 3.\n * @property {string} [schemaLocation] Optional schemaLocation to use when\n * writing out the GML, this will override the default provided.\n * @property {boolean} [hasZ=false] If coordinates have a Z value.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Feature base format for reading and writing data in the GML format.\n * This class cannot be instantiated, it contains only base content that\n * is shared with versioned format classes GML2 and GML3.\n *\n * @abstract\n * @api\n */\nvar GMLBase = /*#__PURE__*/function (_XMLFeature) {\n  /**\n   * @param {Options} [options] Optional configuration object.\n   */\n  function GMLBase(options) {\n    var _this;\n    _classCallCheck(this, GMLBase);\n    _this = _callSuper(this, GMLBase);\n    options = options ? options : {};\n\n    /**\n     * @protected\n     * @type {Array<string>|string|undefined}\n     */\n    _this.featureType = options.featureType;\n\n    /**\n     * @protected\n     * @type {Object<string, string>|string|undefined}\n     */\n    _this.featureNS = options.featureNS;\n\n    /**\n     * @protected\n     * @type {string|undefined}\n     */\n    _this.srsName = options.srsName;\n\n    /**\n     * @protected\n     * @type {string}\n     */\n    _this.schemaLocation = '';\n\n    /**\n     * @type {Object<string, Object<string, Object>>}\n     */\n    _this.FEATURE_COLLECTION_PARSERS = {};\n    _this.FEATURE_COLLECTION_PARSERS[_this.namespace] = {\n      'featureMember': makeArrayPusher(_this.readFeaturesInternal),\n      'featureMembers': makeReplacer(_this.readFeaturesInternal)\n    };\n    _this.supportedMediaTypes = ['application/gml+xml'];\n    return _this;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<Feature> | undefined} Features.\n   */\n  _inherits(GMLBase, _XMLFeature);\n  return _createClass(GMLBase, [{\n    key: \"readFeaturesInternal\",\n    value: function readFeaturesInternal(node, objectStack) {\n      var localName = node.localName;\n      var features = null;\n      if (localName == 'FeatureCollection') {\n        features = pushParseAndPop([], this.FEATURE_COLLECTION_PARSERS, node, objectStack, this);\n      } else if (localName == 'featureMembers' || localName == 'featureMember' || localName == 'member') {\n        var context = objectStack[0];\n        var featureType = context['featureType'];\n        var featureNS = context['featureNS'];\n        var prefix = 'p';\n        var defaultPrefix = 'p0';\n        if (!featureType && node.childNodes) {\n          featureType = [], featureNS = {};\n          for (var i = 0, ii = node.childNodes.length; i < ii; ++i) {\n            var child = /** @type {Element} */node.childNodes[i];\n            if (child.nodeType === 1) {\n              var ft = child.nodeName.split(':').pop();\n              if (!featureType.includes(ft)) {\n                var key = '';\n                var count = 0;\n                var uri = child.namespaceURI;\n                for (var candidate in featureNS) {\n                  if (featureNS[candidate] === uri) {\n                    key = candidate;\n                    break;\n                  }\n                  ++count;\n                }\n                if (!key) {\n                  key = prefix + count;\n                  featureNS[key] = uri;\n                }\n                featureType.push(key + ':' + ft);\n              }\n            }\n          }\n          if (localName != 'featureMember') {\n            // recheck featureType for each featureMember\n            context['featureType'] = featureType;\n            context['featureNS'] = featureNS;\n          }\n        }\n        if (typeof featureNS === 'string') {\n          var ns = featureNS;\n          featureNS = {};\n          featureNS[defaultPrefix] = ns;\n        }\n        /** @type {Object<string, Object<string, import(\"../xml.js\").Parser>>} */\n        var parsersNS = {};\n        var featureTypes = Array.isArray(featureType) ? featureType : [featureType];\n        for (var p in featureNS) {\n          /** @type {Object<string, import(\"../xml.js\").Parser>} */\n          var parsers = {};\n          for (var _i = 0, _ii = featureTypes.length; _i < _ii; ++_i) {\n            var featurePrefix = featureTypes[_i].includes(':') ? featureTypes[_i].split(':')[0] : defaultPrefix;\n            if (featurePrefix === p) {\n              parsers[featureTypes[_i].split(':').pop()] = localName == 'featureMembers' ? makeArrayPusher(this.readFeatureElement, this) : makeReplacer(this.readFeatureElement, this);\n            }\n          }\n          parsersNS[featureNS[p]] = parsers;\n        }\n        if (localName == 'featureMember' || localName == 'member') {\n          features = pushParseAndPop(undefined, parsersNS, node, objectStack);\n        } else {\n          features = pushParseAndPop([], parsersNS, node, objectStack);\n        }\n      }\n      if (features === null) {\n        features = [];\n      }\n      return features;\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent|undefined} Geometry.\n     */\n  }, {\n    key: \"readGeometryOrExtent\",\n    value: function readGeometryOrExtent(node, objectStack) {\n      var context = /** @type {Object} */objectStack[0];\n      context['srsName'] = node.firstElementChild.getAttribute('srsName');\n      context['srsDimension'] = node.firstElementChild.getAttribute('srsDimension');\n      return pushParseAndPop(null, this.GEOMETRY_PARSERS, node, objectStack, this);\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {import(\"../extent.js\").Extent|undefined} Geometry.\n     */\n  }, {\n    key: \"readExtentElement\",\n    value: function readExtentElement(node, objectStack) {\n      var context = /** @type {Object} */objectStack[0];\n      var extent = /** @type {import(\"../extent.js\").Extent} */\n      this.readGeometryOrExtent(node, objectStack);\n      return extent ? transformExtentWithOptions(extent, context) : undefined;\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {import(\"../geom/Geometry.js\").default|undefined} Geometry.\n     */\n  }, {\n    key: \"readGeometryElement\",\n    value: function readGeometryElement(node, objectStack) {\n      var context = /** @type {Object} */objectStack[0];\n      var geometry = /** @type {import(\"../geom/Geometry.js\").default} */\n      this.readGeometryOrExtent(node, objectStack);\n      return geometry ? transformGeometryWithOptions(geometry, false, context) : undefined;\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @param {boolean} asFeature whether result should be wrapped as a feature.\n     * @return {Feature|Object} Feature\n     */\n  }, {\n    key: \"readFeatureElementInternal\",\n    value: function readFeatureElementInternal(node, objectStack, asFeature) {\n      var geometryName;\n      var values = {};\n      for (var n = node.firstElementChild; n; n = n.nextElementSibling) {\n        var value = void 0;\n        var localName = n.localName;\n        // first, check if it is simple attribute\n        if (n.childNodes.length === 0 || n.childNodes.length === 1 && (n.firstChild.nodeType === 3 || n.firstChild.nodeType === 4)) {\n          value = getAllTextContent(n, false);\n          if (ONLY_WHITESPACE_RE.test(value)) {\n            value = undefined;\n          }\n        } else {\n          if (asFeature) {\n            //if feature, try it as a geometry or extent\n            value = localName === 'boundedBy' ? this.readExtentElement(n, objectStack) : this.readGeometryElement(n, objectStack);\n          }\n          if (!value) {\n            //if not a geometry or not a feature, treat it as a complex attribute\n            value = this.readFeatureElementInternal(n, objectStack, false);\n          } else if (localName !== 'boundedBy') {\n            // boundedBy is an extent and must not be considered as a geometry\n            geometryName = localName;\n          }\n        }\n        var len = n.attributes.length;\n        if (len > 0 && !(value instanceof Geometry)) {\n          value = {\n            _content_: value\n          };\n          for (var i = 0; i < len; i++) {\n            var attName = n.attributes[i].name;\n            value[attName] = n.attributes[i].value;\n          }\n        }\n        if (values[localName]) {\n          if (!(values[localName] instanceof Array)) {\n            values[localName] = [values[localName]];\n          }\n          values[localName].push(value);\n        } else {\n          values[localName] = value;\n        }\n      }\n      if (!asFeature) {\n        return values;\n      }\n      var feature = new Feature(values);\n      if (geometryName) {\n        feature.setGeometryName(geometryName);\n      }\n      var fid = node.getAttribute('fid') || getAttributeNS(node, this.namespace, 'id');\n      if (fid) {\n        feature.setId(fid);\n      }\n      return feature;\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {Feature} Feature.\n     */\n  }, {\n    key: \"readFeatureElement\",\n    value: function readFeatureElement(node, objectStack) {\n      return this.readFeatureElementInternal(node, objectStack, true);\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {Point|undefined} Point.\n     */\n  }, {\n    key: \"readPoint\",\n    value: function readPoint(node, objectStack) {\n      var flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n      if (flatCoordinates) {\n        return new Point(flatCoordinates, 'XYZ');\n      }\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {MultiPoint|undefined} MultiPoint.\n     */\n  }, {\n    key: \"readMultiPoint\",\n    value: function readMultiPoint(node, objectStack) {\n      /** @type {Array<Array<number>>} */\n      var coordinates = pushParseAndPop([], this.MULTIPOINT_PARSERS, node, objectStack, this);\n      if (coordinates) {\n        return new MultiPoint(coordinates);\n      }\n      return undefined;\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {MultiLineString|undefined} MultiLineString.\n     */\n  }, {\n    key: \"readMultiLineString\",\n    value: function readMultiLineString(node, objectStack) {\n      /** @type {Array<LineString>} */\n      var lineStrings = pushParseAndPop([], this.MULTILINESTRING_PARSERS, node, objectStack, this);\n      if (lineStrings) {\n        return new MultiLineString(lineStrings);\n      }\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {MultiPolygon|undefined} MultiPolygon.\n     */\n  }, {\n    key: \"readMultiPolygon\",\n    value: function readMultiPolygon(node, objectStack) {\n      /** @type {Array<Polygon>} */\n      var polygons = pushParseAndPop([], this.MULTIPOLYGON_PARSERS, node, objectStack, this);\n      if (polygons) {\n        return new MultiPolygon(polygons);\n      }\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n  }, {\n    key: \"pointMemberParser\",\n    value: function pointMemberParser(node, objectStack) {\n      parseNode(this.POINTMEMBER_PARSERS, node, objectStack, this);\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n  }, {\n    key: \"lineStringMemberParser\",\n    value: function lineStringMemberParser(node, objectStack) {\n      parseNode(this.LINESTRINGMEMBER_PARSERS, node, objectStack, this);\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n  }, {\n    key: \"polygonMemberParser\",\n    value: function polygonMemberParser(node, objectStack) {\n      parseNode(this.POLYGONMEMBER_PARSERS, node, objectStack, this);\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {LineString|undefined} LineString.\n     */\n  }, {\n    key: \"readLineString\",\n    value: function readLineString(node, objectStack) {\n      var flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n      if (flatCoordinates) {\n        var lineString = new LineString(flatCoordinates, 'XYZ');\n        return lineString;\n      }\n      return undefined;\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {Array<number>|undefined} LinearRing flat coordinates.\n     */\n  }, {\n    key: \"readFlatLinearRing\",\n    value: function readFlatLinearRing(node, objectStack) {\n      var ring = pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);\n      if (ring) {\n        return ring;\n      }\n      return undefined;\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {LinearRing|undefined} LinearRing.\n     */\n  }, {\n    key: \"readLinearRing\",\n    value: function readLinearRing(node, objectStack) {\n      var flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n      if (flatCoordinates) {\n        return new LinearRing(flatCoordinates, 'XYZ');\n      }\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {Polygon|undefined} Polygon.\n     */\n  }, {\n    key: \"readPolygon\",\n    value: function readPolygon(node, objectStack) {\n      /** @type {Array<Array<number>>} */\n      var flatLinearRings = pushParseAndPop([null], this.FLAT_LINEAR_RINGS_PARSERS, node, objectStack, this);\n      if (flatLinearRings && flatLinearRings[0]) {\n        var flatCoordinates = flatLinearRings[0];\n        var ends = [flatCoordinates.length];\n        var i, ii;\n        for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n          extend(flatCoordinates, flatLinearRings[i]);\n          ends.push(flatCoordinates.length);\n        }\n        return new Polygon(flatCoordinates, 'XYZ', ends);\n      }\n      return undefined;\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {Array<number>} Flat coordinates.\n     */\n  }, {\n    key: \"readFlatCoordinatesFromNode\",\n    value: function readFlatCoordinatesFromNode(node, objectStack) {\n      return pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n     * @protected\n     * @return {import(\"../geom/Geometry.js\").default} Geometry.\n     */\n  }, {\n    key: \"readGeometryFromNode\",\n    value: function readGeometryFromNode(node, options) {\n      var geometry = this.readGeometryElement(node, [this.getReadOptions(node, options ? options : {})]);\n      return geometry ? geometry : null;\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n     * @return {Array<import(\"../Feature.js\").default>} Features.\n     */\n  }, {\n    key: \"readFeaturesFromNode\",\n    value: function readFeaturesFromNode(node, options) {\n      var internalOptions = {\n        featureType: this.featureType,\n        featureNS: this.featureNS\n      };\n      if (internalOptions) {\n        Object.assign(internalOptions, this.getReadOptions(node, options));\n      }\n      var features = this.readFeaturesInternal(node, [internalOptions]);\n      return features || [];\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @return {import(\"../proj/Projection.js\").default} Projection.\n     */\n  }, {\n    key: \"readProjectionFromNode\",\n    value: function readProjectionFromNode(node) {\n      return getProjection(this.srsName ? this.srsName : node.firstElementChild.getAttribute('srsName'));\n    }\n  }]);\n}(XMLFeature);\nGMLBase.prototype.namespace = GMLNS;\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml': {}\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml': {}\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml': {}\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.MULTIPOINT_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeArrayPusher(GMLBase.prototype.pointMemberParser),\n    'pointMembers': makeArrayPusher(GMLBase.prototype.pointMemberParser)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.MULTILINESTRING_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeArrayPusher(GMLBase.prototype.lineStringMemberParser),\n    'lineStringMembers': makeArrayPusher(GMLBase.prototype.lineStringMemberParser)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.MULTIPOLYGON_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'polygonMember': makeArrayPusher(GMLBase.prototype.polygonMemberParser),\n    'polygonMembers': makeArrayPusher(GMLBase.prototype.polygonMemberParser)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.POINTMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Point': makeArrayPusher(GMLBase.prototype.readFlatCoordinatesFromNode)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.LINESTRINGMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LineString': makeArrayPusher(GMLBase.prototype.readLineString)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.POLYGONMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.RING_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LinearRing': makeReplacer(GMLBase.prototype.readFlatLinearRing)\n  }\n};\nexport default GMLBase;","map":{"version":3,"names":["Feature","Geometry","LineString","LinearRing","MultiLineString","MultiPoint","MultiPolygon","Point","Polygon","XMLFeature","extend","getAllTextContent","getAttributeNS","makeArrayPusher","makeReplacer","parseNode","pushParseAndPop","get","getProjection","transformExtentWithOptions","transformGeometryWithOptions","GMLNS","ONLY_WHITESPACE_RE","GMLBase","_XMLFeature","options","_this","_classCallCheck","_callSuper","featureType","featureNS","srsName","schemaLocation","FEATURE_COLLECTION_PARSERS","namespace","readFeaturesInternal","supportedMediaTypes","_inherits","_createClass","key","value","node","objectStack","localName","features","context","prefix","defaultPrefix","childNodes","i","ii","length","child","nodeType","ft","nodeName","split","pop","includes","count","uri","namespaceURI","candidate","push","ns","parsersNS","featureTypes","Array","isArray","p","parsers","featurePrefix","readFeatureElement","undefined","readGeometryOrExtent","firstElementChild","getAttribute","GEOMETRY_PARSERS","readExtentElement","extent","readGeometryElement","geometry","readFeatureElementInternal","asFeature","geometryName","values","n","nextElementSibling","firstChild","test","len","attributes","_content_","attName","name","feature","setGeometryName","fid","setId","readPoint","flatCoordinates","readFlatCoordinatesFromNode","readMultiPoint","coordinates","MULTIPOINT_PARSERS","readMultiLineString","lineStrings","MULTILINESTRING_PARSERS","readMultiPolygon","polygons","MULTIPOLYGON_PARSERS","pointMemberParser","POINTMEMBER_PARSERS","lineStringMemberParser","LINESTRINGMEMBER_PARSERS","polygonMemberParser","POLYGONMEMBER_PARSERS","readLineString","lineString","readFlatLinearRing","ring","GEOMETRY_FLAT_COORDINATES_PARSERS","readLinearRing","readPolygon","flatLinearRings","FLAT_LINEAR_RINGS_PARSERS","ends","readGeometryFromNode","getReadOptions","readFeaturesFromNode","internalOptions","Object","assign","readProjectionFromNode","prototype","RING_PARSERS"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol/format/GMLBase.js"],"sourcesContent":["/**\n * @module ol/format/GMLBase\n */\n// FIXME Envelopes should not be treated as geometries! readEnvelope_ is part\n// of GEOMETRY_PARSERS_ and methods using GEOMETRY_PARSERS_ do not expect\n// envelopes/extents, only geometries!\nimport Feature from '../Feature.js';\nimport Geometry from '../geom/Geometry.js';\nimport LineString from '../geom/LineString.js';\nimport LinearRing from '../geom/LinearRing.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport XMLFeature from './XMLFeature.js';\nimport {extend} from '../array.js';\nimport {\n  getAllTextContent,\n  getAttributeNS,\n  makeArrayPusher,\n  makeReplacer,\n  parseNode,\n  pushParseAndPop,\n} from '../xml.js';\nimport {get as getProjection} from '../proj.js';\nimport {\n  transformExtentWithOptions,\n  transformGeometryWithOptions,\n} from './Feature.js';\n\n/**\n * @const\n * @type {string}\n */\nexport const GMLNS = 'http://www.opengis.net/gml';\n\n/**\n * A regular expression that matches if a string only contains whitespace\n * characters. It will e.g. match `''`, `' '`, `'\\n'` etc.\n *\n * @const\n * @type {RegExp}\n */\nconst ONLY_WHITESPACE_RE = /^\\s*$/;\n\n/**\n * @typedef {Object} Options\n * @property {Object<string, string>|string} [featureNS] Feature\n * namespace. If not defined will be derived from GML. If multiple\n * feature types have been configured which come from different feature\n * namespaces, this will be an object with the keys being the prefixes used\n * in the entries of featureType array. The values of the object will be the\n * feature namespaces themselves. So for instance there might be a featureType\n * item `topp:states` in the `featureType` array and then there will be a key\n * `topp` in the featureNS object with value `http://www.openplans.org/topp`.\n * @property {Array<string>|string} [featureType] Feature type(s) to parse.\n * If multiple feature types need to be configured\n * which come from different feature namespaces, `featureNS` will be an object\n * with the keys being the prefixes used in the entries of featureType array.\n * The values of the object will be the feature namespaces themselves.\n * So for instance there might be a featureType item `topp:states` and then\n * there will be a key named `topp` in the featureNS object with value\n * `http://www.openplans.org/topp`.\n * @property {string} [srsName] srsName to use when writing geometries.\n * @property {boolean} [surface=false] Write gml:Surface instead of gml:Polygon\n * elements. This also affects the elements in multi-part geometries.\n * @property {boolean} [curve=false] Write gml:Curve instead of gml:LineString\n * elements. This also affects the elements in multi-part geometries.\n * @property {boolean} [multiCurve=true] Write gml:MultiCurve instead of gml:MultiLineString.\n * Since the latter is deprecated in GML 3.\n * @property {boolean} [multiSurface=true] Write gml:multiSurface instead of\n * gml:MultiPolygon. Since the latter is deprecated in GML 3.\n * @property {string} [schemaLocation] Optional schemaLocation to use when\n * writing out the GML, this will override the default provided.\n * @property {boolean} [hasZ=false] If coordinates have a Z value.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Feature base format for reading and writing data in the GML format.\n * This class cannot be instantiated, it contains only base content that\n * is shared with versioned format classes GML2 and GML3.\n *\n * @abstract\n * @api\n */\nclass GMLBase extends XMLFeature {\n  /**\n   * @param {Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @protected\n     * @type {Array<string>|string|undefined}\n     */\n    this.featureType = options.featureType;\n\n    /**\n     * @protected\n     * @type {Object<string, string>|string|undefined}\n     */\n    this.featureNS = options.featureNS;\n\n    /**\n     * @protected\n     * @type {string|undefined}\n     */\n    this.srsName = options.srsName;\n\n    /**\n     * @protected\n     * @type {string}\n     */\n    this.schemaLocation = '';\n\n    /**\n     * @type {Object<string, Object<string, Object>>}\n     */\n    this.FEATURE_COLLECTION_PARSERS = {};\n    this.FEATURE_COLLECTION_PARSERS[this.namespace] = {\n      'featureMember': makeArrayPusher(this.readFeaturesInternal),\n      'featureMembers': makeReplacer(this.readFeaturesInternal),\n    };\n\n    this.supportedMediaTypes = ['application/gml+xml'];\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<Feature> | undefined} Features.\n   */\n  readFeaturesInternal(node, objectStack) {\n    const localName = node.localName;\n    let features = null;\n    if (localName == 'FeatureCollection') {\n      features = pushParseAndPop(\n        [],\n        this.FEATURE_COLLECTION_PARSERS,\n        node,\n        objectStack,\n        this\n      );\n    } else if (\n      localName == 'featureMembers' ||\n      localName == 'featureMember' ||\n      localName == 'member'\n    ) {\n      const context = objectStack[0];\n      let featureType = context['featureType'];\n      let featureNS = context['featureNS'];\n      const prefix = 'p';\n      const defaultPrefix = 'p0';\n      if (!featureType && node.childNodes) {\n        (featureType = []), (featureNS = {});\n        for (let i = 0, ii = node.childNodes.length; i < ii; ++i) {\n          const child = /** @type {Element} */ (node.childNodes[i]);\n          if (child.nodeType === 1) {\n            const ft = child.nodeName.split(':').pop();\n            if (!featureType.includes(ft)) {\n              let key = '';\n              let count = 0;\n              const uri = child.namespaceURI;\n              for (const candidate in featureNS) {\n                if (featureNS[candidate] === uri) {\n                  key = candidate;\n                  break;\n                }\n                ++count;\n              }\n              if (!key) {\n                key = prefix + count;\n                featureNS[key] = uri;\n              }\n              featureType.push(key + ':' + ft);\n            }\n          }\n        }\n        if (localName != 'featureMember') {\n          // recheck featureType for each featureMember\n          context['featureType'] = featureType;\n          context['featureNS'] = featureNS;\n        }\n      }\n      if (typeof featureNS === 'string') {\n        const ns = featureNS;\n        featureNS = {};\n        featureNS[defaultPrefix] = ns;\n      }\n      /** @type {Object<string, Object<string, import(\"../xml.js\").Parser>>} */\n      const parsersNS = {};\n      const featureTypes = Array.isArray(featureType)\n        ? featureType\n        : [featureType];\n      for (const p in featureNS) {\n        /** @type {Object<string, import(\"../xml.js\").Parser>} */\n        const parsers = {};\n        for (let i = 0, ii = featureTypes.length; i < ii; ++i) {\n          const featurePrefix = featureTypes[i].includes(':')\n            ? featureTypes[i].split(':')[0]\n            : defaultPrefix;\n          if (featurePrefix === p) {\n            parsers[featureTypes[i].split(':').pop()] =\n              localName == 'featureMembers'\n                ? makeArrayPusher(this.readFeatureElement, this)\n                : makeReplacer(this.readFeatureElement, this);\n          }\n        }\n        parsersNS[featureNS[p]] = parsers;\n      }\n      if (localName == 'featureMember' || localName == 'member') {\n        features = pushParseAndPop(undefined, parsersNS, node, objectStack);\n      } else {\n        features = pushParseAndPop([], parsersNS, node, objectStack);\n      }\n    }\n    if (features === null) {\n      features = [];\n    }\n    return features;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent|undefined} Geometry.\n   */\n  readGeometryOrExtent(node, objectStack) {\n    const context = /** @type {Object} */ (objectStack[0]);\n    context['srsName'] = node.firstElementChild.getAttribute('srsName');\n    context['srsDimension'] =\n      node.firstElementChild.getAttribute('srsDimension');\n    return pushParseAndPop(\n      null,\n      this.GEOMETRY_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../extent.js\").Extent|undefined} Geometry.\n   */\n  readExtentElement(node, objectStack) {\n    const context = /** @type {Object} */ (objectStack[0]);\n    const extent = /** @type {import(\"../extent.js\").Extent} */ (\n      this.readGeometryOrExtent(node, objectStack)\n    );\n    return extent ? transformExtentWithOptions(extent, context) : undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../geom/Geometry.js\").default|undefined} Geometry.\n   */\n  readGeometryElement(node, objectStack) {\n    const context = /** @type {Object} */ (objectStack[0]);\n    const geometry = /** @type {import(\"../geom/Geometry.js\").default} */ (\n      this.readGeometryOrExtent(node, objectStack)\n    );\n    return geometry\n      ? transformGeometryWithOptions(geometry, false, context)\n      : undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {boolean} asFeature whether result should be wrapped as a feature.\n   * @return {Feature|Object} Feature\n   */\n  readFeatureElementInternal(node, objectStack, asFeature) {\n    let geometryName;\n    const values = {};\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      let value;\n      const localName = n.localName;\n      // first, check if it is simple attribute\n      if (\n        n.childNodes.length === 0 ||\n        (n.childNodes.length === 1 &&\n          (n.firstChild.nodeType === 3 || n.firstChild.nodeType === 4))\n      ) {\n        value = getAllTextContent(n, false);\n        if (ONLY_WHITESPACE_RE.test(value)) {\n          value = undefined;\n        }\n      } else {\n        if (asFeature) {\n          //if feature, try it as a geometry or extent\n          value =\n            localName === 'boundedBy'\n              ? this.readExtentElement(n, objectStack)\n              : this.readGeometryElement(n, objectStack);\n        }\n        if (!value) {\n          //if not a geometry or not a feature, treat it as a complex attribute\n          value = this.readFeatureElementInternal(n, objectStack, false);\n        } else if (localName !== 'boundedBy') {\n          // boundedBy is an extent and must not be considered as a geometry\n          geometryName = localName;\n        }\n      }\n\n      const len = n.attributes.length;\n      if (len > 0 && !(value instanceof Geometry)) {\n        value = {_content_: value};\n        for (let i = 0; i < len; i++) {\n          const attName = n.attributes[i].name;\n          value[attName] = n.attributes[i].value;\n        }\n      }\n\n      if (values[localName]) {\n        if (!(values[localName] instanceof Array)) {\n          values[localName] = [values[localName]];\n        }\n        values[localName].push(value);\n      } else {\n        values[localName] = value;\n      }\n    }\n    if (!asFeature) {\n      return values;\n    }\n    const feature = new Feature(values);\n    if (geometryName) {\n      feature.setGeometryName(geometryName);\n    }\n    const fid =\n      node.getAttribute('fid') || getAttributeNS(node, this.namespace, 'id');\n    if (fid) {\n      feature.setId(fid);\n    }\n    return feature;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Feature} Feature.\n   */\n  readFeatureElement(node, objectStack) {\n    return this.readFeatureElementInternal(node, objectStack, true);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Point|undefined} Point.\n   */\n  readPoint(node, objectStack) {\n    const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n    if (flatCoordinates) {\n      return new Point(flatCoordinates, 'XYZ');\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiPoint|undefined} MultiPoint.\n   */\n  readMultiPoint(node, objectStack) {\n    /** @type {Array<Array<number>>} */\n    const coordinates = pushParseAndPop(\n      [],\n      this.MULTIPOINT_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (coordinates) {\n      return new MultiPoint(coordinates);\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiLineString|undefined} MultiLineString.\n   */\n  readMultiLineString(node, objectStack) {\n    /** @type {Array<LineString>} */\n    const lineStrings = pushParseAndPop(\n      [],\n      this.MULTILINESTRING_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (lineStrings) {\n      return new MultiLineString(lineStrings);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiPolygon|undefined} MultiPolygon.\n   */\n  readMultiPolygon(node, objectStack) {\n    /** @type {Array<Polygon>} */\n    const polygons = pushParseAndPop(\n      [],\n      this.MULTIPOLYGON_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (polygons) {\n      return new MultiPolygon(polygons);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  pointMemberParser(node, objectStack) {\n    parseNode(this.POINTMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  lineStringMemberParser(node, objectStack) {\n    parseNode(this.LINESTRINGMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  polygonMemberParser(node, objectStack) {\n    parseNode(this.POLYGONMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {LineString|undefined} LineString.\n   */\n  readLineString(node, objectStack) {\n    const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n    if (flatCoordinates) {\n      const lineString = new LineString(flatCoordinates, 'XYZ');\n      return lineString;\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} LinearRing flat coordinates.\n   */\n  readFlatLinearRing(node, objectStack) {\n    const ring = pushParseAndPop(\n      null,\n      this.GEOMETRY_FLAT_COORDINATES_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (ring) {\n      return ring;\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {LinearRing|undefined} LinearRing.\n   */\n  readLinearRing(node, objectStack) {\n    const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n    if (flatCoordinates) {\n      return new LinearRing(flatCoordinates, 'XYZ');\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Polygon|undefined} Polygon.\n   */\n  readPolygon(node, objectStack) {\n    /** @type {Array<Array<number>>} */\n    const flatLinearRings = pushParseAndPop(\n      [null],\n      this.FLAT_LINEAR_RINGS_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (flatLinearRings && flatLinearRings[0]) {\n      const flatCoordinates = flatLinearRings[0];\n      const ends = [flatCoordinates.length];\n      let i, ii;\n      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n        extend(flatCoordinates, flatLinearRings[i]);\n        ends.push(flatCoordinates.length);\n      }\n      return new Polygon(flatCoordinates, 'XYZ', ends);\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>} Flat coordinates.\n   */\n  readFlatCoordinatesFromNode(node, objectStack) {\n    return pushParseAndPop(\n      null,\n      this.GEOMETRY_FLAT_COORDINATES_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromNode(node, options) {\n    const geometry = this.readGeometryElement(node, [\n      this.getReadOptions(node, options ? options : {}),\n    ]);\n    return geometry ? geometry : null;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromNode(node, options) {\n    const internalOptions = {\n      featureType: this.featureType,\n      featureNS: this.featureNS,\n    };\n    if (internalOptions) {\n      Object.assign(internalOptions, this.getReadOptions(node, options));\n    }\n    const features = this.readFeaturesInternal(node, [internalOptions]);\n    return features || [];\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromNode(node) {\n    return getProjection(\n      this.srsName\n        ? this.srsName\n        : node.firstElementChild.getAttribute('srsName')\n    );\n  }\n}\n\nGMLBase.prototype.namespace = GMLNS;\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml': {},\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml': {},\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml': {},\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.MULTIPOINT_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeArrayPusher(GMLBase.prototype.pointMemberParser),\n    'pointMembers': makeArrayPusher(GMLBase.prototype.pointMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.MULTILINESTRING_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeArrayPusher(\n      GMLBase.prototype.lineStringMemberParser\n    ),\n    'lineStringMembers': makeArrayPusher(\n      GMLBase.prototype.lineStringMemberParser\n    ),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.MULTIPOLYGON_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'polygonMember': makeArrayPusher(GMLBase.prototype.polygonMemberParser),\n    'polygonMembers': makeArrayPusher(GMLBase.prototype.polygonMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.POINTMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Point': makeArrayPusher(GMLBase.prototype.readFlatCoordinatesFromNode),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.LINESTRINGMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LineString': makeArrayPusher(GMLBase.prototype.readLineString),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.POLYGONMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.RING_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LinearRing': makeReplacer(GMLBase.prototype.readFlatLinearRing),\n  },\n};\n\nexport default GMLBase;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}