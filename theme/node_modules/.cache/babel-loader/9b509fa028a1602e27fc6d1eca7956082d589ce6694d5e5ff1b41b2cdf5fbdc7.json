{"ast":null,"code":"import _objectSpread from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.flat.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.unscopables.flat.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\n/**\n * @module ol/format/Feature\n */\nimport Feature from '../Feature.js';\nimport RenderFeature from '../render/Feature.js';\nimport { GeometryCollection, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon } from '../geom.js';\nimport { abstract as _abstract } from '../util.js';\nimport { equivalent as equivalentProjection, get as getProjection, getTransform, transformExtent } from '../proj.js';\nimport { linearRingsAreOriented, linearRingssAreOriented, orientLinearRings, orientLinearRingsArray } from '../geom/flat/orient.js';\n\n/**\n * @typedef {Object} ReadOptions\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection] Projection of the data we are reading.\n * If not provided, the projection will be derived from the data (where possible) or\n * the `dataProjection` of the format is assigned (where set). If the projection\n * can not be derived from the data and if no `dataProjection` is set for a format,\n * the features will not be reprojected.\n * @property {import(\"../extent.js\").Extent} [extent] Tile extent in map units of the tile being read.\n * This is only required when reading data with tile pixels as geometry units. When configured,\n * a `dataProjection` with `TILE_PIXELS` as `units` and the tile's pixel extent as `extent` needs to be\n * provided.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection of the feature geometries\n * created by the format reader. If not provided, features will be returned in the\n * `dataProjection`.\n */\n\n/**\n * @typedef {Object} WriteOptions\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection] Projection of the data we are writing.\n * If not provided, the `dataProjection` of the format is assigned (where set).\n * If no `dataProjection` is set for a format, the features will be returned\n * in the `featureProjection`.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection of the feature geometries\n * that will be serialized by the format writer. If not provided, geometries are assumed\n * to be in the `dataProjection` if that is set; in other words, they are not transformed.\n * @property {boolean} [rightHanded] When writing geometries, follow the right-hand\n * rule for linear ring orientation.  This means that polygons will have counter-clockwise\n * exterior rings and clockwise interior rings.  By default, coordinates are serialized\n * as they are provided at construction.  If `true`, the right-hand rule will\n * be applied.  If `false`, the left-hand rule will be applied (clockwise for\n * exterior and counter-clockwise for interior rings).  Note that not all\n * formats support this.  The GeoJSON format does use this property when writing\n * geometries.\n * @property {number} [decimals] Maximum number of decimal places for coordinates.\n * Coordinates are stored internally as floats, but floating-point arithmetic can create\n * coordinates with a large number of decimal places, not generally wanted on output.\n * Set a number here to round coordinates. Can also be used to ensure that\n * coordinates read in can be written back out with the same number of decimals.\n * Default is no rounding.\n */\n\n/**\n * @typedef {'arraybuffer' | 'json' | 'text' | 'xml'} Type\n */\n\n/**\n * @typedef {Object} SimpleGeometryObject\n * @property {import('../geom/Geometry.js').Type} type Type.\n * @property {Array<number>} flatCoordinates Flat coordinates.\n * @property {Array<number>|Array<Array<number>>} [ends] Ends or endss.\n * @property {import('../geom/Geometry.js').GeometryLayout} [layout] Layout.\n */\n\n/**\n * @typedef {Array<GeometryObject>} GeometryCollectionObject\n */\n\n/**\n * @typedef {SimpleGeometryObject|GeometryCollectionObject} GeometryObject\n */\n\n/**\n * @typedef {Object} FeatureObject\n * @property {string|number} [id] Id.\n * @property {GeometryObject} [geometry] Geometry.\n * @property {Object<string, *>} [properties] Properties.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for feature formats.\n * {@link module:ol/format/Feature~FeatureFormat} subclasses provide the ability to decode and encode\n * {@link module:ol/Feature~Feature} objects from a variety of commonly used geospatial\n * file formats.  See the documentation for each format for more details.\n *\n * @abstract\n * @api\n */\nvar FeatureFormat = /*#__PURE__*/function () {\n  function FeatureFormat() {\n    _classCallCheck(this, FeatureFormat);\n    /**\n     * @protected\n     * @type {import(\"../proj/Projection.js\").default|undefined}\n     */\n    this.dataProjection = undefined;\n\n    /**\n     * @protected\n     * @type {import(\"../proj/Projection.js\").default|undefined}\n     */\n    this.defaultFeatureProjection = undefined;\n\n    /**\n     * @protected\n     * @type {import(\"../Feature.js\").FeatureClass}\n     */\n    this.featureClass = Feature;\n\n    /**\n     * A list media types supported by the format in descending order of preference.\n     * @type {Array<string>}\n     */\n    this.supportedMediaTypes = null;\n  }\n\n  /**\n   * Adds the data projection to the read options.\n   * @param {Document|Element|Object|string} source Source.\n   * @param {ReadOptions} [options] Options.\n   * @return {ReadOptions|undefined} Options.\n   * @protected\n   */\n  return _createClass(FeatureFormat, [{\n    key: \"getReadOptions\",\n    value: function getReadOptions(source, options) {\n      if (options) {\n        var dataProjection = options.dataProjection ? getProjection(options.dataProjection) : this.readProjection(source);\n        if (options.extent && dataProjection && dataProjection.getUnits() === 'tile-pixels') {\n          dataProjection = getProjection(dataProjection);\n          dataProjection.setWorldExtent(options.extent);\n        }\n        options = {\n          dataProjection: dataProjection,\n          featureProjection: options.featureProjection\n        };\n      }\n      return this.adaptOptions(options);\n    }\n\n    /**\n     * Sets the `dataProjection` on the options, if no `dataProjection`\n     * is set.\n     * @param {WriteOptions|ReadOptions|undefined} options\n     *     Options.\n     * @protected\n     * @return {WriteOptions|ReadOptions|undefined}\n     *     Updated options.\n     */\n  }, {\n    key: \"adaptOptions\",\n    value: function adaptOptions(options) {\n      return Object.assign({\n        dataProjection: this.dataProjection,\n        featureProjection: this.defaultFeatureProjection,\n        featureClass: this.featureClass\n      }, options);\n    }\n\n    /**\n     * @abstract\n     * @return {Type} The format type.\n     */\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return _abstract();\n    }\n\n    /**\n     * Read a single feature from a source.\n     *\n     * @abstract\n     * @param {Document|Element|Object|string} source Source.\n     * @param {ReadOptions} [options] Read options.\n     * @return {import(\"../Feature.js\").FeatureLike|Array<import(\"../render/Feature.js\").default>} Feature.\n     */\n  }, {\n    key: \"readFeature\",\n    value: function readFeature(source, options) {\n      return _abstract();\n    }\n\n    /**\n     * Read all features from a source.\n     *\n     * @abstract\n     * @param {Document|Element|ArrayBuffer|Object|string} source Source.\n     * @param {ReadOptions} [options] Read options.\n     * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n     */\n  }, {\n    key: \"readFeatures\",\n    value: function readFeatures(source, options) {\n      return _abstract();\n    }\n\n    /**\n     * Read a single geometry from a source.\n     *\n     * @abstract\n     * @param {Document|Element|Object|string} source Source.\n     * @param {ReadOptions} [options] Read options.\n     * @return {import(\"../geom/Geometry.js\").default} Geometry.\n     */\n  }, {\n    key: \"readGeometry\",\n    value: function readGeometry(source, options) {\n      return _abstract();\n    }\n\n    /**\n     * Read the projection from a source.\n     *\n     * @abstract\n     * @param {Document|Element|Object|string} source Source.\n     * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\n     */\n  }, {\n    key: \"readProjection\",\n    value: function readProjection(source) {\n      return _abstract();\n    }\n\n    /**\n     * Encode a feature in this format.\n     *\n     * @abstract\n     * @param {import(\"../Feature.js\").default} feature Feature.\n     * @param {WriteOptions} [options] Write options.\n     * @return {string|ArrayBuffer} Result.\n     */\n  }, {\n    key: \"writeFeature\",\n    value: function writeFeature(feature, options) {\n      return _abstract();\n    }\n\n    /**\n     * Encode an array of features in this format.\n     *\n     * @abstract\n     * @param {Array<import(\"../Feature.js\").default>} features Features.\n     * @param {WriteOptions} [options] Write options.\n     * @return {string|ArrayBuffer} Result.\n     */\n  }, {\n    key: \"writeFeatures\",\n    value: function writeFeatures(features, options) {\n      return _abstract();\n    }\n\n    /**\n     * Write a single geometry in this format.\n     *\n     * @abstract\n     * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n     * @param {WriteOptions} [options] Write options.\n     * @return {string|ArrayBuffer} Result.\n     */\n  }, {\n    key: \"writeGeometry\",\n    value: function writeGeometry(geometry, options) {\n      return _abstract();\n    }\n  }]);\n}();\nexport default FeatureFormat;\n\n/**\n * @template {import(\"../geom/Geometry.js\").default|RenderFeature} T\n * @param {T} geometry Geometry.\n * @param {boolean} write Set to true for writing, false for reading.\n * @param {WriteOptions|ReadOptions} [options] Options.\n * @return {T} Transformed geometry.\n */\nexport function transformGeometryWithOptions(geometry, write, options) {\n  var featureProjection = options ? getProjection(options.featureProjection) : null;\n  var dataProjection = options ? getProjection(options.dataProjection) : null;\n  var transformed = geometry;\n  if (featureProjection && dataProjection && !equivalentProjection(featureProjection, dataProjection)) {\n    if (write) {\n      transformed = /** @type {T} */geometry.clone();\n    }\n    var fromProjection = write ? featureProjection : dataProjection;\n    var toProjection = write ? dataProjection : featureProjection;\n    if (fromProjection.getUnits() === 'tile-pixels') {\n      transformed.transform(fromProjection, toProjection);\n    } else {\n      transformed.applyTransform(getTransform(fromProjection, toProjection));\n    }\n  }\n  if (write && options && /** @type {WriteOptions} */options.decimals !== undefined) {\n    var power = Math.pow(10, /** @type {WriteOptions} */options.decimals);\n    // if decimals option on write, round each coordinate appropriately\n    /**\n     * @param {Array<number>} coordinates Coordinates.\n     * @return {Array<number>} Transformed coordinates.\n     */\n    var transform = function transform(coordinates) {\n      for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = Math.round(coordinates[i] * power) / power;\n      }\n      return coordinates;\n    };\n    if (transformed === geometry) {\n      transformed = /** @type {T} */geometry.clone();\n    }\n    transformed.applyTransform(transform);\n  }\n  return transformed;\n}\n\n/**\n * @param {import(\"../extent.js\").Extent} extent Extent.\n * @param {ReadOptions} [options] Read options.\n * @return {import(\"../extent.js\").Extent} Transformed extent.\n */\nexport function transformExtentWithOptions(extent, options) {\n  var featureProjection = options ? getProjection(options.featureProjection) : null;\n  var dataProjection = options ? getProjection(options.dataProjection) : null;\n  if (featureProjection && dataProjection && !equivalentProjection(featureProjection, dataProjection)) {\n    return transformExtent(extent, dataProjection, featureProjection);\n  }\n  return extent;\n}\nvar GeometryConstructor = {\n  Point: Point,\n  LineString: LineString,\n  Polygon: Polygon,\n  MultiPoint: MultiPoint,\n  MultiLineString: MultiLineString,\n  MultiPolygon: MultiPolygon\n};\nfunction orientFlatCoordinates(flatCoordinates, ends, stride) {\n  if (Array.isArray(ends[0])) {\n    // MultiPolagon\n    if (!linearRingssAreOriented(flatCoordinates, 0, ends, stride)) {\n      flatCoordinates = flatCoordinates.slice();\n      orientLinearRingsArray(flatCoordinates, 0, ends, stride);\n    }\n    return flatCoordinates;\n  }\n  if (!linearRingsAreOriented(flatCoordinates, 0, ends, stride)) {\n    flatCoordinates = flatCoordinates.slice();\n    orientLinearRings(flatCoordinates, 0, ends, stride);\n  }\n  return flatCoordinates;\n}\n\n/**\n * @param {FeatureObject} object Feature object.\n * @param {WriteOptions|ReadOptions} [options] Options.\n * @return {RenderFeature|Array<RenderFeature>} Render feature.\n */\nexport function createRenderFeature(object, options) {\n  var _geometry$ends;\n  var geometry = object.geometry;\n  if (!geometry) {\n    return [];\n  }\n  if (Array.isArray(geometry)) {\n    return geometry.map(function (geometry) {\n      return createRenderFeature(_objectSpread(_objectSpread({}, object), {}, {\n        geometry: geometry\n      }));\n    }).flat();\n  }\n  var geometryType = geometry.type === 'MultiPolygon' ? 'Polygon' : geometry.type;\n  if (geometryType === 'GeometryCollection' || geometryType === 'Circle') {\n    throw new Error('Unsupported geometry type: ' + geometryType);\n  }\n  var stride = geometry.layout.length;\n  return transformGeometryWithOptions(new RenderFeature(geometryType, geometryType === 'Polygon' ? orientFlatCoordinates(geometry.flatCoordinates, geometry.ends, stride) : geometry.flatCoordinates, (_geometry$ends = geometry.ends) === null || _geometry$ends === void 0 ? void 0 : _geometry$ends.flat(), stride, object.properties || {}, object.id).enableSimplifyTransformed(), false, options);\n}\n\n/**\n * @param {GeometryObject|null} object Geometry object.\n * @param {WriteOptions|ReadOptions} [options] Options.\n * @return {import(\"../geom/Geometry.js\").default} Geometry.\n */\nexport function createGeometry(object, options) {\n  if (!object) {\n    return null;\n  }\n  if (Array.isArray(object)) {\n    var geometries = object.map(function (geometry) {\n      return createGeometry(geometry, options);\n    });\n    return new GeometryCollection(geometries);\n  }\n  var Geometry = GeometryConstructor[object.type];\n  return transformGeometryWithOptions(new Geometry(object.flatCoordinates, object.layout, object.ends), false, options);\n}","map":{"version":3,"names":["Feature","RenderFeature","GeometryCollection","LineString","MultiLineString","MultiPoint","MultiPolygon","Point","Polygon","abstract","equivalent","equivalentProjection","get","getProjection","getTransform","transformExtent","linearRingsAreOriented","linearRingssAreOriented","orientLinearRings","orientLinearRingsArray","FeatureFormat","_classCallCheck","dataProjection","undefined","defaultFeatureProjection","featureClass","supportedMediaTypes","_createClass","key","value","getReadOptions","source","options","readProjection","extent","getUnits","setWorldExtent","featureProjection","adaptOptions","Object","assign","getType","readFeature","readFeatures","readGeometry","writeFeature","feature","writeFeatures","features","writeGeometry","geometry","transformGeometryWithOptions","write","transformed","clone","fromProjection","toProjection","transform","applyTransform","decimals","power","Math","pow","coordinates","i","ii","length","round","transformExtentWithOptions","GeometryConstructor","orientFlatCoordinates","flatCoordinates","ends","stride","Array","isArray","slice","createRenderFeature","object","_geometry$ends","map","_objectSpread","flat","geometryType","type","Error","layout","properties","id","enableSimplifyTransformed","createGeometry","geometries","Geometry"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol/format/Feature.js"],"sourcesContent":["/**\n * @module ol/format/Feature\n */\nimport Feature from '../Feature.js';\nimport RenderFeature from '../render/Feature.js';\nimport {\n  GeometryCollection,\n  LineString,\n  MultiLineString,\n  MultiPoint,\n  MultiPolygon,\n  Point,\n  Polygon,\n} from '../geom.js';\nimport {abstract} from '../util.js';\nimport {\n  equivalent as equivalentProjection,\n  get as getProjection,\n  getTransform,\n  transformExtent,\n} from '../proj.js';\nimport {\n  linearRingsAreOriented,\n  linearRingssAreOriented,\n  orientLinearRings,\n  orientLinearRingsArray,\n} from '../geom/flat/orient.js';\n\n/**\n * @typedef {Object} ReadOptions\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection] Projection of the data we are reading.\n * If not provided, the projection will be derived from the data (where possible) or\n * the `dataProjection` of the format is assigned (where set). If the projection\n * can not be derived from the data and if no `dataProjection` is set for a format,\n * the features will not be reprojected.\n * @property {import(\"../extent.js\").Extent} [extent] Tile extent in map units of the tile being read.\n * This is only required when reading data with tile pixels as geometry units. When configured,\n * a `dataProjection` with `TILE_PIXELS` as `units` and the tile's pixel extent as `extent` needs to be\n * provided.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection of the feature geometries\n * created by the format reader. If not provided, features will be returned in the\n * `dataProjection`.\n */\n\n/**\n * @typedef {Object} WriteOptions\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection] Projection of the data we are writing.\n * If not provided, the `dataProjection` of the format is assigned (where set).\n * If no `dataProjection` is set for a format, the features will be returned\n * in the `featureProjection`.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection of the feature geometries\n * that will be serialized by the format writer. If not provided, geometries are assumed\n * to be in the `dataProjection` if that is set; in other words, they are not transformed.\n * @property {boolean} [rightHanded] When writing geometries, follow the right-hand\n * rule for linear ring orientation.  This means that polygons will have counter-clockwise\n * exterior rings and clockwise interior rings.  By default, coordinates are serialized\n * as they are provided at construction.  If `true`, the right-hand rule will\n * be applied.  If `false`, the left-hand rule will be applied (clockwise for\n * exterior and counter-clockwise for interior rings).  Note that not all\n * formats support this.  The GeoJSON format does use this property when writing\n * geometries.\n * @property {number} [decimals] Maximum number of decimal places for coordinates.\n * Coordinates are stored internally as floats, but floating-point arithmetic can create\n * coordinates with a large number of decimal places, not generally wanted on output.\n * Set a number here to round coordinates. Can also be used to ensure that\n * coordinates read in can be written back out with the same number of decimals.\n * Default is no rounding.\n */\n\n/**\n * @typedef {'arraybuffer' | 'json' | 'text' | 'xml'} Type\n */\n\n/**\n * @typedef {Object} SimpleGeometryObject\n * @property {import('../geom/Geometry.js').Type} type Type.\n * @property {Array<number>} flatCoordinates Flat coordinates.\n * @property {Array<number>|Array<Array<number>>} [ends] Ends or endss.\n * @property {import('../geom/Geometry.js').GeometryLayout} [layout] Layout.\n */\n\n/**\n * @typedef {Array<GeometryObject>} GeometryCollectionObject\n */\n\n/**\n * @typedef {SimpleGeometryObject|GeometryCollectionObject} GeometryObject\n */\n\n/**\n * @typedef {Object} FeatureObject\n * @property {string|number} [id] Id.\n * @property {GeometryObject} [geometry] Geometry.\n * @property {Object<string, *>} [properties] Properties.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for feature formats.\n * {@link module:ol/format/Feature~FeatureFormat} subclasses provide the ability to decode and encode\n * {@link module:ol/Feature~Feature} objects from a variety of commonly used geospatial\n * file formats.  See the documentation for each format for more details.\n *\n * @abstract\n * @api\n */\nclass FeatureFormat {\n  constructor() {\n    /**\n     * @protected\n     * @type {import(\"../proj/Projection.js\").default|undefined}\n     */\n    this.dataProjection = undefined;\n\n    /**\n     * @protected\n     * @type {import(\"../proj/Projection.js\").default|undefined}\n     */\n    this.defaultFeatureProjection = undefined;\n\n    /**\n     * @protected\n     * @type {import(\"../Feature.js\").FeatureClass}\n     */\n    this.featureClass = Feature;\n\n    /**\n     * A list media types supported by the format in descending order of preference.\n     * @type {Array<string>}\n     */\n    this.supportedMediaTypes = null;\n  }\n\n  /**\n   * Adds the data projection to the read options.\n   * @param {Document|Element|Object|string} source Source.\n   * @param {ReadOptions} [options] Options.\n   * @return {ReadOptions|undefined} Options.\n   * @protected\n   */\n  getReadOptions(source, options) {\n    if (options) {\n      let dataProjection = options.dataProjection\n        ? getProjection(options.dataProjection)\n        : this.readProjection(source);\n      if (\n        options.extent &&\n        dataProjection &&\n        dataProjection.getUnits() === 'tile-pixels'\n      ) {\n        dataProjection = getProjection(dataProjection);\n        dataProjection.setWorldExtent(options.extent);\n      }\n      options = {\n        dataProjection: dataProjection,\n        featureProjection: options.featureProjection,\n      };\n    }\n    return this.adaptOptions(options);\n  }\n\n  /**\n   * Sets the `dataProjection` on the options, if no `dataProjection`\n   * is set.\n   * @param {WriteOptions|ReadOptions|undefined} options\n   *     Options.\n   * @protected\n   * @return {WriteOptions|ReadOptions|undefined}\n   *     Updated options.\n   */\n  adaptOptions(options) {\n    return Object.assign(\n      {\n        dataProjection: this.dataProjection,\n        featureProjection: this.defaultFeatureProjection,\n        featureClass: this.featureClass,\n      },\n      options\n    );\n  }\n\n  /**\n   * @abstract\n   * @return {Type} The format type.\n   */\n  getType() {\n    return abstract();\n  }\n\n  /**\n   * Read a single feature from a source.\n   *\n   * @abstract\n   * @param {Document|Element|Object|string} source Source.\n   * @param {ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").FeatureLike|Array<import(\"../render/Feature.js\").default>} Feature.\n   */\n  readFeature(source, options) {\n    return abstract();\n  }\n\n  /**\n   * Read all features from a source.\n   *\n   * @abstract\n   * @param {Document|Element|ArrayBuffer|Object|string} source Source.\n   * @param {ReadOptions} [options] Read options.\n   * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n   */\n  readFeatures(source, options) {\n    return abstract();\n  }\n\n  /**\n   * Read a single geometry from a source.\n   *\n   * @abstract\n   * @param {Document|Element|Object|string} source Source.\n   * @param {ReadOptions} [options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometry(source, options) {\n    return abstract();\n  }\n\n  /**\n   * Read the projection from a source.\n   *\n   * @abstract\n   * @param {Document|Element|Object|string} source Source.\n   * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\n   */\n  readProjection(source) {\n    return abstract();\n  }\n\n  /**\n   * Encode a feature in this format.\n   *\n   * @abstract\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   */\n  writeFeature(feature, options) {\n    return abstract();\n  }\n\n  /**\n   * Encode an array of features in this format.\n   *\n   * @abstract\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   */\n  writeFeatures(features, options) {\n    return abstract();\n  }\n\n  /**\n   * Write a single geometry in this format.\n   *\n   * @abstract\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   */\n  writeGeometry(geometry, options) {\n    return abstract();\n  }\n}\n\nexport default FeatureFormat;\n\n/**\n * @template {import(\"../geom/Geometry.js\").default|RenderFeature} T\n * @param {T} geometry Geometry.\n * @param {boolean} write Set to true for writing, false for reading.\n * @param {WriteOptions|ReadOptions} [options] Options.\n * @return {T} Transformed geometry.\n */\nexport function transformGeometryWithOptions(geometry, write, options) {\n  const featureProjection = options\n    ? getProjection(options.featureProjection)\n    : null;\n  const dataProjection = options ? getProjection(options.dataProjection) : null;\n\n  let transformed = geometry;\n  if (\n    featureProjection &&\n    dataProjection &&\n    !equivalentProjection(featureProjection, dataProjection)\n  ) {\n    if (write) {\n      transformed = /** @type {T} */ (geometry.clone());\n    }\n    const fromProjection = write ? featureProjection : dataProjection;\n    const toProjection = write ? dataProjection : featureProjection;\n    if (fromProjection.getUnits() === 'tile-pixels') {\n      transformed.transform(fromProjection, toProjection);\n    } else {\n      transformed.applyTransform(getTransform(fromProjection, toProjection));\n    }\n  }\n  if (\n    write &&\n    options &&\n    /** @type {WriteOptions} */ (options).decimals !== undefined\n  ) {\n    const power = Math.pow(10, /** @type {WriteOptions} */ (options).decimals);\n    // if decimals option on write, round each coordinate appropriately\n    /**\n     * @param {Array<number>} coordinates Coordinates.\n     * @return {Array<number>} Transformed coordinates.\n     */\n    const transform = function (coordinates) {\n      for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = Math.round(coordinates[i] * power) / power;\n      }\n      return coordinates;\n    };\n    if (transformed === geometry) {\n      transformed = /** @type {T} */ (geometry.clone());\n    }\n    transformed.applyTransform(transform);\n  }\n  return transformed;\n}\n\n/**\n * @param {import(\"../extent.js\").Extent} extent Extent.\n * @param {ReadOptions} [options] Read options.\n * @return {import(\"../extent.js\").Extent} Transformed extent.\n */\nexport function transformExtentWithOptions(extent, options) {\n  const featureProjection = options\n    ? getProjection(options.featureProjection)\n    : null;\n  const dataProjection = options ? getProjection(options.dataProjection) : null;\n\n  if (\n    featureProjection &&\n    dataProjection &&\n    !equivalentProjection(featureProjection, dataProjection)\n  ) {\n    return transformExtent(extent, dataProjection, featureProjection);\n  }\n  return extent;\n}\n\nconst GeometryConstructor = {\n  Point: Point,\n  LineString: LineString,\n  Polygon: Polygon,\n  MultiPoint: MultiPoint,\n  MultiLineString: MultiLineString,\n  MultiPolygon: MultiPolygon,\n};\n\nfunction orientFlatCoordinates(flatCoordinates, ends, stride) {\n  if (Array.isArray(ends[0])) {\n    // MultiPolagon\n    if (!linearRingssAreOriented(flatCoordinates, 0, ends, stride)) {\n      flatCoordinates = flatCoordinates.slice();\n      orientLinearRingsArray(flatCoordinates, 0, ends, stride);\n    }\n    return flatCoordinates;\n  }\n  if (!linearRingsAreOriented(flatCoordinates, 0, ends, stride)) {\n    flatCoordinates = flatCoordinates.slice();\n    orientLinearRings(flatCoordinates, 0, ends, stride);\n  }\n  return flatCoordinates;\n}\n\n/**\n * @param {FeatureObject} object Feature object.\n * @param {WriteOptions|ReadOptions} [options] Options.\n * @return {RenderFeature|Array<RenderFeature>} Render feature.\n */\nexport function createRenderFeature(object, options) {\n  const geometry = object.geometry;\n  if (!geometry) {\n    return [];\n  }\n  if (Array.isArray(geometry)) {\n    return geometry\n      .map((geometry) => createRenderFeature({...object, geometry}))\n      .flat();\n  }\n\n  const geometryType =\n    geometry.type === 'MultiPolygon' ? 'Polygon' : geometry.type;\n  if (geometryType === 'GeometryCollection' || geometryType === 'Circle') {\n    throw new Error('Unsupported geometry type: ' + geometryType);\n  }\n\n  const stride = geometry.layout.length;\n  return transformGeometryWithOptions(\n    new RenderFeature(\n      geometryType,\n      geometryType === 'Polygon'\n        ? orientFlatCoordinates(geometry.flatCoordinates, geometry.ends, stride)\n        : geometry.flatCoordinates,\n      geometry.ends?.flat(),\n      stride,\n      object.properties || {},\n      object.id\n    ).enableSimplifyTransformed(),\n    false,\n    options\n  );\n}\n\n/**\n * @param {GeometryObject|null} object Geometry object.\n * @param {WriteOptions|ReadOptions} [options] Options.\n * @return {import(\"../geom/Geometry.js\").default} Geometry.\n */\nexport function createGeometry(object, options) {\n  if (!object) {\n    return null;\n  }\n  if (Array.isArray(object)) {\n    const geometries = object.map((geometry) =>\n      createGeometry(geometry, options)\n    );\n    return new GeometryCollection(geometries);\n  }\n  const Geometry = GeometryConstructor[object.type];\n  return transformGeometryWithOptions(\n    new Geometry(object.flatCoordinates, object.layout, object.ends),\n    false,\n    options\n  );\n}\n"],"mappings":";;;;;;;;;;;AAAA;AACA;AACA;AACA,OAAOA,OAAO,MAAM,eAAe;AACnC,OAAOC,aAAa,MAAM,sBAAsB;AAChD,SACEC,kBAAkB,EAClBC,UAAU,EACVC,eAAe,EACfC,UAAU,EACVC,YAAY,EACZC,KAAK,EACLC,OAAO,QACF,YAAY;AACnB,SAAQC,QAAQ,IAARA,SAAQ,QAAO,YAAY;AACnC,SACEC,UAAU,IAAIC,oBAAoB,EAClCC,GAAG,IAAIC,aAAa,EACpBC,YAAY,EACZC,eAAe,QACV,YAAY;AACnB,SACEC,sBAAsB,EACtBC,uBAAuB,EACvBC,iBAAiB,EACjBC,sBAAsB,QACjB,wBAAwB;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA,IAYMC,aAAa;EACjB,SAAAA,cAAA,EAAc;IAAAC,eAAA,OAAAD,aAAA;IACZ;AACJ;AACA;AACA;IACI,IAAI,CAACE,cAAc,GAAGC,SAAS;;IAE/B;AACJ;AACA;AACA;IACI,IAAI,CAACC,wBAAwB,GAAGD,SAAS;;IAEzC;AACJ;AACA;AACA;IACI,IAAI,CAACE,YAAY,GAAGzB,OAAO;;IAE3B;AACJ;AACA;AACA;IACI,IAAI,CAAC0B,mBAAmB,GAAG,IAAI;EACjC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EANE,OAAAC,YAAA,CAAAP,aAAA;IAAAQ,GAAA;IAAAC,KAAA,EAOA,SAAAC,cAAcA,CAACC,MAAM,EAAEC,OAAO,EAAE;MAC9B,IAAIA,OAAO,EAAE;QACX,IAAIV,cAAc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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}