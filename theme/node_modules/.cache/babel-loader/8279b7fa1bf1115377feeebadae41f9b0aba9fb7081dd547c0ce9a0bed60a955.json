{"ast":null,"code":"import _regeneratorRuntime from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _toConsumableArray from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array-buffer.constructor.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.data-view.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.object.entries.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/**\n * @module ol/render/webgl/VectorStyleRenderer\n */\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport { ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER } from '../../webgl.js';\nimport { AttributeType } from '../../webgl/Helper.js';\nimport { WebGLWorkerMessageType } from './constants.js';\nimport { colorEncodeId } from './utils.js';\nimport { create as createTransform, makeInverse as makeInverseTransform } from '../../transform.js';\nimport { create as createWebGLWorker } from '../../worker/webgl.js';\nimport { generateLineStringRenderInstructions, generatePointRenderInstructions, generatePolygonRenderInstructions, getCustomAttributesSize } from './renderinstructions.js';\nimport { parseLiteralStyle } from '../../webgl/styleparser.js';\nvar tmpColor = [];\nvar WEBGL_WORKER = createWebGLWorker();\nvar workerMessageCounter = 0;\n\n/**\n * Names of attributes made available to the vertex shader.\n * Please note: changing these *will* break custom shaders!\n * @enum {string}\n */\nexport var Attributes = {\n  POSITION: 'a_position',\n  INDEX: 'a_index',\n  SEGMENT_START: 'a_segmentStart',\n  SEGMENT_END: 'a_segmentEnd',\n  PARAMETERS: 'a_parameters',\n  JOIN_ANGLES: 'a_joinAngles',\n  DISTANCE: 'a_distance'\n};\n\n/**\n * @typedef {Object} AttributeDefinition A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {number} [size] Amount of numerical values composing the attribute, either 1, 2, 3 or 4; in case size is > 1, the return value\n * of the callback should be an array; if unspecified, assumed to be a single float value\n * @property {function(this:import(\"./MixedGeometryBatch.js\").GeometryBatchItem, import(\"../../Feature\").FeatureLike):number|Array<number>} callback This callback computes the numerical value of the\n * attribute for a given feature.\n */\n\n/**\n * @typedef {Object<string, AttributeDefinition>} AttributeDefinitions\n * @typedef {Object<string, import(\"../../webgl/Helper\").UniformValue>} UniformDefinitions\n */\n\n/**\n * @typedef {Object} WebGLBuffers\n * @property {Array<WebGLArrayBuffer>} polygonBuffers Array containing indices and vertices buffers for polygons\n * @property {Array<WebGLArrayBuffer>} lineStringBuffers Array containing indices and vertices buffers for line strings\n * @property {Array<WebGLArrayBuffer>} pointBuffers Array containing indices and vertices buffers for points\n * @property {import(\"../../transform.js\").Transform} invertVerticesTransform Inverse of the transform applied when generating buffers\n */\n\n/**\n * @typedef {Object} RenderInstructions\n * @property {Float32Array|null} polygonInstructions Polygon instructions; null if nothing to render\n * @property {Float32Array|null} lineStringInstructions LineString instructions; null if nothing to render\n * @property {Float32Array|null} pointInstructions Point instructions; null if nothing to render\n */\n\n/**\n * @typedef {Object} ShaderProgram An object containing both shaders (vertex and fragment)\n * @property {string} vertex Vertex shader source\n * @property {string} fragment Fragment shader source\n */\n\n/**\n * @typedef {Object} StyleShaders\n * @property {import(\"../../webgl/ShaderBuilder.js\").ShaderBuilder} builder Shader builder with the appropriate presets.\n * @property {AttributeDefinitions} [attributes] Custom attributes made available in the vertex shaders.\n * Default shaders rely on the attributes in {@link Attributes}.\n * @property {UniformDefinitions} [uniforms] Additional uniforms usable in shaders.\n */\n\n/**\n * @typedef {import('../../style/webgl.js').WebGLStyle|StyleShaders} VectorStyle\n */\n\n/**\n * @classdesc This class is responsible for:\n * 1. generate WebGL buffers according to a provided style, using a MixedGeometryBatch as input\n * 2. rendering geometries contained in said buffers\n *\n * A layer renderer will typically maintain several of these in order to have several styles rendered separately.\n *\n * A VectorStyleRenderer instance can be created either from a literal style or from shaders using either\n * `VectorStyleRenderer.fromStyle` or `VectorStyleRenderer.fromShaders`. The shaders should not be provided explicitly\n * but instead as a preconfigured ShaderBuilder instance.\n *\n * The `generateBuffers` method returns a promise resolving to WebGL buffers that are intended to be rendered by the\n * same renderer.\n */\nvar VectorStyleRenderer = /*#__PURE__*/function () {\n  /**\n   * @param {VectorStyle} styleOrShaders Literal style or custom shaders\n   * @param {import('../../webgl/Helper.js').default} helper Helper\n   * @param {boolean} enableHitDetection Whether to enable the hit detection (needs compatible shader)\n   */\n  function VectorStyleRenderer(styleOrShaders, helper, enableHitDetection) {\n    _classCallCheck(this, VectorStyleRenderer);\n    this.helper_ = helper;\n    this.hitDetectionEnabled_ = enableHitDetection;\n    var shaders = /** @type {StyleShaders} */styleOrShaders;\n    var isShaders = 'builder' in styleOrShaders;\n    if (!isShaders) {\n      var parseResult = parseLiteralStyle(/** @type {import('../../style/webgl.js').WebGLStyle} */\n      styleOrShaders);\n      shaders = {\n        builder: parseResult.builder,\n        attributes: parseResult.attributes,\n        uniforms: parseResult.uniforms\n      };\n    }\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasFill_ = !!shaders.builder.getFillVertexShader();\n    if (this.hasFill_) {\n      this.fillVertexShader_ = shaders.builder.getFillVertexShader();\n      this.fillFragmentShader_ = shaders.builder.getFillFragmentShader();\n      this.fillProgram_ = this.helper_.getProgram(this.fillFragmentShader_, this.fillVertexShader_);\n    }\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasStroke_ = !!shaders.builder.getStrokeVertexShader();\n    if (this.hasStroke_) {\n      this.strokeVertexShader_ = shaders.builder.getStrokeVertexShader();\n      this.strokeFragmentShader_ = shaders.builder.getStrokeFragmentShader();\n      this.strokeProgram_ = this.helper_.getProgram(this.strokeFragmentShader_, this.strokeVertexShader_);\n    }\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasSymbol_ = !!shaders.builder.getSymbolVertexShader();\n    if (this.hasSymbol_) {\n      this.symbolVertexShader_ = shaders.builder.getSymbolVertexShader();\n      this.symbolFragmentShader_ = shaders.builder.getSymbolFragmentShader();\n      this.symbolProgram_ = this.helper_.getProgram(this.symbolFragmentShader_, this.symbolVertexShader_);\n    }\n    var hitDetectionAttributes = this.hitDetectionEnabled_ ? {\n      hitColor: {\n        callback: function callback() {\n          return colorEncodeId(this.ref, tmpColor);\n        },\n        size: 4\n      }\n    } : {};\n    this.customAttributes_ = Object.assign({}, hitDetectionAttributes, shaders.attributes);\n    this.uniforms_ = shaders.uniforms;\n    var customAttributesDesc = Object.entries(this.customAttributes_).map(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        name = _ref2[0],\n        value = _ref2[1];\n      return {\n        name: \"a_prop_\".concat(name),\n        size: value.size || 1,\n        type: AttributeType.FLOAT\n      };\n    });\n    /**\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     * @private\n     */\n    this.polygonAttributesDesc_ = [{\n      name: Attributes.POSITION,\n      size: 2,\n      type: AttributeType.FLOAT\n    }].concat(_toConsumableArray(customAttributesDesc));\n    /**\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     * @private\n     */\n    this.lineStringAttributesDesc_ = [{\n      name: Attributes.SEGMENT_START,\n      size: 2,\n      type: AttributeType.FLOAT\n    }, {\n      name: Attributes.SEGMENT_END,\n      size: 2,\n      type: AttributeType.FLOAT\n    }, {\n      name: Attributes.JOIN_ANGLES,\n      size: 2,\n      type: AttributeType.FLOAT\n    }, {\n      name: Attributes.DISTANCE,\n      size: 1,\n      type: AttributeType.FLOAT\n    }, {\n      name: Attributes.PARAMETERS,\n      size: 1,\n      type: AttributeType.FLOAT\n    }].concat(_toConsumableArray(customAttributesDesc));\n    /**\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     * @private\n     */\n    this.pointAttributesDesc_ = [{\n      name: Attributes.POSITION,\n      size: 2,\n      type: AttributeType.FLOAT\n    }, {\n      name: Attributes.INDEX,\n      size: 1,\n      type: AttributeType.FLOAT\n    }].concat(_toConsumableArray(customAttributesDesc));\n    if (shaders.uniforms) {\n      this.helper_.addUniforms(shaders.uniforms);\n    }\n  }\n\n  /**\n   * @param {import('./MixedGeometryBatch.js').default} geometryBatch Geometry batch\n   * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n   * @return {Promise<WebGLBuffers>} A promise resolving to WebGL buffers\n   */\n  return _createClass(VectorStyleRenderer, [{\n    key: \"generateBuffers\",\n    value: (function () {\n      var _generateBuffers = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(geometryBatch, transform) {\n        var renderInstructions, _yield$Promise$all, _yield$Promise$all2, polygonBuffers, lineStringBuffers, pointBuffers, invertVerticesTransform;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              renderInstructions = this.generateRenderInstructions_(geometryBatch, transform);\n              _context.next = 3;\n              return Promise.all([this.generateBuffersForType_(renderInstructions.polygonInstructions, 'Polygon', transform), this.generateBuffersForType_(renderInstructions.lineStringInstructions, 'LineString', transform), this.generateBuffersForType_(renderInstructions.pointInstructions, 'Point', transform)]);\n            case 3:\n              _yield$Promise$all = _context.sent;\n              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 3);\n              polygonBuffers = _yield$Promise$all2[0];\n              lineStringBuffers = _yield$Promise$all2[1];\n              pointBuffers = _yield$Promise$all2[2];\n              // also return the inverse of the transform that was applied when generating buffers\n              invertVerticesTransform = makeInverseTransform(createTransform(), transform);\n              return _context.abrupt(\"return\", {\n                polygonBuffers: polygonBuffers,\n                lineStringBuffers: lineStringBuffers,\n                pointBuffers: pointBuffers,\n                invertVerticesTransform: invertVerticesTransform\n              });\n            case 10:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function generateBuffers(_x, _x2) {\n        return _generateBuffers.apply(this, arguments);\n      }\n      return generateBuffers;\n    }()\n    /**\n     * @param {import('./MixedGeometryBatch.js').default} geometryBatch Geometry batch\n     * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n     * @return {RenderInstructions} Render instructions\n     * @private\n     */\n    )\n  }, {\n    key: \"generateRenderInstructions_\",\n    value: function generateRenderInstructions_(geometryBatch, transform) {\n      var polygonInstructions = this.hasFill_ ? generatePolygonRenderInstructions(geometryBatch.polygonBatch, new Float32Array(0), this.customAttributes_, transform) : null;\n      var lineStringInstructions = this.hasStroke_ ? generateLineStringRenderInstructions(geometryBatch.lineStringBatch, new Float32Array(0), this.customAttributes_, transform) : null;\n      var pointInstructions = this.hasSymbol_ ? generatePointRenderInstructions(geometryBatch.pointBatch, new Float32Array(0), this.customAttributes_, transform) : null;\n      return {\n        polygonInstructions: polygonInstructions,\n        lineStringInstructions: lineStringInstructions,\n        pointInstructions: pointInstructions\n      };\n    }\n\n    /**\n     * @param {Float32Array|null} renderInstructions Render instructions\n     * @param {import(\"../../geom/Geometry.js\").Type} geometryType Geometry type\n     * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n     * @return {Promise<Array<WebGLArrayBuffer>>|null} Indices buffer and vertices buffer; null if nothing to render\n     * @private\n     */\n  }, {\n    key: \"generateBuffersForType_\",\n    value: function generateBuffersForType_(renderInstructions, geometryType, transform) {\n      var _this = this;\n      if (renderInstructions === null) {\n        return null;\n      }\n      var messageId = workerMessageCounter++;\n      var messageType;\n      switch (geometryType) {\n        case 'Polygon':\n          messageType = WebGLWorkerMessageType.GENERATE_POLYGON_BUFFERS;\n          break;\n        case 'LineString':\n          messageType = WebGLWorkerMessageType.GENERATE_LINE_STRING_BUFFERS;\n          break;\n        case 'Point':\n          messageType = WebGLWorkerMessageType.GENERATE_POINT_BUFFERS;\n          break;\n        default:\n        // pass\n      }\n\n      /** @type {import('./constants.js').WebGLWorkerGenerateBuffersMessage} */\n      var message = {\n        id: messageId,\n        type: messageType,\n        renderInstructions: renderInstructions.buffer,\n        renderInstructionsTransform: transform,\n        customAttributesSize: getCustomAttributesSize(this.customAttributes_)\n      };\n      WEBGL_WORKER.postMessage(message, [renderInstructions.buffer]);\n\n      // leave ownership of render instructions\n      renderInstructions = null;\n      return new Promise(function (resolve) {\n        /**\n         * @param {*} event Event.\n         */\n        var _handleMessage = function handleMessage(event) {\n          var received = event.data;\n\n          // this is not the response to our request: skip\n          if (received.id !== messageId) {\n            return;\n          }\n\n          // we've received our response: stop listening\n          WEBGL_WORKER.removeEventListener('message', _handleMessage);\n\n          // the helper has disposed in the meantime; the promise will not be resolved\n          if (!_this.helper_.getGL()) {\n            return;\n          }\n\n          // copy & flush received buffers to GPU\n          var verticesBuffer = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW).fromArrayBuffer(received.vertexBuffer);\n          var indicesBuffer = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, DYNAMIC_DRAW).fromArrayBuffer(received.indexBuffer);\n          _this.helper_.flushBufferData(verticesBuffer);\n          _this.helper_.flushBufferData(indicesBuffer);\n          resolve([indicesBuffer, verticesBuffer]);\n        };\n        WEBGL_WORKER.addEventListener('message', _handleMessage);\n      });\n    }\n\n    /**\n     * Render the geometries in the given buffers.\n     * @param {WebGLBuffers} buffers WebGL Buffers to draw\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state\n     * @param {function(): void} preRenderCallback This callback will be called right before drawing, and can be used to set uniforms\n     */\n  }, {\n    key: \"render\",\n    value: function render(buffers, frameState, preRenderCallback) {\n      this.hasFill_ && this.renderInternal_(buffers.polygonBuffers[0], buffers.polygonBuffers[1], this.fillProgram_, this.polygonAttributesDesc_, frameState, preRenderCallback);\n      this.hasStroke_ && this.renderInternal_(buffers.lineStringBuffers[0], buffers.lineStringBuffers[1], this.strokeProgram_, this.lineStringAttributesDesc_, frameState, preRenderCallback);\n      this.hasSymbol_ && this.renderInternal_(buffers.pointBuffers[0], buffers.pointBuffers[1], this.symbolProgram_, this.pointAttributesDesc_, frameState, preRenderCallback);\n    }\n\n    /**\n     * @param {WebGLArrayBuffer} indicesBuffer Indices buffer\n     * @param {WebGLArrayBuffer} verticesBuffer Vertices buffer\n     * @param {WebGLProgram} program Program\n     * @param {Array<import('../../webgl/Helper.js').AttributeDescription>} attributes Attribute descriptions\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     * @param {function(): void} preRenderCallback This callback will be called right before drawing, and can be used to set uniforms\n     * @private\n     */\n  }, {\n    key: \"renderInternal_\",\n    value: function renderInternal_(indicesBuffer, verticesBuffer, program, attributes, frameState, preRenderCallback) {\n      var renderCount = indicesBuffer.getSize();\n      if (renderCount === 0) {\n        return;\n      }\n      this.helper_.useProgram(program, frameState);\n      this.helper_.bindBuffer(verticesBuffer);\n      this.helper_.bindBuffer(indicesBuffer);\n      this.helper_.enableAttributes(attributes);\n      preRenderCallback();\n      this.helper_.drawElements(0, renderCount);\n    }\n  }]);\n}();\nexport default VectorStyleRenderer;","map":{"version":3,"names":["WebGLArrayBuffer","ARRAY_BUFFER","DYNAMIC_DRAW","ELEMENT_ARRAY_BUFFER","AttributeType","WebGLWorkerMessageType","colorEncodeId","create","createTransform","makeInverse","makeInverseTransform","createWebGLWorker","generateLineStringRenderInstructions","generatePointRenderInstructions","generatePolygonRenderInstructions","getCustomAttributesSize","parseLiteralStyle","tmpColor","WEBGL_WORKER","workerMessageCounter","Attributes","POSITION","INDEX","SEGMENT_START","SEGMENT_END","PARAMETERS","JOIN_ANGLES","DISTANCE","VectorStyleRenderer","styleOrShaders","helper","enableHitDetection","_classCallCheck","helper_","hitDetectionEnabled_","shaders","isShaders","parseResult","builder","attributes","uniforms","hasFill_","getFillVertexShader","fillVertexShader_","fillFragmentShader_","getFillFragmentShader","fillProgram_","getProgram","hasStroke_","getStrokeVertexShader","strokeVertexShader_","strokeFragmentShader_","getStrokeFragmentShader","strokeProgram_","hasSymbol_","getSymbolVertexShader","symbolVertexShader_","symbolFragmentShader_","getSymbolFragmentShader","symbolProgram_","hitDetectionAttributes","hitColor","callback","ref","size","customAttributes_","Object","assign","uniforms_","customAttributesDesc","entries","map","_ref","_ref2","_slicedToArray","name","value","concat","type","FLOAT","polygonAttributesDesc_","_toConsumableArray","lineStringAttributesDesc_","pointAttributesDesc_","addUniforms","_createClass","key","_generateBuffers","_asyncToGenerator","_regeneratorRuntime","mark","_callee","geometryBatch","transform","renderInstructions","_yield$Promise$all","_yield$Promise$all2","polygonBuffers","lineStringBuffers","pointBuffers","invertVerticesTransform","wrap","_callee$","_context","prev","next","generateRenderInstructions_","Promise","all","generateBuffersForType_","polygonInstructions","lineStringInstructions","pointInstructions","sent","abrupt","stop","generateBuffers","_x","_x2","apply","arguments","polygonBatch","Float32Array","lineStringBatch","pointBatch","geometryType","_this","messageId","messageType","GENERATE_POLYGON_BUFFERS","GENERATE_LINE_STRING_BUFFERS","GENERATE_POINT_BUFFERS","message","id","buffer","renderInstructionsTransform","customAttributesSize","postMessage","resolve","handleMessage","event","received","data","removeEventListener","getGL","verticesBuffer","fromArrayBuffer","vertexBuffer","indicesBuffer","indexBuffer","flushBufferData","addEventListener","render","buffers","frameState","preRenderCallback","renderInternal_","program","renderCount","getSize","useProgram","bindBuffer","enableAttributes","drawElements"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol/render/webgl/VectorStyleRenderer.js"],"sourcesContent":["/**\n * @module ol/render/webgl/VectorStyleRenderer\n */\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport {ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER} from '../../webgl.js';\nimport {AttributeType} from '../../webgl/Helper.js';\nimport {WebGLWorkerMessageType} from './constants.js';\nimport {colorEncodeId} from './utils.js';\nimport {\n  create as createTransform,\n  makeInverse as makeInverseTransform,\n} from '../../transform.js';\nimport {create as createWebGLWorker} from '../../worker/webgl.js';\nimport {\n  generateLineStringRenderInstructions,\n  generatePointRenderInstructions,\n  generatePolygonRenderInstructions,\n  getCustomAttributesSize,\n} from './renderinstructions.js';\nimport {parseLiteralStyle} from '../../webgl/styleparser.js';\n\nconst tmpColor = [];\nconst WEBGL_WORKER = createWebGLWorker();\nlet workerMessageCounter = 0;\n\n/**\n * Names of attributes made available to the vertex shader.\n * Please note: changing these *will* break custom shaders!\n * @enum {string}\n */\nexport const Attributes = {\n  POSITION: 'a_position',\n  INDEX: 'a_index',\n  SEGMENT_START: 'a_segmentStart',\n  SEGMENT_END: 'a_segmentEnd',\n  PARAMETERS: 'a_parameters',\n  JOIN_ANGLES: 'a_joinAngles',\n  DISTANCE: 'a_distance',\n};\n\n/**\n * @typedef {Object} AttributeDefinition A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {number} [size] Amount of numerical values composing the attribute, either 1, 2, 3 or 4; in case size is > 1, the return value\n * of the callback should be an array; if unspecified, assumed to be a single float value\n * @property {function(this:import(\"./MixedGeometryBatch.js\").GeometryBatchItem, import(\"../../Feature\").FeatureLike):number|Array<number>} callback This callback computes the numerical value of the\n * attribute for a given feature.\n */\n\n/**\n * @typedef {Object<string, AttributeDefinition>} AttributeDefinitions\n * @typedef {Object<string, import(\"../../webgl/Helper\").UniformValue>} UniformDefinitions\n */\n\n/**\n * @typedef {Object} WebGLBuffers\n * @property {Array<WebGLArrayBuffer>} polygonBuffers Array containing indices and vertices buffers for polygons\n * @property {Array<WebGLArrayBuffer>} lineStringBuffers Array containing indices and vertices buffers for line strings\n * @property {Array<WebGLArrayBuffer>} pointBuffers Array containing indices and vertices buffers for points\n * @property {import(\"../../transform.js\").Transform} invertVerticesTransform Inverse of the transform applied when generating buffers\n */\n\n/**\n * @typedef {Object} RenderInstructions\n * @property {Float32Array|null} polygonInstructions Polygon instructions; null if nothing to render\n * @property {Float32Array|null} lineStringInstructions LineString instructions; null if nothing to render\n * @property {Float32Array|null} pointInstructions Point instructions; null if nothing to render\n */\n\n/**\n * @typedef {Object} ShaderProgram An object containing both shaders (vertex and fragment)\n * @property {string} vertex Vertex shader source\n * @property {string} fragment Fragment shader source\n */\n\n/**\n * @typedef {Object} StyleShaders\n * @property {import(\"../../webgl/ShaderBuilder.js\").ShaderBuilder} builder Shader builder with the appropriate presets.\n * @property {AttributeDefinitions} [attributes] Custom attributes made available in the vertex shaders.\n * Default shaders rely on the attributes in {@link Attributes}.\n * @property {UniformDefinitions} [uniforms] Additional uniforms usable in shaders.\n */\n\n/**\n * @typedef {import('../../style/webgl.js').WebGLStyle|StyleShaders} VectorStyle\n */\n\n/**\n * @classdesc This class is responsible for:\n * 1. generate WebGL buffers according to a provided style, using a MixedGeometryBatch as input\n * 2. rendering geometries contained in said buffers\n *\n * A layer renderer will typically maintain several of these in order to have several styles rendered separately.\n *\n * A VectorStyleRenderer instance can be created either from a literal style or from shaders using either\n * `VectorStyleRenderer.fromStyle` or `VectorStyleRenderer.fromShaders`. The shaders should not be provided explicitly\n * but instead as a preconfigured ShaderBuilder instance.\n *\n * The `generateBuffers` method returns a promise resolving to WebGL buffers that are intended to be rendered by the\n * same renderer.\n */\nclass VectorStyleRenderer {\n  /**\n   * @param {VectorStyle} styleOrShaders Literal style or custom shaders\n   * @param {import('../../webgl/Helper.js').default} helper Helper\n   * @param {boolean} enableHitDetection Whether to enable the hit detection (needs compatible shader)\n   */\n  constructor(styleOrShaders, helper, enableHitDetection) {\n    this.helper_ = helper;\n\n    this.hitDetectionEnabled_ = enableHitDetection;\n    let shaders = /** @type {StyleShaders} */ (styleOrShaders);\n    const isShaders = 'builder' in styleOrShaders;\n    if (!isShaders) {\n      const parseResult = parseLiteralStyle(\n        /** @type {import('../../style/webgl.js').WebGLStyle} */ (\n          styleOrShaders\n        )\n      );\n      shaders = {\n        builder: parseResult.builder,\n        attributes: parseResult.attributes,\n        uniforms: parseResult.uniforms,\n      };\n    }\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasFill_ = !!shaders.builder.getFillVertexShader();\n    if (this.hasFill_) {\n      this.fillVertexShader_ = shaders.builder.getFillVertexShader();\n      this.fillFragmentShader_ = shaders.builder.getFillFragmentShader();\n      this.fillProgram_ = this.helper_.getProgram(\n        this.fillFragmentShader_,\n        this.fillVertexShader_\n      );\n    }\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasStroke_ = !!shaders.builder.getStrokeVertexShader();\n    if (this.hasStroke_) {\n      this.strokeVertexShader_ = shaders.builder.getStrokeVertexShader();\n      this.strokeFragmentShader_ = shaders.builder.getStrokeFragmentShader();\n      this.strokeProgram_ = this.helper_.getProgram(\n        this.strokeFragmentShader_,\n        this.strokeVertexShader_\n      );\n    }\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasSymbol_ = !!shaders.builder.getSymbolVertexShader();\n    if (this.hasSymbol_) {\n      this.symbolVertexShader_ = shaders.builder.getSymbolVertexShader();\n      this.symbolFragmentShader_ = shaders.builder.getSymbolFragmentShader();\n      this.symbolProgram_ = this.helper_.getProgram(\n        this.symbolFragmentShader_,\n        this.symbolVertexShader_\n      );\n    }\n\n    const hitDetectionAttributes = this.hitDetectionEnabled_\n      ? {\n          hitColor: {\n            callback() {\n              return colorEncodeId(this.ref, tmpColor);\n            },\n            size: 4,\n          },\n        }\n      : {};\n\n    this.customAttributes_ = Object.assign(\n      {},\n      hitDetectionAttributes,\n      shaders.attributes\n    );\n    this.uniforms_ = shaders.uniforms;\n\n    const customAttributesDesc = Object.entries(this.customAttributes_).map(\n      ([name, value]) => ({\n        name: `a_prop_${name}`,\n        size: value.size || 1,\n        type: AttributeType.FLOAT,\n      })\n    );\n    /**\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     * @private\n     */\n    this.polygonAttributesDesc_ = [\n      {\n        name: Attributes.POSITION,\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      ...customAttributesDesc,\n    ];\n    /**\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     * @private\n     */\n    this.lineStringAttributesDesc_ = [\n      {\n        name: Attributes.SEGMENT_START,\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: Attributes.SEGMENT_END,\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: Attributes.JOIN_ANGLES,\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: Attributes.DISTANCE,\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: Attributes.PARAMETERS,\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n      ...customAttributesDesc,\n    ];\n    /**\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     * @private\n     */\n    this.pointAttributesDesc_ = [\n      {\n        name: Attributes.POSITION,\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: Attributes.INDEX,\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n      ...customAttributesDesc,\n    ];\n\n    if (shaders.uniforms) {\n      this.helper_.addUniforms(shaders.uniforms);\n    }\n  }\n\n  /**\n   * @param {import('./MixedGeometryBatch.js').default} geometryBatch Geometry batch\n   * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n   * @return {Promise<WebGLBuffers>} A promise resolving to WebGL buffers\n   */\n  async generateBuffers(geometryBatch, transform) {\n    const renderInstructions = this.generateRenderInstructions_(\n      geometryBatch,\n      transform\n    );\n    const [polygonBuffers, lineStringBuffers, pointBuffers] = await Promise.all(\n      [\n        this.generateBuffersForType_(\n          renderInstructions.polygonInstructions,\n          'Polygon',\n          transform\n        ),\n        this.generateBuffersForType_(\n          renderInstructions.lineStringInstructions,\n          'LineString',\n          transform\n        ),\n        this.generateBuffersForType_(\n          renderInstructions.pointInstructions,\n          'Point',\n          transform\n        ),\n      ]\n    );\n    // also return the inverse of the transform that was applied when generating buffers\n    const invertVerticesTransform = makeInverseTransform(\n      createTransform(),\n      transform\n    );\n    return {\n      polygonBuffers: polygonBuffers,\n      lineStringBuffers: lineStringBuffers,\n      pointBuffers: pointBuffers,\n      invertVerticesTransform: invertVerticesTransform,\n    };\n  }\n\n  /**\n   * @param {import('./MixedGeometryBatch.js').default} geometryBatch Geometry batch\n   * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n   * @return {RenderInstructions} Render instructions\n   * @private\n   */\n  generateRenderInstructions_(geometryBatch, transform) {\n    const polygonInstructions = this.hasFill_\n      ? generatePolygonRenderInstructions(\n          geometryBatch.polygonBatch,\n          new Float32Array(0),\n          this.customAttributes_,\n          transform\n        )\n      : null;\n    const lineStringInstructions = this.hasStroke_\n      ? generateLineStringRenderInstructions(\n          geometryBatch.lineStringBatch,\n          new Float32Array(0),\n          this.customAttributes_,\n          transform\n        )\n      : null;\n    const pointInstructions = this.hasSymbol_\n      ? generatePointRenderInstructions(\n          geometryBatch.pointBatch,\n          new Float32Array(0),\n          this.customAttributes_,\n          transform\n        )\n      : null;\n\n    return {\n      polygonInstructions,\n      lineStringInstructions,\n      pointInstructions,\n    };\n  }\n\n  /**\n   * @param {Float32Array|null} renderInstructions Render instructions\n   * @param {import(\"../../geom/Geometry.js\").Type} geometryType Geometry type\n   * @param {import(\"../../transform.js\").Transform} transform Transform to apply to coordinates\n   * @return {Promise<Array<WebGLArrayBuffer>>|null} Indices buffer and vertices buffer; null if nothing to render\n   * @private\n   */\n  generateBuffersForType_(renderInstructions, geometryType, transform) {\n    if (renderInstructions === null) {\n      return null;\n    }\n\n    const messageId = workerMessageCounter++;\n    let messageType;\n    switch (geometryType) {\n      case 'Polygon':\n        messageType = WebGLWorkerMessageType.GENERATE_POLYGON_BUFFERS;\n        break;\n      case 'LineString':\n        messageType = WebGLWorkerMessageType.GENERATE_LINE_STRING_BUFFERS;\n        break;\n      case 'Point':\n        messageType = WebGLWorkerMessageType.GENERATE_POINT_BUFFERS;\n        break;\n      default:\n      // pass\n    }\n\n    /** @type {import('./constants.js').WebGLWorkerGenerateBuffersMessage} */\n    const message = {\n      id: messageId,\n      type: messageType,\n      renderInstructions: renderInstructions.buffer,\n      renderInstructionsTransform: transform,\n      customAttributesSize: getCustomAttributesSize(this.customAttributes_),\n    };\n    WEBGL_WORKER.postMessage(message, [renderInstructions.buffer]);\n\n    // leave ownership of render instructions\n    renderInstructions = null;\n\n    return new Promise((resolve) => {\n      /**\n       * @param {*} event Event.\n       */\n      const handleMessage = (event) => {\n        const received = event.data;\n\n        // this is not the response to our request: skip\n        if (received.id !== messageId) {\n          return;\n        }\n\n        // we've received our response: stop listening\n        WEBGL_WORKER.removeEventListener('message', handleMessage);\n\n        // the helper has disposed in the meantime; the promise will not be resolved\n        if (!this.helper_.getGL()) {\n          return;\n        }\n\n        // copy & flush received buffers to GPU\n        const verticesBuffer = new WebGLArrayBuffer(\n          ARRAY_BUFFER,\n          DYNAMIC_DRAW\n        ).fromArrayBuffer(received.vertexBuffer);\n        const indicesBuffer = new WebGLArrayBuffer(\n          ELEMENT_ARRAY_BUFFER,\n          DYNAMIC_DRAW\n        ).fromArrayBuffer(received.indexBuffer);\n        this.helper_.flushBufferData(verticesBuffer);\n        this.helper_.flushBufferData(indicesBuffer);\n\n        resolve([indicesBuffer, verticesBuffer]);\n      };\n\n      WEBGL_WORKER.addEventListener('message', handleMessage);\n    });\n  }\n\n  /**\n   * Render the geometries in the given buffers.\n   * @param {WebGLBuffers} buffers WebGL Buffers to draw\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state\n   * @param {function(): void} preRenderCallback This callback will be called right before drawing, and can be used to set uniforms\n   */\n  render(buffers, frameState, preRenderCallback) {\n    this.hasFill_ &&\n      this.renderInternal_(\n        buffers.polygonBuffers[0],\n        buffers.polygonBuffers[1],\n        this.fillProgram_,\n        this.polygonAttributesDesc_,\n        frameState,\n        preRenderCallback\n      );\n    this.hasStroke_ &&\n      this.renderInternal_(\n        buffers.lineStringBuffers[0],\n        buffers.lineStringBuffers[1],\n        this.strokeProgram_,\n        this.lineStringAttributesDesc_,\n        frameState,\n        preRenderCallback\n      );\n    this.hasSymbol_ &&\n      this.renderInternal_(\n        buffers.pointBuffers[0],\n        buffers.pointBuffers[1],\n        this.symbolProgram_,\n        this.pointAttributesDesc_,\n        frameState,\n        preRenderCallback\n      );\n  }\n\n  /**\n   * @param {WebGLArrayBuffer} indicesBuffer Indices buffer\n   * @param {WebGLArrayBuffer} verticesBuffer Vertices buffer\n   * @param {WebGLProgram} program Program\n   * @param {Array<import('../../webgl/Helper.js').AttributeDescription>} attributes Attribute descriptions\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {function(): void} preRenderCallback This callback will be called right before drawing, and can be used to set uniforms\n   * @private\n   */\n  renderInternal_(\n    indicesBuffer,\n    verticesBuffer,\n    program,\n    attributes,\n    frameState,\n    preRenderCallback\n  ) {\n    const renderCount = indicesBuffer.getSize();\n    if (renderCount === 0) {\n      return;\n    }\n    this.helper_.useProgram(program, frameState);\n    this.helper_.bindBuffer(verticesBuffer);\n    this.helper_.bindBuffer(indicesBuffer);\n    this.helper_.enableAttributes(attributes);\n    preRenderCallback();\n    this.helper_.drawElements(0, renderCount);\n  }\n}\n\nexport default VectorStyleRenderer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}