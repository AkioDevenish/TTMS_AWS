{"ast":null,"code":"import _classCallCheck from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _callSuper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.string.includes.js\";\n/**\n * @module ol/format/TopoJSON\n */\nimport Feature from '../Feature.js';\nimport JSONFeature from './JSONFeature.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport { get as getProjection } from '../proj.js';\nimport { transformGeometryWithOptions } from './Feature.js';\n\n/**\n * @typedef {import(\"topojson-specification\").Topology} TopoJSONTopology\n * @typedef {import(\"topojson-specification\").GeometryCollection} TopoJSONGeometryCollection\n * @typedef {import(\"topojson-specification\").GeometryObject} TopoJSONGeometry\n * @typedef {import(\"topojson-specification\").Point} TopoJSONPoint\n * @typedef {import(\"topojson-specification\").MultiPoint} TopoJSONMultiPoint\n * @typedef {import(\"topojson-specification\").LineString} TopoJSONLineString\n * @typedef {import(\"topojson-specification\").MultiLineString} TopoJSONMultiLineString\n * @typedef {import(\"topojson-specification\").Polygon} TopoJSONPolygon\n * @typedef {import(\"topojson-specification\").MultiPolygon} TopoJSONMultiPolygon\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.\n * @property {string} [layerName] Set the name of the TopoJSON topology\n * `objects`'s children as feature property with the specified name. This means\n * that when set to `'layer'`, a topology like\n * ```\n * {\n *   \"type\": \"Topology\",\n *   \"objects\": {\n *     \"example\": {\n *       \"type\": \"GeometryCollection\",\n *       \"geometries\": []\n *     }\n *   }\n * }\n * ```\n * will result in features that have a property `'layer'` set to `'example'`.\n * When not set, no property will be added to features.\n * @property {Array<string>} [layers] Names of the TopoJSON topology's\n * `objects`'s children to read features from.  If not provided, features will\n * be read from all children.\n */\n\n/**\n * @classdesc\n * Feature format for reading data in the TopoJSON format.\n *\n * @api\n */\nvar TopoJSON = /*#__PURE__*/function (_JSONFeature) {\n  /**\n   * @param {Options} [options] Options.\n   */\n  function TopoJSON(options) {\n    var _this;\n    _classCallCheck(this, TopoJSON);\n    _this = _callSuper(this, TopoJSON);\n    options = options ? options : {};\n\n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    _this.layerName_ = options.layerName;\n\n    /**\n     * @private\n     * @type {?Array<string>}\n     */\n    _this.layers_ = options.layers ? options.layers : null;\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    _this.dataProjection = getProjection(options.dataProjection ? options.dataProjection : 'EPSG:4326');\n    return _this;\n  }\n\n  /**\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<Feature>} Features.\n   */\n  _inherits(TopoJSON, _JSONFeature);\n  return _createClass(TopoJSON, [{\n    key: \"readFeaturesFromObject\",\n    value: function readFeaturesFromObject(object, options) {\n      if (object.type == 'Topology') {\n        var topoJSONTopology = /** @type {TopoJSONTopology} */object;\n        var transform,\n          scale = null,\n          translate = null;\n        if (topoJSONTopology['transform']) {\n          transform = topoJSONTopology['transform'];\n          scale = transform['scale'];\n          translate = transform['translate'];\n        }\n        var arcs = topoJSONTopology['arcs'];\n        if (transform) {\n          transformArcs(arcs, scale, translate);\n        }\n        /** @type {Array<Feature>} */\n        var features = [];\n        var topoJSONFeatures = topoJSONTopology['objects'];\n        var property = this.layerName_;\n        var feature;\n        for (var objectName in topoJSONFeatures) {\n          if (this.layers_ && !this.layers_.includes(objectName)) {\n            continue;\n          }\n          if (topoJSONFeatures[objectName].type === 'GeometryCollection') {\n            feature = /** @type {TopoJSONGeometryCollection} */\n            topoJSONFeatures[objectName];\n            features.push.apply(features, readFeaturesFromGeometryCollection(feature, arcs, scale, translate, property, objectName, options));\n          } else {\n            feature = /** @type {TopoJSONGeometry} */\n            topoJSONFeatures[objectName];\n            features.push(readFeatureFromGeometry(feature, arcs, scale, translate, property, objectName, options));\n          }\n        }\n        return features;\n      }\n      return [];\n    }\n\n    /**\n     * @param {Object} object Object.\n     * @protected\n     * @return {import(\"../proj/Projection.js\").default} Projection.\n     */\n  }, {\n    key: \"readProjectionFromObject\",\n    value: function readProjectionFromObject(object) {\n      return this.dataProjection;\n    }\n  }]);\n}(JSONFeature);\n/**\n * @const\n * @type {Object<string, function(TopoJSONGeometry, Array, ...Array=): import(\"../geom/Geometry.js\").default>}\n */\nvar GEOMETRY_READERS = {\n  'Point': readPointGeometry,\n  'LineString': readLineStringGeometry,\n  'Polygon': readPolygonGeometry,\n  'MultiPoint': readMultiPointGeometry,\n  'MultiLineString': readMultiLineStringGeometry,\n  'MultiPolygon': readMultiPolygonGeometry\n};\n\n/**\n * Concatenate arcs into a coordinate array.\n * @param {Array<number>} indices Indices of arcs to concatenate.  Negative\n *     values indicate arcs need to be reversed.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs (already\n *     transformed).\n * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates array.\n */\nfunction concatenateArcs(indices, arcs) {\n  /** @type {Array<import(\"../coordinate.js\").Coordinate>} */\n  var coordinates = [];\n  var index;\n  for (var i = 0, ii = indices.length; i < ii; ++i) {\n    index = indices[i];\n    if (i > 0) {\n      // splicing together arcs, discard last point\n      coordinates.pop();\n    }\n    if (index >= 0) {\n      // forward arc\n      var arc = arcs[index];\n      for (var j = 0, jj = arc.length; j < jj; ++j) {\n        coordinates.push(arc[j].slice(0));\n      }\n    } else {\n      // reverse arc\n      var _arc = arcs[~index];\n      for (var _j = _arc.length - 1; _j >= 0; --_j) {\n        coordinates.push(_arc[_j].slice(0));\n      }\n    }\n  }\n  return coordinates;\n}\n\n/**\n * Create a point from a TopoJSON geometry object.\n *\n * @param {TopoJSONPoint} object TopoJSON object.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @return {Point} Geometry.\n */\nfunction readPointGeometry(object, scale, translate) {\n  var coordinates = object['coordinates'];\n  if (scale && translate) {\n    transformVertex(coordinates, scale, translate);\n  }\n  return new Point(coordinates);\n}\n\n/**\n * Create a multi-point from a TopoJSON geometry object.\n *\n * @param {TopoJSONMultiPoint} object TopoJSON object.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @return {MultiPoint} Geometry.\n */\nfunction readMultiPointGeometry(object, scale, translate) {\n  var coordinates = object['coordinates'];\n  if (scale && translate) {\n    for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n      transformVertex(coordinates[i], scale, translate);\n    }\n  }\n  return new MultiPoint(coordinates);\n}\n\n/**\n * Create a linestring from a TopoJSON geometry object.\n *\n * @param {TopoJSONLineString} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {LineString} Geometry.\n */\nfunction readLineStringGeometry(object, arcs) {\n  var coordinates = concatenateArcs(object['arcs'], arcs);\n  return new LineString(coordinates);\n}\n\n/**\n * Create a multi-linestring from a TopoJSON geometry object.\n *\n * @param {TopoJSONMultiLineString} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {MultiLineString} Geometry.\n */\nfunction readMultiLineStringGeometry(object, arcs) {\n  var coordinates = [];\n  for (var i = 0, ii = object['arcs'].length; i < ii; ++i) {\n    coordinates[i] = concatenateArcs(object['arcs'][i], arcs);\n  }\n  return new MultiLineString(coordinates);\n}\n\n/**\n * Create a polygon from a TopoJSON geometry object.\n *\n * @param {TopoJSONPolygon} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {Polygon} Geometry.\n */\nfunction readPolygonGeometry(object, arcs) {\n  var coordinates = [];\n  for (var i = 0, ii = object['arcs'].length; i < ii; ++i) {\n    coordinates[i] = concatenateArcs(object['arcs'][i], arcs);\n  }\n  return new Polygon(coordinates);\n}\n\n/**\n * Create a multi-polygon from a TopoJSON geometry object.\n *\n * @param {TopoJSONMultiPolygon} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {MultiPolygon} Geometry.\n */\nfunction readMultiPolygonGeometry(object, arcs) {\n  var coordinates = [];\n  for (var i = 0, ii = object['arcs'].length; i < ii; ++i) {\n    // for each polygon\n    var polyArray = object['arcs'][i];\n    var ringCoords = [];\n    for (var j = 0, jj = polyArray.length; j < jj; ++j) {\n      // for each ring\n      ringCoords[j] = concatenateArcs(polyArray[j], arcs);\n    }\n    coordinates[i] = ringCoords;\n  }\n  return new MultiPolygon(coordinates);\n}\n\n/**\n * Create features from a TopoJSON GeometryCollection object.\n *\n * @param {TopoJSONGeometryCollection} collection TopoJSON Geometry\n *     object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @param {string|undefined} property Property to set the `GeometryCollection`'s parent\n *     object to.\n * @param {string} name Name of the `Topology`'s child object.\n * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n * @return {Array<Feature>} Array of features.\n */\nfunction readFeaturesFromGeometryCollection(collection, arcs, scale, translate, property, name, options) {\n  var geometries = collection['geometries'];\n  var features = [];\n  for (var i = 0, ii = geometries.length; i < ii; ++i) {\n    features[i] = readFeatureFromGeometry(geometries[i], arcs, scale, translate, property, name, options);\n  }\n  return features;\n}\n\n/**\n * Create a feature from a TopoJSON geometry object.\n *\n * @param {TopoJSONGeometry} object TopoJSON geometry object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @param {string|undefined} property Property to set the `GeometryCollection`'s parent\n *     object to.\n * @param {string} name Name of the `Topology`'s child object.\n * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n * @return {Feature} Feature.\n */\nfunction readFeatureFromGeometry(object, arcs, scale, translate, property, name, options) {\n  var geometry = null;\n  var type = object.type;\n  if (type) {\n    var geometryReader = GEOMETRY_READERS[type];\n    if (type === 'Point' || type === 'MultiPoint') {\n      geometry = geometryReader(object, scale, translate);\n    } else {\n      geometry = geometryReader(object, arcs);\n    }\n    geometry = transformGeometryWithOptions(geometry, false, options);\n  }\n  var feature = new Feature({\n    geometry: geometry\n  });\n  if (object.id !== undefined) {\n    feature.setId(object.id);\n  }\n  var properties = object.properties;\n  if (property) {\n    if (!properties) {\n      properties = {};\n    }\n    properties[property] = name;\n  }\n  if (properties) {\n    feature.setProperties(properties, true);\n  }\n  return feature;\n}\n\n/**\n * Apply a linear transform to array of arcs.  The provided array of arcs is\n * modified in place.\n *\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n */\nfunction transformArcs(arcs, scale, translate) {\n  for (var i = 0, ii = arcs.length; i < ii; ++i) {\n    transformArc(arcs[i], scale, translate);\n  }\n}\n\n/**\n * Apply a linear transform to an arc.  The provided arc is modified in place.\n *\n * @param {Array<import(\"../coordinate.js\").Coordinate>} arc Arc.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n */\nfunction transformArc(arc, scale, translate) {\n  var x = 0;\n  var y = 0;\n  for (var i = 0, ii = arc.length; i < ii; ++i) {\n    var vertex = arc[i];\n    x += vertex[0];\n    y += vertex[1];\n    vertex[0] = x;\n    vertex[1] = y;\n    transformVertex(vertex, scale, translate);\n  }\n}\n\n/**\n * Apply a linear transform to a vertex.  The provided vertex is modified in\n * place.\n *\n * @param {import(\"../coordinate.js\").Coordinate} vertex Vertex.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n */\nfunction transformVertex(vertex, scale, translate) {\n  vertex[0] = vertex[0] * scale[0] + translate[0];\n  vertex[1] = vertex[1] * scale[1] + translate[1];\n}\nexport default TopoJSON;","map":{"version":3,"names":["Feature","JSONFeature","LineString","MultiLineString","MultiPoint","MultiPolygon","Point","Polygon","get","getProjection","transformGeometryWithOptions","TopoJSON","_JSONFeature","options","_this","_classCallCheck","_callSuper","layerName_","layerName","layers_","layers","dataProjection","_inherits","_createClass","key","value","readFeaturesFromObject","object","type","topoJSONTopology","transform","scale","translate","arcs","transformArcs","features","topoJSONFeatures","property","feature","objectName","includes","push","apply","readFeaturesFromGeometryCollection","readFeatureFromGeometry","readProjectionFromObject","GEOMETRY_READERS","readPointGeometry","readLineStringGeometry","readPolygonGeometry","readMultiPointGeometry","readMultiLineStringGeometry","readMultiPolygonGeometry","concatenateArcs","indices","coordinates","index","i","ii","length","pop","arc","j","jj","slice","transformVertex","polyArray","ringCoords","collection","name","geometries","geometry","geometryReader","id","undefined","setId","properties","setProperties","transformArc","x","y","vertex"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol/format/TopoJSON.js"],"sourcesContent":["/**\n * @module ol/format/TopoJSON\n */\nimport Feature from '../Feature.js';\nimport JSONFeature from './JSONFeature.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport {get as getProjection} from '../proj.js';\nimport {transformGeometryWithOptions} from './Feature.js';\n\n/**\n * @typedef {import(\"topojson-specification\").Topology} TopoJSONTopology\n * @typedef {import(\"topojson-specification\").GeometryCollection} TopoJSONGeometryCollection\n * @typedef {import(\"topojson-specification\").GeometryObject} TopoJSONGeometry\n * @typedef {import(\"topojson-specification\").Point} TopoJSONPoint\n * @typedef {import(\"topojson-specification\").MultiPoint} TopoJSONMultiPoint\n * @typedef {import(\"topojson-specification\").LineString} TopoJSONLineString\n * @typedef {import(\"topojson-specification\").MultiLineString} TopoJSONMultiLineString\n * @typedef {import(\"topojson-specification\").Polygon} TopoJSONPolygon\n * @typedef {import(\"topojson-specification\").MultiPolygon} TopoJSONMultiPolygon\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.\n * @property {string} [layerName] Set the name of the TopoJSON topology\n * `objects`'s children as feature property with the specified name. This means\n * that when set to `'layer'`, a topology like\n * ```\n * {\n *   \"type\": \"Topology\",\n *   \"objects\": {\n *     \"example\": {\n *       \"type\": \"GeometryCollection\",\n *       \"geometries\": []\n *     }\n *   }\n * }\n * ```\n * will result in features that have a property `'layer'` set to `'example'`.\n * When not set, no property will be added to features.\n * @property {Array<string>} [layers] Names of the TopoJSON topology's\n * `objects`'s children to read features from.  If not provided, features will\n * be read from all children.\n */\n\n/**\n * @classdesc\n * Feature format for reading data in the TopoJSON format.\n *\n * @api\n */\nclass TopoJSON extends JSONFeature {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.layerName_ = options.layerName;\n\n    /**\n     * @private\n     * @type {?Array<string>}\n     */\n    this.layers_ = options.layers ? options.layers : null;\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.dataProjection = getProjection(\n      options.dataProjection ? options.dataProjection : 'EPSG:4326'\n    );\n  }\n\n  /**\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<Feature>} Features.\n   */\n  readFeaturesFromObject(object, options) {\n    if (object.type == 'Topology') {\n      const topoJSONTopology = /** @type {TopoJSONTopology} */ (object);\n      let transform,\n        scale = null,\n        translate = null;\n      if (topoJSONTopology['transform']) {\n        transform = topoJSONTopology['transform'];\n        scale = transform['scale'];\n        translate = transform['translate'];\n      }\n      const arcs = topoJSONTopology['arcs'];\n      if (transform) {\n        transformArcs(arcs, scale, translate);\n      }\n      /** @type {Array<Feature>} */\n      const features = [];\n      const topoJSONFeatures = topoJSONTopology['objects'];\n      const property = this.layerName_;\n      let feature;\n      for (const objectName in topoJSONFeatures) {\n        if (this.layers_ && !this.layers_.includes(objectName)) {\n          continue;\n        }\n        if (topoJSONFeatures[objectName].type === 'GeometryCollection') {\n          feature = /** @type {TopoJSONGeometryCollection} */ (\n            topoJSONFeatures[objectName]\n          );\n          features.push.apply(\n            features,\n            readFeaturesFromGeometryCollection(\n              feature,\n              arcs,\n              scale,\n              translate,\n              property,\n              objectName,\n              options\n            )\n          );\n        } else {\n          feature = /** @type {TopoJSONGeometry} */ (\n            topoJSONFeatures[objectName]\n          );\n          features.push(\n            readFeatureFromGeometry(\n              feature,\n              arcs,\n              scale,\n              translate,\n              property,\n              objectName,\n              options\n            )\n          );\n        }\n      }\n      return features;\n    }\n    return [];\n  }\n\n  /**\n   * @param {Object} object Object.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromObject(object) {\n    return this.dataProjection;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, function(TopoJSONGeometry, Array, ...Array=): import(\"../geom/Geometry.js\").default>}\n */\nconst GEOMETRY_READERS = {\n  'Point': readPointGeometry,\n  'LineString': readLineStringGeometry,\n  'Polygon': readPolygonGeometry,\n  'MultiPoint': readMultiPointGeometry,\n  'MultiLineString': readMultiLineStringGeometry,\n  'MultiPolygon': readMultiPolygonGeometry,\n};\n\n/**\n * Concatenate arcs into a coordinate array.\n * @param {Array<number>} indices Indices of arcs to concatenate.  Negative\n *     values indicate arcs need to be reversed.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs (already\n *     transformed).\n * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates array.\n */\nfunction concatenateArcs(indices, arcs) {\n  /** @type {Array<import(\"../coordinate.js\").Coordinate>} */\n  const coordinates = [];\n  let index;\n  for (let i = 0, ii = indices.length; i < ii; ++i) {\n    index = indices[i];\n    if (i > 0) {\n      // splicing together arcs, discard last point\n      coordinates.pop();\n    }\n    if (index >= 0) {\n      // forward arc\n      const arc = arcs[index];\n      for (let j = 0, jj = arc.length; j < jj; ++j) {\n        coordinates.push(arc[j].slice(0));\n      }\n    } else {\n      // reverse arc\n      const arc = arcs[~index];\n      for (let j = arc.length - 1; j >= 0; --j) {\n        coordinates.push(arc[j].slice(0));\n      }\n    }\n  }\n  return coordinates;\n}\n\n/**\n * Create a point from a TopoJSON geometry object.\n *\n * @param {TopoJSONPoint} object TopoJSON object.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @return {Point} Geometry.\n */\nfunction readPointGeometry(object, scale, translate) {\n  const coordinates = object['coordinates'];\n  if (scale && translate) {\n    transformVertex(coordinates, scale, translate);\n  }\n  return new Point(coordinates);\n}\n\n/**\n * Create a multi-point from a TopoJSON geometry object.\n *\n * @param {TopoJSONMultiPoint} object TopoJSON object.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @return {MultiPoint} Geometry.\n */\nfunction readMultiPointGeometry(object, scale, translate) {\n  const coordinates = object['coordinates'];\n  if (scale && translate) {\n    for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n      transformVertex(coordinates[i], scale, translate);\n    }\n  }\n  return new MultiPoint(coordinates);\n}\n\n/**\n * Create a linestring from a TopoJSON geometry object.\n *\n * @param {TopoJSONLineString} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {LineString} Geometry.\n */\nfunction readLineStringGeometry(object, arcs) {\n  const coordinates = concatenateArcs(object['arcs'], arcs);\n  return new LineString(coordinates);\n}\n\n/**\n * Create a multi-linestring from a TopoJSON geometry object.\n *\n * @param {TopoJSONMultiLineString} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {MultiLineString} Geometry.\n */\nfunction readMultiLineStringGeometry(object, arcs) {\n  const coordinates = [];\n  for (let i = 0, ii = object['arcs'].length; i < ii; ++i) {\n    coordinates[i] = concatenateArcs(object['arcs'][i], arcs);\n  }\n  return new MultiLineString(coordinates);\n}\n\n/**\n * Create a polygon from a TopoJSON geometry object.\n *\n * @param {TopoJSONPolygon} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {Polygon} Geometry.\n */\nfunction readPolygonGeometry(object, arcs) {\n  const coordinates = [];\n  for (let i = 0, ii = object['arcs'].length; i < ii; ++i) {\n    coordinates[i] = concatenateArcs(object['arcs'][i], arcs);\n  }\n  return new Polygon(coordinates);\n}\n\n/**\n * Create a multi-polygon from a TopoJSON geometry object.\n *\n * @param {TopoJSONMultiPolygon} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {MultiPolygon} Geometry.\n */\nfunction readMultiPolygonGeometry(object, arcs) {\n  const coordinates = [];\n  for (let i = 0, ii = object['arcs'].length; i < ii; ++i) {\n    // for each polygon\n    const polyArray = object['arcs'][i];\n    const ringCoords = [];\n    for (let j = 0, jj = polyArray.length; j < jj; ++j) {\n      // for each ring\n      ringCoords[j] = concatenateArcs(polyArray[j], arcs);\n    }\n    coordinates[i] = ringCoords;\n  }\n  return new MultiPolygon(coordinates);\n}\n\n/**\n * Create features from a TopoJSON GeometryCollection object.\n *\n * @param {TopoJSONGeometryCollection} collection TopoJSON Geometry\n *     object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @param {string|undefined} property Property to set the `GeometryCollection`'s parent\n *     object to.\n * @param {string} name Name of the `Topology`'s child object.\n * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n * @return {Array<Feature>} Array of features.\n */\nfunction readFeaturesFromGeometryCollection(\n  collection,\n  arcs,\n  scale,\n  translate,\n  property,\n  name,\n  options\n) {\n  const geometries = collection['geometries'];\n  const features = [];\n  for (let i = 0, ii = geometries.length; i < ii; ++i) {\n    features[i] = readFeatureFromGeometry(\n      geometries[i],\n      arcs,\n      scale,\n      translate,\n      property,\n      name,\n      options\n    );\n  }\n  return features;\n}\n\n/**\n * Create a feature from a TopoJSON geometry object.\n *\n * @param {TopoJSONGeometry} object TopoJSON geometry object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @param {string|undefined} property Property to set the `GeometryCollection`'s parent\n *     object to.\n * @param {string} name Name of the `Topology`'s child object.\n * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n * @return {Feature} Feature.\n */\nfunction readFeatureFromGeometry(\n  object,\n  arcs,\n  scale,\n  translate,\n  property,\n  name,\n  options\n) {\n  let geometry = null;\n  const type = object.type;\n  if (type) {\n    const geometryReader = GEOMETRY_READERS[type];\n    if (type === 'Point' || type === 'MultiPoint') {\n      geometry = geometryReader(object, scale, translate);\n    } else {\n      geometry = geometryReader(object, arcs);\n    }\n    geometry = transformGeometryWithOptions(geometry, false, options);\n  }\n  const feature = new Feature({geometry: geometry});\n  if (object.id !== undefined) {\n    feature.setId(object.id);\n  }\n  let properties = object.properties;\n  if (property) {\n    if (!properties) {\n      properties = {};\n    }\n    properties[property] = name;\n  }\n  if (properties) {\n    feature.setProperties(properties, true);\n  }\n  return feature;\n}\n\n/**\n * Apply a linear transform to array of arcs.  The provided array of arcs is\n * modified in place.\n *\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n */\nfunction transformArcs(arcs, scale, translate) {\n  for (let i = 0, ii = arcs.length; i < ii; ++i) {\n    transformArc(arcs[i], scale, translate);\n  }\n}\n\n/**\n * Apply a linear transform to an arc.  The provided arc is modified in place.\n *\n * @param {Array<import(\"../coordinate.js\").Coordinate>} arc Arc.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n */\nfunction transformArc(arc, scale, translate) {\n  let x = 0;\n  let y = 0;\n  for (let i = 0, ii = arc.length; i < ii; ++i) {\n    const vertex = arc[i];\n    x += vertex[0];\n    y += vertex[1];\n    vertex[0] = x;\n    vertex[1] = y;\n    transformVertex(vertex, scale, translate);\n  }\n}\n\n/**\n * Apply a linear transform to a vertex.  The provided vertex is modified in\n * place.\n *\n * @param {import(\"../coordinate.js\").Coordinate} vertex Vertex.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n */\nfunction transformVertex(vertex, scale, translate) {\n  vertex[0] = vertex[0] * scale[0] + translate[0];\n  vertex[1] = vertex[1] * scale[1] + translate[1];\n}\n\nexport default TopoJSON;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}