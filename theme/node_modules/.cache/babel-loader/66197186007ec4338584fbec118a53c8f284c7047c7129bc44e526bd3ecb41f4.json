{"ast":null,"code":"import _classCallCheck from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _possibleConstructorReturn from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\";\nimport _callSuper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.constructor.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.data-view.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.timers.js\";\n/**\n * @module ol/reproj/DataTile\n */\nimport { ERROR_THRESHOLD } from './common.js';\nimport DataTile, { asArrayLike, asImageLike, toArray } from '../DataTile.js';\nimport EventType from '../events/EventType.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport { calculateSourceExtentResolution, canvasPool, render as renderReprojected } from '../reproj.js';\nimport { clamp } from '../math.js';\nimport { createCanvasContext2D, releaseCanvas } from '../dom.js';\nimport { getArea, getIntersection } from '../extent.js';\nimport { listen, unlistenByKey } from '../events.js';\n\n/**\n * @typedef {function(number, number, number, number) : import(\"../DataTile.js\").default} TileGetter\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n * @property {import(\"../proj/Projection.js\").default} targetProj Target projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n * @property {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n * @property {import(\"../tilecoord.js\").TileCoord} [wrappedTileCoord] Coordinate of the tile wrapped in X.\n * @property {number} pixelRatio Pixel ratio.\n * @property {number} gutter Gutter of the source tiles.\n * @property {TileGetter} getTileFunction Function returning source tiles (z, x, y, pixelRatio).\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {number} [errorThreshold] Acceptable reprojection error (in px).\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected data tile.\n * See {@link module:ol/source/DataTile~DataTileSource}.\n *\n */\nvar ReprojDataTile = /*#__PURE__*/function (_DataTile) {\n  /**\n   * @param {Options} options Tile options.\n   */\n  function ReprojDataTile(options) {\n    var _this;\n    _classCallCheck(this, ReprojDataTile);\n    _this = _callSuper(this, ReprojDataTile, [{\n      tileCoord: options.tileCoord,\n      loader: function loader() {\n        return Promise.resolve(new Uint8Array(4));\n      },\n      interpolate: options.interpolate,\n      transition: options.transition\n    }]);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.pixelRatio_ = options.pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.gutter_ = options.gutter;\n\n    /**\n     * @type {import(\"../DataTile.js\").Data}\n     * @private\n     */\n    _this.reprojData_ = null;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    _this.reprojError_ = null;\n\n    /**\n     * @type {import('../size.js').Size}\n     * @private\n     */\n    _this.reprojSize_ = undefined;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    _this.sourceTileGrid_ = options.sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    _this.targetTileGrid_ = options.targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    _this.wrappedTileCoord_ = options.wrappedTileCoord || options.tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<DataTile>}\n     */\n    _this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    _this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.sourceZ_ = 0;\n    var targetExtent = _this.targetTileGrid_.getTileCoordExtent(_this.wrappedTileCoord_);\n    var maxTargetExtent = _this.targetTileGrid_.getExtent();\n    var maxSourceExtent = _this.sourceTileGrid_.getExtent();\n    var limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      _this.state = TileState.EMPTY;\n      return _possibleConstructorReturn(_this);\n    }\n    var sourceProj = options.sourceProj;\n    var sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n    var targetResolution = _this.targetTileGrid_.getResolution(_this.wrappedTileCoord_[0]);\n    var targetProj = options.targetProj;\n    var sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      _this.state = TileState.EMPTY;\n      return _possibleConstructorReturn(_this);\n    }\n    var errorThresholdInPixels = options.errorThreshold !== undefined ? options.errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    _this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);\n    if (_this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      _this.state = TileState.EMPTY;\n      return _possibleConstructorReturn(_this);\n    }\n    _this.sourceZ_ = _this.sourceTileGrid_.getZForResolution(sourceResolution);\n    var sourceExtent = _this.triangulation_.calculateSourceExtent();\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n        sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n    if (!getArea(sourceExtent)) {\n      _this.state = TileState.EMPTY;\n    } else {\n      var sourceRange = _this.sourceTileGrid_.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);\n      var getTile = options.getTileFunction;\n      for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          var tile = getTile(_this.sourceZ_, srcX, srcY, _this.pixelRatio_);\n          if (tile) {\n            _this.sourceTiles_.push(tile);\n          }\n        }\n      }\n      if (_this.sourceTiles_.length === 0) {\n        _this.state = TileState.EMPTY;\n      }\n    }\n    return _this;\n  }\n\n  /**\n   * Get the tile size.\n   * @return {import('../size.js').Size} Tile size.\n   */\n  _inherits(ReprojDataTile, _DataTile);\n  return _createClass(ReprojDataTile, [{\n    key: \"getSize\",\n    value: function getSize() {\n      return this.reprojSize_;\n    }\n\n    /**\n     * Get the data for the tile.\n     * @return {import(\"../DataTile.js\").Data} Tile data.\n     */\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      return this.reprojData_;\n    }\n\n    /**\n     * Get any loading error.\n     * @return {Error} Loading error.\n     */\n  }, {\n    key: \"getError\",\n    value: function getError() {\n      return this.reprojError_;\n    }\n\n    /**\n     * @private\n     */\n  }, {\n    key: \"reproject_\",\n    value: function reproject_() {\n      var _this2 = this;\n      var dataSources = [];\n      this.sourceTiles_.forEach(function (tile) {\n        if (!tile || tile.getState() !== TileState.LOADED) {\n          return;\n        }\n        var size = tile.getSize();\n        var gutter = _this2.gutter_;\n        /**\n         * @type {import(\"../DataTile.js\").ArrayLike}\n         */\n        var tileData;\n        var arrayData = asArrayLike(tile.getData());\n        if (arrayData) {\n          tileData = arrayData;\n        } else {\n          tileData = toArray(asImageLike(tile.getData()));\n        }\n        var pixelSize = [size[0] + 2 * gutter, size[1] + 2 * gutter];\n        var isFloat = tileData instanceof Float32Array;\n        var pixelCount = pixelSize[0] * pixelSize[1];\n        var DataType = isFloat ? Float32Array : Uint8Array;\n        var tileDataR = new DataType(tileData.buffer);\n        var bytesPerElement = DataType.BYTES_PER_ELEMENT;\n        var bytesPerPixel = bytesPerElement * tileDataR.length / pixelCount;\n        var bytesPerRow = tileDataR.byteLength / pixelSize[1];\n        var bandCount = Math.floor(bytesPerRow / bytesPerElement / pixelSize[0]);\n        var packedLength = pixelCount * bandCount;\n        var packedData = tileDataR;\n        if (tileDataR.length !== packedLength) {\n          packedData = new DataType(packedLength);\n          var dataIndex = 0;\n          var rowOffset = 0;\n          var colCount = pixelSize[0] * bandCount;\n          for (var rowIndex = 0; rowIndex < pixelSize[1]; ++rowIndex) {\n            for (var colIndex = 0; colIndex < colCount; ++colIndex) {\n              packedData[dataIndex++] = tileDataR[rowOffset + colIndex];\n            }\n            rowOffset += bytesPerRow / bytesPerElement;\n          }\n        }\n        dataSources.push({\n          extent: _this2.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n          data: new Uint8Array(packedData.buffer),\n          dataType: DataType,\n          bytesPerPixel: bytesPerPixel,\n          pixelSize: pixelSize\n        });\n      });\n      this.sourceTiles_.length = 0;\n      if (dataSources.length === 0) {\n        this.state = TileState.ERROR;\n      } else {\n        var z = this.wrappedTileCoord_[0];\n        var size = this.targetTileGrid_.getTileSize(z);\n        var targetWidth = typeof size === 'number' ? size : size[0];\n        var targetHeight = typeof size === 'number' ? size : size[1];\n        var targetResolution = this.targetTileGrid_.getResolution(z);\n        var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n        var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n        var dataR, dataU;\n        var bytesPerPixel = dataSources[0].bytesPerPixel;\n        var reprojs = Math.ceil(bytesPerPixel / 3);\n        for (var reproj = reprojs - 1; reproj >= 0; --reproj) {\n          var sources = [];\n          for (var i = 0, len = dataSources.length; i < len; ++i) {\n            var dataSource = dataSources[i];\n            var buffer = dataSource.data;\n            var pixelSize = dataSource.pixelSize;\n            var width = pixelSize[0];\n            var height = pixelSize[1];\n            var _context = createCanvasContext2D(width, height, canvasPool);\n            var _imageData = _context.createImageData(width, height);\n            var _data = _imageData.data;\n            var _offset = reproj * 3;\n            for (var j = 0, _len = _data.length; j < _len; j += 4) {\n              _data[j] = buffer[_offset];\n              _data[j + 1] = buffer[_offset + 1];\n              _data[j + 2] = buffer[_offset + 2];\n              _data[j + 3] = 255;\n              _offset += bytesPerPixel;\n            }\n            _context.putImageData(_imageData, 0, 0);\n            sources.push({\n              extent: dataSource.extent,\n              image: _context.canvas\n            });\n          }\n          var canvas = renderReprojected(targetWidth, targetHeight, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, false, false);\n          for (var _i = 0, _len2 = sources.length; _i < _len2; ++_i) {\n            var _canvas = sources[_i].image;\n            var _context2 = _canvas.getContext('2d');\n            releaseCanvas(_context2);\n            canvasPool.push(_context2.canvas);\n          }\n          var context = canvas.getContext('2d');\n          var imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n          releaseCanvas(context);\n          canvasPool.push(canvas);\n          if (!dataR) {\n            dataU = new Uint8Array(bytesPerPixel * imageData.width * imageData.height);\n            dataR = new dataSources[0].dataType(dataU.buffer);\n          }\n          var data = imageData.data;\n          var offset = reproj * 3;\n          for (var _i2 = 0, _len3 = data.length; _i2 < _len3; _i2 += 4) {\n            if (data[_i2 + 3] === 255) {\n              dataU[offset] = data[_i2];\n              dataU[offset + 1] = data[_i2 + 1];\n              dataU[offset + 2] = data[_i2 + 2];\n            } else {\n              dataU[offset] = 0;\n              dataU[offset + 1] = 0;\n              dataU[offset + 2] = 0;\n            }\n            offset += bytesPerPixel;\n          }\n        }\n        this.reprojData_ = dataR;\n        this.reprojSize_ = [Math.round(targetWidth * this.pixelRatio_), Math.round(targetHeight * this.pixelRatio_)];\n        this.state = TileState.LOADED;\n      }\n      this.changed();\n    }\n\n    /**\n     * Load not yet loaded URI.\n     */\n  }, {\n    key: \"load\",\n    value: function load() {\n      var _this3 = this;\n      if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\n        return;\n      }\n      this.state = TileState.LOADING;\n      this.changed();\n      var leftToLoad = 0;\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(function (tile) {\n        var state = tile.getState();\n        if (state !== TileState.IDLE && state !== TileState.LOADING) {\n          return;\n        }\n        leftToLoad++;\n        var sourceListenKey = listen(tile, EventType.CHANGE, function () {\n          var state = tile.getState();\n          if (state == TileState.LOADED || state == TileState.ERROR || state == TileState.EMPTY) {\n            unlistenByKey(sourceListenKey);\n            leftToLoad--;\n            if (leftToLoad === 0) {\n              this.unlistenSources_();\n              this.reproject_();\n            }\n          }\n        }, _this3);\n        _this3.sourcesListenerKeys_.push(sourceListenKey);\n      });\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      } else {\n        this.sourceTiles_.forEach(function (tile) {\n          var state = tile.getState();\n          if (state == TileState.IDLE) {\n            tile.load();\n          }\n        });\n      }\n    }\n\n    /**\n     * @private\n     */\n  }, {\n    key: \"unlistenSources_\",\n    value: function unlistenSources_() {\n      this.sourcesListenerKeys_.forEach(unlistenByKey);\n      this.sourcesListenerKeys_ = null;\n    }\n  }]);\n}(DataTile);\nexport default ReprojDataTile;","map":{"version":3,"names":["ERROR_THRESHOLD","DataTile","asArrayLike","asImageLike","toArray","EventType","TileState","Triangulation","calculateSourceExtentResolution","canvasPool","render","renderReprojected","clamp","createCanvasContext2D","releaseCanvas","getArea","getIntersection","listen","unlistenByKey","ReprojDataTile","_DataTile","options","_this","_classCallCheck","_callSuper","tileCoord","loader","Promise","resolve","Uint8Array","interpolate","transition","pixelRatio_","pixelRatio","gutter_","gutter","reprojData_","reprojError_","reprojSize_","undefined","sourceTileGrid_","sourceTileGrid","targetTileGrid_","targetTileGrid","wrappedTileCoord_","wrappedTileCoord","sourceTiles_","sourcesListenerKeys_","sourceZ_","targetExtent","getTileCoordExtent","maxTargetExtent","getExtent","maxSourceExtent","limitedTargetExtent","state","EMPTY","_possibleConstructorReturn","sourceProj","sourceProjExtent","targetResolution","getResolution","targetProj","sourceResolution","isFinite","errorThresholdInPixels","errorThreshold","triangulation_","getTriangles","length","getZForResolution","sourceExtent","calculateSourceExtent","canWrapX","sourceRange","getTileRangeForExtentAndZ","getTile","getTileFunction","srcX","minX","maxX","srcY","minY","maxY","tile","push","_inherits","_createClass","key","value","getSize","getData","getError","reproject_","_this2","dataSources","forEach","getState","LOADED","size","tileData","arrayData","pixelSize","isFloat","Float32Array","pixelCount","DataType","tileDataR","buffer","bytesPerElement","BYTES_PER_ELEMENT","bytesPerPixel","bytesPerRow","byteLength","bandCount","Math","floor","packedLength","packedData","dataIndex","rowOffset","colCount","rowIndex","colIndex","extent","data","dataType","ERROR","z","getTileSize","targetWidth","targetHeight","dataR","dataU","reprojs","ceil","reproj","sources","i","len","dataSource","width","height","context","imageData","createImageData","offset","j","putImageData","image","canvas","getContext","getImageData","round","changed","load","_this3","IDLE","LOADING","leftToLoad","sourceListenKey","CHANGE","unlistenSources_","setTimeout","bind"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol/reproj/DataTile.js"],"sourcesContent":["/**\n * @module ol/reproj/DataTile\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport DataTile, {asArrayLike, asImageLike, toArray} from '../DataTile.js';\nimport EventType from '../events/EventType.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport {\n  calculateSourceExtentResolution,\n  canvasPool,\n  render as renderReprojected,\n} from '../reproj.js';\nimport {clamp} from '../math.js';\nimport {createCanvasContext2D, releaseCanvas} from '../dom.js';\nimport {getArea, getIntersection} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {function(number, number, number, number) : import(\"../DataTile.js\").default} TileGetter\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n * @property {import(\"../proj/Projection.js\").default} targetProj Target projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n * @property {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n * @property {import(\"../tilecoord.js\").TileCoord} [wrappedTileCoord] Coordinate of the tile wrapped in X.\n * @property {number} pixelRatio Pixel ratio.\n * @property {number} gutter Gutter of the source tiles.\n * @property {TileGetter} getTileFunction Function returning source tiles (z, x, y, pixelRatio).\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {number} [errorThreshold] Acceptable reprojection error (in px).\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected data tile.\n * See {@link module:ol/source/DataTile~DataTileSource}.\n *\n */\nclass ReprojDataTile extends DataTile {\n  /**\n   * @param {Options} options Tile options.\n   */\n  constructor(options) {\n    super({\n      tileCoord: options.tileCoord,\n      loader: () => Promise.resolve(new Uint8Array(4)),\n      interpolate: options.interpolate,\n      transition: options.transition,\n    });\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = options.pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = options.gutter;\n\n    /**\n     * @type {import(\"../DataTile.js\").Data}\n     * @private\n     */\n    this.reprojData_ = null;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.reprojError_ = null;\n\n    /**\n     * @type {import('../size.js').Size}\n     * @private\n     */\n    this.reprojSize_ = undefined;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = options.sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = options.targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = options.wrappedTileCoord || options.tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<DataTile>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n      this.wrappedTileCoord_\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const sourceProj = options.sourceProj;\n    const sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = this.targetTileGrid_.getResolution(\n      this.wrappedTileCoord_[0]\n    );\n\n    const targetProj = options.targetProj;\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      options.errorThreshold !== undefined\n        ? options.errorThreshold\n        : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = this.sourceTileGrid_.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3]\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3]\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      const sourceRange = this.sourceTileGrid_.getTileRangeForExtentAndZ(\n        sourceExtent,\n        this.sourceZ_\n      );\n      const getTile = options.getTileFunction;\n      for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          const tile = getTile(this.sourceZ_, srcX, srcY, this.pixelRatio_);\n          if (tile) {\n            this.sourceTiles_.push(tile);\n          }\n        }\n      }\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the tile size.\n   * @return {import('../size.js').Size} Tile size.\n   */\n  getSize() {\n    return this.reprojSize_;\n  }\n\n  /**\n   * Get the data for the tile.\n   * @return {import(\"../DataTile.js\").Data} Tile data.\n   */\n  getData() {\n    return this.reprojData_;\n  }\n\n  /**\n   * Get any loading error.\n   * @return {Error} Loading error.\n   */\n  getError() {\n    return this.reprojError_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const dataSources = [];\n    this.sourceTiles_.forEach((tile) => {\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n      const size = tile.getSize();\n      const gutter = this.gutter_;\n      /**\n       * @type {import(\"../DataTile.js\").ArrayLike}\n       */\n      let tileData;\n      const arrayData = asArrayLike(tile.getData());\n      if (arrayData) {\n        tileData = arrayData;\n      } else {\n        tileData = toArray(asImageLike(tile.getData()));\n      }\n      const pixelSize = [size[0] + 2 * gutter, size[1] + 2 * gutter];\n      const isFloat = tileData instanceof Float32Array;\n      const pixelCount = pixelSize[0] * pixelSize[1];\n      const DataType = isFloat ? Float32Array : Uint8Array;\n      const tileDataR = new DataType(tileData.buffer);\n      const bytesPerElement = DataType.BYTES_PER_ELEMENT;\n      const bytesPerPixel = (bytesPerElement * tileDataR.length) / pixelCount;\n      const bytesPerRow = tileDataR.byteLength / pixelSize[1];\n      const bandCount = Math.floor(\n        bytesPerRow / bytesPerElement / pixelSize[0]\n      );\n      const packedLength = pixelCount * bandCount;\n      let packedData = tileDataR;\n      if (tileDataR.length !== packedLength) {\n        packedData = new DataType(packedLength);\n        let dataIndex = 0;\n        let rowOffset = 0;\n        const colCount = pixelSize[0] * bandCount;\n        for (let rowIndex = 0; rowIndex < pixelSize[1]; ++rowIndex) {\n          for (let colIndex = 0; colIndex < colCount; ++colIndex) {\n            packedData[dataIndex++] = tileDataR[rowOffset + colIndex];\n          }\n          rowOffset += bytesPerRow / bytesPerElement;\n        }\n      }\n      dataSources.push({\n        extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n        data: new Uint8Array(packedData.buffer),\n        dataType: DataType,\n        bytesPerPixel: bytesPerPixel,\n        pixelSize: pixelSize,\n      });\n    });\n    this.sourceTiles_.length = 0;\n\n    if (dataSources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const targetWidth = typeof size === 'number' ? size : size[0];\n      const targetHeight = typeof size === 'number' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(\n        this.sourceZ_\n      );\n\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_\n      );\n\n      let dataR, dataU;\n\n      const bytesPerPixel = dataSources[0].bytesPerPixel;\n\n      const reprojs = Math.ceil(bytesPerPixel / 3);\n      for (let reproj = reprojs - 1; reproj >= 0; --reproj) {\n        const sources = [];\n        for (let i = 0, len = dataSources.length; i < len; ++i) {\n          const dataSource = dataSources[i];\n          const buffer = dataSource.data;\n          const pixelSize = dataSource.pixelSize;\n          const width = pixelSize[0];\n          const height = pixelSize[1];\n          const context = createCanvasContext2D(width, height, canvasPool);\n          const imageData = context.createImageData(width, height);\n          const data = imageData.data;\n          let offset = reproj * 3;\n          for (let j = 0, len = data.length; j < len; j += 4) {\n            data[j] = buffer[offset];\n            data[j + 1] = buffer[offset + 1];\n            data[j + 2] = buffer[offset + 2];\n            data[j + 3] = 255;\n            offset += bytesPerPixel;\n          }\n          context.putImageData(imageData, 0, 0);\n          sources.push({\n            extent: dataSource.extent,\n            image: context.canvas,\n          });\n        }\n\n        const canvas = renderReprojected(\n          targetWidth,\n          targetHeight,\n          this.pixelRatio_,\n          sourceResolution,\n          this.sourceTileGrid_.getExtent(),\n          targetResolution,\n          targetExtent,\n          this.triangulation_,\n          sources,\n          this.gutter_,\n          false,\n          false\n        );\n\n        for (let i = 0, len = sources.length; i < len; ++i) {\n          const canvas = sources[i].image;\n          const context = canvas.getContext('2d');\n          releaseCanvas(context);\n          canvasPool.push(context.canvas);\n        }\n\n        const context = canvas.getContext('2d');\n        const imageData = context.getImageData(\n          0,\n          0,\n          canvas.width,\n          canvas.height\n        );\n\n        releaseCanvas(context);\n        canvasPool.push(canvas);\n\n        if (!dataR) {\n          dataU = new Uint8Array(\n            bytesPerPixel * imageData.width * imageData.height\n          );\n          dataR = new dataSources[0].dataType(dataU.buffer);\n        }\n\n        const data = imageData.data;\n        let offset = reproj * 3;\n        for (let i = 0, len = data.length; i < len; i += 4) {\n          if (data[i + 3] === 255) {\n            dataU[offset] = data[i];\n            dataU[offset + 1] = data[i + 1];\n            dataU[offset + 2] = data[i + 2];\n          } else {\n            dataU[offset] = 0;\n            dataU[offset + 1] = 0;\n            dataU[offset + 2] = 0;\n          }\n          offset += bytesPerPixel;\n        }\n      }\n\n      this.reprojData_ = dataR;\n      this.reprojSize_ = [\n        Math.round(targetWidth * this.pixelRatio_),\n        Math.round(targetHeight * this.pixelRatio_),\n      ];\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   */\n  load() {\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\n      return;\n    }\n    this.state = TileState.LOADING;\n    this.changed();\n\n    let leftToLoad = 0;\n\n    this.sourcesListenerKeys_ = [];\n    this.sourceTiles_.forEach((tile) => {\n      const state = tile.getState();\n      if (state !== TileState.IDLE && state !== TileState.LOADING) {\n        return;\n      }\n      leftToLoad++;\n\n      const sourceListenKey = listen(\n        tile,\n        EventType.CHANGE,\n        function () {\n          const state = tile.getState();\n          if (\n            state == TileState.LOADED ||\n            state == TileState.ERROR ||\n            state == TileState.EMPTY\n          ) {\n            unlistenByKey(sourceListenKey);\n            leftToLoad--;\n            if (leftToLoad === 0) {\n              this.unlistenSources_();\n              this.reproject_();\n            }\n          }\n        },\n        this\n      );\n      this.sourcesListenerKeys_.push(sourceListenKey);\n    });\n\n    if (leftToLoad === 0) {\n      setTimeout(this.reproject_.bind(this), 0);\n    } else {\n      this.sourceTiles_.forEach(function (tile) {\n        const state = tile.getState();\n        if (state == TileState.IDLE) {\n          tile.load();\n        }\n      });\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n}\n\nexport default ReprojDataTile;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}