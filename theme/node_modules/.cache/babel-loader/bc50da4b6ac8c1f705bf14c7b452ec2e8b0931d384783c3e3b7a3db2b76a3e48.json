{"ast":null,"code":"import _classCallCheck from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _callSuper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport \"core-js/modules/es.array.fill.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.unshift.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.parse-float.js\";\nimport \"core-js/modules/es.parse-int.js\";\n/*\tCopyright (c) 2019 Jean-Marc VIGLINO, \r\n  released under the CeCILL-B license (French BSD license)\r\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\n\nimport ol_style_Style from 'ol/style/Style.js';\nimport { asString as ol_color_asString } from 'ol/color.js';\nimport { asArray as ol_color_asArray } from 'ol/color.js';\nimport { ol_coordinate_dist2d } from '../geom/GeomUtils.js';\nimport '../geom/LineStringSplitAt.js';\n\n/** Flow line style\r\n * Draw LineString with a variable color / width\r\n * NB: the FlowLine style doesn't impress the hit-detection.\r\n * If you want your lines to be sectionable you have to add your own style to handle this.\r\n * (with transparent line: stroke color opacity to .1 or zero width)\r\n * @constructor\r\n * @extends {ol_style_Style}\r\n * @param {Object} options\r\n *  @param {boolean} options.visible draw only the visible part of the line, default true\r\n *  @param {number|function} options.width Stroke width or a function that gets a feature and the position (beetween [0,1]) and returns current width\r\n *  @param {number} options.width2 Final stroke width (if width is not a function)\r\n *  @param {number} options.arrow Arrow at start (-1), at end (1), at both (2), none (0), default geta\r\n *  @param {ol.colorLike|function} options.color Stroke color or a function that gets a feature and the position (beetween [0,1]) and returns current color\r\n *  @param {ol.colorLike} options.color2 Final sroke color if color is nor a function\r\n *  @param {ol.colorLike} options.arrowColor Color of arrows, if not defined used color or color2\r\n *  @param {string} options.lineCap CanvasRenderingContext2D.lineCap 'butt' | 'round' | 'square', default 'butt'\r\n *  @param {number|ol.size} options.arrowSize height and width of the arrow, default 16\r\n *  @param {boolean} [options.noOverlap=false] prevent segments overlaping\r\n *  @param {number} options.offset0 offset at line start\r\n *  @param {number} options.offset1 offset at line end\r\n */\nvar ol_style_FlowLine = /*#__PURE__*/function (_ol_style_Style) {\n  function olstyleFlowLine(options) {\n    var _this;\n    _classCallCheck(this, olstyleFlowLine);\n    options = options || {};\n    _this = _callSuper(this, olstyleFlowLine, [{\n      stroke: options.stroke,\n      text: options.text,\n      zIndex: options.zIndex,\n      geometry: options.geometry\n    }]);\n    _this.setRenderer(_this._render.bind(_this));\n\n    // Draw only visible\n    _this._visible = options.visible !== false;\n\n    // Width\n    if (typeof options.width === 'function') {\n      _this._widthFn = options.width;\n    } else {\n      _this.setWidth(options.width);\n    }\n    _this.setWidth2(options.width2);\n    // Color\n    if (typeof options.color === 'function') {\n      _this._colorFn = options.color;\n    } else {\n      _this.setColor(options.color);\n    }\n    _this.setColor2(options.color2);\n    // LineCap\n    _this.setLineCap(options.lineCap);\n    // Arrow\n    _this.setArrow(options.arrow);\n    _this.setArrowSize(options.arrowSize);\n    _this.setArrowColor(options.arrowColor);\n    // Offset\n    _this._offset = [0, 0];\n    _this.setOffset(options.offset0, 0);\n    _this.setOffset(options.offset1, 1);\n    // Overlap\n    _this._noOverlap = options.noOverlap;\n    return _this;\n  }\n  /** Set the initial width\r\n   * @param {number} width width, default 0\r\n   */\n  _inherits(olstyleFlowLine, _ol_style_Style);\n  return _createClass(olstyleFlowLine, [{\n    key: \"setWidth\",\n    value: function setWidth(width) {\n      this._width = width || 0;\n    }\n    /** Set the final width\r\n     * @param {number} width width, default 0\r\n     */\n  }, {\n    key: \"setWidth2\",\n    value: function setWidth2(width) {\n      this._width2 = width;\n    }\n    /** Get offset at start or end\r\n     * @param {number} where 0=start, 1=end\r\n     * @return {number} width\r\n     */\n  }, {\n    key: \"getOffset\",\n    value: function getOffset(where) {\n      return this._offset[where];\n    }\n    /** Add an offset at start or end\r\n     * @param {number} width\r\n     * @param {number} where 0=start, 1=end\r\n     */\n  }, {\n    key: \"setOffset\",\n    value: function setOffset(width, where) {\n      width = Math.max(0, parseFloat(width));\n      switch (where) {\n        case 0:\n          {\n            this._offset[0] = width;\n            break;\n          }\n        case 1:\n          {\n            this._offset[1] = width;\n            break;\n          }\n      }\n    }\n    /** Set the LineCap\r\n     * @param {steing} cap LineCap (round or butt), default butt\r\n     */\n  }, {\n    key: \"setLineCap\",\n    value: function setLineCap(cap) {\n      this._lineCap = cap === 'round' ? 'round' : 'butt';\n    }\n    /** Get the current width at step\r\n     * @param {ol.feature} feature\r\n     * @param {number} step current drawing step beetween [0,1]\r\n     * @return {number}\r\n     */\n  }, {\n    key: \"getWidth\",\n    value: function getWidth(feature, step) {\n      if (this._widthFn) return this._widthFn(feature, step);\n      var w2 = typeof this._width2 === 'number' ? this._width2 : this._width;\n      return this._width + (w2 - this._width) * step;\n    }\n    /** Set the initial color\r\n     * @param {ol.colorLike} color\r\n     */\n  }, {\n    key: \"setColor\",\n    value: function setColor(color) {\n      try {\n        this._color = ol_color_asArray(color);\n      } catch (e) {\n        this._color = [0, 0, 0, 1];\n      }\n    }\n    /** Set the final color\r\n     * @param {ol.colorLike} color\r\n     */\n  }, {\n    key: \"setColor2\",\n    value: function setColor2(color) {\n      try {\n        this._color2 = ol_color_asArray(color);\n      } catch (e) {\n        this._color2 = null;\n      }\n    }\n    /** Set the arrow color\r\n     * @param {ol.colorLike} color\r\n     */\n  }, {\n    key: \"setArrowColor\",\n    value: function setArrowColor(color) {\n      try {\n        this._acolor = ol_color_asString(color);\n      } catch (e) {\n        this._acolor = null;\n      }\n    }\n    /** Get the current color at step\r\n     * @param {ol.feature} feature\r\n     * @param {number} step current drawing step beetween [0,1]\r\n     * @return {string}\r\n     */\n  }, {\n    key: \"getColor\",\n    value: function getColor(feature, step) {\n      if (this._colorFn) return ol_color_asString(this._colorFn(feature, step));\n      var color = this._color;\n      var color2 = this._color2 || this._color;\n      return 'rgba(' + +Math.round(color[0] + (color2[0] - color[0]) * step) + ',' + Math.round(color[1] + (color2[1] - color[1]) * step) + ',' + Math.round(color[2] + (color2[2] - color[2]) * step) + ',' + (color[3] + (color2[3] - color[3]) * step) + ')';\n    }\n    /** Get arrow\r\n     */\n  }, {\n    key: \"getArrow\",\n    value: function getArrow() {\n      return this._arrow;\n    }\n    /** Set arrow\r\n     * @param {number} n -1 | 0 | 1 | 2, default: 0\r\n     */\n  }, {\n    key: \"setArrow\",\n    value: function setArrow(n) {\n      this._arrow = parseInt(n);\n      if (this._arrow < -1 || this._arrow > 2) this._arrow = 0;\n    }\n    /** getArrowSize\r\n     * @return {ol.size}\r\n     */\n  }, {\n    key: \"getArrowSize\",\n    value: function getArrowSize() {\n      return this._arrowSize || [16, 16];\n    }\n    /** setArrowSize\r\n     * @param {number|ol.size} size\r\n     */\n  }, {\n    key: \"setArrowSize\",\n    value: function setArrowSize(size) {\n      if (Array.isArray(size)) this._arrowSize = size;else if (typeof size === 'number') this._arrowSize = [size, size];\n    }\n    /** drawArrow\r\n     * @param {CanvasRenderingContext2D} ctx\r\n     * @param {ol.coordinate} p0\r\n     * @param ol.coordinate} p1\r\n     * @param {number} width\r\n     * @param {number} ratio pixelratio\r\n     * @private\r\n     */\n  }, {\n    key: \"drawArrow\",\n    value: function drawArrow(ctx, p0, p1, width, ratio) {\n      var asize = this.getArrowSize()[0] * ratio;\n      var l = ol_coordinate_dist2d(p0, p1);\n      var dx = (p0[0] - p1[0]) / l;\n      var dy = (p0[1] - p1[1]) / l;\n      width = Math.max(this.getArrowSize()[1] / 2, width / 2) * ratio;\n      ctx.beginPath();\n      ctx.moveTo(p0[0], p0[1]);\n      ctx.lineTo(p0[0] - asize * dx + width * dy, p0[1] - asize * dy - width * dx);\n      ctx.lineTo(p0[0] - asize * dx - width * dy, p0[1] - asize * dy + width * dx);\n      ctx.lineTo(p0[0], p0[1]);\n      ctx.fill();\n    }\n    /** Renderer function\r\n     * @param {Array<ol.coordinate>} geom The pixel coordinates of the geometry in GeoJSON notation\r\n     * @param {ol.render.State} e The olx.render.State of the layer renderer\r\n     */\n  }, {\n    key: \"_render\",\n    value: function _render(geom, e) {\n      if (e.geometry.getType() === 'LineString') {\n        var i,\n          g,\n          p,\n          ctx = e.context;\n        // Get geometry used at drawing\n        if (!this._visible) {\n          var a = e.pixelRatio / e.resolution;\n          var cos = Math.cos(e.rotation);\n          var sin = Math.sin(e.rotation);\n          g = e.geometry.getCoordinates();\n          var dx = geom[0][0] - g[0][0] * a * cos - g[0][1] * a * sin;\n          var dy = geom[0][1] - g[0][0] * a * sin + g[0][1] * a * cos;\n          geom = [];\n          for (i = 0; p = g[i]; i++) {\n            geom[i] = [dx + p[0] * a * cos + p[1] * a * sin, dy + p[0] * a * sin - p[1] * a * cos, p[2]];\n          }\n        }\n        var asize = this.getArrowSize()[0] * e.pixelRatio;\n        ctx.save();\n        // Offsets\n        if (this.getOffset(0)) this._splitAsize(geom, this.getOffset(0) * e.pixelRatio);\n        if (this.getOffset(1)) this._splitAsize(geom, this.getOffset(1) * e.pixelRatio, true);\n        // Arrow 1\n        if (geom.length > 1 && (this.getArrow() === -1 || this.getArrow() === 2)) {\n          p = this._splitAsize(geom, asize);\n          if (this._acolor) ctx.fillStyle = this._acolor;else ctx.fillStyle = this.getColor(e.feature, 0);\n          this.drawArrow(ctx, p[0], p[1], this.getWidth(e.feature, 0), e.pixelRatio);\n        }\n        // Arrow 2 \n        if (geom.length > 1 && this.getArrow() > 0) {\n          p = this._splitAsize(geom, asize, true);\n          if (this._acolor) ctx.fillStyle = this._acolor;else ctx.fillStyle = this.getColor(e.feature, 1);\n          this.drawArrow(ctx, p[0], p[1], this.getWidth(e.feature, 1), e.pixelRatio);\n        }\n\n        // Split into\n        var geoms = this._splitInto(geom, 255, 2);\n        var k = 0;\n        var nb = geoms.length;\n\n        // Draw\n        ctx.lineJoin = 'round';\n        ctx.lineCap = this._lineCap || 'butt';\n        if (geoms.length > 1) {\n          for (k = 0; k < geoms.length; k++) {\n            var step = k / nb;\n            g = geoms[k];\n            ctx.lineWidth = this.getWidth(e.feature, step) * e.pixelRatio;\n            ctx.strokeStyle = this.getColor(e.feature, step);\n            ctx.beginPath();\n            ctx.moveTo(g[0][0], g[0][1]);\n            for (i = 1; p = g[i]; i++) {\n              ctx.lineTo(p[0], p[1]);\n            }\n            ctx.stroke();\n          }\n        }\n        ctx.restore();\n      }\n    }\n    /** Split extremity at\r\n     * @param {ol.geom.LineString} geom\r\n     * @param {number} asize\r\n     * @param {boolean} end start=false or end=true, default false (start)\r\n     */\n  }, {\n    key: \"_splitAsize\",\n    value: function _splitAsize(geom, asize, end) {\n      var p, p1, p0;\n      var dl,\n        d = 0;\n      if (end) p0 = geom.pop();else p0 = geom.shift();\n      p = p0;\n      while (geom.length) {\n        if (end) p1 = geom.pop();else p1 = geom.shift();\n        dl = ol_coordinate_dist2d(p, p1);\n        if (d + dl > asize) {\n          p = [p[0] + (p1[0] - p[0]) * (asize - d) / dl, p[1] + (p1[1] - p[1]) * (asize - d) / dl];\n          dl = ol_coordinate_dist2d(p, p0);\n          if (end) {\n            geom.push(p1);\n            geom.push(p);\n            geom.push([p[0] + (p0[0] - p[0]) / dl, p[1] + (p0[1] - p[1]) / dl]);\n          } else {\n            geom.unshift(p1);\n            geom.unshift(p);\n            geom.unshift([p[0] + (p0[0] - p[0]) / dl, p[1] + (p0[1] - p[1]) / dl]);\n          }\n          break;\n        }\n        d += dl;\n        p = p1;\n      }\n      return [p0, p];\n    }\n    /** Split line geometry into equal length geometries\r\n     * @param {Array<ol.coordinate>} geom\r\n     * @param {number} nb number of resulting geometries, default 255\r\n     * @param {number} nim minimum length of the resulting geometries, default 1\r\n     */\n  }, {\n    key: \"_splitInto\",\n    value: function _splitInto(geom, nb, min) {\n      var i, p;\n      var dt = this._noOverlap ? 1 : .9;\n      // Split geom into equal length geoms\n      var geoms = [];\n      var dl,\n        l = 0;\n      for (i = 1; p = geom[i]; i++) {\n        l += ol_coordinate_dist2d(geom[i - 1], p);\n      }\n      var length = Math.max(min || 2, l / (nb || 255));\n      var p0 = geom[0];\n      l = 0;\n      var g = [p0];\n      i = 1;\n      p = geom[1];\n      while (i < geom.length) {\n        var dx = p[0] - p0[0];\n        var dy = p[1] - p0[1];\n        dl = Math.sqrt(dx * dx + dy * dy);\n        if (l + dl > length) {\n          var d = (length - l) / dl;\n          g.push([p0[0] + dx * d, p0[1] + dy * d]);\n          geoms.push(g);\n          p0 = [p0[0] + dx * d * dt, p0[1] + dy * d * dt];\n          g = [p0];\n          l = 0;\n        } else {\n          l += dl;\n          p0 = p;\n          g.push(p0);\n          i++;\n          p = geom[i];\n        }\n      }\n      geoms.push(g);\n      return geoms;\n    }\n  }]);\n}(ol_style_Style);\nexport default ol_style_FlowLine;","map":{"version":3,"names":["ol_style_Style","asString","ol_color_asString","asArray","ol_color_asArray","ol_coordinate_dist2d","ol_style_FlowLine","_ol_style_Style","olstyleFlowLine","options","_this","_classCallCheck","_callSuper","stroke","text","zIndex","geometry","setRenderer","_render","bind","_visible","visible","width","_widthFn","setWidth","setWidth2","width2","color","_colorFn","setColor","setColor2","color2","setLineCap","lineCap","setArrow","arrow","setArrowSize","arrowSize","setArrowColor","arrowColor","_offset","setOffset","offset0","offset1","_noOverlap","noOverlap","_inherits","_createClass","key","value","_width","_width2","getOffset","where","Math","max","parseFloat","cap","_lineCap","getWidth","feature","step","w2","_color","e","_color2","_acolor","getColor","round","getArrow","_arrow","n","parseInt","getArrowSize","_arrowSize","size","Array","isArray","drawArrow","ctx","p0","p1","ratio","asize","l","dx","dy","beginPath","moveTo","lineTo","fill","geom","getType","i","g","p","context","a","pixelRatio","resolution","cos","rotation","sin","getCoordinates","save","_splitAsize","length","fillStyle","geoms","_splitInto","k","nb","lineJoin","lineWidth","strokeStyle","restore","end","dl","d","pop","shift","push","unshift","min","dt","sqrt"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol-ext/style/FlowLine.js"],"sourcesContent":["/*\tCopyright (c) 2019 Jean-Marc VIGLINO, \r\n  released under the CeCILL-B license (French BSD license)\r\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\n\r\nimport ol_style_Style from 'ol/style/Style.js'\r\nimport {asString as ol_color_asString} from 'ol/color.js'\r\nimport {asArray as ol_color_asArray} from 'ol/color.js'\r\nimport {ol_coordinate_dist2d} from '../geom/GeomUtils.js'\r\nimport '../geom/LineStringSplitAt.js'\r\n\r\n/** Flow line style\r\n * Draw LineString with a variable color / width\r\n * NB: the FlowLine style doesn't impress the hit-detection.\r\n * If you want your lines to be sectionable you have to add your own style to handle this.\r\n * (with transparent line: stroke color opacity to .1 or zero width)\r\n * @constructor\r\n * @extends {ol_style_Style}\r\n * @param {Object} options\r\n *  @param {boolean} options.visible draw only the visible part of the line, default true\r\n *  @param {number|function} options.width Stroke width or a function that gets a feature and the position (beetween [0,1]) and returns current width\r\n *  @param {number} options.width2 Final stroke width (if width is not a function)\r\n *  @param {number} options.arrow Arrow at start (-1), at end (1), at both (2), none (0), default geta\r\n *  @param {ol.colorLike|function} options.color Stroke color or a function that gets a feature and the position (beetween [0,1]) and returns current color\r\n *  @param {ol.colorLike} options.color2 Final sroke color if color is nor a function\r\n *  @param {ol.colorLike} options.arrowColor Color of arrows, if not defined used color or color2\r\n *  @param {string} options.lineCap CanvasRenderingContext2D.lineCap 'butt' | 'round' | 'square', default 'butt'\r\n *  @param {number|ol.size} options.arrowSize height and width of the arrow, default 16\r\n *  @param {boolean} [options.noOverlap=false] prevent segments overlaping\r\n *  @param {number} options.offset0 offset at line start\r\n *  @param {number} options.offset1 offset at line end\r\n */\r\nvar ol_style_FlowLine = class olstyleFlowLine extends ol_style_Style {\r\n  constructor(options) {\r\n    options = options || {}\r\n\r\n    super({\r\n      stroke: options.stroke,\r\n      text: options.text,\r\n      zIndex: options.zIndex,\r\n      geometry: options.geometry\r\n    })\r\n    this.setRenderer(this._render.bind(this))\r\n\r\n    // Draw only visible\r\n    this._visible = (options.visible !== false)\r\n\r\n    // Width\r\n    if (typeof options.width === 'function') {\r\n      this._widthFn = options.width\r\n    } else {\r\n      this.setWidth(options.width)\r\n    }\r\n    this.setWidth2(options.width2)\r\n    // Color\r\n    if (typeof options.color === 'function') {\r\n      this._colorFn = options.color\r\n    } else {\r\n      this.setColor(options.color)\r\n    }\r\n    this.setColor2(options.color2)\r\n    // LineCap\r\n    this.setLineCap(options.lineCap)\r\n    // Arrow\r\n    this.setArrow(options.arrow)\r\n    this.setArrowSize(options.arrowSize)\r\n    this.setArrowColor(options.arrowColor)\r\n    // Offset\r\n    this._offset = [0, 0]\r\n    this.setOffset(options.offset0, 0)\r\n    this.setOffset(options.offset1, 1)\r\n    // Overlap\r\n    this._noOverlap = options.noOverlap\r\n  }\r\n  /** Set the initial width\r\n   * @param {number} width width, default 0\r\n   */\r\n  setWidth(width) {\r\n    this._width = width || 0\r\n  }\r\n  /** Set the final width\r\n   * @param {number} width width, default 0\r\n   */\r\n  setWidth2(width) {\r\n    this._width2 = width\r\n  }\r\n  /** Get offset at start or end\r\n   * @param {number} where 0=start, 1=end\r\n   * @return {number} width\r\n   */\r\n  getOffset(where) {\r\n    return this._offset[where]\r\n  }\r\n  /** Add an offset at start or end\r\n   * @param {number} width\r\n   * @param {number} where 0=start, 1=end\r\n   */\r\n  setOffset(width, where) {\r\n    width = Math.max(0, parseFloat(width))\r\n    switch (where) {\r\n      case 0: {\r\n        this._offset[0] = width\r\n        break\r\n      }\r\n      case 1: {\r\n        this._offset[1] = width\r\n        break\r\n      }\r\n    }\r\n  }\r\n  /** Set the LineCap\r\n   * @param {steing} cap LineCap (round or butt), default butt\r\n   */\r\n  setLineCap(cap) {\r\n    this._lineCap = (cap === 'round' ? 'round' : 'butt')\r\n  }\r\n  /** Get the current width at step\r\n   * @param {ol.feature} feature\r\n   * @param {number} step current drawing step beetween [0,1]\r\n   * @return {number}\r\n   */\r\n  getWidth(feature, step) {\r\n    if (this._widthFn)\r\n      return this._widthFn(feature, step)\r\n    var w2 = (typeof (this._width2) === 'number') ? this._width2 : this._width\r\n    return this._width + (w2 - this._width) * step\r\n  }\r\n  /** Set the initial color\r\n   * @param {ol.colorLike} color\r\n   */\r\n  setColor(color) {\r\n    try {\r\n      this._color = ol_color_asArray(color)\r\n    } catch (e) {\r\n      this._color = [0, 0, 0, 1]\r\n    }\r\n  }\r\n  /** Set the final color\r\n   * @param {ol.colorLike} color\r\n   */\r\n  setColor2(color) {\r\n    try {\r\n      this._color2 = ol_color_asArray(color)\r\n    } catch (e) {\r\n      this._color2 = null\r\n    }\r\n  }\r\n  /** Set the arrow color\r\n   * @param {ol.colorLike} color\r\n   */\r\n  setArrowColor(color) {\r\n    try {\r\n      this._acolor = ol_color_asString(color)\r\n    } catch (e) {\r\n      this._acolor = null\r\n    }\r\n  }\r\n  /** Get the current color at step\r\n   * @param {ol.feature} feature\r\n   * @param {number} step current drawing step beetween [0,1]\r\n   * @return {string}\r\n   */\r\n  getColor(feature, step) {\r\n    if (this._colorFn)\r\n      return ol_color_asString(this._colorFn(feature, step))\r\n    var color = this._color\r\n    var color2 = this._color2 || this._color\r\n    return 'rgba(' +\r\n      +Math.round(color[0] + (color2[0] - color[0]) * step) + ','\r\n      + Math.round(color[1] + (color2[1] - color[1]) * step) + ','\r\n      + Math.round(color[2] + (color2[2] - color[2]) * step) + ','\r\n      + (color[3] + (color2[3] - color[3]) * step)\r\n      + ')'\r\n  }\r\n  /** Get arrow\r\n   */\r\n  getArrow() {\r\n    return this._arrow\r\n  }\r\n  /** Set arrow\r\n   * @param {number} n -1 | 0 | 1 | 2, default: 0\r\n   */\r\n  setArrow(n) {\r\n    this._arrow = parseInt(n)\r\n    if (this._arrow < -1 || this._arrow > 2)\r\n      this._arrow = 0\r\n  }\r\n  /** getArrowSize\r\n   * @return {ol.size}\r\n   */\r\n  getArrowSize() {\r\n    return this._arrowSize || [16, 16]\r\n  }\r\n  /** setArrowSize\r\n   * @param {number|ol.size} size\r\n   */\r\n  setArrowSize(size) {\r\n    if (Array.isArray(size))\r\n      this._arrowSize = size\r\n    else if (typeof (size) === 'number')\r\n      this._arrowSize = [size, size]\r\n  }\r\n  /** drawArrow\r\n   * @param {CanvasRenderingContext2D} ctx\r\n   * @param {ol.coordinate} p0\r\n   * @param ol.coordinate} p1\r\n   * @param {number} width\r\n   * @param {number} ratio pixelratio\r\n   * @private\r\n   */\r\n  drawArrow(ctx, p0, p1, width, ratio) {\r\n    var asize = this.getArrowSize()[0] * ratio\r\n    var l = ol_coordinate_dist2d(p0, p1)\r\n    var dx = (p0[0] - p1[0]) / l\r\n    var dy = (p0[1] - p1[1]) / l\r\n    width = Math.max(this.getArrowSize()[1] / 2, width / 2) * ratio\r\n    ctx.beginPath()\r\n    ctx.moveTo(p0[0], p0[1])\r\n    ctx.lineTo(p0[0] - asize * dx + width * dy, p0[1] - asize * dy - width * dx)\r\n    ctx.lineTo(p0[0] - asize * dx - width * dy, p0[1] - asize * dy + width * dx)\r\n    ctx.lineTo(p0[0], p0[1])\r\n    ctx.fill()\r\n  }\r\n  /** Renderer function\r\n   * @param {Array<ol.coordinate>} geom The pixel coordinates of the geometry in GeoJSON notation\r\n   * @param {ol.render.State} e The olx.render.State of the layer renderer\r\n   */\r\n  _render(geom, e) {\r\n    if (e.geometry.getType() === 'LineString') {\r\n      var i, g, p, ctx = e.context\r\n      // Get geometry used at drawing\r\n      if (!this._visible) {\r\n        var a = e.pixelRatio / e.resolution\r\n        var cos = Math.cos(e.rotation)\r\n        var sin = Math.sin(e.rotation)\r\n        g = e.geometry.getCoordinates()\r\n        var dx = geom[0][0] - g[0][0] * a * cos - g[0][1] * a * sin\r\n        var dy = geom[0][1] - g[0][0] * a * sin + g[0][1] * a * cos\r\n        geom = []\r\n        for (i = 0; p = g[i]; i++) {\r\n          geom[i] = [\r\n            dx + p[0] * a * cos + p[1] * a * sin,\r\n            dy + p[0] * a * sin - p[1] * a * cos,\r\n            p[2]\r\n          ]\r\n        }\r\n      }\r\n\r\n      var asize = this.getArrowSize()[0] * e.pixelRatio\r\n\r\n      ctx.save()\r\n      // Offsets\r\n      if (this.getOffset(0))\r\n        this._splitAsize(geom, this.getOffset(0) * e.pixelRatio)\r\n      if (this.getOffset(1))\r\n        this._splitAsize(geom, this.getOffset(1) * e.pixelRatio, true)\r\n      // Arrow 1\r\n      if (geom.length > 1 && (this.getArrow() === -1 || this.getArrow() === 2)) {\r\n        p = this._splitAsize(geom, asize)\r\n        if (this._acolor)\r\n          ctx.fillStyle = this._acolor\r\n        else\r\n          ctx.fillStyle = this.getColor(e.feature, 0)\r\n        this.drawArrow(ctx, p[0], p[1], this.getWidth(e.feature, 0), e.pixelRatio)\r\n      }\r\n      // Arrow 2 \r\n      if (geom.length > 1 && this.getArrow() > 0) {\r\n        p = this._splitAsize(geom, asize, true)\r\n        if (this._acolor)\r\n          ctx.fillStyle = this._acolor\r\n        else\r\n          ctx.fillStyle = this.getColor(e.feature, 1)\r\n        this.drawArrow(ctx, p[0], p[1], this.getWidth(e.feature, 1), e.pixelRatio)\r\n      }\r\n\r\n      // Split into\r\n      var geoms = this._splitInto(geom, 255, 2)\r\n      var k = 0\r\n      var nb = geoms.length\r\n\r\n      // Draw\r\n      ctx.lineJoin = 'round'\r\n      ctx.lineCap = this._lineCap || 'butt'\r\n\r\n      if (geoms.length > 1) {\r\n        for (k = 0; k < geoms.length; k++) {\r\n          var step = k / nb\r\n          g = geoms[k]\r\n          ctx.lineWidth = this.getWidth(e.feature, step) * e.pixelRatio\r\n          ctx.strokeStyle = this.getColor(e.feature, step)\r\n          ctx.beginPath()\r\n          ctx.moveTo(g[0][0], g[0][1])\r\n          for (i = 1; p = g[i]; i++) {\r\n            ctx.lineTo(p[0], p[1])\r\n          }\r\n          ctx.stroke()\r\n        }\r\n      }\r\n      ctx.restore()\r\n    }\r\n  }\r\n  /** Split extremity at\r\n   * @param {ol.geom.LineString} geom\r\n   * @param {number} asize\r\n   * @param {boolean} end start=false or end=true, default false (start)\r\n   */\r\n  _splitAsize(geom, asize, end) {\r\n    var p, p1, p0\r\n    var dl, d = 0\r\n    if (end)\r\n      p0 = geom.pop()\r\n    else\r\n      p0 = geom.shift()\r\n    p = p0\r\n    while (geom.length) {\r\n      if (end)\r\n        p1 = geom.pop()\r\n      else\r\n        p1 = geom.shift()\r\n      dl = ol_coordinate_dist2d(p, p1)\r\n      if (d + dl > asize) {\r\n        p = [p[0] + (p1[0] - p[0]) * (asize - d) / dl, p[1] + (p1[1] - p[1]) * (asize - d) / dl]\r\n        dl = ol_coordinate_dist2d(p, p0)\r\n        if (end) {\r\n          geom.push(p1)\r\n          geom.push(p)\r\n          geom.push([p[0] + (p0[0] - p[0]) / dl, p[1] + (p0[1] - p[1]) / dl])\r\n        } else {\r\n          geom.unshift(p1)\r\n          geom.unshift(p)\r\n          geom.unshift([p[0] + (p0[0] - p[0]) / dl, p[1] + (p0[1] - p[1]) / dl])\r\n        }\r\n        break\r\n      }\r\n      d += dl\r\n      p = p1\r\n    }\r\n    return [p0, p]\r\n  }\r\n  /** Split line geometry into equal length geometries\r\n   * @param {Array<ol.coordinate>} geom\r\n   * @param {number} nb number of resulting geometries, default 255\r\n   * @param {number} nim minimum length of the resulting geometries, default 1\r\n   */\r\n  _splitInto(geom, nb, min) {\r\n    var i, p\r\n    var dt = this._noOverlap ? 1 : .9\r\n    // Split geom into equal length geoms\r\n    var geoms = []\r\n    var dl, l = 0\r\n    for (i = 1; p = geom[i]; i++) {\r\n      l += ol_coordinate_dist2d(geom[i - 1], p)\r\n    }\r\n    var length = Math.max(min || 2, l / (nb || 255))\r\n    var p0 = geom[0]\r\n    l = 0\r\n    var g = [p0]\r\n    i = 1\r\n    p = geom[1]\r\n    while (i < geom.length) {\r\n      var dx = p[0] - p0[0]\r\n      var dy = p[1] - p0[1]\r\n      dl = Math.sqrt(dx * dx + dy * dy)\r\n      if (l + dl > length) {\r\n        var d = (length - l) / dl\r\n        g.push([\r\n          p0[0] + dx * d,\r\n          p0[1] + dy * d\r\n        ])\r\n        geoms.push(g)\r\n        p0 = [\r\n          p0[0] + dx * d * dt,\r\n          p0[1] + dy * d * dt\r\n        ]\r\n        g = [p0]\r\n        l = 0\r\n      } else {\r\n        l += dl\r\n        p0 = p\r\n        g.push(p0)\r\n        i++\r\n        p = geom[i]\r\n      }\r\n    }\r\n    geoms.push(g)\r\n    return geoms\r\n  }\r\n}\r\n\r\nexport default ol_style_FlowLine\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}