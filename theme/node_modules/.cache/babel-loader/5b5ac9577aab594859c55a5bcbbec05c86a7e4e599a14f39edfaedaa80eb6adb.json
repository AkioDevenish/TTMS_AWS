{"ast":null,"code":"import _classCallCheck from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.slice.js\";\n/**\n * @module ol/render/Feature\n */\nimport Feature from '../Feature.js';\nimport { LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon } from '../geom.js';\nimport { compose as composeTransform, create as createTransform } from '../transform.js';\nimport { createOrUpdateFromCoordinate, createOrUpdateFromFlatCoordinates, getCenter, getHeight } from '../extent.js';\nimport { douglasPeucker, douglasPeuckerArray, quantizeArray } from '../geom/flat/simplify.js';\nimport { extend } from '../array.js';\nimport { getInteriorPointOfArray, getInteriorPointsOfMultiArray } from '../geom/flat/interiorpoint.js';\nimport { get as getProjection } from '../proj.js';\nimport { inflateEnds } from '../geom/flat/orient.js';\nimport { interpolatePoint } from '../geom/flat/interpolate.js';\nimport { linearRingss as linearRingssCenter } from '../geom/flat/center.js';\nimport { memoizeOne } from '../functions.js';\nimport { transform2D } from '../geom/flat/transform.js';\n\n/**\n * @typedef {'Point' | 'LineString' | 'LinearRing' | 'Polygon' | 'MultiPoint' | 'MultiLineString'} Type\n * The geometry type.  One of `'Point'`, `'LineString'`, `'LinearRing'`,\n * `'Polygon'`, `'MultiPoint'` or 'MultiLineString'`.\n */\n\n/**\n * @type {import(\"../transform.js\").Transform}\n */\nvar tmpTransform = createTransform();\n\n/**\n * Lightweight, read-only, {@link module:ol/Feature~Feature} and {@link module:ol/geom/Geometry~Geometry} like\n * structure, optimized for vector tile rendering and styling. Geometry access\n * through the API is limited to getting the type and extent of the geometry.\n */\nvar RenderFeature = /*#__PURE__*/function () {\n  /**\n   * @param {Type} type Geometry type.\n   * @param {Array<number>} flatCoordinates Flat coordinates. These always need\n   *     to be right-handed for polygons.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {Object<string, *>} properties Properties.\n   * @param {number|string|undefined} id Feature id.\n   */\n  function RenderFeature(type, flatCoordinates, ends, stride, properties, id) {\n    _classCallCheck(this, RenderFeature);\n    /**\n     * @type {import(\"../style/Style.js\").StyleFunction|undefined}\n     */\n    this.styleFunction;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent|undefined}\n     */\n    this.extent_;\n\n    /**\n     * @private\n     * @type {number|string|undefined}\n     */\n    this.id_ = id;\n\n    /**\n     * @private\n     * @type {Type}\n     */\n    this.type_ = type;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatCoordinates_ = flatCoordinates;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatInteriorPoints_ = null;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatMidpoints_ = null;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.ends_ = ends;\n\n    /**\n     * @private\n     * @type {Object<string, *>}\n     */\n    this.properties_ = properties;\n\n    /**\n     * @type {number}\n     */\n    this.squaredTolerance_;\n\n    /**\n     * @type {number}\n     */\n    this.stride_ = stride;\n\n    /**\n     * @private\n     * @type {RenderFeature}\n     */\n    this.simplifiedGeometry_;\n  }\n\n  /**\n   * Get a feature property by its key.\n   * @param {string} key Key\n   * @return {*} Value for the requested key.\n   * @api\n   */\n  return _createClass(RenderFeature, [{\n    key: \"get\",\n    value: function get(key) {\n      return this.properties_[key];\n    }\n\n    /**\n     * Get the extent of this feature's geometry.\n     * @return {import(\"../extent.js\").Extent} Extent.\n     * @api\n     */\n  }, {\n    key: \"getExtent\",\n    value: function getExtent() {\n      if (!this.extent_) {\n        this.extent_ = this.type_ === 'Point' ? createOrUpdateFromCoordinate(this.flatCoordinates_) : createOrUpdateFromFlatCoordinates(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2);\n      }\n      return this.extent_;\n    }\n\n    /**\n     * @return {Array<number>} Flat interior points.\n     */\n  }, {\n    key: \"getFlatInteriorPoint\",\n    value: function getFlatInteriorPoint() {\n      if (!this.flatInteriorPoints_) {\n        var flatCenter = getCenter(this.getExtent());\n        this.flatInteriorPoints_ = getInteriorPointOfArray(this.flatCoordinates_, 0, /** @type {Array<number>} */this.ends_, 2, flatCenter, 0);\n      }\n      return this.flatInteriorPoints_;\n    }\n\n    /**\n     * @return {Array<number>} Flat interior points.\n     */\n  }, {\n    key: \"getFlatInteriorPoints\",\n    value: function getFlatInteriorPoints() {\n      if (!this.flatInteriorPoints_) {\n        var ends = inflateEnds(this.flatCoordinates_, this.ends_);\n        var flatCenters = linearRingssCenter(this.flatCoordinates_, 0, ends, 2);\n        this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.flatCoordinates_, 0, ends, 2, flatCenters);\n      }\n      return this.flatInteriorPoints_;\n    }\n\n    /**\n     * @return {Array<number>} Flat midpoint.\n     */\n  }, {\n    key: \"getFlatMidpoint\",\n    value: function getFlatMidpoint() {\n      if (!this.flatMidpoints_) {\n        this.flatMidpoints_ = interpolatePoint(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, 0.5);\n      }\n      return this.flatMidpoints_;\n    }\n\n    /**\n     * @return {Array<number>} Flat midpoints.\n     */\n  }, {\n    key: \"getFlatMidpoints\",\n    value: function getFlatMidpoints() {\n      if (!this.flatMidpoints_) {\n        this.flatMidpoints_ = [];\n        var flatCoordinates = this.flatCoordinates_;\n        var offset = 0;\n        var ends = /** @type {Array<number>} */this.ends_;\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n          var end = ends[i];\n          var midpoint = interpolatePoint(flatCoordinates, offset, end, 2, 0.5);\n          extend(this.flatMidpoints_, midpoint);\n          offset = end;\n        }\n      }\n      return this.flatMidpoints_;\n    }\n\n    /**\n     * Get the feature identifier.  This is a stable identifier for the feature and\n     * is set when reading data from a remote source.\n     * @return {number|string|undefined} Id.\n     * @api\n     */\n  }, {\n    key: \"getId\",\n    value: function getId() {\n      return this.id_;\n    }\n\n    /**\n     * @return {Array<number>} Flat coordinates.\n     */\n  }, {\n    key: \"getOrientedFlatCoordinates\",\n    value: function getOrientedFlatCoordinates() {\n      return this.flatCoordinates_;\n    }\n\n    /**\n     * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when\n     * determining the geometry type in style function (see {@link #getType}).\n     * @return {RenderFeature} Feature.\n     * @api\n     */\n  }, {\n    key: \"getGeometry\",\n    value: function getGeometry() {\n      return this;\n    }\n\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {RenderFeature} Simplified geometry.\n     */\n  }, {\n    key: \"getSimplifiedGeometry\",\n    value: function getSimplifiedGeometry(squaredTolerance) {\n      return this;\n    }\n\n    /**\n     * Get a transformed and simplified version of the geometry.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\n     * @return {RenderFeature} Simplified geometry.\n     */\n  }, {\n    key: \"simplifyTransformed\",\n    value: function simplifyTransformed(squaredTolerance, transform) {\n      return this;\n    }\n\n    /**\n     * Get the feature properties.\n     * @return {Object<string, *>} Feature properties.\n     * @api\n     */\n  }, {\n    key: \"getProperties\",\n    value: function getProperties() {\n      return this.properties_;\n    }\n\n    /**\n     * Get an object of all property names and values.  This has the same behavior as getProperties,\n     * but is here to conform with the {@link module:ol/Feature~Feature} interface.\n     * @return {Object<string, *>?} Object.\n     */\n  }, {\n    key: \"getPropertiesInternal\",\n    value: function getPropertiesInternal() {\n      return this.properties_;\n    }\n\n    /**\n     * @return {number} Stride.\n     */\n  }, {\n    key: \"getStride\",\n    value: function getStride() {\n      return this.stride_;\n    }\n\n    /**\n     * @return {import('../style/Style.js').StyleFunction|undefined} Style\n     */\n  }, {\n    key: \"getStyleFunction\",\n    value: function getStyleFunction() {\n      return this.styleFunction;\n    }\n\n    /**\n     * Get the type of this feature's geometry.\n     * @return {Type} Geometry type.\n     * @api\n     */\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return this.type_;\n    }\n\n    /**\n     * Transform geometry coordinates from tile pixel space to projected.\n     *\n     * @param {import(\"../proj.js\").ProjectionLike} projection The data projection\n     */\n  }, {\n    key: \"transform\",\n    value: function transform(projection) {\n      projection = getProjection(projection);\n      var pixelExtent = projection.getExtent();\n      var projectedExtent = projection.getWorldExtent();\n      if (pixelExtent && projectedExtent) {\n        var scale = getHeight(projectedExtent) / getHeight(pixelExtent);\n        composeTransform(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);\n        transform2D(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, tmpTransform, this.flatCoordinates_);\n      }\n    }\n\n    /**\n     * Apply a transform function to the coordinates of the geometry.\n     * The geometry is modified in place.\n     * If you do not want the geometry modified in place, first `clone()` it and\n     * then use this function on the clone.\n     * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n     */\n  }, {\n    key: \"applyTransform\",\n    value: function applyTransform(transformFn) {\n      transformFn(this.flatCoordinates_, this.flatCoordinates_, this.stride_);\n    }\n\n    /**\n     * @return {RenderFeature} A cloned render feature.\n     */\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new RenderFeature(this.type_, this.flatCoordinates_.slice(), this.ends_.slice(), this.stride_, Object.assign({}, this.properties_), this.id_);\n    }\n\n    /**\n     * @return {Array<number>} Ends.\n     */\n  }, {\n    key: \"getEnds\",\n    value: function getEnds() {\n      return this.ends_;\n    }\n\n    /**\n     * Add transform and resolution based geometry simplification to this instance.\n     * @return {RenderFeature} This render feature.\n     */\n  }, {\n    key: \"enableSimplifyTransformed\",\n    value: function enableSimplifyTransformed() {\n      var _this = this;\n      this.simplifyTransformed = memoizeOne(function (squaredTolerance, transform) {\n        if (squaredTolerance === _this.squaredTolerance_) {\n          return _this.simplifiedGeometry_;\n        }\n        _this.simplifiedGeometry_ = _this.clone();\n        if (transform) {\n          _this.simplifiedGeometry_.applyTransform(transform);\n        }\n        var simplifiedFlatCoordinates = _this.simplifiedGeometry_.getFlatCoordinates();\n        var simplifiedEnds;\n        switch (_this.type_) {\n          case 'LineString':\n            simplifiedFlatCoordinates.length = douglasPeucker(simplifiedFlatCoordinates, 0, _this.simplifiedGeometry_.flatCoordinates_.length, _this.simplifiedGeometry_.stride_, squaredTolerance, simplifiedFlatCoordinates, 0);\n            simplifiedEnds = [simplifiedFlatCoordinates.length];\n            break;\n          case 'MultiLineString':\n            simplifiedEnds = [];\n            simplifiedFlatCoordinates.length = douglasPeuckerArray(simplifiedFlatCoordinates, 0, _this.simplifiedGeometry_.ends_, _this.simplifiedGeometry_.stride_, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);\n            break;\n          case 'Polygon':\n            simplifiedEnds = [];\n            simplifiedFlatCoordinates.length = quantizeArray(simplifiedFlatCoordinates, 0, _this.simplifiedGeometry_.ends_, _this.simplifiedGeometry_.stride_, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);\n            break;\n          default:\n        }\n        if (simplifiedEnds) {\n          _this.simplifiedGeometry_ = new RenderFeature(_this.type_, simplifiedFlatCoordinates, simplifiedEnds, 2, _this.properties_, _this.id_);\n        }\n        _this.squaredTolerance_ = squaredTolerance;\n        return _this.simplifiedGeometry_;\n      });\n      return this;\n    }\n  }]);\n}();\n/**\n * @return {Array<number>} Flat coordinates.\n */\nRenderFeature.prototype.getFlatCoordinates = RenderFeature.prototype.getOrientedFlatCoordinates;\n\n/**\n * Create a geometry from an `ol/render/Feature`\n * @param {RenderFeature} renderFeature\n * Render Feature\n * @return {Point|MultiPoint|LineString|MultiLineString|Polygon|MultiPolygon}\n * New geometry instance.\n * @api\n */\nexport function toGeometry(renderFeature) {\n  var geometryType = renderFeature.getType();\n  switch (geometryType) {\n    case 'Point':\n      return new Point(renderFeature.getFlatCoordinates());\n    case 'MultiPoint':\n      return new MultiPoint(renderFeature.getFlatCoordinates(), 'XY');\n    case 'LineString':\n      return new LineString(renderFeature.getFlatCoordinates(), 'XY');\n    case 'MultiLineString':\n      return new MultiLineString(renderFeature.getFlatCoordinates(), 'XY', /** @type {Array<number>} */renderFeature.getEnds());\n    case 'Polygon':\n      var flatCoordinates = renderFeature.getFlatCoordinates();\n      var ends = /** @type {Array<number>} */renderFeature.getEnds();\n      var endss = inflateEnds(flatCoordinates, ends);\n      return endss.length > 1 ? new MultiPolygon(flatCoordinates, 'XY', endss) : new Polygon(flatCoordinates, 'XY', ends);\n    default:\n      throw new Error('Invalid geometry type:' + geometryType);\n  }\n}\n\n/**\n * Create an `ol/Feature` from an `ol/render/Feature`\n * @param {RenderFeature} renderFeature RenderFeature\n * @param {string} [geometryName='geometry'] Geometry name to use\n * when creating the Feature.\n * @return {Feature} Newly constructed `ol/Feature` with properties,\n * geometry, and id copied over.\n * @api\n */\nexport function toFeature(renderFeature, geometryName) {\n  var id = renderFeature.getId();\n  var geometry = toGeometry(renderFeature);\n  var properties = renderFeature.getProperties();\n  var feature = new Feature();\n  if (geometryName !== undefined) {\n    feature.setGeometryName(geometryName);\n  }\n  feature.setGeometry(geometry);\n  if (id !== undefined) {\n    feature.setId(id);\n  }\n  feature.setProperties(properties, true);\n  return feature;\n}\nexport default RenderFeature;","map":{"version":3,"names":["Feature","LineString","MultiLineString","MultiPoint","MultiPolygon","Point","Polygon","compose","composeTransform","create","createTransform","createOrUpdateFromCoordinate","createOrUpdateFromFlatCoordinates","getCenter","getHeight","douglasPeucker","douglasPeuckerArray","quantizeArray","extend","getInteriorPointOfArray","getInteriorPointsOfMultiArray","get","getProjection","inflateEnds","interpolatePoint","linearRingss","linearRingssCenter","memoizeOne","transform2D","tmpTransform","RenderFeature","type","flatCoordinates","ends","stride","properties","id","_classCallCheck","styleFunction","extent_","id_","type_","flatCoordinates_","flatInteriorPoints_","flatMidpoints_","ends_","properties_","squaredTolerance_","stride_","simplifiedGeometry_","_createClass","key","value","getExtent","length","getFlatInteriorPoint","flatCenter","getFlatInteriorPoints","flatCenters","getFlatMidpoint","getFlatMidpoints","offset","i","ii","end","midpoint","getId","getOrientedFlatCoordinates","getGeometry","getSimplifiedGeometry","squaredTolerance","simplifyTransformed","transform","getProperties","getPropertiesInternal","getStride","getStyleFunction","getType","projection","pixelExtent","projectedExtent","getWorldExtent","scale","applyTransform","transformFn","clone","slice","Object","assign","getEnds","enableSimplifyTransformed","_this","simplifiedFlatCoordinates","getFlatCoordinates","simplifiedEnds","Math","sqrt","prototype","toGeometry","renderFeature","geometryType","endss","Error","toFeature","geometryName","geometry","feature","undefined","setGeometryName","setGeometry","setId","setProperties"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol/render/Feature.js"],"sourcesContent":["/**\n * @module ol/render/Feature\n */\nimport Feature from '../Feature.js';\nimport {\n  LineString,\n  MultiLineString,\n  MultiPoint,\n  MultiPolygon,\n  Point,\n  Polygon,\n} from '../geom.js';\nimport {\n  compose as composeTransform,\n  create as createTransform,\n} from '../transform.js';\nimport {\n  createOrUpdateFromCoordinate,\n  createOrUpdateFromFlatCoordinates,\n  getCenter,\n  getHeight,\n} from '../extent.js';\nimport {\n  douglasPeucker,\n  douglasPeuckerArray,\n  quantizeArray,\n} from '../geom/flat/simplify.js';\nimport {extend} from '../array.js';\nimport {\n  getInteriorPointOfArray,\n  getInteriorPointsOfMultiArray,\n} from '../geom/flat/interiorpoint.js';\nimport {get as getProjection} from '../proj.js';\nimport {inflateEnds} from '../geom/flat/orient.js';\nimport {interpolatePoint} from '../geom/flat/interpolate.js';\nimport {linearRingss as linearRingssCenter} from '../geom/flat/center.js';\nimport {memoizeOne} from '../functions.js';\nimport {transform2D} from '../geom/flat/transform.js';\n\n/**\n * @typedef {'Point' | 'LineString' | 'LinearRing' | 'Polygon' | 'MultiPoint' | 'MultiLineString'} Type\n * The geometry type.  One of `'Point'`, `'LineString'`, `'LinearRing'`,\n * `'Polygon'`, `'MultiPoint'` or 'MultiLineString'`.\n */\n\n/**\n * @type {import(\"../transform.js\").Transform}\n */\nconst tmpTransform = createTransform();\n\n/**\n * Lightweight, read-only, {@link module:ol/Feature~Feature} and {@link module:ol/geom/Geometry~Geometry} like\n * structure, optimized for vector tile rendering and styling. Geometry access\n * through the API is limited to getting the type and extent of the geometry.\n */\nclass RenderFeature {\n  /**\n   * @param {Type} type Geometry type.\n   * @param {Array<number>} flatCoordinates Flat coordinates. These always need\n   *     to be right-handed for polygons.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {Object<string, *>} properties Properties.\n   * @param {number|string|undefined} id Feature id.\n   */\n  constructor(type, flatCoordinates, ends, stride, properties, id) {\n    /**\n     * @type {import(\"../style/Style.js\").StyleFunction|undefined}\n     */\n    this.styleFunction;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent|undefined}\n     */\n    this.extent_;\n\n    /**\n     * @private\n     * @type {number|string|undefined}\n     */\n    this.id_ = id;\n\n    /**\n     * @private\n     * @type {Type}\n     */\n    this.type_ = type;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatCoordinates_ = flatCoordinates;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatInteriorPoints_ = null;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatMidpoints_ = null;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.ends_ = ends;\n\n    /**\n     * @private\n     * @type {Object<string, *>}\n     */\n    this.properties_ = properties;\n\n    /**\n     * @type {number}\n     */\n    this.squaredTolerance_;\n\n    /**\n     * @type {number}\n     */\n    this.stride_ = stride;\n\n    /**\n     * @private\n     * @type {RenderFeature}\n     */\n    this.simplifiedGeometry_;\n  }\n\n  /**\n   * Get a feature property by its key.\n   * @param {string} key Key\n   * @return {*} Value for the requested key.\n   * @api\n   */\n  get(key) {\n    return this.properties_[key];\n  }\n\n  /**\n   * Get the extent of this feature's geometry.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getExtent() {\n    if (!this.extent_) {\n      this.extent_ =\n        this.type_ === 'Point'\n          ? createOrUpdateFromCoordinate(this.flatCoordinates_)\n          : createOrUpdateFromFlatCoordinates(\n              this.flatCoordinates_,\n              0,\n              this.flatCoordinates_.length,\n              2\n            );\n    }\n    return this.extent_;\n  }\n\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  getFlatInteriorPoint() {\n    if (!this.flatInteriorPoints_) {\n      const flatCenter = getCenter(this.getExtent());\n      this.flatInteriorPoints_ = getInteriorPointOfArray(\n        this.flatCoordinates_,\n        0,\n        /** @type {Array<number>} */ (this.ends_),\n        2,\n        flatCenter,\n        0\n      );\n    }\n    return this.flatInteriorPoints_;\n  }\n\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  getFlatInteriorPoints() {\n    if (!this.flatInteriorPoints_) {\n      const ends = inflateEnds(this.flatCoordinates_, this.ends_);\n      const flatCenters = linearRingssCenter(this.flatCoordinates_, 0, ends, 2);\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(\n        this.flatCoordinates_,\n        0,\n        ends,\n        2,\n        flatCenters\n      );\n    }\n    return this.flatInteriorPoints_;\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoint.\n   */\n  getFlatMidpoint() {\n    if (!this.flatMidpoints_) {\n      this.flatMidpoints_ = interpolatePoint(\n        this.flatCoordinates_,\n        0,\n        this.flatCoordinates_.length,\n        2,\n        0.5\n      );\n    }\n    return this.flatMidpoints_;\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoints.\n   */\n  getFlatMidpoints() {\n    if (!this.flatMidpoints_) {\n      this.flatMidpoints_ = [];\n      const flatCoordinates = this.flatCoordinates_;\n      let offset = 0;\n      const ends = /** @type {Array<number>} */ (this.ends_);\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        const end = ends[i];\n        const midpoint = interpolatePoint(flatCoordinates, offset, end, 2, 0.5);\n        extend(this.flatMidpoints_, midpoint);\n        offset = end;\n      }\n    }\n    return this.flatMidpoints_;\n  }\n\n  /**\n   * Get the feature identifier.  This is a stable identifier for the feature and\n   * is set when reading data from a remote source.\n   * @return {number|string|undefined} Id.\n   * @api\n   */\n  getId() {\n    return this.id_;\n  }\n\n  /**\n   * @return {Array<number>} Flat coordinates.\n   */\n  getOrientedFlatCoordinates() {\n    return this.flatCoordinates_;\n  }\n\n  /**\n   * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when\n   * determining the geometry type in style function (see {@link #getType}).\n   * @return {RenderFeature} Feature.\n   * @api\n   */\n  getGeometry() {\n    return this;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {RenderFeature} Simplified geometry.\n   */\n  getSimplifiedGeometry(squaredTolerance) {\n    return this;\n  }\n\n  /**\n   * Get a transformed and simplified version of the geometry.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\n   * @return {RenderFeature} Simplified geometry.\n   */\n  simplifyTransformed(squaredTolerance, transform) {\n    return this;\n  }\n\n  /**\n   * Get the feature properties.\n   * @return {Object<string, *>} Feature properties.\n   * @api\n   */\n  getProperties() {\n    return this.properties_;\n  }\n\n  /**\n   * Get an object of all property names and values.  This has the same behavior as getProperties,\n   * but is here to conform with the {@link module:ol/Feature~Feature} interface.\n   * @return {Object<string, *>?} Object.\n   */\n  getPropertiesInternal() {\n    return this.properties_;\n  }\n\n  /**\n   * @return {number} Stride.\n   */\n  getStride() {\n    return this.stride_;\n  }\n\n  /**\n   * @return {import('../style/Style.js').StyleFunction|undefined} Style\n   */\n  getStyleFunction() {\n    return this.styleFunction;\n  }\n\n  /**\n   * Get the type of this feature's geometry.\n   * @return {Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return this.type_;\n  }\n\n  /**\n   * Transform geometry coordinates from tile pixel space to projected.\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} projection The data projection\n   */\n  transform(projection) {\n    projection = getProjection(projection);\n    const pixelExtent = projection.getExtent();\n    const projectedExtent = projection.getWorldExtent();\n    if (pixelExtent && projectedExtent) {\n      const scale = getHeight(projectedExtent) / getHeight(pixelExtent);\n      composeTransform(\n        tmpTransform,\n        projectedExtent[0],\n        projectedExtent[3],\n        scale,\n        -scale,\n        0,\n        0,\n        0\n      );\n      transform2D(\n        this.flatCoordinates_,\n        0,\n        this.flatCoordinates_.length,\n        2,\n        tmpTransform,\n        this.flatCoordinates_\n      );\n    }\n  }\n\n  /**\n   * Apply a transform function to the coordinates of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n   */\n  applyTransform(transformFn) {\n    transformFn(this.flatCoordinates_, this.flatCoordinates_, this.stride_);\n  }\n\n  /**\n   * @return {RenderFeature} A cloned render feature.\n   */\n  clone() {\n    return new RenderFeature(\n      this.type_,\n      this.flatCoordinates_.slice(),\n      this.ends_.slice(),\n      this.stride_,\n      Object.assign({}, this.properties_),\n      this.id_\n    );\n  }\n\n  /**\n   * @return {Array<number>} Ends.\n   */\n  getEnds() {\n    return this.ends_;\n  }\n\n  /**\n   * Add transform and resolution based geometry simplification to this instance.\n   * @return {RenderFeature} This render feature.\n   */\n  enableSimplifyTransformed() {\n    this.simplifyTransformed = memoizeOne((squaredTolerance, transform) => {\n      if (squaredTolerance === this.squaredTolerance_) {\n        return this.simplifiedGeometry_;\n      }\n      this.simplifiedGeometry_ = this.clone();\n      if (transform) {\n        this.simplifiedGeometry_.applyTransform(transform);\n      }\n      const simplifiedFlatCoordinates =\n        this.simplifiedGeometry_.getFlatCoordinates();\n      let simplifiedEnds;\n      switch (this.type_) {\n        case 'LineString':\n          simplifiedFlatCoordinates.length = douglasPeucker(\n            simplifiedFlatCoordinates,\n            0,\n            this.simplifiedGeometry_.flatCoordinates_.length,\n            this.simplifiedGeometry_.stride_,\n            squaredTolerance,\n            simplifiedFlatCoordinates,\n            0\n          );\n          simplifiedEnds = [simplifiedFlatCoordinates.length];\n          break;\n        case 'MultiLineString':\n          simplifiedEnds = [];\n          simplifiedFlatCoordinates.length = douglasPeuckerArray(\n            simplifiedFlatCoordinates,\n            0,\n            this.simplifiedGeometry_.ends_,\n            this.simplifiedGeometry_.stride_,\n            squaredTolerance,\n            simplifiedFlatCoordinates,\n            0,\n            simplifiedEnds\n          );\n          break;\n        case 'Polygon':\n          simplifiedEnds = [];\n          simplifiedFlatCoordinates.length = quantizeArray(\n            simplifiedFlatCoordinates,\n            0,\n            this.simplifiedGeometry_.ends_,\n            this.simplifiedGeometry_.stride_,\n            Math.sqrt(squaredTolerance),\n            simplifiedFlatCoordinates,\n            0,\n            simplifiedEnds\n          );\n          break;\n        default:\n      }\n      if (simplifiedEnds) {\n        this.simplifiedGeometry_ = new RenderFeature(\n          this.type_,\n          simplifiedFlatCoordinates,\n          simplifiedEnds,\n          2,\n          this.properties_,\n          this.id_\n        );\n      }\n      this.squaredTolerance_ = squaredTolerance;\n      return this.simplifiedGeometry_;\n    });\n    return this;\n  }\n}\n\n/**\n * @return {Array<number>} Flat coordinates.\n */\nRenderFeature.prototype.getFlatCoordinates =\n  RenderFeature.prototype.getOrientedFlatCoordinates;\n\n/**\n * Create a geometry from an `ol/render/Feature`\n * @param {RenderFeature} renderFeature\n * Render Feature\n * @return {Point|MultiPoint|LineString|MultiLineString|Polygon|MultiPolygon}\n * New geometry instance.\n * @api\n */\nexport function toGeometry(renderFeature) {\n  const geometryType = renderFeature.getType();\n  switch (geometryType) {\n    case 'Point':\n      return new Point(renderFeature.getFlatCoordinates());\n    case 'MultiPoint':\n      return new MultiPoint(renderFeature.getFlatCoordinates(), 'XY');\n    case 'LineString':\n      return new LineString(renderFeature.getFlatCoordinates(), 'XY');\n    case 'MultiLineString':\n      return new MultiLineString(\n        renderFeature.getFlatCoordinates(),\n        'XY',\n        /** @type {Array<number>} */ (renderFeature.getEnds())\n      );\n    case 'Polygon':\n      const flatCoordinates = renderFeature.getFlatCoordinates();\n      const ends = /** @type {Array<number>} */ (renderFeature.getEnds());\n      const endss = inflateEnds(flatCoordinates, ends);\n      return endss.length > 1\n        ? new MultiPolygon(flatCoordinates, 'XY', endss)\n        : new Polygon(flatCoordinates, 'XY', ends);\n    default:\n      throw new Error('Invalid geometry type:' + geometryType);\n  }\n}\n\n/**\n * Create an `ol/Feature` from an `ol/render/Feature`\n * @param {RenderFeature} renderFeature RenderFeature\n * @param {string} [geometryName='geometry'] Geometry name to use\n * when creating the Feature.\n * @return {Feature} Newly constructed `ol/Feature` with properties,\n * geometry, and id copied over.\n * @api\n */\nexport function toFeature(renderFeature, geometryName) {\n  const id = renderFeature.getId();\n  const geometry = toGeometry(renderFeature);\n  const properties = renderFeature.getProperties();\n  const feature = new Feature();\n  if (geometryName !== undefined) {\n    feature.setGeometryName(geometryName);\n  }\n  feature.setGeometry(geometry);\n  if (id !== undefined) {\n    feature.setId(id);\n  }\n  feature.setProperties(properties, true);\n  return feature;\n}\n\nexport default RenderFeature;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}