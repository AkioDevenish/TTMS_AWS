{"ast":null,"code":"import _classCallCheck from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _callSuper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.parse-float.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.string.substr.js\";\n/**\n * @module ol/format/GML3\n */\nimport GML2 from './GML2.js';\nimport GMLBase, { GMLNS } from './GMLBase.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Polygon from '../geom/Polygon.js';\nimport { OBJECT_PROPERTY_NODE_FACTORY, XML_SCHEMA_INSTANCE_URI, createElementNS, getAllTextContent, makeArrayExtender, makeArrayPusher, makeChildAppender, makeReplacer, makeSimpleNodeFactory, parseNode, pushParseAndPop, pushSerializeAndPop } from '../xml.js';\nimport { createOrUpdate } from '../extent.js';\nimport { extend } from '../array.js';\nimport { get as getProjection } from '../proj.js';\nimport { readNonNegativeIntegerString, writeStringTextNode } from './xsd.js';\nimport { transformExtentWithOptions, transformGeometryWithOptions } from './Feature.js';\n\n/**\n * @const\n * @type {string}\n * @private\n */\nvar schemaLocation = GMLNS + ' http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/' + '1.0.0/gmlsf.xsd';\n\n/**\n * @const\n * @type {Object<string, string>}\n */\nvar MULTIGEOMETRY_TO_MEMBER_NODENAME = {\n  'MultiLineString': 'lineStringMember',\n  'MultiCurve': 'curveMember',\n  'MultiPolygon': 'polygonMember',\n  'MultiSurface': 'surfaceMember'\n};\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the GML format\n * version 3.1.1.\n * Currently only supports GML 3.1.1 Simple Features profile.\n *\n * @api\n */\nvar GML3 = /*#__PURE__*/function (_GMLBase) {\n  /**\n   * @param {import(\"./GMLBase.js\").Options} [options] Optional configuration object.\n   */\n  function GML3(options) {\n    var _this;\n    _classCallCheck(this, GML3);\n    options = options ? options : {};\n    _this = _callSuper(this, GML3, [options]);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.surface_ = options.surface !== undefined ? options.surface : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.curve_ = options.curve !== undefined ? options.curve : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.multiCurve_ = options.multiCurve !== undefined ? options.multiCurve : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.multiSurface_ = options.multiSurface !== undefined ? options.multiSurface : true;\n\n    /**\n     * @type {string}\n     */\n    _this.schemaLocation = options.schemaLocation ? options.schemaLocation : schemaLocation;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.hasZ = options.hasZ !== undefined ? options.hasZ : false;\n    return _this;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiLineString|undefined} MultiLineString.\n   */\n  _inherits(GML3, _GMLBase);\n  return _createClass(GML3, [{\n    key: \"readMultiCurve\",\n    value: function readMultiCurve(node, objectStack) {\n      /** @type {Array<LineString>} */\n      var lineStrings = pushParseAndPop([], this.MULTICURVE_PARSERS, node, objectStack, this);\n      if (lineStrings) {\n        var multiLineString = new MultiLineString(lineStrings);\n        return multiLineString;\n      }\n      return undefined;\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {Array<number>|undefined} Polygon.\n     */\n  }, {\n    key: \"readFlatCurveRing\",\n    value: function readFlatCurveRing(node, objectStack) {\n      /** @type {Array<LineString>} */\n      var lineStrings = pushParseAndPop([], this.MULTICURVE_PARSERS, node, objectStack, this);\n      var flatCoordinates = [];\n      for (var i = 0, ii = lineStrings.length; i < ii; ++i) {\n        extend(flatCoordinates, lineStrings[i].getFlatCoordinates());\n      }\n      return flatCoordinates;\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {MultiPolygon|undefined} MultiPolygon.\n     */\n  }, {\n    key: \"readMultiSurface\",\n    value: function readMultiSurface(node, objectStack) {\n      /** @type {Array<Polygon>} */\n      var polygons = pushParseAndPop([], this.MULTISURFACE_PARSERS, node, objectStack, this);\n      if (polygons) {\n        return new MultiPolygon(polygons);\n      }\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n  }, {\n    key: \"curveMemberParser\",\n    value: function curveMemberParser(node, objectStack) {\n      parseNode(this.CURVEMEMBER_PARSERS, node, objectStack, this);\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n  }, {\n    key: \"surfaceMemberParser\",\n    value: function surfaceMemberParser(node, objectStack) {\n      parseNode(this.SURFACEMEMBER_PARSERS, node, objectStack, this);\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {Array<(Array<number>)>|undefined} flat coordinates.\n     */\n  }, {\n    key: \"readPatch\",\n    value: function readPatch(node, objectStack) {\n      return pushParseAndPop([null], this.PATCHES_PARSERS, node, objectStack, this);\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {Array<number>|undefined} flat coordinates.\n     */\n  }, {\n    key: \"readSegment\",\n    value: function readSegment(node, objectStack) {\n      return pushParseAndPop([], this.SEGMENTS_PARSERS, node, objectStack, this);\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {Array<(Array<number>)>|undefined} flat coordinates.\n     */\n  }, {\n    key: \"readPolygonPatch\",\n    value: function readPolygonPatch(node, objectStack) {\n      return pushParseAndPop([null], this.FLAT_LINEAR_RINGS_PARSERS, node, objectStack, this);\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {Array<number>|undefined} flat coordinates.\n     */\n  }, {\n    key: \"readLineStringSegment\",\n    value: function readLineStringSegment(node, objectStack) {\n      return pushParseAndPop([null], this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n  }, {\n    key: \"interiorParser\",\n    value: function interiorParser(node, objectStack) {\n      /** @type {Array<number>|undefined} */\n      var flatLinearRing = pushParseAndPop(undefined, this.RING_PARSERS, node, objectStack, this);\n      if (flatLinearRing) {\n        var flatLinearRings = /** @type {Array<Array<number>>} */\n        objectStack[objectStack.length - 1];\n        flatLinearRings.push(flatLinearRing);\n      }\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n  }, {\n    key: \"exteriorParser\",\n    value: function exteriorParser(node, objectStack) {\n      /** @type {Array<number>|undefined} */\n      var flatLinearRing = pushParseAndPop(undefined, this.RING_PARSERS, node, objectStack, this);\n      if (flatLinearRing) {\n        var flatLinearRings = /** @type {Array<Array<number>>} */\n        objectStack[objectStack.length - 1];\n        flatLinearRings[0] = flatLinearRing;\n      }\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {Polygon|undefined} Polygon.\n     */\n  }, {\n    key: \"readSurface\",\n    value: function readSurface(node, objectStack) {\n      /** @type {Array<Array<number>>} */\n      var flatLinearRings = pushParseAndPop([null], this.SURFACE_PARSERS, node, objectStack, this);\n      if (flatLinearRings && flatLinearRings[0]) {\n        var flatCoordinates = flatLinearRings[0];\n        var ends = [flatCoordinates.length];\n        var i, ii;\n        for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n          extend(flatCoordinates, flatLinearRings[i]);\n          ends.push(flatCoordinates.length);\n        }\n        return new Polygon(flatCoordinates, 'XYZ', ends);\n      }\n      return undefined;\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {LineString|undefined} LineString.\n     */\n  }, {\n    key: \"readCurve\",\n    value: function readCurve(node, objectStack) {\n      /** @type {Array<number>} */\n      var flatCoordinates = pushParseAndPop([null], this.CURVE_PARSERS, node, objectStack, this);\n      if (flatCoordinates) {\n        var lineString = new LineString(flatCoordinates, 'XYZ');\n        return lineString;\n      }\n      return undefined;\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {import(\"../extent.js\").Extent|undefined} Envelope.\n     */\n  }, {\n    key: \"readEnvelope\",\n    value: function readEnvelope(node, objectStack) {\n      /** @type {Array<number>} */\n      var flatCoordinates = pushParseAndPop([null], this.ENVELOPE_PARSERS, node, objectStack, this);\n      return createOrUpdate(flatCoordinates[1][0], flatCoordinates[1][1], flatCoordinates[2][0], flatCoordinates[2][1]);\n    }\n\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {Array<number>|undefined} Flat coordinates.\n     */\n  }, {\n    key: \"readFlatPos\",\n    value: function readFlatPos(node, objectStack) {\n      var s = getAllTextContent(node, false);\n      var re = /^\\s*([+\\-]?\\d*\\.?\\d+(?:[eE][+\\-]?\\d+)?)\\s*/;\n      /** @type {Array<number>} */\n      var flatCoordinates = [];\n      var m;\n      while (m = re.exec(s)) {\n        flatCoordinates.push(parseFloat(m[1]));\n        s = s.substr(m[0].length);\n      }\n      if (s !== '') {\n        return undefined;\n      }\n      var context = objectStack[0];\n      var containerSrs = context['srsName'];\n      var axisOrientation = 'enu';\n      if (containerSrs) {\n        var proj = getProjection(containerSrs);\n        axisOrientation = proj.getAxisOrientation();\n      }\n      if (axisOrientation === 'neu') {\n        var i, ii;\n        for (i = 0, ii = flatCoordinates.length; i < ii; i += 3) {\n          var y = flatCoordinates[i];\n          var x = flatCoordinates[i + 1];\n          flatCoordinates[i] = x;\n          flatCoordinates[i + 1] = y;\n        }\n      }\n      var len = flatCoordinates.length;\n      if (len == 2) {\n        flatCoordinates.push(0);\n      }\n      if (len === 0) {\n        return undefined;\n      }\n      return flatCoordinates;\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     * @return {Array<number>|undefined} Flat coordinates.\n     */\n  }, {\n    key: \"readFlatPosList\",\n    value: function readFlatPosList(node, objectStack) {\n      var s = getAllTextContent(node, false).replace(/^\\s*|\\s*$/g, '');\n      var context = objectStack[0];\n      var containerSrs = context['srsName'];\n      var contextDimension = context['srsDimension'];\n      var axisOrientation = 'enu';\n      if (containerSrs) {\n        var proj = getProjection(containerSrs);\n        axisOrientation = proj.getAxisOrientation();\n      }\n      var coords = s.split(/\\s+/);\n      // The \"dimension\" attribute is from the GML 3.0.1 spec.\n      var dim = 2;\n      if (node.getAttribute('srsDimension')) {\n        dim = readNonNegativeIntegerString(node.getAttribute('srsDimension'));\n      } else if (node.getAttribute('dimension')) {\n        dim = readNonNegativeIntegerString(node.getAttribute('dimension'));\n      } else if (/** @type {Element} */node.parentNode.getAttribute('srsDimension')) {\n        dim = readNonNegativeIntegerString(/** @type {Element} */node.parentNode.getAttribute('srsDimension'));\n      } else if (contextDimension) {\n        dim = readNonNegativeIntegerString(contextDimension);\n      }\n      var x, y, z;\n      var flatCoordinates = [];\n      for (var i = 0, ii = coords.length; i < ii; i += dim) {\n        x = parseFloat(coords[i]);\n        y = parseFloat(coords[i + 1]);\n        z = dim === 3 ? parseFloat(coords[i + 2]) : 0;\n        if (axisOrientation.substr(0, 2) === 'en') {\n          flatCoordinates.push(x, y, z);\n        } else {\n          flatCoordinates.push(y, x, z);\n        }\n      }\n      return flatCoordinates;\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {import(\"../geom/Point.js\").default} value Point geometry.\n     * @param {Array<*>} objectStack Node stack.\n     * @private\n     */\n  }, {\n    key: \"writePos_\",\n    value: function writePos_(node, value, objectStack) {\n      var context = objectStack[objectStack.length - 1];\n      var hasZ = context['hasZ'];\n      var srsDimension = hasZ ? '3' : '2';\n      node.setAttribute('srsDimension', srsDimension);\n      var srsName = context['srsName'];\n      var axisOrientation = 'enu';\n      if (srsName) {\n        axisOrientation = getProjection(srsName).getAxisOrientation();\n      }\n      var point = value.getCoordinates();\n      var coords;\n      // only 2d for simple features profile\n      if (axisOrientation.substr(0, 2) === 'en') {\n        coords = point[0] + ' ' + point[1];\n      } else {\n        coords = point[1] + ' ' + point[0];\n      }\n      if (hasZ) {\n        // For newly created points, Z can be undefined.\n        var z = point[2] || 0;\n        coords += ' ' + z;\n      }\n      writeStringTextNode(node, coords);\n    }\n\n    /**\n     * @param {Array<number>} point Point geometry.\n     * @param {string} [srsName] Optional srsName\n     * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.\n     * @return {string} The coords string.\n     * @private\n     */\n  }, {\n    key: \"getCoords_\",\n    value: function getCoords_(point, srsName, hasZ) {\n      var axisOrientation = 'enu';\n      if (srsName) {\n        axisOrientation = getProjection(srsName).getAxisOrientation();\n      }\n      var coords = axisOrientation.substr(0, 2) === 'en' ? point[0] + ' ' + point[1] : point[1] + ' ' + point[0];\n      if (hasZ) {\n        // For newly created points, Z can be undefined.\n        var z = point[2] || 0;\n        coords += ' ' + z;\n      }\n      return coords;\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {LineString|import(\"../geom/LinearRing.js\").default} value Geometry.\n     * @param {Array<*>} objectStack Node stack.\n     * @private\n     */\n  }, {\n    key: \"writePosList_\",\n    value: function writePosList_(node, value, objectStack) {\n      var context = objectStack[objectStack.length - 1];\n      var hasZ = context['hasZ'];\n      var srsDimension = hasZ ? '3' : '2';\n      node.setAttribute('srsDimension', srsDimension);\n      var srsName = context['srsName'];\n      // only 2d for simple features profile\n      var points = value.getCoordinates();\n      var len = points.length;\n      var parts = new Array(len);\n      var point;\n      for (var i = 0; i < len; ++i) {\n        point = points[i];\n        parts[i] = this.getCoords_(point, srsName, hasZ);\n      }\n      writeStringTextNode(node, parts.join(' '));\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {import(\"../geom/Point.js\").default} geometry Point geometry.\n     * @param {Array<*>} objectStack Node stack.\n     */\n  }, {\n    key: \"writePoint\",\n    value: function writePoint(node, geometry, objectStack) {\n      var context = objectStack[objectStack.length - 1];\n      var srsName = context['srsName'];\n      if (srsName) {\n        node.setAttribute('srsName', srsName);\n      }\n      var pos = createElementNS(node.namespaceURI, 'pos');\n      node.appendChild(pos);\n      this.writePos_(pos, geometry, objectStack);\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {Array<*>} objectStack Node stack.\n     */\n  }, {\n    key: \"writeEnvelope\",\n    value: function writeEnvelope(node, extent, objectStack) {\n      var context = objectStack[objectStack.length - 1];\n      var srsName = context['srsName'];\n      if (srsName) {\n        node.setAttribute('srsName', srsName);\n      }\n      var keys = ['lowerCorner', 'upperCorner'];\n      var values = [extent[0] + ' ' + extent[1], extent[2] + ' ' + extent[3]];\n      pushSerializeAndPop(/** @type {import(\"../xml.js\").NodeStackItem} */\n      {\n        node: node\n      }, this.ENVELOPE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, keys, this);\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {import(\"../geom/LinearRing.js\").default} geometry LinearRing geometry.\n     * @param {Array<*>} objectStack Node stack.\n     */\n  }, {\n    key: \"writeLinearRing\",\n    value: function writeLinearRing(node, geometry, objectStack) {\n      var context = objectStack[objectStack.length - 1];\n      var srsName = context['srsName'];\n      if (srsName) {\n        node.setAttribute('srsName', srsName);\n      }\n      var posList = createElementNS(node.namespaceURI, 'posList');\n      node.appendChild(posList);\n      this.writePosList_(posList, geometry, objectStack);\n    }\n\n    /**\n     * @param {*} value Value.\n     * @param {Array<*>} objectStack Object stack.\n     * @param {string} [nodeName] Node name.\n     * @return {Node} Node.\n     * @private\n     */\n  }, {\n    key: \"RING_NODE_FACTORY_\",\n    value: function RING_NODE_FACTORY_(value, objectStack, nodeName) {\n      var context = objectStack[objectStack.length - 1];\n      var parentNode = context.node;\n      var exteriorWritten = context['exteriorWritten'];\n      if (exteriorWritten === undefined) {\n        context['exteriorWritten'] = true;\n      }\n      return createElementNS(parentNode.namespaceURI, exteriorWritten !== undefined ? 'interior' : 'exterior');\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Polygon} geometry Polygon geometry.\n     * @param {Array<*>} objectStack Node stack.\n     */\n  }, {\n    key: \"writeSurfaceOrPolygon\",\n    value: function writeSurfaceOrPolygon(node, geometry, objectStack) {\n      var context = objectStack[objectStack.length - 1];\n      var hasZ = context['hasZ'];\n      var srsName = context['srsName'];\n      if (node.nodeName !== 'PolygonPatch' && srsName) {\n        node.setAttribute('srsName', srsName);\n      }\n      if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {\n        var rings = geometry.getLinearRings();\n        pushSerializeAndPop({\n          node: node,\n          hasZ: hasZ,\n          srsName: srsName\n        }, this.RING_SERIALIZERS, this.RING_NODE_FACTORY_, rings, objectStack, undefined, this);\n      } else if (node.nodeName === 'Surface') {\n        var patches = createElementNS(node.namespaceURI, 'patches');\n        node.appendChild(patches);\n        this.writeSurfacePatches_(patches, geometry, objectStack);\n      }\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {LineString} geometry LineString geometry.\n     * @param {Array<*>} objectStack Node stack.\n     */\n  }, {\n    key: \"writeCurveOrLineString\",\n    value: function writeCurveOrLineString(node, geometry, objectStack) {\n      var context = objectStack[objectStack.length - 1];\n      var srsName = context['srsName'];\n      if (node.nodeName !== 'LineStringSegment' && srsName) {\n        node.setAttribute('srsName', srsName);\n      }\n      if (node.nodeName === 'LineString' || node.nodeName === 'LineStringSegment') {\n        var posList = createElementNS(node.namespaceURI, 'posList');\n        node.appendChild(posList);\n        this.writePosList_(posList, geometry, objectStack);\n      } else if (node.nodeName === 'Curve') {\n        var segments = createElementNS(node.namespaceURI, 'segments');\n        node.appendChild(segments);\n        this.writeCurveSegments_(segments, geometry, objectStack);\n      }\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {MultiPolygon} geometry MultiPolygon geometry.\n     * @param {Array<*>} objectStack Node stack.\n     */\n  }, {\n    key: \"writeMultiSurfaceOrPolygon\",\n    value: function writeMultiSurfaceOrPolygon(node, geometry, objectStack) {\n      var context = objectStack[objectStack.length - 1];\n      var hasZ = context['hasZ'];\n      var srsName = context['srsName'];\n      var surface = context['surface'];\n      if (srsName) {\n        node.setAttribute('srsName', srsName);\n      }\n      var polygons = geometry.getPolygons();\n      pushSerializeAndPop({\n        node: node,\n        hasZ: hasZ,\n        srsName: srsName,\n        surface: surface\n      }, this.SURFACEORPOLYGONMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, polygons, objectStack, undefined, this);\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {import(\"../geom/MultiPoint.js\").default} geometry MultiPoint geometry.\n     * @param {Array<*>} objectStack Node stack.\n     */\n  }, {\n    key: \"writeMultiPoint\",\n    value: function writeMultiPoint(node, geometry, objectStack) {\n      var context = objectStack[objectStack.length - 1];\n      var srsName = context['srsName'];\n      var hasZ = context['hasZ'];\n      if (srsName) {\n        node.setAttribute('srsName', srsName);\n      }\n      var points = geometry.getPoints();\n      pushSerializeAndPop({\n        node: node,\n        hasZ: hasZ,\n        srsName: srsName\n      }, this.POINTMEMBER_SERIALIZERS, makeSimpleNodeFactory('pointMember'), points, objectStack, undefined, this);\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {MultiLineString} geometry MultiLineString geometry.\n     * @param {Array<*>} objectStack Node stack.\n     */\n  }, {\n    key: \"writeMultiCurveOrLineString\",\n    value: function writeMultiCurveOrLineString(node, geometry, objectStack) {\n      var context = objectStack[objectStack.length - 1];\n      var hasZ = context['hasZ'];\n      var srsName = context['srsName'];\n      var curve = context['curve'];\n      if (srsName) {\n        node.setAttribute('srsName', srsName);\n      }\n      var lines = geometry.getLineStrings();\n      pushSerializeAndPop({\n        node: node,\n        hasZ: hasZ,\n        srsName: srsName,\n        curve: curve\n      }, this.LINESTRINGORCURVEMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, lines, objectStack, undefined, this);\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {import(\"../geom/LinearRing.js\").default} ring LinearRing geometry.\n     * @param {Array<*>} objectStack Node stack.\n     */\n  }, {\n    key: \"writeRing\",\n    value: function writeRing(node, ring, objectStack) {\n      var linearRing = createElementNS(node.namespaceURI, 'LinearRing');\n      node.appendChild(linearRing);\n      this.writeLinearRing(linearRing, ring, objectStack);\n    }\n\n    /**\n     * @param {Node} node Node.\n     * @param {Polygon} polygon Polygon geometry.\n     * @param {Array<*>} objectStack Node stack.\n     */\n  }, {\n    key: \"writeSurfaceOrPolygonMember\",\n    value: function writeSurfaceOrPolygonMember(node, polygon, objectStack) {\n      var child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);\n      if (child) {\n        node.appendChild(child);\n        this.writeSurfaceOrPolygon(child, polygon, objectStack);\n      }\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {import(\"../geom/Point.js\").default} point Point geometry.\n     * @param {Array<*>} objectStack Node stack.\n     */\n  }, {\n    key: \"writePointMember\",\n    value: function writePointMember(node, point, objectStack) {\n      var child = createElementNS(node.namespaceURI, 'Point');\n      node.appendChild(child);\n      this.writePoint(child, point, objectStack);\n    }\n\n    /**\n     * @param {Node} node Node.\n     * @param {LineString} line LineString geometry.\n     * @param {Array<*>} objectStack Node stack.\n     */\n  }, {\n    key: \"writeLineStringOrCurveMember\",\n    value: function writeLineStringOrCurveMember(node, line, objectStack) {\n      var child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);\n      if (child) {\n        node.appendChild(child);\n        this.writeCurveOrLineString(child, line, objectStack);\n      }\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {Polygon} polygon Polygon geometry.\n     * @param {Array<*>} objectStack Node stack.\n     * @private\n     */\n  }, {\n    key: \"writeSurfacePatches_\",\n    value: function writeSurfacePatches_(node, polygon, objectStack) {\n      var child = createElementNS(node.namespaceURI, 'PolygonPatch');\n      node.appendChild(child);\n      this.writeSurfaceOrPolygon(child, polygon, objectStack);\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {LineString} line LineString geometry.\n     * @param {Array<*>} objectStack Node stack.\n     * @private\n     */\n  }, {\n    key: \"writeCurveSegments_\",\n    value: function writeCurveSegments_(node, line, objectStack) {\n      var child = createElementNS(node.namespaceURI, 'LineStringSegment');\n      node.appendChild(child);\n      this.writeCurveOrLineString(child, line, objectStack);\n    }\n\n    /**\n     * @param {Node} node Node.\n     * @param {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent} geometry Geometry.\n     * @param {Array<*>} objectStack Node stack.\n     */\n  }, {\n    key: \"writeGeometryElement\",\n    value: function writeGeometryElement(node, geometry, objectStack) {\n      var context = /** @type {import(\"./Feature.js\").WriteOptions} */\n      objectStack[objectStack.length - 1];\n      var item = Object.assign({}, context);\n      item['node'] = node;\n      var value;\n      if (Array.isArray(geometry)) {\n        value = transformExtentWithOptions(/** @type {import(\"../extent.js\").Extent} */geometry, context);\n      } else {\n        value = transformGeometryWithOptions(/** @type {import(\"../geom/Geometry.js\").default} */geometry, true, context);\n      }\n      pushSerializeAndPop(/** @type {import(\"../xml.js\").NodeStackItem} */\n      item, this.GEOMETRY_SERIALIZERS, this.GEOMETRY_NODE_FACTORY_, [value], objectStack, undefined, this);\n    }\n\n    /**\n     * @param {Element} node Node.\n     * @param {import(\"../Feature.js\").default} feature Feature.\n     * @param {Array<*>} objectStack Node stack.\n     */\n  }, {\n    key: \"writeFeatureElement\",\n    value: function writeFeatureElement(node, feature, objectStack) {\n      var fid = feature.getId();\n      if (fid) {\n        node.setAttribute('fid', /** @type {string} */fid);\n      }\n      var context = /** @type {Object} */objectStack[objectStack.length - 1];\n      var featureNS = context['featureNS'];\n      var geometryName = feature.getGeometryName();\n      if (!context.serializers) {\n        context.serializers = {};\n        context.serializers[featureNS] = {};\n      }\n      var keys = [];\n      var values = [];\n      if (feature.hasProperties()) {\n        var properties = feature.getProperties();\n        for (var key in properties) {\n          var value = properties[key];\n          if (value !== null) {\n            keys.push(key);\n            values.push(value);\n            if (key == geometryName || typeof (/** @type {?} */value.getSimplifiedGeometry) === 'function') {\n              if (!(key in context.serializers[featureNS])) {\n                context.serializers[featureNS][key] = makeChildAppender(this.writeGeometryElement, this);\n              }\n            } else {\n              if (!(key in context.serializers[featureNS])) {\n                context.serializers[featureNS][key] = makeChildAppender(writeStringTextNode);\n              }\n            }\n          }\n        }\n      }\n      var item = Object.assign({}, context);\n      item.node = node;\n      pushSerializeAndPop(/** @type {import(\"../xml.js\").NodeStackItem} */\n      item, context.serializers, makeSimpleNodeFactory(undefined, featureNS), values, objectStack, keys);\n    }\n\n    /**\n     * @param {Node} node Node.\n     * @param {Array<import(\"../Feature.js\").default>} features Features.\n     * @param {Array<*>} objectStack Node stack.\n     * @private\n     */\n  }, {\n    key: \"writeFeatureMembers_\",\n    value: function writeFeatureMembers_(node, features, objectStack) {\n      var context = /** @type {Object} */objectStack[objectStack.length - 1];\n      var featureType = context['featureType'];\n      var featureNS = context['featureNS'];\n      /** @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>} */\n      var serializers = {};\n      serializers[featureNS] = {};\n      serializers[featureNS][featureType] = makeChildAppender(this.writeFeatureElement, this);\n      var item = Object.assign({}, context);\n      item.node = node;\n      pushSerializeAndPop(/** @type {import(\"../xml.js\").NodeStackItem} */\n      item, serializers, makeSimpleNodeFactory(featureType, featureNS), features, objectStack);\n    }\n\n    /**\n     * @const\n     * @param {*} value Value.\n     * @param {Array<*>} objectStack Object stack.\n     * @param {string} [nodeName] Node name.\n     * @return {Node|undefined} Node.\n     * @private\n     */\n  }, {\n    key: \"MULTIGEOMETRY_MEMBER_NODE_FACTORY_\",\n    value: function MULTIGEOMETRY_MEMBER_NODE_FACTORY_(value, objectStack, nodeName) {\n      var parentNode = objectStack[objectStack.length - 1].node;\n      return createElementNS(this.namespace, MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]);\n    }\n\n    /**\n     * @const\n     * @param {*} value Value.\n     * @param {Array<*>} objectStack Object stack.\n     * @param {string} [nodeName] Node name.\n     * @return {Element|undefined} Node.\n     * @private\n     */\n  }, {\n    key: \"GEOMETRY_NODE_FACTORY_\",\n    value: function GEOMETRY_NODE_FACTORY_(value, objectStack, nodeName) {\n      var context = objectStack[objectStack.length - 1];\n      var multiSurface = context['multiSurface'];\n      var surface = context['surface'];\n      var curve = context['curve'];\n      var multiCurve = context['multiCurve'];\n      if (!Array.isArray(value)) {\n        nodeName = /** @type {import(\"../geom/Geometry.js\").default} */value.getType();\n        if (nodeName === 'MultiPolygon' && multiSurface === true) {\n          nodeName = 'MultiSurface';\n        } else if (nodeName === 'Polygon' && surface === true) {\n          nodeName = 'Surface';\n        } else if (nodeName === 'LineString' && curve === true) {\n          nodeName = 'Curve';\n        } else if (nodeName === 'MultiLineString' && multiCurve === true) {\n          nodeName = 'MultiCurve';\n        }\n      } else {\n        nodeName = 'Envelope';\n      }\n      return createElementNS(this.namespace, nodeName);\n    }\n\n    /**\n     * Encode a geometry in GML 3.1.1 Simple Features.\n     *\n     * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n     * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n     * @return {Node} Node.\n     * @api\n     */\n  }, {\n    key: \"writeGeometryNode\",\n    value: function writeGeometryNode(geometry, options) {\n      options = this.adaptOptions(options);\n      var geom = createElementNS(this.namespace, 'geom');\n      var context = {\n        node: geom,\n        hasZ: this.hasZ,\n        srsName: this.srsName,\n        curve: this.curve_,\n        surface: this.surface_,\n        multiSurface: this.multiSurface_,\n        multiCurve: this.multiCurve_\n      };\n      if (options) {\n        Object.assign(context, options);\n      }\n      this.writeGeometryElement(geom, geometry, [context]);\n      return geom;\n    }\n\n    /**\n     * Encode an array of features in the GML 3.1.1 format as an XML node.\n     *\n     * @param {Array<import(\"../Feature.js\").default>} features Features.\n     * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n     * @return {Element} Node.\n     * @api\n     */\n  }, {\n    key: \"writeFeaturesNode\",\n    value: function writeFeaturesNode(features, options) {\n      options = this.adaptOptions(options);\n      var node = createElementNS(this.namespace, 'featureMembers');\n      node.setAttributeNS(XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', this.schemaLocation);\n      var context = {\n        srsName: this.srsName,\n        hasZ: this.hasZ,\n        curve: this.curve_,\n        surface: this.surface_,\n        multiSurface: this.multiSurface_,\n        multiCurve: this.multiCurve_,\n        featureNS: this.featureNS,\n        featureType: this.featureType\n      };\n      if (options) {\n        Object.assign(context, options);\n      }\n      this.writeFeatureMembers_(node, features, [context]);\n      return node;\n    }\n  }]);\n}(GMLBase);\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'pos': makeReplacer(GML3.prototype.readFlatPos),\n    'posList': makeReplacer(GML3.prototype.readFlatPosList),\n    'coordinates': makeReplacer(GML2.prototype.readFlatCoordinates)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'interior': GML3.prototype.interiorParser,\n    'exterior': GML3.prototype.exteriorParser\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Point': makeReplacer(GMLBase.prototype.readPoint),\n    'MultiPoint': makeReplacer(GMLBase.prototype.readMultiPoint),\n    'LineString': makeReplacer(GMLBase.prototype.readLineString),\n    'MultiLineString': makeReplacer(GMLBase.prototype.readMultiLineString),\n    'LinearRing': makeReplacer(GMLBase.prototype.readLinearRing),\n    'Polygon': makeReplacer(GMLBase.prototype.readPolygon),\n    'MultiPolygon': makeReplacer(GMLBase.prototype.readMultiPolygon),\n    'Surface': makeReplacer(GML3.prototype.readSurface),\n    'MultiSurface': makeReplacer(GML3.prototype.readMultiSurface),\n    'Curve': makeReplacer(GML3.prototype.readCurve),\n    'MultiCurve': makeReplacer(GML3.prototype.readMultiCurve),\n    'Envelope': makeReplacer(GML3.prototype.readEnvelope)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.MULTICURVE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'curveMember': makeArrayPusher(GML3.prototype.curveMemberParser),\n    'curveMembers': makeArrayPusher(GML3.prototype.curveMemberParser)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.MULTISURFACE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeArrayPusher(GML3.prototype.surfaceMemberParser),\n    'surfaceMembers': makeArrayPusher(GML3.prototype.surfaceMemberParser)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.CURVEMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LineString': makeArrayPusher(GMLBase.prototype.readLineString),\n    'Curve': makeArrayPusher(GML3.prototype.readCurve)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.SURFACEMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon),\n    'Surface': makeArrayPusher(GML3.prototype.readSurface)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.SURFACE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'patches': makeReplacer(GML3.prototype.readPatch)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.CURVE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'segments': makeReplacer(GML3.prototype.readSegment)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.ENVELOPE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeArrayPusher(GML3.prototype.readFlatPosList),\n    'upperCorner': makeArrayPusher(GML3.prototype.readFlatPosList)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.PATCHES_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'PolygonPatch': makeReplacer(GML3.prototype.readPolygonPatch)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.SEGMENTS_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LineStringSegment': makeArrayExtender(GML3.prototype.readLineStringSegment)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.RING_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LinearRing': makeReplacer(GMLBase.prototype.readFlatLinearRing),\n    'Ring': makeReplacer(GML3.prototype.readFlatCurveRing)\n  }\n};\n\n/**\n * Encode an array of features in GML 3.1.1 Simple Features.\n *\n * @function\n * @param {Array<import(\"../Feature.js\").default>} features Features.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n * @return {string} Result.\n * @api\n */\nGML3.prototype.writeFeatures;\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.RING_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'exterior': makeChildAppender(GML3.prototype.writeRing),\n    'interior': makeChildAppender(GML3.prototype.writeRing)\n  }\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.ENVELOPE_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeChildAppender(writeStringTextNode),\n    'upperCorner': makeChildAppender(writeStringTextNode)\n  }\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeChildAppender(GML3.prototype.writeSurfaceOrPolygonMember),\n    'polygonMember': makeChildAppender(GML3.prototype.writeSurfaceOrPolygonMember)\n  }\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.POINTMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeChildAppender(GML3.prototype.writePointMember)\n  }\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeChildAppender(GML3.prototype.writeLineStringOrCurveMember),\n    'curveMember': makeChildAppender(GML3.prototype.writeLineStringOrCurveMember)\n  }\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.GEOMETRY_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'Curve': makeChildAppender(GML3.prototype.writeCurveOrLineString),\n    'MultiCurve': makeChildAppender(GML3.prototype.writeMultiCurveOrLineString),\n    'Point': makeChildAppender(GML3.prototype.writePoint),\n    'MultiPoint': makeChildAppender(GML3.prototype.writeMultiPoint),\n    'LineString': makeChildAppender(GML3.prototype.writeCurveOrLineString),\n    'MultiLineString': makeChildAppender(GML3.prototype.writeMultiCurveOrLineString),\n    'LinearRing': makeChildAppender(GML3.prototype.writeLinearRing),\n    'Polygon': makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),\n    'MultiPolygon': makeChildAppender(GML3.prototype.writeMultiSurfaceOrPolygon),\n    'Surface': makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),\n    'MultiSurface': makeChildAppender(GML3.prototype.writeMultiSurfaceOrPolygon),\n    'Envelope': makeChildAppender(GML3.prototype.writeEnvelope)\n  }\n};\nexport default GML3;","map":{"version":3,"names":["GML2","GMLBase","GMLNS","LineString","MultiLineString","MultiPolygon","Polygon","OBJECT_PROPERTY_NODE_FACTORY","XML_SCHEMA_INSTANCE_URI","createElementNS","getAllTextContent","makeArrayExtender","makeArrayPusher","makeChildAppender","makeReplacer","makeSimpleNodeFactory","parseNode","pushParseAndPop","pushSerializeAndPop","createOrUpdate","extend","get","getProjection","readNonNegativeIntegerString","writeStringTextNode","transformExtentWithOptions","transformGeometryWithOptions","schemaLocation","MULTIGEOMETRY_TO_MEMBER_NODENAME","GML3","_GMLBase","options","_this","_classCallCheck","_callSuper","surface_","surface","undefined","curve_","curve","multiCurve_","multiCurve","multiSurface_","multiSurface","hasZ","_inherits","_createClass","key","value","readMultiCurve","node","objectStack","lineStrings","MULTICURVE_PARSERS","multiLineString","readFlatCurveRing","flatCoordinates","i","ii","length","getFlatCoordinates","readMultiSurface","polygons","MULTISURFACE_PARSERS","curveMemberParser","CURVEMEMBER_PARSERS","surfaceMemberParser","SURFACEMEMBER_PARSERS","readPatch","PATCHES_PARSERS","readSegment","SEGMENTS_PARSERS","readPolygonPatch","FLAT_LINEAR_RINGS_PARSERS","readLineStringSegment","GEOMETRY_FLAT_COORDINATES_PARSERS","interiorParser","flatLinearRing","RING_PARSERS","flatLinearRings","push","exteriorParser","readSurface","SURFACE_PARSERS","ends","readCurve","CURVE_PARSERS","lineString","readEnvelope","ENVELOPE_PARSERS","readFlatPos","s","re","m","exec","parseFloat","substr","context","containerSrs","axisOrientation","proj","getAxisOrientation","y","x","len","readFlatPosList","replace","contextDimension","coords","split","dim","getAttribute","parentNode","z","writePos_","srsDimension","setAttribute","srsName","point","getCoordinates","getCoords_","writePosList_","points","parts","Array","join","writePoint","geometry","pos","namespaceURI","appendChild","writeEnvelope","extent","keys","values","ENVELOPE_SERIALIZERS","writeLinearRing","posList","RING_NODE_FACTORY_","nodeName","exteriorWritten","writeSurfaceOrPolygon","rings","getLinearRings","RING_SERIALIZERS","patches","writeSurfacePatches_","writeCurveOrLineString","segments","writeCurveSegments_","writeMultiSurfaceOrPolygon","getPolygons","SURFACEORPOLYGONMEMBER_SERIALIZERS","MULTIGEOMETRY_MEMBER_NODE_FACTORY_","writeMultiPoint","getPoints","POINTMEMBER_SERIALIZERS","writeMultiCurveOrLineString","lines","getLineStrings","LINESTRINGORCURVEMEMBER_SERIALIZERS","writeRing","ring","linearRing","writeSurfaceOrPolygonMember","polygon","child","GEOMETRY_NODE_FACTORY_","writePointMember","writeLineStringOrCurveMember","line","writeGeometryElement","item","Object","assign","isArray","GEOMETRY_SERIALIZERS","writeFeatureElement","feature","fid","getId","featureNS","geometryName","getGeometryName","serializers","hasProperties","properties","getProperties","getSimplifiedGeometry","writeFeatureMembers_","features","featureType","namespace","getType","writeGeometryNode","adaptOptions","geom","writeFeaturesNode","setAttributeNS","prototype","readFlatCoordinates","GEOMETRY_PARSERS","readPoint","readMultiPoint","readLineString","readMultiLineString","readLinearRing","readPolygon","readMultiPolygon","readFlatLinearRing","writeFeatures"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol/format/GML3.js"],"sourcesContent":["/**\n * @module ol/format/GML3\n */\nimport GML2 from './GML2.js';\nimport GMLBase, {GMLNS} from './GMLBase.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Polygon from '../geom/Polygon.js';\nimport {\n  OBJECT_PROPERTY_NODE_FACTORY,\n  XML_SCHEMA_INSTANCE_URI,\n  createElementNS,\n  getAllTextContent,\n  makeArrayExtender,\n  makeArrayPusher,\n  makeChildAppender,\n  makeReplacer,\n  makeSimpleNodeFactory,\n  parseNode,\n  pushParseAndPop,\n  pushSerializeAndPop,\n} from '../xml.js';\nimport {createOrUpdate} from '../extent.js';\nimport {extend} from '../array.js';\nimport {get as getProjection} from '../proj.js';\nimport {readNonNegativeIntegerString, writeStringTextNode} from './xsd.js';\nimport {\n  transformExtentWithOptions,\n  transformGeometryWithOptions,\n} from './Feature.js';\n\n/**\n * @const\n * @type {string}\n * @private\n */\nconst schemaLocation =\n  GMLNS +\n  ' http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/' +\n  '1.0.0/gmlsf.xsd';\n\n/**\n * @const\n * @type {Object<string, string>}\n */\nconst MULTIGEOMETRY_TO_MEMBER_NODENAME = {\n  'MultiLineString': 'lineStringMember',\n  'MultiCurve': 'curveMember',\n  'MultiPolygon': 'polygonMember',\n  'MultiSurface': 'surfaceMember',\n};\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the GML format\n * version 3.1.1.\n * Currently only supports GML 3.1.1 Simple Features profile.\n *\n * @api\n */\nclass GML3 extends GMLBase {\n  /**\n   * @param {import(\"./GMLBase.js\").Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super(options);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.surface_ = options.surface !== undefined ? options.surface : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.curve_ = options.curve !== undefined ? options.curve : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multiCurve_ =\n      options.multiCurve !== undefined ? options.multiCurve : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multiSurface_ =\n      options.multiSurface !== undefined ? options.multiSurface : true;\n\n    /**\n     * @type {string}\n     */\n    this.schemaLocation = options.schemaLocation\n      ? options.schemaLocation\n      : schemaLocation;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hasZ = options.hasZ !== undefined ? options.hasZ : false;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiLineString|undefined} MultiLineString.\n   */\n  readMultiCurve(node, objectStack) {\n    /** @type {Array<LineString>} */\n    const lineStrings = pushParseAndPop(\n      [],\n      this.MULTICURVE_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (lineStrings) {\n      const multiLineString = new MultiLineString(lineStrings);\n      return multiLineString;\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} Polygon.\n   */\n  readFlatCurveRing(node, objectStack) {\n    /** @type {Array<LineString>} */\n    const lineStrings = pushParseAndPop(\n      [],\n      this.MULTICURVE_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    const flatCoordinates = [];\n    for (let i = 0, ii = lineStrings.length; i < ii; ++i) {\n      extend(flatCoordinates, lineStrings[i].getFlatCoordinates());\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiPolygon|undefined} MultiPolygon.\n   */\n  readMultiSurface(node, objectStack) {\n    /** @type {Array<Polygon>} */\n    const polygons = pushParseAndPop(\n      [],\n      this.MULTISURFACE_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (polygons) {\n      return new MultiPolygon(polygons);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  curveMemberParser(node, objectStack) {\n    parseNode(this.CURVEMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  surfaceMemberParser(node, objectStack) {\n    parseNode(this.SURFACEMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<(Array<number>)>|undefined} flat coordinates.\n   */\n  readPatch(node, objectStack) {\n    return pushParseAndPop(\n      [null],\n      this.PATCHES_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} flat coordinates.\n   */\n  readSegment(node, objectStack) {\n    return pushParseAndPop([], this.SEGMENTS_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<(Array<number>)>|undefined} flat coordinates.\n   */\n  readPolygonPatch(node, objectStack) {\n    return pushParseAndPop(\n      [null],\n      this.FLAT_LINEAR_RINGS_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} flat coordinates.\n   */\n  readLineStringSegment(node, objectStack) {\n    return pushParseAndPop(\n      [null],\n      this.GEOMETRY_FLAT_COORDINATES_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  interiorParser(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(\n      undefined,\n      this.RING_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (flatLinearRing) {\n      const flatLinearRings =\n        /** @type {Array<Array<number>>} */\n        (objectStack[objectStack.length - 1]);\n      flatLinearRings.push(flatLinearRing);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  exteriorParser(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(\n      undefined,\n      this.RING_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (flatLinearRing) {\n      const flatLinearRings =\n        /** @type {Array<Array<number>>} */\n        (objectStack[objectStack.length - 1]);\n      flatLinearRings[0] = flatLinearRing;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Polygon|undefined} Polygon.\n   */\n  readSurface(node, objectStack) {\n    /** @type {Array<Array<number>>} */\n    const flatLinearRings = pushParseAndPop(\n      [null],\n      this.SURFACE_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (flatLinearRings && flatLinearRings[0]) {\n      const flatCoordinates = flatLinearRings[0];\n      const ends = [flatCoordinates.length];\n      let i, ii;\n      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n        extend(flatCoordinates, flatLinearRings[i]);\n        ends.push(flatCoordinates.length);\n      }\n      return new Polygon(flatCoordinates, 'XYZ', ends);\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {LineString|undefined} LineString.\n   */\n  readCurve(node, objectStack) {\n    /** @type {Array<number>} */\n    const flatCoordinates = pushParseAndPop(\n      [null],\n      this.CURVE_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (flatCoordinates) {\n      const lineString = new LineString(flatCoordinates, 'XYZ');\n      return lineString;\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../extent.js\").Extent|undefined} Envelope.\n   */\n  readEnvelope(node, objectStack) {\n    /** @type {Array<number>} */\n    const flatCoordinates = pushParseAndPop(\n      [null],\n      this.ENVELOPE_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    return createOrUpdate(\n      flatCoordinates[1][0],\n      flatCoordinates[1][1],\n      flatCoordinates[2][0],\n      flatCoordinates[2][1]\n    );\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} Flat coordinates.\n   */\n  readFlatPos(node, objectStack) {\n    let s = getAllTextContent(node, false);\n    const re = /^\\s*([+\\-]?\\d*\\.?\\d+(?:[eE][+\\-]?\\d+)?)\\s*/;\n    /** @type {Array<number>} */\n    const flatCoordinates = [];\n    let m;\n    while ((m = re.exec(s))) {\n      flatCoordinates.push(parseFloat(m[1]));\n      s = s.substr(m[0].length);\n    }\n    if (s !== '') {\n      return undefined;\n    }\n    const context = objectStack[0];\n    const containerSrs = context['srsName'];\n    let axisOrientation = 'enu';\n    if (containerSrs) {\n      const proj = getProjection(containerSrs);\n      axisOrientation = proj.getAxisOrientation();\n    }\n    if (axisOrientation === 'neu') {\n      let i, ii;\n      for (i = 0, ii = flatCoordinates.length; i < ii; i += 3) {\n        const y = flatCoordinates[i];\n        const x = flatCoordinates[i + 1];\n        flatCoordinates[i] = x;\n        flatCoordinates[i + 1] = y;\n      }\n    }\n    const len = flatCoordinates.length;\n    if (len == 2) {\n      flatCoordinates.push(0);\n    }\n    if (len === 0) {\n      return undefined;\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} Flat coordinates.\n   */\n  readFlatPosList(node, objectStack) {\n    const s = getAllTextContent(node, false).replace(/^\\s*|\\s*$/g, '');\n    const context = objectStack[0];\n    const containerSrs = context['srsName'];\n    const contextDimension = context['srsDimension'];\n    let axisOrientation = 'enu';\n    if (containerSrs) {\n      const proj = getProjection(containerSrs);\n      axisOrientation = proj.getAxisOrientation();\n    }\n    const coords = s.split(/\\s+/);\n    // The \"dimension\" attribute is from the GML 3.0.1 spec.\n    let dim = 2;\n    if (node.getAttribute('srsDimension')) {\n      dim = readNonNegativeIntegerString(node.getAttribute('srsDimension'));\n    } else if (node.getAttribute('dimension')) {\n      dim = readNonNegativeIntegerString(node.getAttribute('dimension'));\n    } else if (\n      /** @type {Element} */ (node.parentNode).getAttribute('srsDimension')\n    ) {\n      dim = readNonNegativeIntegerString(\n        /** @type {Element} */ (node.parentNode).getAttribute('srsDimension')\n      );\n    } else if (contextDimension) {\n      dim = readNonNegativeIntegerString(contextDimension);\n    }\n    let x, y, z;\n    const flatCoordinates = [];\n    for (let i = 0, ii = coords.length; i < ii; i += dim) {\n      x = parseFloat(coords[i]);\n      y = parseFloat(coords[i + 1]);\n      z = dim === 3 ? parseFloat(coords[i + 2]) : 0;\n      if (axisOrientation.substr(0, 2) === 'en') {\n        flatCoordinates.push(x, y, z);\n      } else {\n        flatCoordinates.push(y, x, z);\n      }\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} value Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writePos_(node, value, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsDimension = hasZ ? '3' : '2';\n    node.setAttribute('srsDimension', srsDimension);\n    const srsName = context['srsName'];\n    let axisOrientation = 'enu';\n    if (srsName) {\n      axisOrientation = getProjection(srsName).getAxisOrientation();\n    }\n    const point = value.getCoordinates();\n    let coords;\n    // only 2d for simple features profile\n    if (axisOrientation.substr(0, 2) === 'en') {\n      coords = point[0] + ' ' + point[1];\n    } else {\n      coords = point[1] + ' ' + point[0];\n    }\n    if (hasZ) {\n      // For newly created points, Z can be undefined.\n      const z = point[2] || 0;\n      coords += ' ' + z;\n    }\n    writeStringTextNode(node, coords);\n  }\n\n  /**\n   * @param {Array<number>} point Point geometry.\n   * @param {string} [srsName] Optional srsName\n   * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.\n   * @return {string} The coords string.\n   * @private\n   */\n  getCoords_(point, srsName, hasZ) {\n    let axisOrientation = 'enu';\n    if (srsName) {\n      axisOrientation = getProjection(srsName).getAxisOrientation();\n    }\n    let coords =\n      axisOrientation.substr(0, 2) === 'en'\n        ? point[0] + ' ' + point[1]\n        : point[1] + ' ' + point[0];\n    if (hasZ) {\n      // For newly created points, Z can be undefined.\n      const z = point[2] || 0;\n      coords += ' ' + z;\n    }\n\n    return coords;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {LineString|import(\"../geom/LinearRing.js\").default} value Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writePosList_(node, value, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsDimension = hasZ ? '3' : '2';\n    node.setAttribute('srsDimension', srsDimension);\n    const srsName = context['srsName'];\n    // only 2d for simple features profile\n    const points = value.getCoordinates();\n    const len = points.length;\n    const parts = new Array(len);\n    let point;\n    for (let i = 0; i < len; ++i) {\n      point = points[i];\n      parts[i] = this.getCoords_(point, srsName, hasZ);\n    }\n    writeStringTextNode(node, parts.join(' '));\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} geometry Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writePoint(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const pos = createElementNS(node.namespaceURI, 'pos');\n    node.appendChild(pos);\n    this.writePos_(pos, geometry, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeEnvelope(node, extent, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const keys = ['lowerCorner', 'upperCorner'];\n    const values = [extent[0] + ' ' + extent[1], extent[2] + ' ' + extent[3]];\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      ({node: node}),\n      this.ENVELOPE_SERIALIZERS,\n      OBJECT_PROPERTY_NODE_FACTORY,\n      values,\n      objectStack,\n      keys,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} geometry LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeLinearRing(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const posList = createElementNS(node.namespaceURI, 'posList');\n    node.appendChild(posList);\n    this.writePosList_(posList, geometry, objectStack);\n  }\n\n  /**\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Node} Node.\n   * @private\n   */\n  RING_NODE_FACTORY_(value, objectStack, nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const parentNode = context.node;\n    const exteriorWritten = context['exteriorWritten'];\n    if (exteriorWritten === undefined) {\n      context['exteriorWritten'] = true;\n    }\n    return createElementNS(\n      parentNode.namespaceURI,\n      exteriorWritten !== undefined ? 'interior' : 'exterior'\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Polygon} geometry Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeSurfaceOrPolygon(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'PolygonPatch' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {\n      const rings = geometry.getLinearRings();\n      pushSerializeAndPop(\n        {node: node, hasZ: hasZ, srsName: srsName},\n        this.RING_SERIALIZERS,\n        this.RING_NODE_FACTORY_,\n        rings,\n        objectStack,\n        undefined,\n        this\n      );\n    } else if (node.nodeName === 'Surface') {\n      const patches = createElementNS(node.namespaceURI, 'patches');\n      node.appendChild(patches);\n      this.writeSurfacePatches_(patches, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {LineString} geometry LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeCurveOrLineString(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'LineStringSegment' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (\n      node.nodeName === 'LineString' ||\n      node.nodeName === 'LineStringSegment'\n    ) {\n      const posList = createElementNS(node.namespaceURI, 'posList');\n      node.appendChild(posList);\n      this.writePosList_(posList, geometry, objectStack);\n    } else if (node.nodeName === 'Curve') {\n      const segments = createElementNS(node.namespaceURI, 'segments');\n      node.appendChild(segments);\n      this.writeCurveSegments_(segments, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {MultiPolygon} geometry MultiPolygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiSurfaceOrPolygon(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const surface = context['surface'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const polygons = geometry.getPolygons();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName, surface: surface},\n      this.SURFACEORPOLYGONMEMBER_SERIALIZERS,\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,\n      polygons,\n      objectStack,\n      undefined,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry MultiPoint geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiPoint(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    const hasZ = context['hasZ'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const points = geometry.getPoints();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName},\n      this.POINTMEMBER_SERIALIZERS,\n      makeSimpleNodeFactory('pointMember'),\n      points,\n      objectStack,\n      undefined,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {MultiLineString} geometry MultiLineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiCurveOrLineString(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const curve = context['curve'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const lines = geometry.getLineStrings();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName, curve: curve},\n      this.LINESTRINGORCURVEMEMBER_SERIALIZERS,\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,\n      lines,\n      objectStack,\n      undefined,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} ring LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeRing(node, ring, objectStack) {\n    const linearRing = createElementNS(node.namespaceURI, 'LinearRing');\n    node.appendChild(linearRing);\n    this.writeLinearRing(linearRing, ring, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Polygon} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeSurfaceOrPolygonMember(node, polygon, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeSurfaceOrPolygon(child, polygon, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} point Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writePointMember(node, point, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'Point');\n    node.appendChild(child);\n    this.writePoint(child, point, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {LineString} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeLineStringOrCurveMember(node, line, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeCurveOrLineString(child, line, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Polygon} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeSurfacePatches_(node, polygon, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'PolygonPatch');\n    node.appendChild(child);\n    this.writeSurfaceOrPolygon(child, polygon, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {LineString} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeCurveSegments_(node, line, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'LineStringSegment');\n    node.appendChild(child);\n    this.writeCurveOrLineString(child, line, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent} geometry Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeGeometryElement(node, geometry, objectStack) {\n    const context = /** @type {import(\"./Feature.js\").WriteOptions} */ (\n      objectStack[objectStack.length - 1]\n    );\n    const item = Object.assign({}, context);\n    item['node'] = node;\n    let value;\n    if (Array.isArray(geometry)) {\n      value = transformExtentWithOptions(\n        /** @type {import(\"../extent.js\").Extent} */ (geometry),\n        context\n      );\n    } else {\n      value = transformGeometryWithOptions(\n        /** @type {import(\"../geom/Geometry.js\").default} */ (geometry),\n        true,\n        context\n      );\n    }\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      this.GEOMETRY_SERIALIZERS,\n      this.GEOMETRY_NODE_FACTORY_,\n      [value],\n      objectStack,\n      undefined,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeFeatureElement(node, feature, objectStack) {\n    const fid = feature.getId();\n    if (fid) {\n      node.setAttribute('fid', /** @type {string} */ (fid));\n    }\n    const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    const featureNS = context['featureNS'];\n    const geometryName = feature.getGeometryName();\n    if (!context.serializers) {\n      context.serializers = {};\n      context.serializers[featureNS] = {};\n    }\n    const keys = [];\n    const values = [];\n    if (feature.hasProperties()) {\n      const properties = feature.getProperties();\n      for (const key in properties) {\n        const value = properties[key];\n        if (value !== null) {\n          keys.push(key);\n          values.push(value);\n          if (\n            key == geometryName ||\n            typeof (/** @type {?} */ (value).getSimplifiedGeometry) ===\n              'function'\n          ) {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] = makeChildAppender(\n                this.writeGeometryElement,\n                this\n              );\n            }\n          } else {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] =\n                makeChildAppender(writeStringTextNode);\n            }\n          }\n        }\n      }\n    }\n    const item = Object.assign({}, context);\n    item.node = node;\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      context.serializers,\n      makeSimpleNodeFactory(undefined, featureNS),\n      values,\n      objectStack,\n      keys\n    );\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeFeatureMembers_(node, features, objectStack) {\n    const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    const featureType = context['featureType'];\n    const featureNS = context['featureNS'];\n    /** @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>} */\n    const serializers = {};\n    serializers[featureNS] = {};\n    serializers[featureNS][featureType] = makeChildAppender(\n      this.writeFeatureElement,\n      this\n    );\n    const item = Object.assign({}, context);\n    item.node = node;\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      serializers,\n      makeSimpleNodeFactory(featureType, featureNS),\n      features,\n      objectStack\n    );\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Node|undefined} Node.\n   * @private\n   */\n  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(value, objectStack, nodeName) {\n    const parentNode = objectStack[objectStack.length - 1].node;\n    return createElementNS(\n      this.namespace,\n      MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]\n    );\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Element|undefined} Node.\n   * @private\n   */\n  GEOMETRY_NODE_FACTORY_(value, objectStack, nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const multiSurface = context['multiSurface'];\n    const surface = context['surface'];\n    const curve = context['curve'];\n    const multiCurve = context['multiCurve'];\n    if (!Array.isArray(value)) {\n      nodeName = /** @type {import(\"../geom/Geometry.js\").default} */ (\n        value\n      ).getType();\n      if (nodeName === 'MultiPolygon' && multiSurface === true) {\n        nodeName = 'MultiSurface';\n      } else if (nodeName === 'Polygon' && surface === true) {\n        nodeName = 'Surface';\n      } else if (nodeName === 'LineString' && curve === true) {\n        nodeName = 'Curve';\n      } else if (nodeName === 'MultiLineString' && multiCurve === true) {\n        nodeName = 'MultiCurve';\n      }\n    } else {\n      nodeName = 'Envelope';\n    }\n    return createElementNS(this.namespace, nodeName);\n  }\n\n  /**\n   * Encode a geometry in GML 3.1.1 Simple Features.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Node} Node.\n   * @api\n   */\n  writeGeometryNode(geometry, options) {\n    options = this.adaptOptions(options);\n    const geom = createElementNS(this.namespace, 'geom');\n    const context = {\n      node: geom,\n      hasZ: this.hasZ,\n      srsName: this.srsName,\n      curve: this.curve_,\n      surface: this.surface_,\n      multiSurface: this.multiSurface_,\n      multiCurve: this.multiCurve_,\n    };\n    if (options) {\n      Object.assign(context, options);\n    }\n    this.writeGeometryElement(geom, geometry, [context]);\n    return geom;\n  }\n\n  /**\n   * Encode an array of features in the GML 3.1.1 format as an XML node.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Element} Node.\n   * @api\n   */\n  writeFeaturesNode(features, options) {\n    options = this.adaptOptions(options);\n    const node = createElementNS(this.namespace, 'featureMembers');\n    node.setAttributeNS(\n      XML_SCHEMA_INSTANCE_URI,\n      'xsi:schemaLocation',\n      this.schemaLocation\n    );\n    const context = {\n      srsName: this.srsName,\n      hasZ: this.hasZ,\n      curve: this.curve_,\n      surface: this.surface_,\n      multiSurface: this.multiSurface_,\n      multiCurve: this.multiCurve_,\n      featureNS: this.featureNS,\n      featureType: this.featureType,\n    };\n    if (options) {\n      Object.assign(context, options);\n    }\n    this.writeFeatureMembers_(node, features, [context]);\n    return node;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'pos': makeReplacer(GML3.prototype.readFlatPos),\n    'posList': makeReplacer(GML3.prototype.readFlatPosList),\n    'coordinates': makeReplacer(GML2.prototype.readFlatCoordinates),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'interior': GML3.prototype.interiorParser,\n    'exterior': GML3.prototype.exteriorParser,\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Point': makeReplacer(GMLBase.prototype.readPoint),\n    'MultiPoint': makeReplacer(GMLBase.prototype.readMultiPoint),\n    'LineString': makeReplacer(GMLBase.prototype.readLineString),\n    'MultiLineString': makeReplacer(GMLBase.prototype.readMultiLineString),\n    'LinearRing': makeReplacer(GMLBase.prototype.readLinearRing),\n    'Polygon': makeReplacer(GMLBase.prototype.readPolygon),\n    'MultiPolygon': makeReplacer(GMLBase.prototype.readMultiPolygon),\n    'Surface': makeReplacer(GML3.prototype.readSurface),\n    'MultiSurface': makeReplacer(GML3.prototype.readMultiSurface),\n    'Curve': makeReplacer(GML3.prototype.readCurve),\n    'MultiCurve': makeReplacer(GML3.prototype.readMultiCurve),\n    'Envelope': makeReplacer(GML3.prototype.readEnvelope),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.MULTICURVE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'curveMember': makeArrayPusher(GML3.prototype.curveMemberParser),\n    'curveMembers': makeArrayPusher(GML3.prototype.curveMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.MULTISURFACE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeArrayPusher(GML3.prototype.surfaceMemberParser),\n    'surfaceMembers': makeArrayPusher(GML3.prototype.surfaceMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.CURVEMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LineString': makeArrayPusher(GMLBase.prototype.readLineString),\n    'Curve': makeArrayPusher(GML3.prototype.readCurve),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.SURFACEMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon),\n    'Surface': makeArrayPusher(GML3.prototype.readSurface),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.SURFACE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'patches': makeReplacer(GML3.prototype.readPatch),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.CURVE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'segments': makeReplacer(GML3.prototype.readSegment),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.ENVELOPE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeArrayPusher(GML3.prototype.readFlatPosList),\n    'upperCorner': makeArrayPusher(GML3.prototype.readFlatPosList),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.PATCHES_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'PolygonPatch': makeReplacer(GML3.prototype.readPolygonPatch),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.SEGMENTS_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LineStringSegment': makeArrayExtender(\n      GML3.prototype.readLineStringSegment\n    ),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.RING_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LinearRing': makeReplacer(GMLBase.prototype.readFlatLinearRing),\n    'Ring': makeReplacer(GML3.prototype.readFlatCurveRing),\n  },\n};\n\n/**\n * Encode an array of features in GML 3.1.1 Simple Features.\n *\n * @function\n * @param {Array<import(\"../Feature.js\").default>} features Features.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n * @return {string} Result.\n * @api\n */\nGML3.prototype.writeFeatures;\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.RING_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'exterior': makeChildAppender(GML3.prototype.writeRing),\n    'interior': makeChildAppender(GML3.prototype.writeRing),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.ENVELOPE_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeChildAppender(writeStringTextNode),\n    'upperCorner': makeChildAppender(writeStringTextNode),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygonMember\n    ),\n    'polygonMember': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygonMember\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.POINTMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeChildAppender(GML3.prototype.writePointMember),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeChildAppender(\n      GML3.prototype.writeLineStringOrCurveMember\n    ),\n    'curveMember': makeChildAppender(\n      GML3.prototype.writeLineStringOrCurveMember\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.GEOMETRY_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'Curve': makeChildAppender(GML3.prototype.writeCurveOrLineString),\n    'MultiCurve': makeChildAppender(GML3.prototype.writeMultiCurveOrLineString),\n    'Point': makeChildAppender(GML3.prototype.writePoint),\n    'MultiPoint': makeChildAppender(GML3.prototype.writeMultiPoint),\n    'LineString': makeChildAppender(GML3.prototype.writeCurveOrLineString),\n    'MultiLineString': makeChildAppender(\n      GML3.prototype.writeMultiCurveOrLineString\n    ),\n    'LinearRing': makeChildAppender(GML3.prototype.writeLinearRing),\n    'Polygon': makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),\n    'MultiPolygon': makeChildAppender(\n      GML3.prototype.writeMultiSurfaceOrPolygon\n    ),\n    'Surface': makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),\n    'MultiSurface': makeChildAppender(\n      GML3.prototype.writeMultiSurfaceOrPolygon\n    ),\n    'Envelope': makeChildAppender(GML3.prototype.writeEnvelope),\n  },\n};\n\nexport default GML3;\n"],"mappings":";;;;;;;;;;;;AAAA;AACA;AACA;AACA,OAAOA,IAAI,MAAM,WAAW;AAC5B,OAAOC,OAAO,IAAGC,KAAK,QAAO,cAAc;AAC3C,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,eAAe,MAAM,4BAA4B;AACxD,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,OAAO,MAAM,oBAAoB;AACxC,SACEC,4BAA4B,EAC5BC,uBAAuB,EACvBC,eAAe,EACfC,iBAAiB,EACjBC,iBAAiB,EACjBC,eAAe,EACfC,iBAAiB,EACjBC,YAAY,EACZC,qBAAqB,EACrBC,SAAS,EACTC,eAAe,EACfC,mBAAmB,QACd,WAAW;AAClB,SAAQC,cAAc,QAAO,cAAc;AAC3C,SAAQC,MAAM,QAAO,aAAa;AAClC,SAAQC,GAAG,IAAIC,aAAa,QAAO,YAAY;AAC/C,SAAQC,4BAA4B,EAAEC,mBAAmB,QAAO,UAAU;AAC1E,SACEC,0BAA0B,EAC1BC,4BAA4B,QACvB,cAAc;;AAErB;AACA;AACA;AACA;AACA;AACA,IAAMC,cAAc,GAClBzB,KAAK,GACL,8DAA8D,GAC9D,iBAAiB;;AAEnB;AACA;AACA;AACA;AACA,IAAM0B,gCAAgC,GAAG;EACvC,iBAAiB,EAAE,kBAAkB;EACrC,YAAY,EAAE,aAAa;EAC3B,cAAc,EAAE,eAAe;EAC/B,cAAc,EAAE;AAClB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA,IAQMC,IAAI,0BAAAC,QAAA;EACR;AACF;AACA;EACE,SAAAD,KAAYE,OAAO,EAAE;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAJ,IAAA;IACnBE,OAAO,GAAGA,OAAO,GAAGA,OAAO,GAAG,CAAC,CAAC;IAEhCC,KAAA,GAAAE,UAAA,OAAAL,IAAA,GAAME,OAAO;;IAEb;AACJ;AACA;AACA;IACIC,KAAA,CAAKG,QAAQ,GAAGJ,OAAO,CAACK,OAAO,KAAKC,SAAS,GAAGN,OAAO,CAACK,OAAO,GAAG,KAAK;;IAEvE;AACJ;AACA;AACA;IACIJ,KAAA,CAAKM,MAAM,GAAGP,OAAO,CAACQ,KAAK,KAAKF,SAAS,GAAGN,OAAO,CAACQ,KAAK,GAAG,KAAK;;IAEjE;AACJ;AACA;AACA;IACIP,KAAA,CAAKQ,WAAW,GACdT,OAAO,CAACU,UAAU,KAAKJ,SAAS,GAAGN,OAAO,CAACU,UAAU,GAAG,IAAI;;IAE9D;AACJ;AACA;AACA;IACIT,KAAA,CAAKU,aAAa,GAChBX,OAAO,CAACY,YAAY,KAAKN,SAAS,GAAGN,OAAO,CAACY,YAAY,GAAG,IAAI;;IAElE;AACJ;AACA;IACIX,KAAA,CAAKL,cAAc,GAAGI,OAAO,CAACJ,cAAc,GACxCI,OAAO,CAACJ,cAAc,GACtBA,cAAc;;IAElB;AACJ;AACA;AACA;IACIK,KAAA,CAAKY,IAAI,GAAGb,OAAO,CAACa,IAAI,KAAKP,SAAS,GAAGN,OAAO,CAACa,IAAI,GAAG,KAAK;IAAC,OAAAZ,KAAA;EAChE;;EAEA;AACF;AACA;AACA;AACA;EAJEa,SAAA,CAAAhB,IAAA,EAAAC,QAAA;EAAA,OAAAgB,YAAA,CAAAjB,IAAA;IAAAkB,GAAA;IAAAC,KAAA,EAKA,SAAAC,cAAcA,CAACC,IAAI,EAAEC,WAAW,EAAE;MAChC;MACA,IAAMC,WAAW,GAAGnC,eAAe,CACjC,EAAE,EACF,IAAI,CAACoC,kBAAkB,EACvBH,IAAI,EACJC,WAAW,EACX,IACF,CAAC;MACD,IAAIC,WAAW,EAAE;QACf,IAAME,eAAe,GAAG,IAAIlD,eAAe,CAACgD,WAAW,CAAC;QACxD,OAAOE,eAAe;MACxB;MACA,OAAOjB,SAAS;IAClB;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAAU,GAAA;IAAAC,KAAA,EAKA,SAAAO,iBAAiBA,CAACL,IAAI,EAAEC,WAAW,EAAE;MACnC;MACA,IAAMC,WAAW,GAAGnC,eAAe,CACjC,EAAE,EACF,IAAI,CAACoC,kBAAkB,EACvBH,IAAI,EACJC,WAAW,EACX,IACF,CAAC;MACD,IAAMK,eAAe,GAAG,EAAE;MAC1B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGN,WAAW,CAACO,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAE,EAAED,CAAC,EAAE;QACpDrC,MAAM,CAACoC,eAAe,EAAEJ,WAAW,CAACK,CAAC,CAAC,CAACG,kBAAkB,CAAC,CAAC,CAAC;MAC9D;MACA,OAAOJ,eAAe;IACxB;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAAT,GAAA;IAAAC,KAAA,EAKA,SAAAa,gBAAgBA,CAACX,IAAI,EAAEC,WAAW,EAAE;MAClC;MACA,IAAMW,QAAQ,GAAG7C,eAAe,CAC9B,EAAE,EACF,IAAI,CAAC8C,oBAAoB,EACzBb,IAAI,EACJC,WAAW,EACX,IACF,CAAC;MACD,IAAIW,QAAQ,EAAE;QACZ,OAAO,IAAIzD,YAAY,CAACyD,QAAQ,CAAC;MACnC;IACF;;IAEA;AACF;AACA;AACA;EAHE;IAAAf,GAAA;IAAAC,KAAA,EAIA,SAAAgB,iBAAiBA,CAACd,IAAI,EAAEC,WAAW,EAAE;MACnCnC,SAAS,CAAC,IAAI,CAACiD,mBAAmB,EAAEf,IAAI,EAAEC,WAAW,EAAE,IAAI,CAAC;IAC9D;;IAEA;AACF;AACA;AACA;EAHE;IAAAJ,GAAA;IAAAC,KAAA,EAIA,SAAAkB,mBAAmBA,CAAChB,IAAI,EAAEC,WAAW,EAAE;MACrCnC,SAAS,CAAC,IAAI,CAACmD,qBAAqB,EAAEjB,IAAI,EAAEC,WAAW,EAAE,IAAI,CAAC;IAChE;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAAJ,GAAA;IAAAC,KAAA,EAKA,SAAAoB,SAASA,CAAClB,IAAI,EAAEC,WAAW,EAAE;MAC3B,OAAOlC,eAAe,CACpB,CAAC,IAAI,CAAC,EACN,IAAI,CAACoD,eAAe,EACpBnB,IAAI,EACJC,WAAW,EACX,IACF,CAAC;IACH;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAAJ,GAAA;IAAAC,KAAA,EAKA,SAAAsB,WAAWA,CAACpB,IAAI,EAAEC,WAAW,EAAE;MAC7B,OAAOlC,eAAe,CAAC,EAAE,EAAE,IAAI,CAACsD,gBAAgB,EAAErB,IAAI,EAAEC,WAAW,EAAE,IAAI,CAAC;IAC5E;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAAJ,GAAA;IAAAC,KAAA,EAKA,SAAAwB,gBAAgBA,CAACtB,IAAI,EAAEC,WAAW,EAAE;MAClC,OAAOlC,eAAe,CACpB,CAAC,IAAI,CAAC,EACN,IAAI,CAACwD,yBAAyB,EAC9BvB,IAAI,EACJC,WAAW,EACX,IACF,CAAC;IACH;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAAJ,GAAA;IAAAC,KAAA,EAKA,SAAA0B,qBAAqBA,CAACxB,IAAI,EAAEC,WAAW,EAAE;MACvC,OAAOlC,eAAe,CACpB,CAAC,IAAI,CAAC,EACN,IAAI,CAAC0D,iCAAiC,EACtCzB,IAAI,EACJC,WAAW,EACX,IACF,CAAC;IACH;;IAEA;AACF;AACA;AACA;EAHE;IAAAJ,GAAA;IAAAC,KAAA,EAIA,SAAA4B,cAAcA,CAAC1B,IAAI,EAAEC,WAAW,EAAE;MAChC;MACA,IAAM0B,cAAc,GAAG5D,eAAe,CACpCoB,SAAS,EACT,IAAI,CAACyC,YAAY,EACjB5B,IAAI,EACJC,WAAW,EACX,IACF,CAAC;MACD,IAAI0B,cAAc,EAAE;QAClB,IAAME,eAAe,GACnB;QACC5B,WAAW,CAACA,WAAW,CAACQ,MAAM,GAAG,CAAC,CAAE;QACvCoB,eAAe,CAACC,IAAI,CAACH,cAAc,CAAC;MACtC;IACF;;IAEA;AACF;AACA;AACA;EAHE;IAAA9B,GAAA;IAAAC,KAAA,EAIA,SAAAiC,cAAcA,CAAC/B,IAAI,EAAEC,WAAW,EAAE;MAChC;MACA,IAAM0B,cAAc,GAAG5D,eAAe,CACpCoB,SAAS,EACT,IAAI,CAACyC,YAAY,EACjB5B,IAAI,EACJC,WAAW,EACX,IACF,CAAC;MACD,IAAI0B,cAAc,EAAE;QAClB,IAAME,eAAe,GACnB;QACC5B,WAAW,CAACA,WAAW,CAACQ,MAAM,GAAG,CAAC,CAAE;QACvCoB,eAAe,CAAC,CAAC,CAAC,GAAGF,cAAc;MACrC;IACF;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAA9B,GAAA;IAAAC,KAAA,EAKA,SAAAkC,WAAWA,CAAChC,IAAI,EAAEC,WAAW,EAAE;MAC7B;MACA,IAAM4B,eAAe,GAAG9D,eAAe,CACrC,CAAC,IAAI,CAAC,EACN,IAAI,CAACkE,eAAe,EACpBjC,IAAI,EACJC,WAAW,EACX,IACF,CAAC;MACD,IAAI4B,eAAe,IAAIA,eAAe,CAAC,CAAC,CAAC,EAAE;QACzC,IAAMvB,eAAe,GAAGuB,eAAe,CAAC,CAAC,CAAC;QAC1C,IAAMK,IAAI,GAAG,CAAC5B,eAAe,CAACG,MAAM,CAAC;QACrC,IAAIF,CAAC,EAAEC,EAAE;QACT,KAAKD,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGqB,eAAe,CAACpB,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAE,EAAED,CAAC,EAAE;UACpDrC,MAAM,CAACoC,eAAe,EAAEuB,eAAe,CAACtB,CAAC,CAAC,CAAC;UAC3C2B,IAAI,CAACJ,IAAI,CAACxB,eAAe,CAACG,MAAM,CAAC;QACnC;QACA,OAAO,IAAIrD,OAAO,CAACkD,eAAe,EAAE,KAAK,EAAE4B,IAAI,CAAC;MAClD;MACA,OAAO/C,SAAS;IAClB;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAAU,GAAA;IAAAC,KAAA,EAKA,SAAAqC,SAASA,CAACnC,IAAI,EAAEC,WAAW,EAAE;MAC3B;MACA,IAAMK,eAAe,GAAGvC,eAAe,CACrC,CAAC,IAAI,CAAC,EACN,IAAI,CAACqE,aAAa,EAClBpC,IAAI,EACJC,WAAW,EACX,IACF,CAAC;MACD,IAAIK,eAAe,EAAE;QACnB,IAAM+B,UAAU,GAAG,IAAIpF,UAAU,CAACqD,eAAe,EAAE,KAAK,CAAC;QACzD,OAAO+B,UAAU;MACnB;MACA,OAAOlD,SAAS;IAClB;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAAU,GAAA;IAAAC,KAAA,EAKA,SAAAwC,YAAYA,CAACtC,IAAI,EAAEC,WAAW,EAAE;MAC9B;MACA,IAAMK,eAAe,GAAGvC,eAAe,CACrC,CAAC,IAAI,CAAC,EACN,IAAI,CAACwE,gBAAgB,EACrBvC,IAAI,EACJC,WAAW,EACX,IACF,CAAC;MACD,OAAOhC,cAAc,CACnBqC,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EACrBA,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EACrBA,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EACrBA,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC,CACtB,CAAC;IACH;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAAT,GAAA;IAAAC,KAAA,EAKA,SAAA0C,WAAWA,CAACxC,IAAI,EAAEC,WAAW,EAAE;MAC7B,IAAIwC,CAAC,GAAGjF,iBAAiB,CAACwC,IAAI,EAAE,KAAK,CAAC;MACtC,IAAM0C,EAAE,GAAG,4CAA4C;MACvD;MACA,IAAMpC,eAAe,GAAG,EAAE;MAC1B,IAAIqC,CAAC;MACL,OAAQA,CAAC,GAAGD,EAAE,CAACE,IAAI,CAACH,CAAC,CAAC,EAAG;QACvBnC,eAAe,CAACwB,IAAI,CAACe,UAAU,CAACF,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACtCF,CAAC,GAAGA,CAAC,CAACK,MAAM,CAACH,CAAC,CAAC,CAAC,CAAC,CAAClC,MAAM,CAAC;MAC3B;MACA,IAAIgC,CAAC,KAAK,EAAE,EAAE;QACZ,OAAOtD,SAAS;MAClB;MACA,IAAM4D,OAAO,GAAG9C,WAAW,CAAC,CAAC,CAAC;MAC9B,IAAM+C,YAAY,GAAGD,OAAO,CAAC,SAAS,CAAC;MACvC,IAAIE,eAAe,GAAG,KAAK;MAC3B,IAAID,YAAY,EAAE;QAChB,IAAME,IAAI,GAAG9E,aAAa,CAAC4E,YAAY,CAAC;QACxCC,eAAe,GAAGC,IAAI,CAACC,kBAAkB,CAAC,CAAC;MAC7C;MACA,IAAIF,eAAe,KAAK,KAAK,EAAE;QAC7B,IAAI1C,CAAC,EAAEC,EAAE;QACT,KAAKD,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGF,eAAe,CAACG,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAED,CAAC,IAAI,CAAC,EAAE;UACvD,IAAM6C,CAAC,GAAG9C,eAAe,CAACC,CAAC,CAAC;UAC5B,IAAM8C,CAAC,GAAG/C,eAAe,CAACC,CAAC,GAAG,CAAC,CAAC;UAChCD,eAAe,CAACC,CAAC,CAAC,GAAG8C,CAAC;UACtB/C,eAAe,CAACC,CAAC,GAAG,CAAC,CAAC,GAAG6C,CAAC;QAC5B;MACF;MACA,IAAME,GAAG,GAAGhD,eAAe,CAACG,MAAM;MAClC,IAAI6C,GAAG,IAAI,CAAC,EAAE;QACZhD,eAAe,CAACwB,IAAI,CAAC,CAAC,CAAC;MACzB;MACA,IAAIwB,GAAG,KAAK,CAAC,EAAE;QACb,OAAOnE,SAAS;MAClB;MACA,OAAOmB,eAAe;IACxB;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAAT,GAAA;IAAAC,KAAA,EAKA,SAAAyD,eAAeA,CAACvD,IAAI,EAAEC,WAAW,EAAE;MACjC,IAAMwC,CAAC,GAAGjF,iBAAiB,CAACwC,IAAI,EAAE,KAAK,CAAC,CAACwD,OAAO,CAAC,YAAY,EAAE,EAAE,CAAC;MAClE,IAAMT,OAAO,GAAG9C,WAAW,CAAC,CAAC,CAAC;MAC9B,IAAM+C,YAAY,GAAGD,OAAO,CAAC,SAAS,CAAC;MACvC,IAAMU,gBAAgB,GAAGV,OAAO,CAAC,cAAc,CAAC;MAChD,IAAIE,eAAe,GAAG,KAAK;MAC3B,IAAID,YAAY,EAAE;QAChB,IAAME,IAAI,GAAG9E,aAAa,CAAC4E,YAAY,CAAC;QACxCC,eAAe,GAAGC,IAAI,CAACC,kBAAkB,CAAC,CAAC;MAC7C;MACA,IAAMO,MAAM,GAAGjB,CAAC,CAACkB,KAAK,CAAC,KAAK,CAAC;MAC7B;MACA,IAAIC,GAAG,GAAG,CAAC;MACX,IAAI5D,IAAI,CAAC6D,YAAY,CAAC,cAAc,CAAC,EAAE;QACrCD,GAAG,GAAGvF,4BAA4B,CAAC2B,IAAI,CAAC6D,YAAY,CAAC,cAAc,CAAC,CAAC;MACvE,CAAC,MAAM,IAAI7D,IAAI,CAAC6D,YAAY,CAAC,WAAW,CAAC,EAAE;QACzCD,GAAG,GAAGvF,4BAA4B,CAAC2B,IAAI,CAAC6D,YAAY,CAAC,WAAW,CAAC,CAAC;MACpE,CAAC,MAAM,IACL,sBAAwB7D,IAAI,CAAC8D,UAAU,CAAED,YAAY,CAAC,cAAc,CAAC,EACrE;QACAD,GAAG,GAAGvF,4BAA4B,CAChC,sBAAwB2B,IAAI,CAAC8D,UAAU,CAAED,YAAY,CAAC,cAAc,CACtE,CAAC;MACH,CAAC,MAAM,IAAIJ,gBAAgB,EAAE;QAC3BG,GAAG,GAAGvF,4BAA4B,CAACoF,gBAAgB,CAAC;MACtD;MACA,IAAIJ,CAAC,EAAED,CAAC,EAAEW,CAAC;MACX,IAAMzD,eAAe,GAAG,EAAE;MAC1B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGkD,MAAM,CAACjD,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAED,CAAC,IAAIqD,GAAG,EAAE;QACpDP,CAAC,GAAGR,UAAU,CAACa,MAAM,CAACnD,CAAC,CAAC,CAAC;QACzB6C,CAAC,GAAGP,UAAU,CAACa,MAAM,CAACnD,CAAC,GAAG,CAAC,CAAC,CAAC;QAC7BwD,CAAC,GAAGH,GAAG,KAAK,CAAC,GAAGf,UAAU,CAACa,MAAM,CAACnD,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;QAC7C,IAAI0C,eAAe,CAACH,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI,EAAE;UACzCxC,eAAe,CAACwB,IAAI,CAACuB,CAAC,EAAED,CAAC,EAAEW,CAAC,CAAC;QAC/B,CAAC,MAAM;UACLzD,eAAe,CAACwB,IAAI,CAACsB,CAAC,EAAEC,CAAC,EAAEU,CAAC,CAAC;QAC/B;MACF;MACA,OAAOzD,eAAe;IACxB;;IAEA;AACF;AACA;AACA;AACA;AACA;EALE;IAAAT,GAAA;IAAAC,KAAA,EAMA,SAAAkE,SAASA,CAAChE,IAAI,EAAEF,KAAK,EAAEG,WAAW,EAAE;MAClC,IAAM8C,OAAO,GAAG9C,WAAW,CAACA,WAAW,CAACQ,MAAM,GAAG,CAAC,CAAC;MACnD,IAAMf,IAAI,GAAGqD,OAAO,CAAC,MAAM,CAAC;MAC5B,IAAMkB,YAAY,GAAGvE,IAAI,GAAG,GAAG,GAAG,GAAG;MACrCM,IAAI,CAACkE,YAAY,CAAC,cAAc,EAAED,YAAY,CAAC;MAC/C,IAAME,OAAO,GAAGpB,OAAO,CAAC,SAAS,CAAC;MAClC,IAAIE,eAAe,GAAG,KAAK;MAC3B,IAAIkB,OAAO,EAAE;QACXlB,eAAe,GAAG7E,aAAa,CAAC+F,OAAO,CAAC,CAAChB,kBAAkB,CAAC,CAAC;MAC/D;MACA,IAAMiB,KAAK,GAAGtE,KAAK,CAACuE,cAAc,CAAC,CAAC;MACpC,IAAIX,MAAM;MACV;MACA,IAAIT,eAAe,CAACH,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI,EAAE;QACzCY,MAAM,GAAGU,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG,GAAGA,KAAK,CAAC,CAAC,CAAC;MACpC,CAAC,MAAM;QACLV,MAAM,GAAGU,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG,GAAGA,KAAK,CAAC,CAAC,CAAC;MACpC;MACA,IAAI1E,IAAI,EAAE;QACR;QACA,IAAMqE,CAAC,GAAGK,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC;QACvBV,MAAM,IAAI,GAAG,GAAGK,CAAC;MACnB;MACAzF,mBAAmB,CAAC0B,IAAI,EAAE0D,MAAM,CAAC;IACnC;;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;EANE;IAAA7D,GAAA;IAAAC,KAAA,EAOA,SAAAwE,UAAUA,CAACF,KAAK,EAAED,OAAO,EAAEzE,IAAI,EAAE;MAC/B,IAAIuD,eAAe,GAAG,KAAK;MAC3B,IAAIkB,OAAO,EAAE;QACXlB,eAAe,GAAG7E,aAAa,CAAC+F,OAAO,CAAC,CAAChB,kBAAkB,CAAC,CAAC;MAC/D;MACA,IAAIO,MAAM,GACRT,eAAe,CAACH,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI,GACjCsB,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG,GAAGA,KAAK,CAAC,CAAC,CAAC,GACzBA,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG,GAAGA,KAAK,CAAC,CAAC,CAAC;MAC/B,IAAI1E,IAAI,EAAE;QACR;QACA,IAAMqE,CAAC,GAAGK,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC;QACvBV,MAAM,IAAI,GAAG,GAAGK,CAAC;MACnB;MAEA,OAAOL,MAAM;IACf;;IAEA;AACF;AACA;AACA;AACA;AACA;EALE;IAAA7D,GAAA;IAAAC,KAAA,EAMA,SAAAyE,aAAaA,CAACvE,IAAI,EAAEF,KAAK,EAAEG,WAAW,EAAE;MACtC,IAAM8C,OAAO,GAAG9C,WAAW,CAACA,WAAW,CAACQ,MAAM,GAAG,CAAC,CAAC;MACnD,IAAMf,IAAI,GAAGqD,OAAO,CAAC,MAAM,CAAC;MAC5B,IAAMkB,YAAY,GAAGvE,IAAI,GAAG,GAAG,GAAG,GAAG;MACrCM,IAAI,CAACkE,YAAY,CAAC,cAAc,EAAED,YAAY,CAAC;MAC/C,IAAME,OAAO,GAAGpB,OAAO,CAAC,SAAS,CAAC;MAClC;MACA,IAAMyB,MAAM,GAAG1E,KAAK,CAACuE,cAAc,CAAC,CAAC;MACrC,IAAMf,GAAG,GAAGkB,MAAM,CAAC/D,MAAM;MACzB,IAAMgE,KAAK,GAAG,IAAIC,KAAK,CAACpB,GAAG,CAAC;MAC5B,IAAIc,KAAK;MACT,KAAK,IAAI7D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+C,GAAG,EAAE,EAAE/C,CAAC,EAAE;QAC5B6D,KAAK,GAAGI,MAAM,CAACjE,CAAC,CAAC;QACjBkE,KAAK,CAAClE,CAAC,CAAC,GAAG,IAAI,CAAC+D,UAAU,CAACF,KAAK,EAAED,OAAO,EAAEzE,IAAI,CAAC;MAClD;MACApB,mBAAmB,CAAC0B,IAAI,EAAEyE,KAAK,CAACE,IAAI,CAAC,GAAG,CAAC,CAAC;IAC5C;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAA9E,GAAA;IAAAC,KAAA,EAKA,SAAA8E,UAAUA,CAAC5E,IAAI,EAAE6E,QAAQ,EAAE5E,WAAW,EAAE;MACtC,IAAM8C,OAAO,GAAG9C,WAAW,CAACA,WAAW,CAACQ,MAAM,GAAG,CAAC,CAAC;MACnD,IAAM0D,OAAO,GAAGpB,OAAO,CAAC,SAAS,CAAC;MAClC,IAAIoB,OAAO,EAAE;QACXnE,IAAI,CAACkE,YAAY,CAAC,SAAS,EAAEC,OAAO,CAAC;MACvC;MACA,IAAMW,GAAG,GAAGvH,eAAe,CAACyC,IAAI,CAAC+E,YAAY,EAAE,KAAK,CAAC;MACrD/E,IAAI,CAACgF,WAAW,CAACF,GAAG,CAAC;MACrB,IAAI,CAACd,SAAS,CAACc,GAAG,EAAED,QAAQ,EAAE5E,WAAW,CAAC;IAC5C;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAAJ,GAAA;IAAAC,KAAA,EAKA,SAAAmF,aAAaA,CAACjF,IAAI,EAAEkF,MAAM,EAAEjF,WAAW,EAAE;MACvC,IAAM8C,OAAO,GAAG9C,WAAW,CAACA,WAAW,CAACQ,MAAM,GAAG,CAAC,CAAC;MACnD,IAAM0D,OAAO,GAAGpB,OAAO,CAAC,SAAS,CAAC;MAClC,IAAIoB,OAAO,EAAE;QACXnE,IAAI,CAACkE,YAAY,CAAC,SAAS,EAAEC,OAAO,CAAC;MACvC;MACA,IAAMgB,IAAI,GAAG,CAAC,aAAa,EAAE,aAAa,CAAC;MAC3C,IAAMC,MAAM,GAAG,CAACF,MAAM,CAAC,CAAC,CAAC,GAAG,GAAG,GAAGA,MAAM,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,GAAG,GAAG,GAAGA,MAAM,CAAC,CAAC,CAAC,CAAC;MACzElH,mBAAmB,CACjB;MACC;QAACgC,IAAI,EAAEA;MAAI,CAAC,EACb,IAAI,CAACqF,oBAAoB,EACzBhI,4BAA4B,EAC5B+H,MAAM,EACNnF,WAAW,EACXkF,IAAI,EACJ,IACF,CAAC;IACH;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAAtF,GAAA;IAAAC,KAAA,EAKA,SAAAwF,eAAeA,CAACtF,IAAI,EAAE6E,QAAQ,EAAE5E,WAAW,EAAE;MAC3C,IAAM8C,OAAO,GAAG9C,WAAW,CAACA,WAAW,CAACQ,MAAM,GAAG,CAAC,CAAC;MACnD,IAAM0D,OAAO,GAAGpB,OAAO,CAAC,SAAS,CAAC;MAClC,IAAIoB,OAAO,EAAE;QACXnE,IAAI,CAACkE,YAAY,CAAC,SAAS,EAAEC,OAAO,CAAC;MACvC;MACA,IAAMoB,OAAO,GAAGhI,eAAe,CAACyC,IAAI,CAAC+E,YAAY,EAAE,SAAS,CAAC;MAC7D/E,IAAI,CAACgF,WAAW,CAACO,OAAO,CAAC;MACzB,IAAI,CAAChB,aAAa,CAACgB,OAAO,EAAEV,QAAQ,EAAE5E,WAAW,CAAC;IACpD;;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;EANE;IAAAJ,GAAA;IAAAC,KAAA,EAOA,SAAA0F,kBAAkBA,CAAC1F,KAAK,EAAEG,WAAW,EAAEwF,QAAQ,EAAE;MAC/C,IAAM1C,OAAO,GAAG9C,WAAW,CAACA,WAAW,CAACQ,MAAM,GAAG,CAAC,CAAC;MACnD,IAAMqD,UAAU,GAAGf,OAAO,CAAC/C,IAAI;MAC/B,IAAM0F,eAAe,GAAG3C,OAAO,CAAC,iBAAiB,CAAC;MAClD,IAAI2C,eAAe,KAAKvG,SAAS,EAAE;QACjC4D,OAAO,CAAC,iBAAiB,CAAC,GAAG,IAAI;MACnC;MACA,OAAOxF,eAAe,CACpBuG,UAAU,CAACiB,YAAY,EACvBW,eAAe,KAAKvG,SAAS,GAAG,UAAU,GAAG,UAC/C,CAAC;IACH;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAAU,GAAA;IAAAC,KAAA,EAKA,SAAA6F,qBAAqBA,CAAC3F,IAAI,EAAE6E,QAAQ,EAAE5E,WAAW,EAAE;MACjD,IAAM8C,OAAO,GAAG9C,WAAW,CAACA,WAAW,CAACQ,MAAM,GAAG,CAAC,CAAC;MACnD,IAAMf,IAAI,GAAGqD,OAAO,CAAC,MAAM,CAAC;MAC5B,IAAMoB,OAAO,GAAGpB,OAAO,CAAC,SAAS,CAAC;MAClC,IAAI/C,IAAI,CAACyF,QAAQ,KAAK,cAAc,IAAItB,OAAO,EAAE;QAC/CnE,IAAI,CAACkE,YAAY,CAAC,SAAS,EAAEC,OAAO,CAAC;MACvC;MACA,IAAInE,IAAI,CAACyF,QAAQ,KAAK,SAAS,IAAIzF,IAAI,CAACyF,QAAQ,KAAK,cAAc,EAAE;QACnE,IAAMG,KAAK,GAAGf,QAAQ,CAACgB,cAAc,CAAC,CAAC;QACvC7H,mBAAmB,CACjB;UAACgC,IAAI,EAAEA,IAAI;UAAEN,IAAI,EAAEA,IAAI;UAAEyE,OAAO,EAAEA;QAAO,CAAC,EAC1C,IAAI,CAAC2B,gBAAgB,EACrB,IAAI,CAACN,kBAAkB,EACvBI,KAAK,EACL3F,WAAW,EACXd,SAAS,EACT,IACF,CAAC;MACH,CAAC,MAAM,IAAIa,IAAI,CAACyF,QAAQ,KAAK,SAAS,EAAE;QACtC,IAAMM,OAAO,GAAGxI,eAAe,CAACyC,IAAI,CAAC+E,YAAY,EAAE,SAAS,CAAC;QAC7D/E,IAAI,CAACgF,WAAW,CAACe,OAAO,CAAC;QACzB,IAAI,CAACC,oBAAoB,CAACD,OAAO,EAAElB,QAAQ,EAAE5E,WAAW,CAAC;MAC3D;IACF;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAAJ,GAAA;IAAAC,KAAA,EAKA,SAAAmG,sBAAsBA,CAACjG,IAAI,EAAE6E,QAAQ,EAAE5E,WAAW,EAAE;MAClD,IAAM8C,OAAO,GAAG9C,WAAW,CAACA,WAAW,CAACQ,MAAM,GAAG,CAAC,CAAC;MACnD,IAAM0D,OAAO,GAAGpB,OAAO,CAAC,SAAS,CAAC;MAClC,IAAI/C,IAAI,CAACyF,QAAQ,KAAK,mBAAmB,IAAItB,OAAO,EAAE;QACpDnE,IAAI,CAACkE,YAAY,CAAC,SAAS,EAAEC,OAAO,CAAC;MACvC;MACA,IACEnE,IAAI,CAACyF,QAAQ,KAAK,YAAY,IAC9BzF,IAAI,CAACyF,QAAQ,KAAK,mBAAmB,EACrC;QACA,IAAMF,OAAO,GAAGhI,eAAe,CAACyC,IAAI,CAAC+E,YAAY,EAAE,SAAS,CAAC;QAC7D/E,IAAI,CAACgF,WAAW,CAACO,OAAO,CAAC;QACzB,IAAI,CAAChB,aAAa,CAACgB,OAAO,EAAEV,QAAQ,EAAE5E,WAAW,CAAC;MACpD,CAAC,MAAM,IAAID,IAAI,CAACyF,QAAQ,KAAK,OAAO,EAAE;QACpC,IAAMS,QAAQ,GAAG3I,eAAe,CAACyC,IAAI,CAAC+E,YAAY,EAAE,UAAU,CAAC;QAC/D/E,IAAI,CAACgF,WAAW,CAACkB,QAAQ,CAAC;QAC1B,IAAI,CAACC,mBAAmB,CAACD,QAAQ,EAAErB,QAAQ,EAAE5E,WAAW,CAAC;MAC3D;IACF;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAAJ,GAAA;IAAAC,KAAA,EAKA,SAAAsG,0BAA0BA,CAACpG,IAAI,EAAE6E,QAAQ,EAAE5E,WAAW,EAAE;MACtD,IAAM8C,OAAO,GAAG9C,WAAW,CAACA,WAAW,CAACQ,MAAM,GAAG,CAAC,CAAC;MACnD,IAAMf,IAAI,GAAGqD,OAAO,CAAC,MAAM,CAAC;MAC5B,IAAMoB,OAAO,GAAGpB,OAAO,CAAC,SAAS,CAAC;MAClC,IAAM7D,OAAO,GAAG6D,OAAO,CAAC,SAAS,CAAC;MAClC,IAAIoB,OAAO,EAAE;QACXnE,IAAI,CAACkE,YAAY,CAAC,SAAS,EAAEC,OAAO,CAAC;MACvC;MACA,IAAMvD,QAAQ,GAAGiE,QAAQ,CAACwB,WAAW,CAAC,CAAC;MACvCrI,mBAAmB,CACjB;QAACgC,IAAI,EAAEA,IAAI;QAAEN,IAAI,EAAEA,IAAI;QAAEyE,OAAO,EAAEA,OAAO;QAAEjF,OAAO,EAAEA;MAAO,CAAC,EAC5D,IAAI,CAACoH,kCAAkC,EACvC,IAAI,CAACC,kCAAkC,EACvC3F,QAAQ,EACRX,WAAW,EACXd,SAAS,EACT,IACF,CAAC;IACH;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAAU,GAAA;IAAAC,KAAA,EAKA,SAAA0G,eAAeA,CAACxG,IAAI,EAAE6E,QAAQ,EAAE5E,WAAW,EAAE;MAC3C,IAAM8C,OAAO,GAAG9C,WAAW,CAACA,WAAW,CAACQ,MAAM,GAAG,CAAC,CAAC;MACnD,IAAM0D,OAAO,GAAGpB,OAAO,CAAC,SAAS,CAAC;MAClC,IAAMrD,IAAI,GAAGqD,OAAO,CAAC,MAAM,CAAC;MAC5B,IAAIoB,OAAO,EAAE;QACXnE,IAAI,CAACkE,YAAY,CAAC,SAAS,EAAEC,OAAO,CAAC;MACvC;MACA,IAAMK,MAAM,GAAGK,QAAQ,CAAC4B,SAAS,CAAC,CAAC;MACnCzI,mBAAmB,CACjB;QAACgC,IAAI,EAAEA,IAAI;QAAEN,IAAI,EAAEA,IAAI;QAAEyE,OAAO,EAAEA;MAAO,CAAC,EAC1C,IAAI,CAACuC,uBAAuB,EAC5B7I,qBAAqB,CAAC,aAAa,CAAC,EACpC2G,MAAM,EACNvE,WAAW,EACXd,SAAS,EACT,IACF,CAAC;IACH;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAAU,GAAA;IAAAC,KAAA,EAKA,SAAA6G,2BAA2BA,CAAC3G,IAAI,EAAE6E,QAAQ,EAAE5E,WAAW,EAAE;MACvD,IAAM8C,OAAO,GAAG9C,WAAW,CAACA,WAAW,CAACQ,MAAM,GAAG,CAAC,CAAC;MACnD,IAAMf,IAAI,GAAGqD,OAAO,CAAC,MAAM,CAAC;MAC5B,IAAMoB,OAAO,GAAGpB,OAAO,CAAC,SAAS,CAAC;MAClC,IAAM1D,KAAK,GAAG0D,OAAO,CAAC,OAAO,CAAC;MAC9B,IAAIoB,OAAO,EAAE;QACXnE,IAAI,CAACkE,YAAY,CAAC,SAAS,EAAEC,OAAO,CAAC;MACvC;MACA,IAAMyC,KAAK,GAAG/B,QAAQ,CAACgC,cAAc,CAAC,CAAC;MACvC7I,mBAAmB,CACjB;QAACgC,IAAI,EAAEA,IAAI;QAAEN,IAAI,EAAEA,IAAI;QAAEyE,OAAO,EAAEA,OAAO;QAAE9E,KAAK,EAAEA;MAAK,CAAC,EACxD,IAAI,CAACyH,mCAAmC,EACxC,IAAI,CAACP,kCAAkC,EACvCK,KAAK,EACL3G,WAAW,EACXd,SAAS,EACT,IACF,CAAC;IACH;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAAU,GAAA;IAAAC,KAAA,EAKA,SAAAiH,SAASA,CAAC/G,IAAI,EAAEgH,IAAI,EAAE/G,WAAW,EAAE;MACjC,IAAMgH,UAAU,GAAG1J,eAAe,CAACyC,IAAI,CAAC+E,YAAY,EAAE,YAAY,CAAC;MACnE/E,IAAI,CAACgF,WAAW,CAACiC,UAAU,CAAC;MAC5B,IAAI,CAAC3B,eAAe,CAAC2B,UAAU,EAAED,IAAI,EAAE/G,WAAW,CAAC;IACrD;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAAJ,GAAA;IAAAC,KAAA,EAKA,SAAAoH,2BAA2BA,CAAClH,IAAI,EAAEmH,OAAO,EAAElH,WAAW,EAAE;MACtD,IAAMmH,KAAK,GAAG,IAAI,CAACC,sBAAsB,CAACF,OAAO,EAAElH,WAAW,CAAC;MAC/D,IAAImH,KAAK,EAAE;QACTpH,IAAI,CAACgF,WAAW,CAACoC,KAAK,CAAC;QACvB,IAAI,CAACzB,qBAAqB,CAACyB,KAAK,EAAED,OAAO,EAAElH,WAAW,CAAC;MACzD;IACF;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAAJ,GAAA;IAAAC,KAAA,EAKA,SAAAwH,gBAAgBA,CAACtH,IAAI,EAAEoE,KAAK,EAAEnE,WAAW,EAAE;MACzC,IAAMmH,KAAK,GAAG7J,eAAe,CAACyC,IAAI,CAAC+E,YAAY,EAAE,OAAO,CAAC;MACzD/E,IAAI,CAACgF,WAAW,CAACoC,KAAK,CAAC;MACvB,IAAI,CAACxC,UAAU,CAACwC,KAAK,EAAEhD,KAAK,EAAEnE,WAAW,CAAC;IAC5C;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAAJ,GAAA;IAAAC,KAAA,EAKA,SAAAyH,4BAA4BA,CAACvH,IAAI,EAAEwH,IAAI,EAAEvH,WAAW,EAAE;MACpD,IAAMmH,KAAK,GAAG,IAAI,CAACC,sBAAsB,CAACG,IAAI,EAAEvH,WAAW,CAAC;MAC5D,IAAImH,KAAK,EAAE;QACTpH,IAAI,CAACgF,WAAW,CAACoC,KAAK,CAAC;QACvB,IAAI,CAACnB,sBAAsB,CAACmB,KAAK,EAAEI,IAAI,EAAEvH,WAAW,CAAC;MACvD;IACF;;IAEA;AACF;AACA;AACA;AACA;AACA;EALE;IAAAJ,GAAA;IAAAC,KAAA,EAMA,SAAAkG,oBAAoBA,CAAChG,IAAI,EAAEmH,OAAO,EAAElH,WAAW,EAAE;MAC/C,IAAMmH,KAAK,GAAG7J,eAAe,CAACyC,IAAI,CAAC+E,YAAY,EAAE,cAAc,CAAC;MAChE/E,IAAI,CAACgF,WAAW,CAACoC,KAAK,CAAC;MACvB,IAAI,CAACzB,qBAAqB,CAACyB,KAAK,EAAED,OAAO,EAAElH,WAAW,CAAC;IACzD;;IAEA;AACF;AACA;AACA;AACA;AACA;EALE;IAAAJ,GAAA;IAAAC,KAAA,EAMA,SAAAqG,mBAAmBA,CAACnG,IAAI,EAAEwH,IAAI,EAAEvH,WAAW,EAAE;MAC3C,IAAMmH,KAAK,GAAG7J,eAAe,CAACyC,IAAI,CAAC+E,YAAY,EAAE,mBAAmB,CAAC;MACrE/E,IAAI,CAACgF,WAAW,CAACoC,KAAK,CAAC;MACvB,IAAI,CAACnB,sBAAsB,CAACmB,KAAK,EAAEI,IAAI,EAAEvH,WAAW,CAAC;IACvD;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAAJ,GAAA;IAAAC,KAAA,EAKA,SAAA2H,oBAAoBA,CAACzH,IAAI,EAAE6E,QAAQ,EAAE5E,WAAW,EAAE;MAChD,IAAM8C,OAAO,GAAG;MACd9C,WAAW,CAACA,WAAW,CAACQ,MAAM,GAAG,CAAC,CACnC;MACD,IAAMiH,IAAI,GAAGC,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAE7E,OAAO,CAAC;MACvC2E,IAAI,CAAC,MAAM,CAAC,GAAG1H,IAAI;MACnB,IAAIF,KAAK;MACT,IAAI4E,KAAK,CAACmD,OAAO,CAAChD,QAAQ,CAAC,EAAE;QAC3B/E,KAAK,GAAGvB,0BAA0B,CAChC,4CAA8CsG,QAAQ,EACtD9B,OACF,CAAC;MACH,CAAC,MAAM;QACLjD,KAAK,GAAGtB,4BAA4B,CAClC,oDAAsDqG,QAAQ,EAC9D,IAAI,EACJ9B,OACF,CAAC;MACH;MACA/E,mBAAmB,CACjB;MACC0J,IAAI,EACL,IAAI,CAACI,oBAAoB,EACzB,IAAI,CAACT,sBAAsB,EAC3B,CAACvH,KAAK,CAAC,EACPG,WAAW,EACXd,SAAS,EACT,IACF,CAAC;IACH;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAAU,GAAA;IAAAC,KAAA,EAKA,SAAAiI,mBAAmBA,CAAC/H,IAAI,EAAEgI,OAAO,EAAE/H,WAAW,EAAE;MAC9C,IAAMgI,GAAG,GAAGD,OAAO,CAACE,KAAK,CAAC,CAAC;MAC3B,IAAID,GAAG,EAAE;QACPjI,IAAI,CAACkE,YAAY,CAAC,KAAK,EAAE,qBAAuB+D,GAAI,CAAC;MACvD;MACA,IAAMlF,OAAO,GAAG,qBAAuB9C,WAAW,CAACA,WAAW,CAACQ,MAAM,GAAG,CAAC,CAAE;MAC3E,IAAM0H,SAAS,GAAGpF,OAAO,CAAC,WAAW,CAAC;MACtC,IAAMqF,YAAY,GAAGJ,OAAO,CAACK,eAAe,CAAC,CAAC;MAC9C,IAAI,CAACtF,OAAO,CAACuF,WAAW,EAAE;QACxBvF,OAAO,CAACuF,WAAW,GAAG,CAAC,CAAC;QACxBvF,OAAO,CAACuF,WAAW,CAACH,SAAS,CAAC,GAAG,CAAC,CAAC;MACrC;MACA,IAAMhD,IAAI,GAAG,EAAE;MACf,IAAMC,MAAM,GAAG,EAAE;MACjB,IAAI4C,OAAO,CAACO,aAAa,CAAC,CAAC,EAAE;QAC3B,IAAMC,UAAU,GAAGR,OAAO,CAACS,aAAa,CAAC,CAAC;QAC1C,KAAK,IAAM5I,GAAG,IAAI2I,UAAU,EAAE;UAC5B,IAAM1I,KAAK,GAAG0I,UAAU,CAAC3I,GAAG,CAAC;UAC7B,IAAIC,KAAK,KAAK,IAAI,EAAE;YAClBqF,IAAI,CAACrD,IAAI,CAACjC,GAAG,CAAC;YACduF,MAAM,CAACtD,IAAI,CAAChC,KAAK,CAAC;YAClB,IACED,GAAG,IAAIuI,YAAY,IACnB,QAAQ,gBAAkBtI,KAAK,CAAE4I,qBAAqB,CAAC,KACrD,UAAU,EACZ;cACA,IAAI,EAAE7I,GAAG,IAAIkD,OAAO,CAACuF,WAAW,CAACH,SAAS,CAAC,CAAC,EAAE;gBAC5CpF,OAAO,CAACuF,WAAW,CAACH,SAAS,CAAC,CAACtI,GAAG,CAAC,GAAGlC,iBAAiB,CACrD,IAAI,CAAC8J,oBAAoB,EACzB,IACF,CAAC;cACH;YACF,CAAC,MAAM;cACL,IAAI,EAAE5H,GAAG,IAAIkD,OAAO,CAACuF,WAAW,CAACH,SAAS,CAAC,CAAC,EAAE;gBAC5CpF,OAAO,CAACuF,WAAW,CAACH,SAAS,CAAC,CAACtI,GAAG,CAAC,GACjClC,iBAAiB,CAACW,mBAAmB,CAAC;cAC1C;YACF;UACF;QACF;MACF;MACA,IAAMoJ,IAAI,GAAGC,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAE7E,OAAO,CAAC;MACvC2E,IAAI,CAAC1H,IAAI,GAAGA,IAAI;MAChBhC,mBAAmB,CACjB;MACC0J,IAAI,EACL3E,OAAO,CAACuF,WAAW,EACnBzK,qBAAqB,CAACsB,SAAS,EAAEgJ,SAAS,CAAC,EAC3C/C,MAAM,EACNnF,WAAW,EACXkF,IACF,CAAC;IACH;;IAEA;AACF;AACA;AACA;AACA;AACA;EALE;IAAAtF,GAAA;IAAAC,KAAA,EAMA,SAAA6I,oBAAoBA,CAAC3I,IAAI,EAAE4I,QAAQ,EAAE3I,WAAW,EAAE;MAChD,IAAM8C,OAAO,GAAG,qBAAuB9C,WAAW,CAACA,WAAW,CAACQ,MAAM,GAAG,CAAC,CAAE;MAC3E,IAAMoI,WAAW,GAAG9F,OAAO,CAAC,aAAa,CAAC;MAC1C,IAAMoF,SAAS,GAAGpF,OAAO,CAAC,WAAW,CAAC;MACtC;MACA,IAAMuF,WAAW,GAAG,CAAC,CAAC;MACtBA,WAAW,CAACH,SAAS,CAAC,GAAG,CAAC,CAAC;MAC3BG,WAAW,CAACH,SAAS,CAAC,CAACU,WAAW,CAAC,GAAGlL,iBAAiB,CACrD,IAAI,CAACoK,mBAAmB,EACxB,IACF,CAAC;MACD,IAAML,IAAI,GAAGC,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAE7E,OAAO,CAAC;MACvC2E,IAAI,CAAC1H,IAAI,GAAGA,IAAI;MAChBhC,mBAAmB,CACjB;MACC0J,IAAI,EACLY,WAAW,EACXzK,qBAAqB,CAACgL,WAAW,EAAEV,SAAS,CAAC,EAC7CS,QAAQ,EACR3I,WACF,CAAC;IACH;;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EAPE;IAAAJ,GAAA;IAAAC,KAAA,EAQA,SAAAyG,kCAAkCA,CAACzG,KAAK,EAAEG,WAAW,EAAEwF,QAAQ,EAAE;MAC/D,IAAM3B,UAAU,GAAG7D,WAAW,CAACA,WAAW,CAACQ,MAAM,GAAG,CAAC,CAAC,CAACT,IAAI;MAC3D,OAAOzC,eAAe,CACpB,IAAI,CAACuL,SAAS,EACdpK,gCAAgC,CAACoF,UAAU,CAAC2B,QAAQ,CACtD,CAAC;IACH;;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EAPE;IAAA5F,GAAA;IAAAC,KAAA,EAQA,SAAAuH,sBAAsBA,CAACvH,KAAK,EAAEG,WAAW,EAAEwF,QAAQ,EAAE;MACnD,IAAM1C,OAAO,GAAG9C,WAAW,CAACA,WAAW,CAACQ,MAAM,GAAG,CAAC,CAAC;MACnD,IAAMhB,YAAY,GAAGsD,OAAO,CAAC,cAAc,CAAC;MAC5C,IAAM7D,OAAO,GAAG6D,OAAO,CAAC,SAAS,CAAC;MAClC,IAAM1D,KAAK,GAAG0D,OAAO,CAAC,OAAO,CAAC;MAC9B,IAAMxD,UAAU,GAAGwD,OAAO,CAAC,YAAY,CAAC;MACxC,IAAI,CAAC2B,KAAK,CAACmD,OAAO,CAAC/H,KAAK,CAAC,EAAE;QACzB2F,QAAQ,GAAG,oDACT3F,KAAK,CACLiJ,OAAO,CAAC,CAAC;QACX,IAAItD,QAAQ,KAAK,cAAc,IAAIhG,YAAY,KAAK,IAAI,EAAE;UACxDgG,QAAQ,GAAG,cAAc;QAC3B,CAAC,MAAM,IAAIA,QAAQ,KAAK,SAAS,IAAIvG,OAAO,KAAK,IAAI,EAAE;UACrDuG,QAAQ,GAAG,SAAS;QACtB,CAAC,MAAM,IAAIA,QAAQ,KAAK,YAAY,IAAIpG,KAAK,KAAK,IAAI,EAAE;UACtDoG,QAAQ,GAAG,OAAO;QACpB,CAAC,MAAM,IAAIA,QAAQ,KAAK,iBAAiB,IAAIlG,UAAU,KAAK,IAAI,EAAE;UAChEkG,QAAQ,GAAG,YAAY;QACzB;MACF,CAAC,MAAM;QACLA,QAAQ,GAAG,UAAU;MACvB;MACA,OAAOlI,eAAe,CAAC,IAAI,CAACuL,SAAS,EAAErD,QAAQ,CAAC;IAClD;;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EAPE;IAAA5F,GAAA;IAAAC,KAAA,EAQA,SAAAkJ,iBAAiBA,CAACnE,QAAQ,EAAEhG,OAAO,EAAE;MACnCA,OAAO,GAAG,IAAI,CAACoK,YAAY,CAACpK,OAAO,CAAC;MACpC,IAAMqK,IAAI,GAAG3L,eAAe,CAAC,IAAI,CAACuL,SAAS,EAAE,MAAM,CAAC;MACpD,IAAM/F,OAAO,GAAG;QACd/C,IAAI,EAAEkJ,IAAI;QACVxJ,IAAI,EAAE,IAAI,CAACA,IAAI;QACfyE,OAAO,EAAE,IAAI,CAACA,OAAO;QACrB9E,KAAK,EAAE,IAAI,CAACD,MAAM;QAClBF,OAAO,EAAE,IAAI,CAACD,QAAQ;QACtBQ,YAAY,EAAE,IAAI,CAACD,aAAa;QAChCD,UAAU,EAAE,IAAI,CAACD;MACnB,CAAC;MACD,IAAIT,OAAO,EAAE;QACX8I,MAAM,CAACC,MAAM,CAAC7E,OAAO,EAAElE,OAAO,CAAC;MACjC;MACA,IAAI,CAAC4I,oBAAoB,CAACyB,IAAI,EAAErE,QAAQ,EAAE,CAAC9B,OAAO,CAAC,CAAC;MACpD,OAAOmG,IAAI;IACb;;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EAPE;IAAArJ,GAAA;IAAAC,KAAA,EAQA,SAAAqJ,iBAAiBA,CAACP,QAAQ,EAAE/J,OAAO,EAAE;MACnCA,OAAO,GAAG,IAAI,CAACoK,YAAY,CAACpK,OAAO,CAAC;MACpC,IAAMmB,IAAI,GAAGzC,eAAe,CAAC,IAAI,CAACuL,SAAS,EAAE,gBAAgB,CAAC;MAC9D9I,IAAI,CAACoJ,cAAc,CACjB9L,uBAAuB,EACvB,oBAAoB,EACpB,IAAI,CAACmB,cACP,CAAC;MACD,IAAMsE,OAAO,GAAG;QACdoB,OAAO,EAAE,IAAI,CAACA,OAAO;QACrBzE,IAAI,EAAE,IAAI,CAACA,IAAI;QACfL,KAAK,EAAE,IAAI,CAACD,MAAM;QAClBF,OAAO,EAAE,IAAI,CAACD,QAAQ;QACtBQ,YAAY,EAAE,IAAI,CAACD,aAAa;QAChCD,UAAU,EAAE,IAAI,CAACD,WAAW;QAC5B6I,SAAS,EAAE,IAAI,CAACA,SAAS;QACzBU,WAAW,EAAE,IAAI,CAACA;MACpB,CAAC;MACD,IAAIhK,OAAO,EAAE;QACX8I,MAAM,CAACC,MAAM,CAAC7E,OAAO,EAAElE,OAAO,CAAC;MACjC;MACA,IAAI,CAAC8J,oBAAoB,CAAC3I,IAAI,EAAE4I,QAAQ,EAAE,CAAC7F,OAAO,CAAC,CAAC;MACpD,OAAO/C,IAAI;IACb;EAAC;AAAA,EA58BgBjD,OAAO;AA+8B1B;AACA;AACA;AACA;AACA4B,IAAI,CAAC0K,SAAS,CAAC5H,iCAAiC,GAAG;EACjD,4BAA4B,EAAE;IAC5B,KAAK,EAAE7D,YAAY,CAACe,IAAI,CAAC0K,SAAS,CAAC7G,WAAW,CAAC;IAC/C,SAAS,EAAE5E,YAAY,CAACe,IAAI,CAAC0K,SAAS,CAAC9F,eAAe,CAAC;IACvD,aAAa,EAAE3F,YAAY,CAACd,IAAI,CAACuM,SAAS,CAACC,mBAAmB;EAChE;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA3K,IAAI,CAAC0K,SAAS,CAAC9H,yBAAyB,GAAG;EACzC,4BAA4B,EAAE;IAC5B,UAAU,EAAE5C,IAAI,CAAC0K,SAAS,CAAC3H,cAAc;IACzC,UAAU,EAAE/C,IAAI,CAAC0K,SAAS,CAACtH;EAC7B;AACF,CAAC;;AAED;AACA;AACA;AACA;AACApD,IAAI,CAAC0K,SAAS,CAACE,gBAAgB,GAAG;EAChC,4BAA4B,EAAE;IAC5B,OAAO,EAAE3L,YAAY,CAACb,OAAO,CAACsM,SAAS,CAACG,SAAS,CAAC;IAClD,YAAY,EAAE5L,YAAY,CAACb,OAAO,CAACsM,SAAS,CAACI,cAAc,CAAC;IAC5D,YAAY,EAAE7L,YAAY,CAACb,OAAO,CAACsM,SAAS,CAACK,cAAc,CAAC;IAC5D,iBAAiB,EAAE9L,YAAY,CAACb,OAAO,CAACsM,SAAS,CAACM,mBAAmB,CAAC;IACtE,YAAY,EAAE/L,YAAY,CAACb,OAAO,CAACsM,SAAS,CAACO,cAAc,CAAC;IAC5D,SAAS,EAAEhM,YAAY,CAACb,OAAO,CAACsM,SAAS,CAACQ,WAAW,CAAC;IACtD,cAAc,EAAEjM,YAAY,CAACb,OAAO,CAACsM,SAAS,CAACS,gBAAgB,CAAC;IAChE,SAAS,EAAElM,YAAY,CAACe,IAAI,CAAC0K,SAAS,CAACrH,WAAW,CAAC;IACnD,cAAc,EAAEpE,YAAY,CAACe,IAAI,CAAC0K,SAAS,CAAC1I,gBAAgB,CAAC;IAC7D,OAAO,EAAE/C,YAAY,CAACe,IAAI,CAAC0K,SAAS,CAAClH,SAAS,CAAC;IAC/C,YAAY,EAAEvE,YAAY,CAACe,IAAI,CAAC0K,SAAS,CAACtJ,cAAc,CAAC;IACzD,UAAU,EAAEnC,YAAY,CAACe,IAAI,CAAC0K,SAAS,CAAC/G,YAAY;EACtD;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA3D,IAAI,CAAC0K,SAAS,CAAClJ,kBAAkB,GAAG;EAClC,4BAA4B,EAAE;IAC5B,aAAa,EAAEzC,eAAe,CAACiB,IAAI,CAAC0K,SAAS,CAACvI,iBAAiB,CAAC;IAChE,cAAc,EAAEpD,eAAe,CAACiB,IAAI,CAAC0K,SAAS,CAACvI,iBAAiB;EAClE;AACF,CAAC;;AAED;AACA;AACA;AACA;AACAnC,IAAI,CAAC0K,SAAS,CAACxI,oBAAoB,GAAG;EACpC,4BAA4B,EAAE;IAC5B,eAAe,EAAEnD,eAAe,CAACiB,IAAI,CAAC0K,SAAS,CAACrI,mBAAmB,CAAC;IACpE,gBAAgB,EAAEtD,eAAe,CAACiB,IAAI,CAAC0K,SAAS,CAACrI,mBAAmB;EACtE;AACF,CAAC;;AAED;AACA;AACA;AACA;AACArC,IAAI,CAAC0K,SAAS,CAACtI,mBAAmB,GAAG;EACnC,4BAA4B,EAAE;IAC5B,YAAY,EAAErD,eAAe,CAACX,OAAO,CAACsM,SAAS,CAACK,cAAc,CAAC;IAC/D,OAAO,EAAEhM,eAAe,CAACiB,IAAI,CAAC0K,SAAS,CAAClH,SAAS;EACnD;AACF,CAAC;;AAED;AACA;AACA;AACA;AACAxD,IAAI,CAAC0K,SAAS,CAACpI,qBAAqB,GAAG;EACrC,4BAA4B,EAAE;IAC5B,SAAS,EAAEvD,eAAe,CAACX,OAAO,CAACsM,SAAS,CAACQ,WAAW,CAAC;IACzD,SAAS,EAAEnM,eAAe,CAACiB,IAAI,CAAC0K,SAAS,CAACrH,WAAW;EACvD;AACF,CAAC;;AAED;AACA;AACA;AACA;AACArD,IAAI,CAAC0K,SAAS,CAACpH,eAAe,GAAG;EAC/B,4BAA4B,EAAE;IAC5B,SAAS,EAAErE,YAAY,CAACe,IAAI,CAAC0K,SAAS,CAACnI,SAAS;EAClD;AACF,CAAC;;AAED;AACA;AACA;AACA;AACAvC,IAAI,CAAC0K,SAAS,CAACjH,aAAa,GAAG;EAC7B,4BAA4B,EAAE;IAC5B,UAAU,EAAExE,YAAY,CAACe,IAAI,CAAC0K,SAAS,CAACjI,WAAW;EACrD;AACF,CAAC;;AAED;AACA;AACA;AACA;AACAzC,IAAI,CAAC0K,SAAS,CAAC9G,gBAAgB,GAAG;EAChC,4BAA4B,EAAE;IAC5B,aAAa,EAAE7E,eAAe,CAACiB,IAAI,CAAC0K,SAAS,CAAC9F,eAAe,CAAC;IAC9D,aAAa,EAAE7F,eAAe,CAACiB,IAAI,CAAC0K,SAAS,CAAC9F,eAAe;EAC/D;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA5E,IAAI,CAAC0K,SAAS,CAAClI,eAAe,GAAG;EAC/B,4BAA4B,EAAE;IAC5B,cAAc,EAAEvD,YAAY,CAACe,IAAI,CAAC0K,SAAS,CAAC/H,gBAAgB;EAC9D;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA3C,IAAI,CAAC0K,SAAS,CAAChI,gBAAgB,GAAG;EAChC,4BAA4B,EAAE;IAC5B,mBAAmB,EAAE5D,iBAAiB,CACpCkB,IAAI,CAAC0K,SAAS,CAAC7H,qBACjB;EACF;AACF,CAAC;;AAED;AACA;AACA;AACA;AACAzE,OAAO,CAACsM,SAAS,CAACzH,YAAY,GAAG;EAC/B,4BAA4B,EAAE;IAC5B,YAAY,EAAEhE,YAAY,CAACb,OAAO,CAACsM,SAAS,CAACU,kBAAkB,CAAC;IAChE,MAAM,EAAEnM,YAAY,CAACe,IAAI,CAAC0K,SAAS,CAAChJ,iBAAiB;EACvD;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA1B,IAAI,CAAC0K,SAAS,CAACW,aAAa;;AAE5B;AACA;AACA;AACArL,IAAI,CAAC0K,SAAS,CAACvD,gBAAgB,GAAG;EAChC,4BAA4B,EAAE;IAC5B,UAAU,EAAEnI,iBAAiB,CAACgB,IAAI,CAAC0K,SAAS,CAACtC,SAAS,CAAC;IACvD,UAAU,EAAEpJ,iBAAiB,CAACgB,IAAI,CAAC0K,SAAS,CAACtC,SAAS;EACxD;AACF,CAAC;;AAED;AACA;AACA;AACApI,IAAI,CAAC0K,SAAS,CAAChE,oBAAoB,GAAG;EACpC,4BAA4B,EAAE;IAC5B,aAAa,EAAE1H,iBAAiB,CAACW,mBAAmB,CAAC;IACrD,aAAa,EAAEX,iBAAiB,CAACW,mBAAmB;EACtD;AACF,CAAC;;AAED;AACA;AACA;AACAK,IAAI,CAAC0K,SAAS,CAAC/C,kCAAkC,GAAG;EAClD,4BAA4B,EAAE;IAC5B,eAAe,EAAE3I,iBAAiB,CAChCgB,IAAI,CAAC0K,SAAS,CAACnC,2BACjB,CAAC;IACD,eAAe,EAAEvJ,iBAAiB,CAChCgB,IAAI,CAAC0K,SAAS,CAACnC,2BACjB;EACF;AACF,CAAC;;AAED;AACA;AACA;AACAvI,IAAI,CAAC0K,SAAS,CAAC3C,uBAAuB,GAAG;EACvC,4BAA4B,EAAE;IAC5B,aAAa,EAAE/I,iBAAiB,CAACgB,IAAI,CAAC0K,SAAS,CAAC/B,gBAAgB;EAClE;AACF,CAAC;;AAED;AACA;AACA;AACA3I,IAAI,CAAC0K,SAAS,CAACvC,mCAAmC,GAAG;EACnD,4BAA4B,EAAE;IAC5B,kBAAkB,EAAEnJ,iBAAiB,CACnCgB,IAAI,CAAC0K,SAAS,CAAC9B,4BACjB,CAAC;IACD,aAAa,EAAE5J,iBAAiB,CAC9BgB,IAAI,CAAC0K,SAAS,CAAC9B,4BACjB;EACF;AACF,CAAC;;AAED;AACA;AACA;AACA5I,IAAI,CAAC0K,SAAS,CAACvB,oBAAoB,GAAG;EACpC,4BAA4B,EAAE;IAC5B,OAAO,EAAEnK,iBAAiB,CAACgB,IAAI,CAAC0K,SAAS,CAACpD,sBAAsB,CAAC;IACjE,YAAY,EAAEtI,iBAAiB,CAACgB,IAAI,CAAC0K,SAAS,CAAC1C,2BAA2B,CAAC;IAC3E,OAAO,EAAEhJ,iBAAiB,CAACgB,IAAI,CAAC0K,SAAS,CAACzE,UAAU,CAAC;IACrD,YAAY,EAAEjH,iBAAiB,CAACgB,IAAI,CAAC0K,SAAS,CAAC7C,eAAe,CAAC;IAC/D,YAAY,EAAE7I,iBAAiB,CAACgB,IAAI,CAAC0K,SAAS,CAACpD,sBAAsB,CAAC;IACtE,iBAAiB,EAAEtI,iBAAiB,CAClCgB,IAAI,CAAC0K,SAAS,CAAC1C,2BACjB,CAAC;IACD,YAAY,EAAEhJ,iBAAiB,CAACgB,IAAI,CAAC0K,SAAS,CAAC/D,eAAe,CAAC;IAC/D,SAAS,EAAE3H,iBAAiB,CAACgB,IAAI,CAAC0K,SAAS,CAAC1D,qBAAqB,CAAC;IAClE,cAAc,EAAEhI,iBAAiB,CAC/BgB,IAAI,CAAC0K,SAAS,CAACjD,0BACjB,CAAC;IACD,SAAS,EAAEzI,iBAAiB,CAACgB,IAAI,CAAC0K,SAAS,CAAC1D,qBAAqB,CAAC;IAClE,cAAc,EAAEhI,iBAAiB,CAC/BgB,IAAI,CAAC0K,SAAS,CAACjD,0BACjB,CAAC;IACD,UAAU,EAAEzI,iBAAiB,CAACgB,IAAI,CAAC0K,SAAS,CAACpE,aAAa;EAC5D;AACF,CAAC;AAED,eAAetG,IAAI","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}