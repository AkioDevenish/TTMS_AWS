{"ast":null,"code":"var _typeof = require(\"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"];\nrequire(\"core-js/modules/es.array.index-of.js\");\nrequire(\"core-js/modules/es.array.slice.js\");\nrequire(\"core-js/modules/es.regexp.constructor.js\");\nrequire(\"core-js/modules/es.regexp.dot-all.js\");\nrequire(\"core-js/modules/es.regexp.exec.js\");\nrequire(\"core-js/modules/es.regexp.sticky.js\");\nrequire(\"core-js/modules/es.regexp.to-string.js\");\nfunction getAttribute(tag, attributeName, options) {\n  var debug = options && options.debug || false;\n  if (debug) console.log(\"[xml-utils] getting \" + attributeName + \" in \" + tag);\n  var xml = _typeof(tag) === \"object\" ? tag.outer : tag;\n\n  // only search for attributes in the opening tag\n  var opening = xml.slice(0, xml.indexOf(\">\") + 1);\n  var quotechars = ['\"', \"'\"];\n  for (var i = 0; i < quotechars.length; i++) {\n    var _char = quotechars[i];\n    var pattern = attributeName + \"\\\\=\" + _char + \"([^\" + _char + \"]*)\" + _char;\n    if (debug) console.log(\"[xml-utils] pattern:\", pattern);\n    var re = new RegExp(pattern);\n    var match = re.exec(opening);\n    if (debug) console.log(\"[xml-utils] match:\", match);\n    if (match) return match[1];\n  }\n}\nmodule.exports = getAttribute;\nmodule.exports[\"default\"] = getAttribute;","map":{"version":3,"names":["getAttribute","tag","attributeName","options","debug","console","log","xml","_typeof","outer","opening","slice","indexOf","quotechars","i","length","char","pattern","re","RegExp","match","exec","module","exports"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/xml-utils/get-attribute.js"],"sourcesContent":["function getAttribute(tag, attributeName, options) {\n  const debug = (options && options.debug) || false;\n  if (debug) console.log(\"[xml-utils] getting \" + attributeName + \" in \" + tag);\n\n  const xml = typeof tag === \"object\" ? tag.outer : tag;\n\n  // only search for attributes in the opening tag\n  const opening = xml.slice(0, xml.indexOf(\">\") + 1);\n\n  const quotechars = ['\"', \"'\"];\n  for (let i = 0; i < quotechars.length; i++) {\n    const char = quotechars[i];\n    const pattern = attributeName + \"\\\\=\" + char + \"([^\" + char + \"]*)\" + char;\n    if (debug) console.log(\"[xml-utils] pattern:\", pattern);\n\n    const re = new RegExp(pattern);\n    const match = re.exec(opening);\n    if (debug) console.log(\"[xml-utils] match:\", match);\n    if (match) return match[1];\n  }\n}\n\nmodule.exports = getAttribute;\nmodule.exports.default = getAttribute;\n"],"mappings":";;;;;;;;AAAA,SAASA,YAAYA,CAACC,GAAG,EAAEC,aAAa,EAAEC,OAAO,EAAE;EACjD,IAAMC,KAAK,GAAID,OAAO,IAAIA,OAAO,CAACC,KAAK,IAAK,KAAK;EACjD,IAAIA,KAAK,EAAEC,OAAO,CAACC,GAAG,CAAC,sBAAsB,GAAGJ,aAAa,GAAG,MAAM,GAAGD,GAAG,CAAC;EAE7E,IAAMM,GAAG,GAAGC,OAAA,CAAOP,GAAG,MAAK,QAAQ,GAAGA,GAAG,CAACQ,KAAK,GAAGR,GAAG;;EAErD;EACA,IAAMS,OAAO,GAAGH,GAAG,CAACI,KAAK,CAAC,CAAC,EAAEJ,GAAG,CAACK,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAElD,IAAMC,UAAU,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC;EAC7B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,UAAU,CAACE,MAAM,EAAED,CAAC,EAAE,EAAE;IAC1C,IAAME,KAAI,GAAGH,UAAU,CAACC,CAAC,CAAC;IAC1B,IAAMG,OAAO,GAAGf,aAAa,GAAG,KAAK,GAAGc,KAAI,GAAG,KAAK,GAAGA,KAAI,GAAG,KAAK,GAAGA,KAAI;IAC1E,IAAIZ,KAAK,EAAEC,OAAO,CAACC,GAAG,CAAC,sBAAsB,EAAEW,OAAO,CAAC;IAEvD,IAAMC,EAAE,GAAG,IAAIC,MAAM,CAACF,OAAO,CAAC;IAC9B,IAAMG,KAAK,GAAGF,EAAE,CAACG,IAAI,CAACX,OAAO,CAAC;IAC9B,IAAIN,KAAK,EAAEC,OAAO,CAACC,GAAG,CAAC,oBAAoB,EAAEc,KAAK,CAAC;IACnD,IAAIA,KAAK,EAAE,OAAOA,KAAK,CAAC,CAAC,CAAC;EAC5B;AACF;AAEAE,MAAM,CAACC,OAAO,GAAGvB,YAAY;AAC7BsB,MAAM,CAACC,OAAO,WAAQ,GAAGvB,YAAY","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}