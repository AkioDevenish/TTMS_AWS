{"ast":null,"code":"import _classCallCheck from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _callSuper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reverse.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.unshift.js\";\nimport \"core-js/modules/es.array-buffer.constructor.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.data-view.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.parse-float.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.int8-array.js\";\nimport \"core-js/modules/es.typed-array.int16-array.js\";\nimport \"core-js/modules/es.typed-array.int32-array.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.uint8-clamped-array.js\";\nimport \"core-js/modules/es.typed-array.uint16-array.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/**\n * @module ol/source/GeoTIFF\n */\nimport DataTile from './DataTile.js';\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport { Pool, globals as geotiffGlobals, fromBlob as tiffFromBlob, fromUrl as tiffFromUrl, fromUrls as tiffFromUrls } from 'geotiff';\nimport { Projection, get as getCachedProjection, toUserCoordinate, toUserExtent } from '../proj.js';\nimport { clamp } from '../math.js';\nimport { getCenter, getIntersection } from '../extent.js';\nimport { error as logError } from '../console.js';\nimport { fromCode as unitsFromCode } from '../proj/Units.js';\n\n/**\n * Determine if an image type is a mask.\n * See https://www.awaresystems.be/imaging/tiff/tifftags/newsubfiletype.html\n * @param {GeoTIFFImage} image The image.\n * @return {boolean} The image is a mask.\n */\nfunction isMask(image) {\n  var fileDirectory = image.fileDirectory;\n  var type = fileDirectory.NewSubfileType || 0;\n  return (type & 4) === 4;\n}\n\n/**\n * @param {true|false|'auto'} preference The convertToRGB option.\n * @param {GeoTIFFImage} image The image.\n * @return {boolean} Use the `image.readRGB()` method.\n */\nfunction readRGB(preference, image) {\n  if (!preference) {\n    return false;\n  }\n  if (preference === true) {\n    return true;\n  }\n  if (image.getSamplesPerPixel() !== 3) {\n    return false;\n  }\n  var interpretation = image.fileDirectory.PhotometricInterpretation;\n  var interpretations = geotiffGlobals.photometricInterpretations;\n  return interpretation === interpretations.CMYK || interpretation === interpretations.YCbCr || interpretation === interpretations.CIELab || interpretation === interpretations.ICCLab;\n}\n\n/**\n * @typedef {Object} SourceInfo\n * @property {string} [url] URL for the source GeoTIFF.\n * @property {Array<string>} [overviews] List of any overview URLs, only applies if the url parameter is given.\n * @property {Blob} [blob] Blob containing the source GeoTIFF. `blob` and `url` are mutually exclusive.\n * @property {number} [min=0] The minimum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the minimum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [max] The maximum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the maximum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [nodata] Values to discard (overriding any nodata values in the metadata).\n * When provided, an additional alpha band will be added to the data.  Often the GeoTIFF metadata\n * will include information about nodata values, so you should only need to set this property if\n * you find that it is not already extracted from the metadata.\n * @property {Array<number>} [bands] Band numbers to be read from (where the first band is `1`). If not provided, all bands will\n * be read. For example, if a GeoTIFF has blue (1), green (2), red (3), and near-infrared (4) bands, and you only need the\n * near-infrared band, configure `bands: [4]`.\n */\n\n/**\n * @typedef {Object} GeoKeys\n * @property {number} GTModelTypeGeoKey Model type.\n * @property {number} GTRasterTypeGeoKey Raster type.\n * @property {number} GeogAngularUnitsGeoKey Angular units.\n * @property {number} GeogInvFlatteningGeoKey Inverse flattening.\n * @property {number} GeogSemiMajorAxisGeoKey Semi-major axis.\n * @property {number} GeographicTypeGeoKey Geographic coordinate system code.\n * @property {number} ProjLinearUnitsGeoKey Projected linear unit code.\n * @property {number} ProjectedCSTypeGeoKey Projected coordinate system code.\n */\n\n/**\n * @typedef {import(\"geotiff\").GeoTIFF} GeoTIFF\n */\n\n/**\n * @typedef {import(\"geotiff\").MultiGeoTIFF} MultiGeoTIFF\n */\n\n/**\n * @typedef {Object} GDALMetadata\n * @property {string} STATISTICS_MINIMUM The minimum value (as a string).\n * @property {string} STATISTICS_MAXIMUM The maximum value (as a string).\n */\n\nvar STATISTICS_MAXIMUM = 'STATISTICS_MAXIMUM';\nvar STATISTICS_MINIMUM = 'STATISTICS_MINIMUM';\nvar defaultTileSize = 256;\n\n/**\n * @typedef {import(\"geotiff\").GeoTIFFImage} GeoTIFFImage\n */\n\nvar workerPool;\nfunction getWorkerPool() {\n  if (!workerPool) {\n    workerPool = new Pool();\n  }\n  return workerPool;\n}\n\n/**\n * Get the bounding box of an image.  If the image does not have an affine transform,\n * the pixel bounds are returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image bounding box.\n */\nfunction getBoundingBox(image) {\n  try {\n    return image.getBoundingBox();\n  } catch (_) {\n    return [0, 0, image.getWidth(), image.getHeight()];\n  }\n}\n\n/**\n * Get the origin of an image.  If the image does not have an affine transform,\n * the top-left corner of the pixel bounds is returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image origin.\n */\nfunction getOrigin(image) {\n  try {\n    return image.getOrigin().slice(0, 2);\n  } catch (_) {\n    return [0, image.getHeight()];\n  }\n}\n\n/**\n * Get the resolution of an image.  If the image does not have an affine transform,\n * the width of the image is compared with the reference image.\n * @param {GeoTIFFImage} image The image.\n * @param {GeoTIFFImage} referenceImage The reference image.\n * @return {Array<number>} The map x and y units per pixel.\n */\nfunction getResolutions(image, referenceImage) {\n  try {\n    return image.getResolution(referenceImage);\n  } catch (_) {\n    return [referenceImage.getWidth() / image.getWidth(), referenceImage.getHeight() / image.getHeight()];\n  }\n}\n\n/**\n * @param {GeoTIFFImage} image A GeoTIFF.\n * @return {import(\"../proj/Projection.js\").default} The image projection.\n */\nfunction getProjection(image) {\n  var geoKeys = image.geoKeys;\n  if (!geoKeys) {\n    return null;\n  }\n  if (geoKeys.ProjectedCSTypeGeoKey && geoKeys.ProjectedCSTypeGeoKey !== 32767) {\n    var code = 'EPSG:' + geoKeys.ProjectedCSTypeGeoKey;\n    var projection = getCachedProjection(code);\n    if (!projection) {\n      var units = unitsFromCode(geoKeys.ProjLinearUnitsGeoKey);\n      if (units) {\n        projection = new Projection({\n          code: code,\n          units: units\n        });\n      }\n    }\n    return projection;\n  }\n  if (geoKeys.GeographicTypeGeoKey && geoKeys.GeographicTypeGeoKey !== 32767) {\n    var _code = 'EPSG:' + geoKeys.GeographicTypeGeoKey;\n    var _projection = getCachedProjection(_code);\n    if (!_projection) {\n      var _units = unitsFromCode(geoKeys.GeogAngularUnitsGeoKey);\n      if (_units) {\n        _projection = new Projection({\n          code: _code,\n          units: _units\n        });\n      }\n    }\n    return _projection;\n  }\n  return null;\n}\n\n/**\n * @param {GeoTIFF|MultiGeoTIFF} tiff A GeoTIFF.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\nfunction getImagesForTIFF(tiff) {\n  return tiff.getImageCount().then(function (count) {\n    var requests = new Array(count);\n    for (var i = 0; i < count; ++i) {\n      requests[i] = tiff.getImage(i);\n    }\n    return Promise.all(requests);\n  });\n}\n\n/**\n * @param {SourceInfo} source The GeoTIFF source.\n * @param {Object} options Options for the GeoTIFF source.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\nfunction getImagesForSource(source, options) {\n  var request;\n  if (source.blob) {\n    request = tiffFromBlob(source.blob);\n  } else if (source.overviews) {\n    request = tiffFromUrls(source.url, source.overviews, options);\n  } else {\n    request = tiffFromUrl(source.url, options);\n  }\n  return request.then(getImagesForTIFF);\n}\n\n/**\n * @param {number|Array<number>|Array<Array<number>>} expected Expected value.\n * @param {number|Array<number>|Array<Array<number>>} got Actual value.\n * @param {number} tolerance Accepted tolerance in fraction of expected between expected and got.\n * @param {string} message The error message.\n * @param {function(Error):void} rejector A function to be called with any error.\n */\nfunction assertEqual(expected, got, tolerance, message, rejector) {\n  if (Array.isArray(expected)) {\n    var length = expected.length;\n    if (!Array.isArray(got) || length != got.length) {\n      var error = new Error(message);\n      rejector(error);\n      throw error;\n    }\n    for (var i = 0; i < length; ++i) {\n      assertEqual(expected[i], got[i], tolerance, message, rejector);\n    }\n    return;\n  }\n  got = /** @type {number} */got;\n  if (Math.abs(expected - got) > tolerance * expected) {\n    throw new Error(message);\n  }\n}\n\n/**\n * @param {Array} array The data array.\n * @return {number} The minimum value.\n */\nfunction getMinForDataType(array) {\n  if (array instanceof Int8Array) {\n    return -128;\n  }\n  if (array instanceof Int16Array) {\n    return -32768;\n  }\n  if (array instanceof Int32Array) {\n    return -2147483648;\n  }\n  if (array instanceof Float32Array) {\n    return 1.2e-38;\n  }\n  return 0;\n}\n\n/**\n * @param {Array} array The data array.\n * @return {number} The maximum value.\n */\nfunction getMaxForDataType(array) {\n  if (array instanceof Int8Array) {\n    return 127;\n  }\n  if (array instanceof Uint8Array) {\n    return 255;\n  }\n  if (array instanceof Uint8ClampedArray) {\n    return 255;\n  }\n  if (array instanceof Int16Array) {\n    return 32767;\n  }\n  if (array instanceof Uint16Array) {\n    return 65535;\n  }\n  if (array instanceof Int32Array) {\n    return 2147483647;\n  }\n  if (array instanceof Uint32Array) {\n    return 4294967295;\n  }\n  if (array instanceof Float32Array) {\n    return 3.4e38;\n  }\n  return 255;\n}\n\n/**\n * @typedef {Object} GeoTIFFSourceOptions\n * @property {boolean} [forceXHR=false] Whether to force the usage of the browsers XMLHttpRequest API.\n * @property {Object<string, string>} [headers] additional key-value pairs of headers to be passed with each request. Key is the header name, value the header value.\n * @property {string} [credentials] How credentials shall be handled. See\n * https://developer.mozilla.org/en-US/docs/Web/API/fetch for reference and possible values\n * @property {number} [maxRanges] The maximum amount of ranges to request in a single multi-range request.\n * By default only a single range is used.\n * @property {boolean} [allowFullFile=false] Whether or not a full file is accepted when only a portion is\n * requested. Only use this when you know the source image to be small enough to fit in memory.\n * @property {number} [blockSize=65536] The block size to use.\n * @property {number} [cacheSize=100] The number of blocks that shall be held in a LRU cache.\n */\n\n/**\n * @typedef {Object} Options\n * @property {Array<SourceInfo>} sources List of information about GeoTIFF sources.\n * Multiple sources can be combined when their resolution sets are equal after applying a scale.\n * The list of sources defines a mapping between input bands as they are read from each GeoTIFF and\n * the output bands that are provided by data tiles. To control which bands to read from each GeoTIFF,\n * use the {@link import(\"./GeoTIFF.js\").SourceInfo bands} property. If, for example, you specify two\n * sources, one with 3 bands and {@link import(\"./GeoTIFF.js\").SourceInfo nodata} configured, and\n * another with 1 band, the resulting data tiles will have 5 bands: 3 from the first source, 1 alpha\n * band from the first source, and 1 band from the second source.\n * @property {GeoTIFFSourceOptions} [sourceOptions] Additional options to be passed to [geotiff.js](https://geotiffjs.github.io/geotiff.js/module-geotiff.html)'s `fromUrl` or `fromUrls` methods.\n * @property {true|false|'auto'} [convertToRGB=false] By default, bands from the sources are read as-is. When\n * reading GeoTIFFs with the purpose of displaying them as RGB images, setting this to `true` will\n * convert other color spaces (YCbCr, CMYK) to RGB.  Setting the option to `'auto'` will make it so CMYK, YCbCr,\n * CIELab, and ICCLab images will automatically be converted to RGB.\n * @property {boolean} [normalize=true] By default, the source data is normalized to values between\n * 0 and 1 with scaling factors based on the raster statistics or `min` and `max` properties of each source.\n * If instead you want to work with the raw values in a style expression, set this to `false`.  Setting this option\n * to `false` will make it so any `min` and `max` properties on sources are ignored.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Source projection.  If not provided, the GeoTIFF metadata\n * will be read for projection information.\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {boolean} [wrapX=false] Render tiles beyond the tile grid extent.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * the linear interpolation is used to resample the data.  If false, nearest neighbor is used.\n */\n\n/**\n * @classdesc\n * A source for working with GeoTIFF data.\n * **Note for users of the full build**: The `GeoTIFF` source requires the\n * [geotiff.js](https://github.com/geotiffjs/geotiff.js) library to be loaded as well.\n *\n * @api\n */\nvar GeoTIFFSource = /*#__PURE__*/function (_DataTile) {\n  /**\n   * @param {Options} options Data tile options.\n   */\n  function GeoTIFFSource(options) {\n    var _this;\n    _classCallCheck(this, GeoTIFFSource);\n    _this = _callSuper(this, GeoTIFFSource, [{\n      state: 'loading',\n      tileGrid: null,\n      projection: options.projection || null,\n      opaque: options.opaque,\n      transition: options.transition,\n      interpolate: options.interpolate !== false,\n      wrapX: options.wrapX\n    }]);\n\n    /**\n     * @type {Array<SourceInfo>}\n     * @private\n     */\n    _this.sourceInfo_ = options.sources;\n    var numSources = _this.sourceInfo_.length;\n\n    /**\n     * @type {Object}\n     * @private\n     */\n    _this.sourceOptions_ = options.sourceOptions;\n\n    /**\n     * @type {Array<Array<GeoTIFFImage>>}\n     * @private\n     */\n    _this.sourceImagery_ = new Array(numSources);\n\n    /**\n     * @type {Array<Array<GeoTIFFImage>>}\n     * @private\n     */\n    _this.sourceMasks_ = new Array(numSources);\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    _this.resolutionFactors_ = new Array(numSources);\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    _this.samplesPerPixel_;\n\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n    _this.nodataValues_;\n\n    /**\n     * @type {Array<Array<GDALMetadata>>}\n     * @private\n     */\n    _this.metadata_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    _this.normalize_ = options.normalize !== false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    _this.addAlpha_ = false;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    _this.error_ = null;\n\n    /**\n     * @type {true|false|'auto'}\n     */\n    _this.convertToRGB_ = options.convertToRGB || false;\n    _this.setKey(_this.sourceInfo_.map(function (source) {\n      return source.url;\n    }).join(','));\n    var self = _this;\n    var requests = new Array(numSources);\n    for (var i = 0; i < numSources; ++i) {\n      requests[i] = getImagesForSource(_this.sourceInfo_[i], _this.sourceOptions_);\n    }\n    Promise.all(requests).then(function (sources) {\n      self.configure_(sources);\n    })[\"catch\"](function (error) {\n      logError(error);\n      self.error_ = error;\n      self.setState('error');\n    });\n    return _this;\n  }\n\n  /**\n   * @return {Error} A source loading error. When the source state is `error`, use this function\n   * to get more information about the error. To debug a faulty configuration, you may want to use\n   * a listener like\n   * ```js\n   * geotiffSource.on('change', () => {\n   *   if (geotiffSource.getState() === 'error') {\n   *     console.error(geotiffSource.getError());\n   *   }\n   * });\n   * ```\n   */\n  _inherits(GeoTIFFSource, _DataTile);\n  return _createClass(GeoTIFFSource, [{\n    key: \"getError\",\n    value: function getError() {\n      return this.error_;\n    }\n\n    /**\n     * Determine the projection of the images in this GeoTIFF.\n     * The default implementation looks at the ProjectedCSTypeGeoKey and the GeographicTypeGeoKey\n     * of each image in turn.\n     * You can override this method in a subclass to support more projections.\n     *\n     * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n     * from a single GeoTIFF.\n     */\n  }, {\n    key: \"determineProjection\",\n    value: function determineProjection(sources) {\n      var firstSource = sources[0];\n      for (var i = firstSource.length - 1; i >= 0; --i) {\n        var image = firstSource[i];\n        var projection = getProjection(image);\n        if (projection) {\n          this.projection = projection;\n          break;\n        }\n      }\n    }\n\n    /**\n     * Configure the tile grid based on images within the source GeoTIFFs.  Each GeoTIFF\n     * must have the same internal tiled structure.\n     * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n     * from a single GeoTIFF.\n     * @private\n     */\n  }, {\n    key: \"configure_\",\n    value: function configure_(sources) {\n      var _this2 = this;\n      var extent;\n      var origin;\n      var commonRenderTileSizes;\n      var commonSourceTileSizes;\n      var resolutions;\n      var samplesPerPixel = new Array(sources.length);\n      var nodataValues = new Array(sources.length);\n      var metadata = new Array(sources.length);\n      var minZoom = 0;\n      var sourceCount = sources.length;\n      var _loop = function _loop() {\n        var images = [];\n        var masks = [];\n        sources[sourceIndex].forEach(function (item) {\n          if (isMask(item)) {\n            masks.push(item);\n          } else {\n            images.push(item);\n          }\n        });\n        var imageCount = images.length;\n        if (masks.length > 0 && masks.length !== imageCount) {\n          throw new Error(\"Expected one mask per image found \".concat(masks.length, \" masks and \").concat(imageCount, \" images\"));\n        }\n        var sourceExtent;\n        var sourceOrigin;\n        var sourceTileSizes = new Array(imageCount);\n        var renderTileSizes = new Array(imageCount);\n        var sourceResolutions = new Array(imageCount);\n        nodataValues[sourceIndex] = new Array(imageCount);\n        metadata[sourceIndex] = new Array(imageCount);\n        for (var _imageIndex = 0; _imageIndex < imageCount; ++_imageIndex) {\n          var image = images[_imageIndex];\n          var nodataValue = image.getGDALNoData();\n          metadata[sourceIndex][_imageIndex] = image.getGDALMetadata(0);\n          nodataValues[sourceIndex][_imageIndex] = nodataValue;\n          var wantedSamples = _this2.sourceInfo_[sourceIndex].bands;\n          samplesPerPixel[sourceIndex] = wantedSamples ? wantedSamples.length : image.getSamplesPerPixel();\n          var level = imageCount - (_imageIndex + 1);\n          if (!sourceExtent) {\n            sourceExtent = getBoundingBox(image);\n          }\n          if (!sourceOrigin) {\n            sourceOrigin = getOrigin(image);\n          }\n          var imageResolutions = getResolutions(image, images[0]);\n          sourceResolutions[level] = imageResolutions[0];\n          var sourceTileSize = [image.getTileWidth(), image.getTileHeight()];\n\n          // request larger blocks for untiled layouts\n          if (sourceTileSize[0] !== sourceTileSize[1] && sourceTileSize[1] < defaultTileSize) {\n            sourceTileSize[0] = defaultTileSize;\n            sourceTileSize[1] = defaultTileSize;\n          }\n          sourceTileSizes[level] = sourceTileSize;\n          var aspectRatio = imageResolutions[0] / Math.abs(imageResolutions[1]);\n          renderTileSizes[level] = [sourceTileSize[0], sourceTileSize[1] / aspectRatio];\n        }\n        if (!extent) {\n          extent = sourceExtent;\n        } else {\n          getIntersection(extent, sourceExtent, extent);\n        }\n        if (!origin) {\n          origin = sourceOrigin;\n        } else {\n          var message = \"Origin mismatch for source \".concat(sourceIndex, \", got [\").concat(sourceOrigin, \"] but expected [\").concat(origin, \"]\");\n          assertEqual(origin, sourceOrigin, 0, message, _this2.viewRejector);\n        }\n        if (!resolutions) {\n          resolutions = sourceResolutions;\n          _this2.resolutionFactors_[sourceIndex] = 1;\n        } else {\n          if (resolutions.length - minZoom > sourceResolutions.length) {\n            minZoom = resolutions.length - sourceResolutions.length;\n          }\n          var resolutionFactor = resolutions[resolutions.length - 1] / sourceResolutions[sourceResolutions.length - 1];\n          _this2.resolutionFactors_[sourceIndex] = resolutionFactor;\n          var scaledSourceResolutions = sourceResolutions.map(function (resolution) {\n            return resolution *= resolutionFactor;\n          });\n          var _message = \"Resolution mismatch for source \".concat(sourceIndex, \", got [\").concat(scaledSourceResolutions, \"] but expected [\").concat(resolutions, \"]\");\n          assertEqual(resolutions.slice(minZoom, resolutions.length), scaledSourceResolutions, 0.02, _message, _this2.viewRejector);\n        }\n        if (!commonRenderTileSizes) {\n          commonRenderTileSizes = renderTileSizes;\n        } else {\n          assertEqual(commonRenderTileSizes.slice(minZoom, commonRenderTileSizes.length), renderTileSizes, 0.01, \"Tile size mismatch for source \".concat(sourceIndex), _this2.viewRejector);\n        }\n        if (!commonSourceTileSizes) {\n          commonSourceTileSizes = sourceTileSizes;\n        } else {\n          assertEqual(commonSourceTileSizes.slice(minZoom, commonSourceTileSizes.length), sourceTileSizes, 0, \"Tile size mismatch for source \".concat(sourceIndex), _this2.viewRejector);\n        }\n        _this2.sourceImagery_[sourceIndex] = images.reverse();\n        _this2.sourceMasks_[sourceIndex] = masks.reverse();\n      };\n      for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n        _loop();\n      }\n      for (var i = 0, ii = this.sourceImagery_.length; i < ii; ++i) {\n        var sourceImagery = this.sourceImagery_[i];\n        while (sourceImagery.length < resolutions.length) {\n          sourceImagery.unshift(undefined);\n        }\n      }\n      if (!this.getProjection()) {\n        this.determineProjection(sources);\n      }\n      this.samplesPerPixel_ = samplesPerPixel;\n      this.nodataValues_ = nodataValues;\n      this.metadata_ = metadata;\n\n      // decide if we need to add an alpha band to handle nodata\n      outer: for (var _sourceIndex = 0; _sourceIndex < sourceCount; ++_sourceIndex) {\n        // option 1: source is configured with a nodata value\n        if (this.sourceInfo_[_sourceIndex].nodata !== undefined) {\n          this.addAlpha_ = true;\n          break;\n        }\n        if (this.sourceMasks_[_sourceIndex].length) {\n          this.addAlpha_ = true;\n          break;\n        }\n        var values = nodataValues[_sourceIndex];\n\n        // option 2: check image metadata for limited bands\n        var bands = this.sourceInfo_[_sourceIndex].bands;\n        if (bands) {\n          for (var _i = 0; _i < bands.length; ++_i) {\n            if (values[bands[_i] - 1] !== null) {\n              this.addAlpha_ = true;\n              break outer;\n            }\n          }\n          continue;\n        }\n\n        // option 3: check image metadata for all bands\n        for (var imageIndex = 0; imageIndex < values.length; ++imageIndex) {\n          if (values[imageIndex] !== null) {\n            this.addAlpha_ = true;\n            break outer;\n          }\n        }\n      }\n      var bandCount = this.addAlpha_ ? 1 : 0;\n      for (var _sourceIndex2 = 0; _sourceIndex2 < sourceCount; ++_sourceIndex2) {\n        bandCount += samplesPerPixel[_sourceIndex2];\n      }\n      this.bandCount = bandCount;\n      var tileGrid = new TileGrid({\n        extent: extent,\n        minZoom: minZoom,\n        origin: origin,\n        resolutions: resolutions,\n        tileSizes: commonRenderTileSizes\n      });\n      this.tileGrid = tileGrid;\n      this.setTileSizes(commonSourceTileSizes);\n      this.setLoader(this.loadTile_.bind(this));\n      this.setState('ready');\n      var zoom = 1;\n      if (resolutions.length === 2) {\n        resolutions = [resolutions[0], resolutions[1], resolutions[1] / 2];\n      } else if (resolutions.length === 1) {\n        resolutions = [resolutions[0] * 2, resolutions[0], resolutions[0] / 2];\n      }\n      this.viewResolver({\n        showFullExtent: true,\n        projection: this.projection,\n        resolutions: resolutions,\n        center: toUserCoordinate(getCenter(extent), this.projection),\n        extent: toUserExtent(extent, this.projection),\n        zoom: zoom\n      });\n    }\n\n    /**\n     * @param {number} z The z tile index.\n     * @param {number} x The x tile index.\n     * @param {number} y The y tile index.\n     * @return {Promise} The composed tile data.\n     * @private\n     */\n  }, {\n    key: \"loadTile_\",\n    value: function loadTile_(z, x, y) {\n      var _this3 = this;\n      var sourceTileSize = this.getTileSize(z);\n      var sourceCount = this.sourceImagery_.length;\n      var requests = new Array(sourceCount * 2);\n      var nodataValues = this.nodataValues_;\n      var sourceInfo = this.sourceInfo_;\n      var pool = getWorkerPool();\n      var _loop2 = function _loop2(sourceIndex) {\n        var source = sourceInfo[sourceIndex];\n        var resolutionFactor = _this3.resolutionFactors_[sourceIndex];\n        var pixelBounds = [Math.round(x * (sourceTileSize[0] * resolutionFactor)), Math.round(y * (sourceTileSize[1] * resolutionFactor)), Math.round((x + 1) * (sourceTileSize[0] * resolutionFactor)), Math.round((y + 1) * (sourceTileSize[1] * resolutionFactor))];\n        var image = _this3.sourceImagery_[sourceIndex][z];\n        var samples;\n        if (source.bands) {\n          samples = source.bands.map(function (bandNumber) {\n            return bandNumber - 1;\n          });\n        }\n\n        /** @type {number|Array<number>} */\n        var fillValue;\n        if ('nodata' in source && source.nodata !== null) {\n          fillValue = source.nodata;\n        } else {\n          if (!samples) {\n            fillValue = nodataValues[sourceIndex];\n          } else {\n            fillValue = samples.map(function (sampleIndex) {\n              return nodataValues[sourceIndex][sampleIndex];\n            });\n          }\n        }\n        var readOptions = {\n          window: pixelBounds,\n          width: sourceTileSize[0],\n          height: sourceTileSize[1],\n          samples: samples,\n          fillValue: fillValue,\n          pool: pool,\n          interleave: false\n        };\n        if (readRGB(_this3.convertToRGB_, image)) {\n          requests[sourceIndex] = image.readRGB(readOptions);\n        } else {\n          requests[sourceIndex] = image.readRasters(readOptions);\n        }\n\n        // requests after `sourceCount` are for mask data (if any)\n        var maskIndex = sourceCount + sourceIndex;\n        var mask = _this3.sourceMasks_[sourceIndex][z];\n        if (!mask) {\n          requests[maskIndex] = Promise.resolve(null);\n          return 1; // continue\n        }\n        requests[maskIndex] = mask.readRasters({\n          window: pixelBounds,\n          width: sourceTileSize[0],\n          height: sourceTileSize[1],\n          samples: [0],\n          pool: pool,\n          interleave: false\n        });\n      };\n      for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n        if (_loop2(sourceIndex)) continue;\n      }\n      return Promise.all(requests).then(this.composeTile_.bind(this, sourceTileSize))[\"catch\"](function (error) {\n        logError(error);\n        throw error;\n      });\n    }\n\n    /**\n     * @param {import(\"../size.js\").Size} sourceTileSize The source tile size.\n     * @param {Array} sourceSamples The source samples.\n     * @return {import(\"../DataTile.js\").Data} The composed tile data.\n     * @private\n     */\n  }, {\n    key: \"composeTile_\",\n    value: function composeTile_(sourceTileSize, sourceSamples) {\n      var metadata = this.metadata_;\n      var sourceInfo = this.sourceInfo_;\n      var sourceCount = this.sourceImagery_.length;\n      var bandCount = this.bandCount;\n      var samplesPerPixel = this.samplesPerPixel_;\n      var nodataValues = this.nodataValues_;\n      var normalize = this.normalize_;\n      var addAlpha = this.addAlpha_;\n      var pixelCount = sourceTileSize[0] * sourceTileSize[1];\n      var dataLength = pixelCount * bandCount;\n\n      /** @type {Uint8Array|Float32Array} */\n      var data;\n      if (normalize) {\n        data = new Uint8Array(dataLength);\n      } else {\n        data = new Float32Array(dataLength);\n      }\n      var dataIndex = 0;\n      for (var pixelIndex = 0; pixelIndex < pixelCount; ++pixelIndex) {\n        var transparent = addAlpha;\n        for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n          var source = sourceInfo[sourceIndex];\n          var min = source.min;\n          var max = source.max;\n          var gain = void 0,\n            bias = void 0;\n          if (normalize) {\n            var stats = metadata[sourceIndex][0];\n            if (min === undefined) {\n              if (stats && STATISTICS_MINIMUM in stats) {\n                min = parseFloat(stats[STATISTICS_MINIMUM]);\n              } else {\n                min = getMinForDataType(sourceSamples[sourceIndex][0]);\n              }\n            }\n            if (max === undefined) {\n              if (stats && STATISTICS_MAXIMUM in stats) {\n                max = parseFloat(stats[STATISTICS_MAXIMUM]);\n              } else {\n                max = getMaxForDataType(sourceSamples[sourceIndex][0]);\n              }\n            }\n            gain = 255 / (max - min);\n            bias = -min * gain;\n          }\n          for (var sampleIndex = 0; sampleIndex < samplesPerPixel[sourceIndex]; ++sampleIndex) {\n            var sourceValue = sourceSamples[sourceIndex][sampleIndex][pixelIndex];\n            var value = void 0;\n            if (normalize) {\n              value = clamp(gain * sourceValue + bias, 0, 255);\n            } else {\n              value = sourceValue;\n            }\n            if (!addAlpha) {\n              data[dataIndex] = value;\n            } else {\n              var nodata = source.nodata;\n              if (nodata === undefined) {\n                var bandIndex = void 0;\n                if (source.bands) {\n                  bandIndex = source.bands[sampleIndex] - 1;\n                } else {\n                  bandIndex = sampleIndex;\n                }\n                nodata = nodataValues[sourceIndex][bandIndex];\n              }\n              var nodataIsNaN = isNaN(nodata);\n              if (!nodataIsNaN && sourceValue !== nodata || nodataIsNaN && !isNaN(sourceValue)) {\n                transparent = false;\n                data[dataIndex] = value;\n              }\n            }\n            dataIndex++;\n          }\n          if (!transparent) {\n            var maskIndex = sourceCount + sourceIndex;\n            var mask = sourceSamples[maskIndex];\n            if (mask && !mask[0][pixelIndex]) {\n              transparent = true;\n            }\n          }\n        }\n        if (addAlpha) {\n          if (!transparent) {\n            data[dataIndex] = 255;\n          }\n          dataIndex++;\n        }\n      }\n      return data;\n    }\n  }]);\n}(DataTile);\n/**\n * Get a promise for view properties based on the source.  Use the result of this function\n * as the `view` option in a map constructor.\n *\n *     const source = new GeoTIFF(options);\n *\n *     const map = new Map({\n *       target: 'map',\n *       layers: [\n *         new TileLayer({\n *           source: source,\n *         }),\n *       ],\n *       view: source.getView(),\n *     });\n *\n * @function\n * @return {Promise<import(\"../View.js\").ViewOptions>} A promise for view-related properties.\n * @api\n *\n */\nGeoTIFFSource.prototype.getView;\nexport default GeoTIFFSource;","map":{"version":3,"names":["DataTile","TileGrid","Pool","globals","geotiffGlobals","fromBlob","tiffFromBlob","fromUrl","tiffFromUrl","fromUrls","tiffFromUrls","Projection","get","getCachedProjection","toUserCoordinate","toUserExtent","clamp","getCenter","getIntersection","error","logError","fromCode","unitsFromCode","isMask","image","fileDirectory","type","NewSubfileType","readRGB","preference","getSamplesPerPixel","interpretation","PhotometricInterpretation","interpretations","photometricInterpretations","CMYK","YCbCr","CIELab","ICCLab","STATISTICS_MAXIMUM","STATISTICS_MINIMUM","defaultTileSize","workerPool","getWorkerPool","getBoundingBox","_","getWidth","getHeight","getOrigin","slice","getResolutions","referenceImage","getResolution","getProjection","geoKeys","ProjectedCSTypeGeoKey","code","projection","units","ProjLinearUnitsGeoKey","GeographicTypeGeoKey","GeogAngularUnitsGeoKey","getImagesForTIFF","tiff","getImageCount","then","count","requests","Array","i","getImage","Promise","all","getImagesForSource","source","options","request","blob","overviews","url","assertEqual","expected","got","tolerance","message","rejector","isArray","length","Error","Math","abs","getMinForDataType","array","Int8Array","Int16Array","Int32Array","Float32Array","getMaxForDataType","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","GeoTIFFSource","_DataTile","_this","_classCallCheck","_callSuper","state","tileGrid","opaque","transition","interpolate","wrapX","sourceInfo_","sources","numSources","sourceOptions_","sourceOptions","sourceImagery_","sourceMasks_","resolutionFactors_","samplesPerPixel_","nodataValues_","metadata_","normalize_","normalize","addAlpha_","error_","convertToRGB_","convertToRGB","setKey","map","join","self","configure_","setState","_inherits","_createClass","key","value","getError","determineProjection","firstSource","_this2","extent","origin","commonRenderTileSizes","commonSourceTileSizes","resolutions","samplesPerPixel","nodataValues","metadata","minZoom","sourceCount","_loop","images","masks","sourceIndex","forEach","item","push","imageCount","concat","sourceExtent","sourceOrigin","sourceTileSizes","renderTileSizes","sourceResolutions","imageIndex","nodataValue","getGDALNoData","getGDALMetadata","wantedSamples","bands","level","imageResolutions","sourceTileSize","getTileWidth","getTileHeight","aspectRatio","viewRejector","resolutionFactor","scaledSourceResolutions","resolution","reverse","ii","sourceImagery","unshift","undefined","outer","nodata","values","bandCount","tileSizes","setTileSizes","setLoader","loadTile_","bind","zoom","viewResolver","showFullExtent","center","z","x","y","_this3","getTileSize","sourceInfo","pool","_loop2","pixelBounds","round","samples","bandNumber","fillValue","sampleIndex","readOptions","window","width","height","interleave","readRasters","maskIndex","mask","resolve","composeTile_","sourceSamples","addAlpha","pixelCount","dataLength","data","dataIndex","pixelIndex","transparent","min","max","gain","bias","stats","parseFloat","sourceValue","bandIndex","nodataIsNaN","isNaN","prototype","getView"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol/source/GeoTIFF.js"],"sourcesContent":["/**\n * @module ol/source/GeoTIFF\n */\nimport DataTile from './DataTile.js';\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport {\n  Pool,\n  globals as geotiffGlobals,\n  fromBlob as tiffFromBlob,\n  fromUrl as tiffFromUrl,\n  fromUrls as tiffFromUrls,\n} from 'geotiff';\nimport {\n  Projection,\n  get as getCachedProjection,\n  toUserCoordinate,\n  toUserExtent,\n} from '../proj.js';\nimport {clamp} from '../math.js';\nimport {getCenter, getIntersection} from '../extent.js';\nimport {error as logError} from '../console.js';\nimport {fromCode as unitsFromCode} from '../proj/Units.js';\n\n/**\n * Determine if an image type is a mask.\n * See https://www.awaresystems.be/imaging/tiff/tifftags/newsubfiletype.html\n * @param {GeoTIFFImage} image The image.\n * @return {boolean} The image is a mask.\n */\nfunction isMask(image) {\n  const fileDirectory = image.fileDirectory;\n  const type = fileDirectory.NewSubfileType || 0;\n  return (type & 4) === 4;\n}\n\n/**\n * @param {true|false|'auto'} preference The convertToRGB option.\n * @param {GeoTIFFImage} image The image.\n * @return {boolean} Use the `image.readRGB()` method.\n */\nfunction readRGB(preference, image) {\n  if (!preference) {\n    return false;\n  }\n  if (preference === true) {\n    return true;\n  }\n  if (image.getSamplesPerPixel() !== 3) {\n    return false;\n  }\n  const interpretation = image.fileDirectory.PhotometricInterpretation;\n  const interpretations = geotiffGlobals.photometricInterpretations;\n  return (\n    interpretation === interpretations.CMYK ||\n    interpretation === interpretations.YCbCr ||\n    interpretation === interpretations.CIELab ||\n    interpretation === interpretations.ICCLab\n  );\n}\n\n/**\n * @typedef {Object} SourceInfo\n * @property {string} [url] URL for the source GeoTIFF.\n * @property {Array<string>} [overviews] List of any overview URLs, only applies if the url parameter is given.\n * @property {Blob} [blob] Blob containing the source GeoTIFF. `blob` and `url` are mutually exclusive.\n * @property {number} [min=0] The minimum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the minimum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [max] The maximum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the maximum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [nodata] Values to discard (overriding any nodata values in the metadata).\n * When provided, an additional alpha band will be added to the data.  Often the GeoTIFF metadata\n * will include information about nodata values, so you should only need to set this property if\n * you find that it is not already extracted from the metadata.\n * @property {Array<number>} [bands] Band numbers to be read from (where the first band is `1`). If not provided, all bands will\n * be read. For example, if a GeoTIFF has blue (1), green (2), red (3), and near-infrared (4) bands, and you only need the\n * near-infrared band, configure `bands: [4]`.\n */\n\n/**\n * @typedef {Object} GeoKeys\n * @property {number} GTModelTypeGeoKey Model type.\n * @property {number} GTRasterTypeGeoKey Raster type.\n * @property {number} GeogAngularUnitsGeoKey Angular units.\n * @property {number} GeogInvFlatteningGeoKey Inverse flattening.\n * @property {number} GeogSemiMajorAxisGeoKey Semi-major axis.\n * @property {number} GeographicTypeGeoKey Geographic coordinate system code.\n * @property {number} ProjLinearUnitsGeoKey Projected linear unit code.\n * @property {number} ProjectedCSTypeGeoKey Projected coordinate system code.\n */\n\n/**\n * @typedef {import(\"geotiff\").GeoTIFF} GeoTIFF\n */\n\n/**\n * @typedef {import(\"geotiff\").MultiGeoTIFF} MultiGeoTIFF\n */\n\n/**\n * @typedef {Object} GDALMetadata\n * @property {string} STATISTICS_MINIMUM The minimum value (as a string).\n * @property {string} STATISTICS_MAXIMUM The maximum value (as a string).\n */\n\nconst STATISTICS_MAXIMUM = 'STATISTICS_MAXIMUM';\nconst STATISTICS_MINIMUM = 'STATISTICS_MINIMUM';\n\nconst defaultTileSize = 256;\n\n/**\n * @typedef {import(\"geotiff\").GeoTIFFImage} GeoTIFFImage\n */\n\nlet workerPool;\nfunction getWorkerPool() {\n  if (!workerPool) {\n    workerPool = new Pool();\n  }\n  return workerPool;\n}\n\n/**\n * Get the bounding box of an image.  If the image does not have an affine transform,\n * the pixel bounds are returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image bounding box.\n */\nfunction getBoundingBox(image) {\n  try {\n    return image.getBoundingBox();\n  } catch (_) {\n    return [0, 0, image.getWidth(), image.getHeight()];\n  }\n}\n\n/**\n * Get the origin of an image.  If the image does not have an affine transform,\n * the top-left corner of the pixel bounds is returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image origin.\n */\nfunction getOrigin(image) {\n  try {\n    return image.getOrigin().slice(0, 2);\n  } catch (_) {\n    return [0, image.getHeight()];\n  }\n}\n\n/**\n * Get the resolution of an image.  If the image does not have an affine transform,\n * the width of the image is compared with the reference image.\n * @param {GeoTIFFImage} image The image.\n * @param {GeoTIFFImage} referenceImage The reference image.\n * @return {Array<number>} The map x and y units per pixel.\n */\nfunction getResolutions(image, referenceImage) {\n  try {\n    return image.getResolution(referenceImage);\n  } catch (_) {\n    return [\n      referenceImage.getWidth() / image.getWidth(),\n      referenceImage.getHeight() / image.getHeight(),\n    ];\n  }\n}\n\n/**\n * @param {GeoTIFFImage} image A GeoTIFF.\n * @return {import(\"../proj/Projection.js\").default} The image projection.\n */\nfunction getProjection(image) {\n  const geoKeys = image.geoKeys;\n  if (!geoKeys) {\n    return null;\n  }\n\n  if (\n    geoKeys.ProjectedCSTypeGeoKey &&\n    geoKeys.ProjectedCSTypeGeoKey !== 32767\n  ) {\n    const code = 'EPSG:' + geoKeys.ProjectedCSTypeGeoKey;\n    let projection = getCachedProjection(code);\n    if (!projection) {\n      const units = unitsFromCode(geoKeys.ProjLinearUnitsGeoKey);\n      if (units) {\n        projection = new Projection({\n          code: code,\n          units: units,\n        });\n      }\n    }\n    return projection;\n  }\n\n  if (geoKeys.GeographicTypeGeoKey && geoKeys.GeographicTypeGeoKey !== 32767) {\n    const code = 'EPSG:' + geoKeys.GeographicTypeGeoKey;\n    let projection = getCachedProjection(code);\n    if (!projection) {\n      const units = unitsFromCode(geoKeys.GeogAngularUnitsGeoKey);\n      if (units) {\n        projection = new Projection({\n          code: code,\n          units: units,\n        });\n      }\n    }\n    return projection;\n  }\n\n  return null;\n}\n\n/**\n * @param {GeoTIFF|MultiGeoTIFF} tiff A GeoTIFF.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\nfunction getImagesForTIFF(tiff) {\n  return tiff.getImageCount().then(function (count) {\n    const requests = new Array(count);\n    for (let i = 0; i < count; ++i) {\n      requests[i] = tiff.getImage(i);\n    }\n    return Promise.all(requests);\n  });\n}\n\n/**\n * @param {SourceInfo} source The GeoTIFF source.\n * @param {Object} options Options for the GeoTIFF source.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\nfunction getImagesForSource(source, options) {\n  let request;\n  if (source.blob) {\n    request = tiffFromBlob(source.blob);\n  } else if (source.overviews) {\n    request = tiffFromUrls(source.url, source.overviews, options);\n  } else {\n    request = tiffFromUrl(source.url, options);\n  }\n  return request.then(getImagesForTIFF);\n}\n\n/**\n * @param {number|Array<number>|Array<Array<number>>} expected Expected value.\n * @param {number|Array<number>|Array<Array<number>>} got Actual value.\n * @param {number} tolerance Accepted tolerance in fraction of expected between expected and got.\n * @param {string} message The error message.\n * @param {function(Error):void} rejector A function to be called with any error.\n */\nfunction assertEqual(expected, got, tolerance, message, rejector) {\n  if (Array.isArray(expected)) {\n    const length = expected.length;\n    if (!Array.isArray(got) || length != got.length) {\n      const error = new Error(message);\n      rejector(error);\n      throw error;\n    }\n    for (let i = 0; i < length; ++i) {\n      assertEqual(expected[i], got[i], tolerance, message, rejector);\n    }\n    return;\n  }\n\n  got = /** @type {number} */ (got);\n  if (Math.abs(expected - got) > tolerance * expected) {\n    throw new Error(message);\n  }\n}\n\n/**\n * @param {Array} array The data array.\n * @return {number} The minimum value.\n */\nfunction getMinForDataType(array) {\n  if (array instanceof Int8Array) {\n    return -128;\n  }\n  if (array instanceof Int16Array) {\n    return -32768;\n  }\n  if (array instanceof Int32Array) {\n    return -2147483648;\n  }\n  if (array instanceof Float32Array) {\n    return 1.2e-38;\n  }\n  return 0;\n}\n\n/**\n * @param {Array} array The data array.\n * @return {number} The maximum value.\n */\nfunction getMaxForDataType(array) {\n  if (array instanceof Int8Array) {\n    return 127;\n  }\n  if (array instanceof Uint8Array) {\n    return 255;\n  }\n  if (array instanceof Uint8ClampedArray) {\n    return 255;\n  }\n  if (array instanceof Int16Array) {\n    return 32767;\n  }\n  if (array instanceof Uint16Array) {\n    return 65535;\n  }\n  if (array instanceof Int32Array) {\n    return 2147483647;\n  }\n  if (array instanceof Uint32Array) {\n    return 4294967295;\n  }\n  if (array instanceof Float32Array) {\n    return 3.4e38;\n  }\n  return 255;\n}\n\n/**\n * @typedef {Object} GeoTIFFSourceOptions\n * @property {boolean} [forceXHR=false] Whether to force the usage of the browsers XMLHttpRequest API.\n * @property {Object<string, string>} [headers] additional key-value pairs of headers to be passed with each request. Key is the header name, value the header value.\n * @property {string} [credentials] How credentials shall be handled. See\n * https://developer.mozilla.org/en-US/docs/Web/API/fetch for reference and possible values\n * @property {number} [maxRanges] The maximum amount of ranges to request in a single multi-range request.\n * By default only a single range is used.\n * @property {boolean} [allowFullFile=false] Whether or not a full file is accepted when only a portion is\n * requested. Only use this when you know the source image to be small enough to fit in memory.\n * @property {number} [blockSize=65536] The block size to use.\n * @property {number} [cacheSize=100] The number of blocks that shall be held in a LRU cache.\n */\n\n/**\n * @typedef {Object} Options\n * @property {Array<SourceInfo>} sources List of information about GeoTIFF sources.\n * Multiple sources can be combined when their resolution sets are equal after applying a scale.\n * The list of sources defines a mapping between input bands as they are read from each GeoTIFF and\n * the output bands that are provided by data tiles. To control which bands to read from each GeoTIFF,\n * use the {@link import(\"./GeoTIFF.js\").SourceInfo bands} property. If, for example, you specify two\n * sources, one with 3 bands and {@link import(\"./GeoTIFF.js\").SourceInfo nodata} configured, and\n * another with 1 band, the resulting data tiles will have 5 bands: 3 from the first source, 1 alpha\n * band from the first source, and 1 band from the second source.\n * @property {GeoTIFFSourceOptions} [sourceOptions] Additional options to be passed to [geotiff.js](https://geotiffjs.github.io/geotiff.js/module-geotiff.html)'s `fromUrl` or `fromUrls` methods.\n * @property {true|false|'auto'} [convertToRGB=false] By default, bands from the sources are read as-is. When\n * reading GeoTIFFs with the purpose of displaying them as RGB images, setting this to `true` will\n * convert other color spaces (YCbCr, CMYK) to RGB.  Setting the option to `'auto'` will make it so CMYK, YCbCr,\n * CIELab, and ICCLab images will automatically be converted to RGB.\n * @property {boolean} [normalize=true] By default, the source data is normalized to values between\n * 0 and 1 with scaling factors based on the raster statistics or `min` and `max` properties of each source.\n * If instead you want to work with the raw values in a style expression, set this to `false`.  Setting this option\n * to `false` will make it so any `min` and `max` properties on sources are ignored.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Source projection.  If not provided, the GeoTIFF metadata\n * will be read for projection information.\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {boolean} [wrapX=false] Render tiles beyond the tile grid extent.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * the linear interpolation is used to resample the data.  If false, nearest neighbor is used.\n */\n\n/**\n * @classdesc\n * A source for working with GeoTIFF data.\n * **Note for users of the full build**: The `GeoTIFF` source requires the\n * [geotiff.js](https://github.com/geotiffjs/geotiff.js) library to be loaded as well.\n *\n * @api\n */\nclass GeoTIFFSource extends DataTile {\n  /**\n   * @param {Options} options Data tile options.\n   */\n  constructor(options) {\n    super({\n      state: 'loading',\n      tileGrid: null,\n      projection: options.projection || null,\n      opaque: options.opaque,\n      transition: options.transition,\n      interpolate: options.interpolate !== false,\n      wrapX: options.wrapX,\n    });\n\n    /**\n     * @type {Array<SourceInfo>}\n     * @private\n     */\n    this.sourceInfo_ = options.sources;\n\n    const numSources = this.sourceInfo_.length;\n\n    /**\n     * @type {Object}\n     * @private\n     */\n    this.sourceOptions_ = options.sourceOptions;\n\n    /**\n     * @type {Array<Array<GeoTIFFImage>>}\n     * @private\n     */\n    this.sourceImagery_ = new Array(numSources);\n\n    /**\n     * @type {Array<Array<GeoTIFFImage>>}\n     * @private\n     */\n    this.sourceMasks_ = new Array(numSources);\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.resolutionFactors_ = new Array(numSources);\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.samplesPerPixel_;\n\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n    this.nodataValues_;\n\n    /**\n     * @type {Array<Array<GDALMetadata>>}\n     * @private\n     */\n    this.metadata_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.normalize_ = options.normalize !== false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.addAlpha_ = false;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.error_ = null;\n\n    /**\n     * @type {true|false|'auto'}\n     */\n    this.convertToRGB_ = options.convertToRGB || false;\n\n    this.setKey(this.sourceInfo_.map((source) => source.url).join(','));\n\n    const self = this;\n    const requests = new Array(numSources);\n    for (let i = 0; i < numSources; ++i) {\n      requests[i] = getImagesForSource(\n        this.sourceInfo_[i],\n        this.sourceOptions_\n      );\n    }\n    Promise.all(requests)\n      .then(function (sources) {\n        self.configure_(sources);\n      })\n      .catch(function (error) {\n        logError(error);\n        self.error_ = error;\n        self.setState('error');\n      });\n  }\n\n  /**\n   * @return {Error} A source loading error. When the source state is `error`, use this function\n   * to get more information about the error. To debug a faulty configuration, you may want to use\n   * a listener like\n   * ```js\n   * geotiffSource.on('change', () => {\n   *   if (geotiffSource.getState() === 'error') {\n   *     console.error(geotiffSource.getError());\n   *   }\n   * });\n   * ```\n   */\n  getError() {\n    return this.error_;\n  }\n\n  /**\n   * Determine the projection of the images in this GeoTIFF.\n   * The default implementation looks at the ProjectedCSTypeGeoKey and the GeographicTypeGeoKey\n   * of each image in turn.\n   * You can override this method in a subclass to support more projections.\n   *\n   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n   * from a single GeoTIFF.\n   */\n  determineProjection(sources) {\n    const firstSource = sources[0];\n    for (let i = firstSource.length - 1; i >= 0; --i) {\n      const image = firstSource[i];\n      const projection = getProjection(image);\n      if (projection) {\n        this.projection = projection;\n        break;\n      }\n    }\n  }\n\n  /**\n   * Configure the tile grid based on images within the source GeoTIFFs.  Each GeoTIFF\n   * must have the same internal tiled structure.\n   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n   * from a single GeoTIFF.\n   * @private\n   */\n  configure_(sources) {\n    let extent;\n    let origin;\n    let commonRenderTileSizes;\n    let commonSourceTileSizes;\n    let resolutions;\n    const samplesPerPixel = new Array(sources.length);\n    const nodataValues = new Array(sources.length);\n    const metadata = new Array(sources.length);\n    let minZoom = 0;\n\n    const sourceCount = sources.length;\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      const images = [];\n      const masks = [];\n      sources[sourceIndex].forEach((item) => {\n        if (isMask(item)) {\n          masks.push(item);\n        } else {\n          images.push(item);\n        }\n      });\n\n      const imageCount = images.length;\n      if (masks.length > 0 && masks.length !== imageCount) {\n        throw new Error(\n          `Expected one mask per image found ${masks.length} masks and ${imageCount} images`\n        );\n      }\n\n      let sourceExtent;\n      let sourceOrigin;\n      const sourceTileSizes = new Array(imageCount);\n      const renderTileSizes = new Array(imageCount);\n      const sourceResolutions = new Array(imageCount);\n\n      nodataValues[sourceIndex] = new Array(imageCount);\n      metadata[sourceIndex] = new Array(imageCount);\n\n      for (let imageIndex = 0; imageIndex < imageCount; ++imageIndex) {\n        const image = images[imageIndex];\n        const nodataValue = image.getGDALNoData();\n        metadata[sourceIndex][imageIndex] = image.getGDALMetadata(0);\n        nodataValues[sourceIndex][imageIndex] = nodataValue;\n\n        const wantedSamples = this.sourceInfo_[sourceIndex].bands;\n        samplesPerPixel[sourceIndex] = wantedSamples\n          ? wantedSamples.length\n          : image.getSamplesPerPixel();\n        const level = imageCount - (imageIndex + 1);\n\n        if (!sourceExtent) {\n          sourceExtent = getBoundingBox(image);\n        }\n\n        if (!sourceOrigin) {\n          sourceOrigin = getOrigin(image);\n        }\n\n        const imageResolutions = getResolutions(image, images[0]);\n        sourceResolutions[level] = imageResolutions[0];\n\n        const sourceTileSize = [image.getTileWidth(), image.getTileHeight()];\n\n        // request larger blocks for untiled layouts\n        if (\n          sourceTileSize[0] !== sourceTileSize[1] &&\n          sourceTileSize[1] < defaultTileSize\n        ) {\n          sourceTileSize[0] = defaultTileSize;\n          sourceTileSize[1] = defaultTileSize;\n        }\n\n        sourceTileSizes[level] = sourceTileSize;\n\n        const aspectRatio = imageResolutions[0] / Math.abs(imageResolutions[1]);\n        renderTileSizes[level] = [\n          sourceTileSize[0],\n          sourceTileSize[1] / aspectRatio,\n        ];\n      }\n\n      if (!extent) {\n        extent = sourceExtent;\n      } else {\n        getIntersection(extent, sourceExtent, extent);\n      }\n\n      if (!origin) {\n        origin = sourceOrigin;\n      } else {\n        const message = `Origin mismatch for source ${sourceIndex}, got [${sourceOrigin}] but expected [${origin}]`;\n        assertEqual(origin, sourceOrigin, 0, message, this.viewRejector);\n      }\n\n      if (!resolutions) {\n        resolutions = sourceResolutions;\n        this.resolutionFactors_[sourceIndex] = 1;\n      } else {\n        if (resolutions.length - minZoom > sourceResolutions.length) {\n          minZoom = resolutions.length - sourceResolutions.length;\n        }\n        const resolutionFactor =\n          resolutions[resolutions.length - 1] /\n          sourceResolutions[sourceResolutions.length - 1];\n        this.resolutionFactors_[sourceIndex] = resolutionFactor;\n        const scaledSourceResolutions = sourceResolutions.map(\n          (resolution) => (resolution *= resolutionFactor)\n        );\n        const message = `Resolution mismatch for source ${sourceIndex}, got [${scaledSourceResolutions}] but expected [${resolutions}]`;\n        assertEqual(\n          resolutions.slice(minZoom, resolutions.length),\n          scaledSourceResolutions,\n          0.02,\n          message,\n          this.viewRejector\n        );\n      }\n\n      if (!commonRenderTileSizes) {\n        commonRenderTileSizes = renderTileSizes;\n      } else {\n        assertEqual(\n          commonRenderTileSizes.slice(minZoom, commonRenderTileSizes.length),\n          renderTileSizes,\n          0.01,\n          `Tile size mismatch for source ${sourceIndex}`,\n          this.viewRejector\n        );\n      }\n\n      if (!commonSourceTileSizes) {\n        commonSourceTileSizes = sourceTileSizes;\n      } else {\n        assertEqual(\n          commonSourceTileSizes.slice(minZoom, commonSourceTileSizes.length),\n          sourceTileSizes,\n          0,\n          `Tile size mismatch for source ${sourceIndex}`,\n          this.viewRejector\n        );\n      }\n\n      this.sourceImagery_[sourceIndex] = images.reverse();\n      this.sourceMasks_[sourceIndex] = masks.reverse();\n    }\n\n    for (let i = 0, ii = this.sourceImagery_.length; i < ii; ++i) {\n      const sourceImagery = this.sourceImagery_[i];\n      while (sourceImagery.length < resolutions.length) {\n        sourceImagery.unshift(undefined);\n      }\n    }\n\n    if (!this.getProjection()) {\n      this.determineProjection(sources);\n    }\n\n    this.samplesPerPixel_ = samplesPerPixel;\n    this.nodataValues_ = nodataValues;\n    this.metadata_ = metadata;\n\n    // decide if we need to add an alpha band to handle nodata\n    outer: for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      // option 1: source is configured with a nodata value\n      if (this.sourceInfo_[sourceIndex].nodata !== undefined) {\n        this.addAlpha_ = true;\n        break;\n      }\n      if (this.sourceMasks_[sourceIndex].length) {\n        this.addAlpha_ = true;\n        break;\n      }\n\n      const values = nodataValues[sourceIndex];\n\n      // option 2: check image metadata for limited bands\n      const bands = this.sourceInfo_[sourceIndex].bands;\n      if (bands) {\n        for (let i = 0; i < bands.length; ++i) {\n          if (values[bands[i] - 1] !== null) {\n            this.addAlpha_ = true;\n            break outer;\n          }\n        }\n        continue;\n      }\n\n      // option 3: check image metadata for all bands\n      for (let imageIndex = 0; imageIndex < values.length; ++imageIndex) {\n        if (values[imageIndex] !== null) {\n          this.addAlpha_ = true;\n          break outer;\n        }\n      }\n    }\n\n    let bandCount = this.addAlpha_ ? 1 : 0;\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      bandCount += samplesPerPixel[sourceIndex];\n    }\n    this.bandCount = bandCount;\n\n    const tileGrid = new TileGrid({\n      extent: extent,\n      minZoom: minZoom,\n      origin: origin,\n      resolutions: resolutions,\n      tileSizes: commonRenderTileSizes,\n    });\n\n    this.tileGrid = tileGrid;\n    this.setTileSizes(commonSourceTileSizes);\n\n    this.setLoader(this.loadTile_.bind(this));\n    this.setState('ready');\n\n    const zoom = 1;\n    if (resolutions.length === 2) {\n      resolutions = [resolutions[0], resolutions[1], resolutions[1] / 2];\n    } else if (resolutions.length === 1) {\n      resolutions = [resolutions[0] * 2, resolutions[0], resolutions[0] / 2];\n    }\n\n    this.viewResolver({\n      showFullExtent: true,\n      projection: this.projection,\n      resolutions: resolutions,\n      center: toUserCoordinate(getCenter(extent), this.projection),\n      extent: toUserExtent(extent, this.projection),\n      zoom: zoom,\n    });\n  }\n\n  /**\n   * @param {number} z The z tile index.\n   * @param {number} x The x tile index.\n   * @param {number} y The y tile index.\n   * @return {Promise} The composed tile data.\n   * @private\n   */\n  loadTile_(z, x, y) {\n    const sourceTileSize = this.getTileSize(z);\n    const sourceCount = this.sourceImagery_.length;\n    const requests = new Array(sourceCount * 2);\n    const nodataValues = this.nodataValues_;\n    const sourceInfo = this.sourceInfo_;\n    const pool = getWorkerPool();\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      const source = sourceInfo[sourceIndex];\n      const resolutionFactor = this.resolutionFactors_[sourceIndex];\n      const pixelBounds = [\n        Math.round(x * (sourceTileSize[0] * resolutionFactor)),\n        Math.round(y * (sourceTileSize[1] * resolutionFactor)),\n        Math.round((x + 1) * (sourceTileSize[0] * resolutionFactor)),\n        Math.round((y + 1) * (sourceTileSize[1] * resolutionFactor)),\n      ];\n      const image = this.sourceImagery_[sourceIndex][z];\n      let samples;\n      if (source.bands) {\n        samples = source.bands.map(function (bandNumber) {\n          return bandNumber - 1;\n        });\n      }\n\n      /** @type {number|Array<number>} */\n      let fillValue;\n      if ('nodata' in source && source.nodata !== null) {\n        fillValue = source.nodata;\n      } else {\n        if (!samples) {\n          fillValue = nodataValues[sourceIndex];\n        } else {\n          fillValue = samples.map(function (sampleIndex) {\n            return nodataValues[sourceIndex][sampleIndex];\n          });\n        }\n      }\n\n      const readOptions = {\n        window: pixelBounds,\n        width: sourceTileSize[0],\n        height: sourceTileSize[1],\n        samples: samples,\n        fillValue: fillValue,\n        pool: pool,\n        interleave: false,\n      };\n      if (readRGB(this.convertToRGB_, image)) {\n        requests[sourceIndex] = image.readRGB(readOptions);\n      } else {\n        requests[sourceIndex] = image.readRasters(readOptions);\n      }\n\n      // requests after `sourceCount` are for mask data (if any)\n      const maskIndex = sourceCount + sourceIndex;\n      const mask = this.sourceMasks_[sourceIndex][z];\n      if (!mask) {\n        requests[maskIndex] = Promise.resolve(null);\n        continue;\n      }\n\n      requests[maskIndex] = mask.readRasters({\n        window: pixelBounds,\n        width: sourceTileSize[0],\n        height: sourceTileSize[1],\n        samples: [0],\n        pool: pool,\n        interleave: false,\n      });\n    }\n\n    return Promise.all(requests)\n      .then(this.composeTile_.bind(this, sourceTileSize))\n      .catch(function (error) {\n        logError(error);\n        throw error;\n      });\n  }\n\n  /**\n   * @param {import(\"../size.js\").Size} sourceTileSize The source tile size.\n   * @param {Array} sourceSamples The source samples.\n   * @return {import(\"../DataTile.js\").Data} The composed tile data.\n   * @private\n   */\n  composeTile_(sourceTileSize, sourceSamples) {\n    const metadata = this.metadata_;\n    const sourceInfo = this.sourceInfo_;\n    const sourceCount = this.sourceImagery_.length;\n    const bandCount = this.bandCount;\n    const samplesPerPixel = this.samplesPerPixel_;\n    const nodataValues = this.nodataValues_;\n    const normalize = this.normalize_;\n    const addAlpha = this.addAlpha_;\n\n    const pixelCount = sourceTileSize[0] * sourceTileSize[1];\n    const dataLength = pixelCount * bandCount;\n\n    /** @type {Uint8Array|Float32Array} */\n    let data;\n    if (normalize) {\n      data = new Uint8Array(dataLength);\n    } else {\n      data = new Float32Array(dataLength);\n    }\n\n    let dataIndex = 0;\n    for (let pixelIndex = 0; pixelIndex < pixelCount; ++pixelIndex) {\n      let transparent = addAlpha;\n      for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n        const source = sourceInfo[sourceIndex];\n\n        let min = source.min;\n        let max = source.max;\n        let gain, bias;\n        if (normalize) {\n          const stats = metadata[sourceIndex][0];\n          if (min === undefined) {\n            if (stats && STATISTICS_MINIMUM in stats) {\n              min = parseFloat(stats[STATISTICS_MINIMUM]);\n            } else {\n              min = getMinForDataType(sourceSamples[sourceIndex][0]);\n            }\n          }\n          if (max === undefined) {\n            if (stats && STATISTICS_MAXIMUM in stats) {\n              max = parseFloat(stats[STATISTICS_MAXIMUM]);\n            } else {\n              max = getMaxForDataType(sourceSamples[sourceIndex][0]);\n            }\n          }\n\n          gain = 255 / (max - min);\n          bias = -min * gain;\n        }\n\n        for (\n          let sampleIndex = 0;\n          sampleIndex < samplesPerPixel[sourceIndex];\n          ++sampleIndex\n        ) {\n          const sourceValue =\n            sourceSamples[sourceIndex][sampleIndex][pixelIndex];\n\n          let value;\n          if (normalize) {\n            value = clamp(gain * sourceValue + bias, 0, 255);\n          } else {\n            value = sourceValue;\n          }\n\n          if (!addAlpha) {\n            data[dataIndex] = value;\n          } else {\n            let nodata = source.nodata;\n            if (nodata === undefined) {\n              let bandIndex;\n              if (source.bands) {\n                bandIndex = source.bands[sampleIndex] - 1;\n              } else {\n                bandIndex = sampleIndex;\n              }\n              nodata = nodataValues[sourceIndex][bandIndex];\n            }\n\n            const nodataIsNaN = isNaN(nodata);\n            if (\n              (!nodataIsNaN && sourceValue !== nodata) ||\n              (nodataIsNaN && !isNaN(sourceValue))\n            ) {\n              transparent = false;\n              data[dataIndex] = value;\n            }\n          }\n          dataIndex++;\n        }\n        if (!transparent) {\n          const maskIndex = sourceCount + sourceIndex;\n          const mask = sourceSamples[maskIndex];\n          if (mask && !mask[0][pixelIndex]) {\n            transparent = true;\n          }\n        }\n      }\n      if (addAlpha) {\n        if (!transparent) {\n          data[dataIndex] = 255;\n        }\n        dataIndex++;\n      }\n    }\n\n    return data;\n  }\n}\n\n/**\n * Get a promise for view properties based on the source.  Use the result of this function\n * as the `view` option in a map constructor.\n *\n *     const source = new GeoTIFF(options);\n *\n *     const map = new Map({\n *       target: 'map',\n *       layers: [\n *         new TileLayer({\n *           source: source,\n *         }),\n *       ],\n *       view: source.getView(),\n *     });\n *\n * @function\n * @return {Promise<import(\"../View.js\").ViewOptions>} A promise for view-related properties.\n * @api\n *\n */\nGeoTIFFSource.prototype.getView;\n\nexport default GeoTIFFSource;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}