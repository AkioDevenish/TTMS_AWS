{"ast":null,"code":"import _slicedToArray from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _callSuper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _superPropGet from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/superPropGet.js\";\nimport _inherits from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array-buffer.constructor.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.data-view.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\n/**\n * @module ol/renderer/webgl/PointsLayer\n */\nimport BaseVector from '../../layer/BaseVector.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport ViewHint from '../../ViewHint.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport WebGLRenderTarget from '../../webgl/RenderTarget.js';\nimport { ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER } from '../../webgl.js';\nimport { AttributeType, DefaultUniform } from '../../webgl/Helper.js';\nimport { WebGLWorkerMessageType } from '../../render/webgl/constants.js';\nimport { apply as applyTransform, create as createTransform, makeInverse as makeInverseTransform, multiply as multiplyTransform, translate as translateTransform } from '../../transform.js';\nimport { assert } from '../../asserts.js';\nimport { buffer, createEmpty, equals } from '../../extent.js';\nimport { colorDecodeId, colorEncodeId } from '../../render/webgl/utils.js';\nimport { create as createWebGLWorker } from '../../worker/webgl.js';\nimport { fromUserCoordinate, getUserProjection } from '../../proj.js';\nimport { getUid } from '../../util.js';\nimport { getWorldParameters } from './worldUtil.js';\nimport { listen, unlistenByKey } from '../../events.js';\n\n/**\n * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {string} name Attribute name.\n * @property {function(import(\"../../Feature\").default, Object<string, *>):number} callback This callback computes the numerical value of the\n * attribute for a given feature (properties are available as 2nd arg for quicker access).\n */\n\n/**\n * @typedef {Object} FeatureCacheItem Object that holds a reference to a feature, its geometry and properties. Used to optimize\n * rebuildBuffers by accessing these objects quicker.\n * @property {import(\"../../Feature\").default} feature Feature\n * @property {Object<string, *>} properties Feature properties\n * @property {import(\"../../geom\").Geometry} geometry Feature geometry\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {Array<CustomAttribute>} [attributes] These attributes will be read from the features in the source and then\n * passed to the GPU. The `name` property of each attribute will serve as its identifier:\n *  * In the vertex shader as an `attribute` by prefixing it with `a_`\n *  * In the fragment shader as a `varying` by prefixing it with `v_`\n * Please note that these can only be numerical values.\n * @property {string} vertexShader Vertex shader source, mandatory.\n * @property {string} fragmentShader Fragment shader source, mandatory.\n * @property {boolean} [hitDetectionEnabled] Whether shader is hit detection aware.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * Please note that `u_texture` is reserved for the main texture slot and `u_opacity` is reserved for the layer opacity.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * WebGL vector renderer optimized for points.\n * All features will be rendered as quads (two triangles forming a square). New data will be flushed to the GPU\n * every time the vector source changes.\n *\n * You need to provide vertex and fragment shaders for rendering. This can be done using\n * {@link module:ol/webgl/ShaderBuilder~ShaderBuilder} utilities. These shaders shall expect a `a_position` attribute\n * containing the screen-space projected center of the quad, as well as a `a_index` attribute\n * whose value (0, 1, 2 or 3) indicates which quad vertex is currently getting processed (see structure below).\n *\n * To include variable attributes in the shaders, you need to declare them using the `attributes` property of\n * the options object like so:\n * ```js\n * new WebGLPointsLayerRenderer(layer, {\n *   attributes: [\n *     {\n *       name: 'size',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *     {\n *       name: 'weight',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *   ],\n *   vertexShader:\n *     // shader using attribute a_weight and a_size\n *   fragmentShader:\n *     // shader using varying v_weight and v_size\n * ```\n *\n * To enable hit detection, you must as well provide dedicated shaders using the `hitVertexShader`\n * and `hitFragmentShader` properties. These shall expect the `a_hitColor` attribute to contain\n * the final color that will have to be output for hit detection to work.\n *\n * The following uniform is used for the main texture: `u_texture`.\n * The following uniform is used for the layer opacity: `u_opacity`.\n *\n * Please note that the main shader output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Points are rendered as quads with the following structure:\n *\n * ```\n *   (u0, v1)      (u1, v1)\n *  [3]----------[2]\n *   |`           |\n *   |  `         |\n *   |    `       |\n *   |      `     |\n *   |        `   |\n *   |          ` |\n *  [0]----------[1]\n *   (u0, v0)      (u1, v0)\n *  ```\n *\n * This uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n *\n * @api\n */\nvar WebGLPointsLayerRenderer = /*#__PURE__*/function (_WebGLLayerRenderer) {\n  /**\n   * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n   * @param {Options} options Options.\n   */\n  function WebGLPointsLayerRenderer(layer, options) {\n    var _options$hitDetection, _this$attributes;\n    var _this;\n    _classCallCheck(this, WebGLPointsLayerRenderer);\n    var uniforms = options.uniforms || {};\n    var projectionMatrixTransform = createTransform();\n    uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;\n    _this = _callSuper(this, WebGLPointsLayerRenderer, [layer, {\n      uniforms: uniforms,\n      postProcesses: options.postProcesses\n    }]);\n    _this.sourceRevision_ = -1;\n    _this.verticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n    _this.indicesBuffer_ = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, DYNAMIC_DRAW);\n\n    /**\n     * @private\n     */\n    _this.vertexShader_ = options.vertexShader;\n\n    /**\n     * @private\n     */\n    _this.fragmentShader_ = options.fragmentShader;\n\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n    _this.program_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    _this.hitDetectionEnabled_ = (_options$hitDetection = options.hitDetectionEnabled) !== null && _options$hitDetection !== void 0 ? _options$hitDetection : true;\n    var customAttributes = options.attributes ? options.attributes.map(function (attribute) {\n      return {\n        name: 'a_prop_' + attribute.name,\n        size: 1,\n        type: AttributeType.FLOAT\n      };\n    }) : [];\n\n    /**\n     * A list of attributes used by the renderer. By default only the position and\n     * index of the vertex (0 to 3) are required.\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     */\n    _this.attributes = [{\n      name: 'a_position',\n      size: 2,\n      type: AttributeType.FLOAT\n    }, {\n      name: 'a_index',\n      size: 1,\n      type: AttributeType.FLOAT\n    }];\n    if (_this.hitDetectionEnabled_) {\n      _this.attributes.push({\n        name: 'a_hitColor',\n        size: 4,\n        type: AttributeType.FLOAT\n      });\n      _this.attributes.push({\n        name: 'a_featureUid',\n        size: 1,\n        type: AttributeType.FLOAT\n      });\n    }\n    (_this$attributes = _this.attributes).push.apply(_this$attributes, _toConsumableArray(customAttributes));\n    _this.customAttributes = options.attributes ? options.attributes : [];\n    _this.previousExtent_ = createEmpty();\n\n    /**\n     * This transform is updated on every frame and is the composition of:\n     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n     * - current world->screen transform\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    _this.currentTransform_ = projectionMatrixTransform;\n\n    /**\n     * This transform is updated when buffers are rebuilt and converts world space coordinates to screen space\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    _this.renderTransform_ = createTransform();\n\n    /**\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    _this.invertRenderTransform_ = createTransform();\n\n    /**\n     * @type {Float32Array}\n     * @private\n     */\n    _this.renderInstructions_ = new Float32Array(0);\n\n    /**\n     * @type {WebGLRenderTarget}\n     * @private\n     */\n    _this.hitRenderTarget_;\n\n    /**\n     * Keep track of latest message sent to worker\n     * @type {number}\n     * @private\n     */\n    _this.lastSentId = 0;\n\n    /**\n     * @private\n     */\n    _this.worker_ = createWebGLWorker();\n    _this.worker_.addEventListener('message',\n    /**\n     * @param {*} event Event.\n     */\n    function (event) {\n      var received = event.data;\n      if (received.type === WebGLWorkerMessageType.GENERATE_POINT_BUFFERS) {\n        var projectionTransform = received.projectionTransform;\n        _this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n        _this.helper.flushBufferData(_this.verticesBuffer_);\n        _this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);\n        _this.helper.flushBufferData(_this.indicesBuffer_);\n        _this.renderTransform_ = projectionTransform;\n        makeInverseTransform(_this.invertRenderTransform_, _this.renderTransform_);\n        _this.renderInstructions_ = new Float32Array(event.data.renderInstructions);\n        if (received.id === _this.lastSentId) {\n          _this.ready = true;\n        }\n        _this.getLayer().changed();\n      }\n    });\n\n    /**\n     * This object will be updated when the source changes. Key is uid.\n     * @type {Object<string, FeatureCacheItem>}\n     * @private\n     */\n    _this.featureCache_ = {};\n\n    /**\n     * Amount of features in the cache.\n     * @type {number}\n     * @private\n     */\n    _this.featureCount_ = 0;\n    var source = _this.getLayer().getSource();\n    _this.sourceListenKeys_ = [listen(source, VectorEventType.ADDFEATURE, _this.handleSourceFeatureAdded_, _this), listen(source, VectorEventType.CHANGEFEATURE, _this.handleSourceFeatureChanged_, _this), listen(source, VectorEventType.REMOVEFEATURE, _this.handleSourceFeatureDelete_, _this), listen(source, VectorEventType.CLEAR, _this.handleSourceFeatureClear_, _this)];\n    source.forEachFeature(function (feature) {\n      _this.featureCache_[getUid(feature)] = {\n        feature: feature,\n        properties: feature.getProperties(),\n        geometry: feature.getGeometry()\n      };\n      _this.featureCount_++;\n    });\n    return _this;\n  }\n  _inherits(WebGLPointsLayerRenderer, _WebGLLayerRenderer);\n  return _createClass(WebGLPointsLayerRenderer, [{\n    key: \"afterHelperCreated\",\n    value: function afterHelperCreated() {\n      this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);\n      if (this.hitDetectionEnabled_) {\n        this.hitRenderTarget_ = new WebGLRenderTarget(this.helper);\n      }\n    }\n\n    /**\n     * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n     * @private\n     */\n  }, {\n    key: \"handleSourceFeatureAdded_\",\n    value: function handleSourceFeatureAdded_(event) {\n      var feature = event.feature;\n      this.featureCache_[getUid(feature)] = {\n        feature: feature,\n        properties: feature.getProperties(),\n        geometry: feature.getGeometry()\n      };\n      this.featureCount_++;\n    }\n\n    /**\n     * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n     * @private\n     */\n  }, {\n    key: \"handleSourceFeatureChanged_\",\n    value: function handleSourceFeatureChanged_(event) {\n      var feature = event.feature;\n      this.featureCache_[getUid(feature)] = {\n        feature: feature,\n        properties: feature.getProperties(),\n        geometry: feature.getGeometry()\n      };\n    }\n\n    /**\n     * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n     * @private\n     */\n  }, {\n    key: \"handleSourceFeatureDelete_\",\n    value: function handleSourceFeatureDelete_(event) {\n      var feature = event.feature;\n      delete this.featureCache_[getUid(feature)];\n      this.featureCount_--;\n    }\n\n    /**\n     * @private\n     */\n  }, {\n    key: \"handleSourceFeatureClear_\",\n    value: function handleSourceFeatureClear_() {\n      this.featureCache_ = {};\n      this.featureCount_ = 0;\n    }\n\n    /**\n     * Render the layer.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     * @return {HTMLElement} The rendered element.\n     */\n  }, {\n    key: \"renderFrame\",\n    value: function renderFrame(frameState) {\n      var gl = this.helper.getGL();\n      this.preRender(gl, frameState);\n      var _getWorldParameters = getWorldParameters(frameState, this.getLayer()),\n        _getWorldParameters2 = _slicedToArray(_getWorldParameters, 3),\n        startWorld = _getWorldParameters2[0],\n        endWorld = _getWorldParameters2[1],\n        worldWidth = _getWorldParameters2[2];\n\n      // draw the normal canvas\n      this.renderWorlds(frameState, false, startWorld, endWorld, worldWidth);\n      this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);\n      if (this.hitDetectionEnabled_) {\n        // draw the hit buffer\n        this.renderWorlds(frameState, true, startWorld, endWorld, worldWidth);\n        this.hitRenderTarget_.clearCachedData();\n      }\n      this.postRender(gl, frameState);\n      var canvas = this.helper.getCanvas();\n      return canvas;\n    }\n\n    /**\n     * Determine whether renderFrame should be called.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     */\n  }, {\n    key: \"prepareFrameInternal\",\n    value: function prepareFrameInternal(frameState) {\n      var layer = this.getLayer();\n      var vectorSource = layer.getSource();\n      var viewState = frameState.viewState;\n      var viewNotMoving = !frameState.viewHints[ViewHint.ANIMATING] && !frameState.viewHints[ViewHint.INTERACTING];\n      var extentChanged = !equals(this.previousExtent_, frameState.extent);\n      var sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n      if (sourceChanged) {\n        this.sourceRevision_ = vectorSource.getRevision();\n      }\n      if (viewNotMoving && (extentChanged || sourceChanged)) {\n        var projection = viewState.projection;\n        var resolution = viewState.resolution;\n        var renderBuffer = layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n        var extent = buffer(frameState.extent, renderBuffer * resolution);\n        vectorSource.loadFeatures(extent, resolution, projection);\n        this.rebuildBuffers_(frameState);\n        this.previousExtent_ = frameState.extent.slice();\n      }\n      this.helper.useProgram(this.program_, frameState);\n      this.helper.prepareDraw(frameState);\n\n      // write new data\n      this.helper.bindBuffer(this.verticesBuffer_);\n      this.helper.bindBuffer(this.indicesBuffer_);\n      this.helper.enableAttributes(this.attributes);\n      return true;\n    }\n\n    /**\n     * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much\n     * @param {import(\"../../Map\").FrameState} frameState Frame state.\n     * @private\n     */\n  }, {\n    key: \"rebuildBuffers_\",\n    value: function rebuildBuffers_(frameState) {\n      // saves the projection transform for the current frame state\n      var projectionTransform = createTransform();\n      this.helper.makeProjectionTransform(frameState, projectionTransform);\n      var userProjection = getUserProjection();\n      var baseInstructionLength = this.hitDetectionEnabled_ ? 7 : 2; // see below\n      var singleInstructionLength = baseInstructionLength + this.customAttributes.length;\n      var totalSize = singleInstructionLength * this.featureCount_;\n      if (!this.renderInstructions_ || this.renderInstructions_.length !== totalSize) {\n        this.renderInstructions_ = new Float32Array(totalSize);\n      }\n\n      // loop on features to fill the buffer\n      var featureCache, geometry;\n      var tmpCoords = [];\n      var tmpColor = [];\n      var idx = -1;\n      for (var featureUid in this.featureCache_) {\n        featureCache = this.featureCache_[featureUid];\n        geometry = /** @type {import(\"../../geom\").Point} */\n        featureCache.geometry;\n        if (!geometry || geometry.getType() !== 'Point') {\n          continue;\n        }\n        if (userProjection) {\n          var userCoords = fromUserCoordinate(geometry.getFlatCoordinates(), frameState.viewState.projection);\n          tmpCoords[0] = userCoords[0];\n          tmpCoords[1] = userCoords[1];\n        } else {\n          tmpCoords[0] = geometry.getFlatCoordinates()[0];\n          tmpCoords[1] = geometry.getFlatCoordinates()[1];\n        }\n        applyTransform(projectionTransform, tmpCoords);\n        this.renderInstructions_[++idx] = tmpCoords[0];\n        this.renderInstructions_[++idx] = tmpCoords[1];\n\n        // for hit detection, the feature uid is saved in the opacity value\n        // and the index of the opacity value is encoded in the color values\n        if (this.hitDetectionEnabled_) {\n          var hitColor = colorEncodeId(idx + 5, tmpColor);\n          this.renderInstructions_[++idx] = hitColor[0];\n          this.renderInstructions_[++idx] = hitColor[1];\n          this.renderInstructions_[++idx] = hitColor[2];\n          this.renderInstructions_[++idx] = hitColor[3];\n          this.renderInstructions_[++idx] = Number(featureUid);\n        }\n\n        // pushing custom attributes\n        for (var j = 0; j < this.customAttributes.length; j++) {\n          var value = this.customAttributes[j].callback(featureCache.feature, featureCache.properties);\n          this.renderInstructions_[++idx] = value;\n        }\n      }\n\n      /** @type {import('../../render/webgl/constants.js').WebGLWorkerGenerateBuffersMessage} */\n      var message = {\n        id: ++this.lastSentId,\n        type: WebGLWorkerMessageType.GENERATE_POINT_BUFFERS,\n        renderInstructions: this.renderInstructions_.buffer,\n        customAttributesSize: singleInstructionLength - 2\n      };\n      // additional properties will be sent back as-is by the worker\n      message['projectionTransform'] = projectionTransform;\n      this.ready = false;\n      this.worker_.postMessage(message, [this.renderInstructions_.buffer]);\n      this.renderInstructions_ = null;\n    }\n\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n     * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n     * @return {T|undefined} Callback result.\n     * @template T\n     */\n  }, {\n    key: \"forEachFeatureAtCoordinate\",\n    value: function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {\n      assert(this.hitDetectionEnabled_, '`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has been disabled using the `disableHitDetection: true` option.');\n      if (!this.renderInstructions_ || !this.hitDetectionEnabled_) {\n        return undefined;\n      }\n      var pixel = applyTransform(frameState.coordinateToPixelTransform, coordinate.slice());\n      var data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);\n      var color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];\n      var index = colorDecodeId(color);\n      var opacity = this.renderInstructions_[index];\n      var uid = Math.floor(opacity).toString();\n      var source = this.getLayer().getSource();\n      var feature = source.getFeatureByUid(uid);\n      if (feature) {\n        return callback(feature, this.getLayer(), null);\n      }\n      return undefined;\n    }\n\n    /**\n     * Render the world, either to the main framebuffer or to the hit framebuffer\n     * @param {import(\"../../Map.js\").FrameState} frameState current frame state\n     * @param {boolean} forHitDetection whether the rendering is for hit detection\n     * @param {number} startWorld the world to render in the first iteration\n     * @param {number} endWorld the last world to render\n     * @param {number} worldWidth the width of the worlds being rendered\n     */\n  }, {\n    key: \"renderWorlds\",\n    value: function renderWorlds(frameState, forHitDetection, startWorld, endWorld, worldWidth) {\n      var world = startWorld;\n      this.helper.useProgram(this.program_, frameState);\n      if (forHitDetection) {\n        this.hitRenderTarget_.setSize([Math.floor(frameState.size[0] / 2), Math.floor(frameState.size[1] / 2)]);\n        this.helper.prepareDrawToRenderTarget(frameState, this.hitRenderTarget_, true);\n      }\n      this.helper.bindBuffer(this.verticesBuffer_);\n      this.helper.bindBuffer(this.indicesBuffer_);\n      this.helper.enableAttributes(this.attributes);\n      do {\n        this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n        translateTransform(this.currentTransform_, world * worldWidth, 0);\n        multiplyTransform(this.currentTransform_, this.invertRenderTransform_);\n        this.helper.applyUniforms(frameState);\n        this.helper.applyHitDetectionUniform(forHitDetection);\n        var renderCount = this.indicesBuffer_.getSize();\n        this.helper.drawElements(0, renderCount);\n      } while (++world < endWorld);\n    }\n\n    /**\n     * Clean up.\n     */\n  }, {\n    key: \"disposeInternal\",\n    value: function disposeInternal() {\n      this.worker_.terminate();\n      this.layer_ = null;\n      this.sourceListenKeys_.forEach(function (key) {\n        unlistenByKey(key);\n      });\n      this.sourceListenKeys_ = null;\n      _superPropGet(WebGLPointsLayerRenderer, \"disposeInternal\", this, 3)([]);\n    }\n  }]);\n}(WebGLLayerRenderer);\nexport default WebGLPointsLayerRenderer;","map":{"version":3,"names":["BaseVector","VectorEventType","ViewHint","WebGLArrayBuffer","WebGLLayerRenderer","WebGLRenderTarget","ARRAY_BUFFER","DYNAMIC_DRAW","ELEMENT_ARRAY_BUFFER","AttributeType","DefaultUniform","WebGLWorkerMessageType","apply","applyTransform","create","createTransform","makeInverse","makeInverseTransform","multiply","multiplyTransform","translate","translateTransform","assert","buffer","createEmpty","equals","colorDecodeId","colorEncodeId","createWebGLWorker","fromUserCoordinate","getUserProjection","getUid","getWorldParameters","listen","unlistenByKey","WebGLPointsLayerRenderer","_WebGLLayerRenderer","layer","options","_options$hitDetection","_this$attributes","_this","_classCallCheck","uniforms","projectionMatrixTransform","PROJECTION_MATRIX","_callSuper","postProcesses","sourceRevision_","verticesBuffer_","indicesBuffer_","vertexShader_","vertexShader","fragmentShader_","fragmentShader","program_","hitDetectionEnabled_","hitDetectionEnabled","customAttributes","attributes","map","attribute","name","size","type","FLOAT","push","_toConsumableArray","previousExtent_","currentTransform_","renderTransform_","invertRenderTransform_","renderInstructions_","Float32Array","hitRenderTarget_","lastSentId","worker_","addEventListener","event","received","data","GENERATE_POINT_BUFFERS","projectionTransform","fromArrayBuffer","vertexBuffer","helper","flushBufferData","indexBuffer","renderInstructions","id","ready","getLayer","changed","featureCache_","featureCount_","source","getSource","sourceListenKeys_","ADDFEATURE","handleSourceFeatureAdded_","CHANGEFEATURE","handleSourceFeatureChanged_","REMOVEFEATURE","handleSourceFeatureDelete_","CLEAR","handleSourceFeatureClear_","forEachFeature","feature","properties","getProperties","geometry","getGeometry","_inherits","_createClass","key","value","afterHelperCreated","getProgram","renderFrame","frameState","gl","getGL","preRender","_getWorldParameters","_getWorldParameters2","_slicedToArray","startWorld","endWorld","worldWidth","renderWorlds","finalizeDraw","dispatchPreComposeEvent","dispatchPostComposeEvent","clearCachedData","postRender","canvas","getCanvas","prepareFrameInternal","vectorSource","viewState","viewNotMoving","viewHints","ANIMATING","INTERACTING","extentChanged","extent","sourceChanged","getRevision","projection","resolution","renderBuffer","getRenderBuffer","loadFeatures","rebuildBuffers_","slice","useProgram","prepareDraw","bindBuffer","enableAttributes","makeProjectionTransform","userProjection","baseInstructionLength","singleInstructionLength","length","totalSize","featureCache","tmpCoords","tmpColor","idx","featureUid","getType","userCoords","getFlatCoordinates","hitColor","Number","j","callback","message","customAttributesSize","postMessage","forEachFeatureAtCoordinate","coordinate","hitTolerance","matches","undefined","pixel","coordinateToPixelTransform","readPixel","color","index","opacity","uid","Math","floor","toString","getFeatureByUid","forHitDetection","world","setSize","prepareDrawToRenderTarget","applyUniforms","applyHitDetectionUniform","renderCount","getSize","drawElements","disposeInternal","terminate","layer_","forEach","_superPropGet"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol/renderer/webgl/PointsLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/webgl/PointsLayer\n */\nimport BaseVector from '../../layer/BaseVector.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport ViewHint from '../../ViewHint.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport WebGLRenderTarget from '../../webgl/RenderTarget.js';\nimport {ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER} from '../../webgl.js';\nimport {AttributeType, DefaultUniform} from '../../webgl/Helper.js';\nimport {WebGLWorkerMessageType} from '../../render/webgl/constants.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  makeInverse as makeInverseTransform,\n  multiply as multiplyTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {assert} from '../../asserts.js';\nimport {buffer, createEmpty, equals} from '../../extent.js';\nimport {colorDecodeId, colorEncodeId} from '../../render/webgl/utils.js';\nimport {create as createWebGLWorker} from '../../worker/webgl.js';\nimport {fromUserCoordinate, getUserProjection} from '../../proj.js';\nimport {getUid} from '../../util.js';\nimport {getWorldParameters} from './worldUtil.js';\nimport {listen, unlistenByKey} from '../../events.js';\n\n/**\n * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {string} name Attribute name.\n * @property {function(import(\"../../Feature\").default, Object<string, *>):number} callback This callback computes the numerical value of the\n * attribute for a given feature (properties are available as 2nd arg for quicker access).\n */\n\n/**\n * @typedef {Object} FeatureCacheItem Object that holds a reference to a feature, its geometry and properties. Used to optimize\n * rebuildBuffers by accessing these objects quicker.\n * @property {import(\"../../Feature\").default} feature Feature\n * @property {Object<string, *>} properties Feature properties\n * @property {import(\"../../geom\").Geometry} geometry Feature geometry\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {Array<CustomAttribute>} [attributes] These attributes will be read from the features in the source and then\n * passed to the GPU. The `name` property of each attribute will serve as its identifier:\n *  * In the vertex shader as an `attribute` by prefixing it with `a_`\n *  * In the fragment shader as a `varying` by prefixing it with `v_`\n * Please note that these can only be numerical values.\n * @property {string} vertexShader Vertex shader source, mandatory.\n * @property {string} fragmentShader Fragment shader source, mandatory.\n * @property {boolean} [hitDetectionEnabled] Whether shader is hit detection aware.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * Please note that `u_texture` is reserved for the main texture slot and `u_opacity` is reserved for the layer opacity.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * WebGL vector renderer optimized for points.\n * All features will be rendered as quads (two triangles forming a square). New data will be flushed to the GPU\n * every time the vector source changes.\n *\n * You need to provide vertex and fragment shaders for rendering. This can be done using\n * {@link module:ol/webgl/ShaderBuilder~ShaderBuilder} utilities. These shaders shall expect a `a_position` attribute\n * containing the screen-space projected center of the quad, as well as a `a_index` attribute\n * whose value (0, 1, 2 or 3) indicates which quad vertex is currently getting processed (see structure below).\n *\n * To include variable attributes in the shaders, you need to declare them using the `attributes` property of\n * the options object like so:\n * ```js\n * new WebGLPointsLayerRenderer(layer, {\n *   attributes: [\n *     {\n *       name: 'size',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *     {\n *       name: 'weight',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *   ],\n *   vertexShader:\n *     // shader using attribute a_weight and a_size\n *   fragmentShader:\n *     // shader using varying v_weight and v_size\n * ```\n *\n * To enable hit detection, you must as well provide dedicated shaders using the `hitVertexShader`\n * and `hitFragmentShader` properties. These shall expect the `a_hitColor` attribute to contain\n * the final color that will have to be output for hit detection to work.\n *\n * The following uniform is used for the main texture: `u_texture`.\n * The following uniform is used for the layer opacity: `u_opacity`.\n *\n * Please note that the main shader output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Points are rendered as quads with the following structure:\n *\n * ```\n *   (u0, v1)      (u1, v1)\n *  [3]----------[2]\n *   |`           |\n *   |  `         |\n *   |    `       |\n *   |      `     |\n *   |        `   |\n *   |          ` |\n *  [0]----------[1]\n *   (u0, v0)      (u1, v0)\n *  ```\n *\n * This uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n *\n * @api\n */\nclass WebGLPointsLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n   * @param {Options} options Options.\n   */\n  constructor(layer, options) {\n    const uniforms = options.uniforms || {};\n    const projectionMatrixTransform = createTransform();\n    uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;\n\n    super(layer, {\n      uniforms: uniforms,\n      postProcesses: options.postProcesses,\n    });\n\n    this.sourceRevision_ = -1;\n\n    this.verticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n    this.indicesBuffer_ = new WebGLArrayBuffer(\n      ELEMENT_ARRAY_BUFFER,\n      DYNAMIC_DRAW\n    );\n\n    /**\n     * @private\n     */\n    this.vertexShader_ = options.vertexShader;\n\n    /**\n     * @private\n     */\n    this.fragmentShader_ = options.fragmentShader;\n\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n    this.program_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hitDetectionEnabled_ = options.hitDetectionEnabled ?? true;\n\n    const customAttributes = options.attributes\n      ? options.attributes.map(function (attribute) {\n          return {\n            name: 'a_prop_' + attribute.name,\n            size: 1,\n            type: AttributeType.FLOAT,\n          };\n        })\n      : [];\n\n    /**\n     * A list of attributes used by the renderer. By default only the position and\n     * index of the vertex (0 to 3) are required.\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     */\n    this.attributes = [\n      {\n        name: 'a_position',\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: 'a_index',\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n    ];\n\n    if (this.hitDetectionEnabled_) {\n      this.attributes.push({\n        name: 'a_hitColor',\n        size: 4,\n        type: AttributeType.FLOAT,\n      });\n      this.attributes.push({\n        name: 'a_featureUid',\n        size: 1,\n        type: AttributeType.FLOAT,\n      });\n    }\n    this.attributes.push(...customAttributes);\n\n    this.customAttributes = options.attributes ? options.attributes : [];\n\n    this.previousExtent_ = createEmpty();\n\n    /**\n     * This transform is updated on every frame and is the composition of:\n     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n     * - current world->screen transform\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.currentTransform_ = projectionMatrixTransform;\n\n    /**\n     * This transform is updated when buffers are rebuilt and converts world space coordinates to screen space\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.renderTransform_ = createTransform();\n\n    /**\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.invertRenderTransform_ = createTransform();\n\n    /**\n     * @type {Float32Array}\n     * @private\n     */\n    this.renderInstructions_ = new Float32Array(0);\n\n    /**\n     * @type {WebGLRenderTarget}\n     * @private\n     */\n    this.hitRenderTarget_;\n\n    /**\n     * Keep track of latest message sent to worker\n     * @type {number}\n     * @private\n     */\n    this.lastSentId = 0;\n\n    /**\n     * @private\n     */\n    this.worker_ = createWebGLWorker();\n\n    this.worker_.addEventListener(\n      'message',\n      /**\n       * @param {*} event Event.\n       */\n      (event) => {\n        const received = event.data;\n        if (received.type === WebGLWorkerMessageType.GENERATE_POINT_BUFFERS) {\n          const projectionTransform = received.projectionTransform;\n          this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n          this.helper.flushBufferData(this.verticesBuffer_);\n          this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);\n          this.helper.flushBufferData(this.indicesBuffer_);\n\n          this.renderTransform_ = projectionTransform;\n          makeInverseTransform(\n            this.invertRenderTransform_,\n            this.renderTransform_\n          );\n          this.renderInstructions_ = new Float32Array(\n            event.data.renderInstructions\n          );\n          if (received.id === this.lastSentId) {\n            this.ready = true;\n          }\n          this.getLayer().changed();\n        }\n      }\n    );\n\n    /**\n     * This object will be updated when the source changes. Key is uid.\n     * @type {Object<string, FeatureCacheItem>}\n     * @private\n     */\n    this.featureCache_ = {};\n\n    /**\n     * Amount of features in the cache.\n     * @type {number}\n     * @private\n     */\n    this.featureCount_ = 0;\n\n    const source = this.getLayer().getSource();\n    this.sourceListenKeys_ = [\n      listen(\n        source,\n        VectorEventType.ADDFEATURE,\n        this.handleSourceFeatureAdded_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.CHANGEFEATURE,\n        this.handleSourceFeatureChanged_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.REMOVEFEATURE,\n        this.handleSourceFeatureDelete_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.CLEAR,\n        this.handleSourceFeatureClear_,\n        this\n      ),\n    ];\n    source.forEachFeature((feature) => {\n      this.featureCache_[getUid(feature)] = {\n        feature: feature,\n        properties: feature.getProperties(),\n        geometry: feature.getGeometry(),\n      };\n      this.featureCount_++;\n    });\n  }\n\n  afterHelperCreated() {\n    this.program_ = this.helper.getProgram(\n      this.fragmentShader_,\n      this.vertexShader_\n    );\n\n    if (this.hitDetectionEnabled_) {\n      this.hitRenderTarget_ = new WebGLRenderTarget(this.helper);\n    }\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureAdded_(event) {\n    const feature = event.feature;\n    this.featureCache_[getUid(feature)] = {\n      feature: feature,\n      properties: feature.getProperties(),\n      geometry: feature.getGeometry(),\n    };\n    this.featureCount_++;\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureChanged_(event) {\n    const feature = event.feature;\n    this.featureCache_[getUid(feature)] = {\n      feature: feature,\n      properties: feature.getProperties(),\n      geometry: feature.getGeometry(),\n    };\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureDelete_(event) {\n    const feature = event.feature;\n    delete this.featureCache_[getUid(feature)];\n    this.featureCount_--;\n  }\n\n  /**\n   * @private\n   */\n  handleSourceFeatureClear_() {\n    this.featureCache_ = {};\n    this.featureCount_ = 0;\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState) {\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n    const [startWorld, endWorld, worldWidth] = getWorldParameters(\n      frameState,\n      this.getLayer()\n    );\n\n    // draw the normal canvas\n    this.renderWorlds(frameState, false, startWorld, endWorld, worldWidth);\n    this.helper.finalizeDraw(\n      frameState,\n      this.dispatchPreComposeEvent,\n      this.dispatchPostComposeEvent\n    );\n\n    if (this.hitDetectionEnabled_) {\n      // draw the hit buffer\n      this.renderWorlds(frameState, true, startWorld, endWorld, worldWidth);\n      this.hitRenderTarget_.clearCachedData();\n    }\n\n    this.postRender(gl, frameState);\n\n    const canvas = this.helper.getCanvas();\n    return canvas;\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrameInternal(frameState) {\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    const viewState = frameState.viewState;\n    const viewNotMoving =\n      !frameState.viewHints[ViewHint.ANIMATING] &&\n      !frameState.viewHints[ViewHint.INTERACTING];\n    const extentChanged = !equals(this.previousExtent_, frameState.extent);\n    const sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n\n    if (sourceChanged) {\n      this.sourceRevision_ = vectorSource.getRevision();\n    }\n\n    if (viewNotMoving && (extentChanged || sourceChanged)) {\n      const projection = viewState.projection;\n      const resolution = viewState.resolution;\n\n      const renderBuffer =\n        layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n      const extent = buffer(frameState.extent, renderBuffer * resolution);\n      vectorSource.loadFeatures(extent, resolution, projection);\n\n      this.rebuildBuffers_(frameState);\n      this.previousExtent_ = frameState.extent.slice();\n    }\n\n    this.helper.useProgram(this.program_, frameState);\n    this.helper.prepareDraw(frameState);\n\n    // write new data\n    this.helper.bindBuffer(this.verticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n    this.helper.enableAttributes(this.attributes);\n\n    return true;\n  }\n\n  /**\n   * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much\n   * @param {import(\"../../Map\").FrameState} frameState Frame state.\n   * @private\n   */\n  rebuildBuffers_(frameState) {\n    // saves the projection transform for the current frame state\n    const projectionTransform = createTransform();\n    this.helper.makeProjectionTransform(frameState, projectionTransform);\n\n    const userProjection = getUserProjection();\n\n    const baseInstructionLength = this.hitDetectionEnabled_ ? 7 : 2; // see below\n    const singleInstructionLength =\n      baseInstructionLength + this.customAttributes.length;\n    const totalSize = singleInstructionLength * this.featureCount_;\n    if (\n      !this.renderInstructions_ ||\n      this.renderInstructions_.length !== totalSize\n    ) {\n      this.renderInstructions_ = new Float32Array(totalSize);\n    }\n\n    // loop on features to fill the buffer\n    let featureCache, geometry;\n    const tmpCoords = [];\n    const tmpColor = [];\n    let idx = -1;\n    for (const featureUid in this.featureCache_) {\n      featureCache = this.featureCache_[featureUid];\n      geometry = /** @type {import(\"../../geom\").Point} */ (\n        featureCache.geometry\n      );\n      if (!geometry || geometry.getType() !== 'Point') {\n        continue;\n      }\n      if (userProjection) {\n        const userCoords = fromUserCoordinate(\n          geometry.getFlatCoordinates(),\n          frameState.viewState.projection\n        );\n        tmpCoords[0] = userCoords[0];\n        tmpCoords[1] = userCoords[1];\n      } else {\n        tmpCoords[0] = geometry.getFlatCoordinates()[0];\n        tmpCoords[1] = geometry.getFlatCoordinates()[1];\n      }\n      applyTransform(projectionTransform, tmpCoords);\n\n      this.renderInstructions_[++idx] = tmpCoords[0];\n      this.renderInstructions_[++idx] = tmpCoords[1];\n\n      // for hit detection, the feature uid is saved in the opacity value\n      // and the index of the opacity value is encoded in the color values\n      if (this.hitDetectionEnabled_) {\n        const hitColor = colorEncodeId(idx + 5, tmpColor);\n        this.renderInstructions_[++idx] = hitColor[0];\n        this.renderInstructions_[++idx] = hitColor[1];\n        this.renderInstructions_[++idx] = hitColor[2];\n        this.renderInstructions_[++idx] = hitColor[3];\n        this.renderInstructions_[++idx] = Number(featureUid);\n      }\n\n      // pushing custom attributes\n      for (let j = 0; j < this.customAttributes.length; j++) {\n        const value = this.customAttributes[j].callback(\n          featureCache.feature,\n          featureCache.properties\n        );\n        this.renderInstructions_[++idx] = value;\n      }\n    }\n\n    /** @type {import('../../render/webgl/constants.js').WebGLWorkerGenerateBuffersMessage} */\n    const message = {\n      id: ++this.lastSentId,\n      type: WebGLWorkerMessageType.GENERATE_POINT_BUFFERS,\n      renderInstructions: this.renderInstructions_.buffer,\n      customAttributesSize: singleInstructionLength - 2,\n    };\n    // additional properties will be sent back as-is by the worker\n    message['projectionTransform'] = projectionTransform;\n    this.ready = false;\n    this.worker_.postMessage(message, [this.renderInstructions_.buffer]);\n    this.renderInstructions_ = null;\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches\n  ) {\n    assert(\n      this.hitDetectionEnabled_,\n      '`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has been disabled using the `disableHitDetection: true` option.'\n    );\n    if (!this.renderInstructions_ || !this.hitDetectionEnabled_) {\n      return undefined;\n    }\n\n    const pixel = applyTransform(\n      frameState.coordinateToPixelTransform,\n      coordinate.slice()\n    );\n\n    const data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);\n    const color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];\n    const index = colorDecodeId(color);\n    const opacity = this.renderInstructions_[index];\n    const uid = Math.floor(opacity).toString();\n\n    const source = this.getLayer().getSource();\n    const feature = source.getFeatureByUid(uid);\n    if (feature) {\n      return callback(feature, this.getLayer(), null);\n    }\n    return undefined;\n  }\n\n  /**\n   * Render the world, either to the main framebuffer or to the hit framebuffer\n   * @param {import(\"../../Map.js\").FrameState} frameState current frame state\n   * @param {boolean} forHitDetection whether the rendering is for hit detection\n   * @param {number} startWorld the world to render in the first iteration\n   * @param {number} endWorld the last world to render\n   * @param {number} worldWidth the width of the worlds being rendered\n   */\n  renderWorlds(frameState, forHitDetection, startWorld, endWorld, worldWidth) {\n    let world = startWorld;\n\n    this.helper.useProgram(this.program_, frameState);\n\n    if (forHitDetection) {\n      this.hitRenderTarget_.setSize([\n        Math.floor(frameState.size[0] / 2),\n        Math.floor(frameState.size[1] / 2),\n      ]);\n      this.helper.prepareDrawToRenderTarget(\n        frameState,\n        this.hitRenderTarget_,\n        true\n      );\n    }\n\n    this.helper.bindBuffer(this.verticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n    this.helper.enableAttributes(this.attributes);\n\n    do {\n      this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n      translateTransform(this.currentTransform_, world * worldWidth, 0);\n      multiplyTransform(this.currentTransform_, this.invertRenderTransform_);\n      this.helper.applyUniforms(frameState);\n      this.helper.applyHitDetectionUniform(forHitDetection);\n      const renderCount = this.indicesBuffer_.getSize();\n      this.helper.drawElements(0, renderCount);\n    } while (++world < endWorld);\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.worker_.terminate();\n    this.layer_ = null;\n    this.sourceListenKeys_.forEach(function (key) {\n      unlistenByKey(key);\n    });\n    this.sourceListenKeys_ = null;\n    super.disposeInternal();\n  }\n}\n\nexport default WebGLPointsLayerRenderer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}