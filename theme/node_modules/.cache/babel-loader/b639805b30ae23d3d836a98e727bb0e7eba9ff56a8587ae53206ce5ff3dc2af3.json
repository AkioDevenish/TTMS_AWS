{"ast":null,"code":"import _classCallCheck from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _callSuper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.slice.js\";\n/**\n * @module ol/geom/MultiPolygon\n */\nimport MultiPoint from './MultiPoint.js';\nimport Polygon from './Polygon.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { assignClosestMultiArrayPoint, multiArrayMaxSquaredDelta } from './flat/closest.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport { deflateMultiCoordinatesArray } from './flat/deflate.js';\nimport { extend } from '../array.js';\nimport { getInteriorPointsOfMultiArray } from './flat/interiorpoint.js';\nimport { inflateMultiCoordinatesArray } from './flat/inflate.js';\nimport { intersectsLinearRingMultiArray } from './flat/intersectsextent.js';\nimport { linearRingssAreOriented, orientLinearRingsArray } from './flat/orient.js';\nimport { linearRingss as linearRingssArea } from './flat/area.js';\nimport { linearRingss as linearRingssCenter } from './flat/center.js';\nimport { linearRingssContainsXY } from './flat/contains.js';\nimport { quantizeMultiArray } from './flat/simplify.js';\n\n/**\n * @classdesc\n * Multi-polygon geometry.\n *\n * @api\n */\nvar MultiPolygon = /*#__PURE__*/function (_SimpleGeometry) {\n  /**\n   * @param {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.\n   *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.\n   */\n  function MultiPolygon(coordinates, layout, endss) {\n    var _this;\n    _classCallCheck(this, MultiPolygon);\n    _this = _callSuper(this, MultiPolygon);\n\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n    _this.endss_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.flatInteriorPointsRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>|null}\n     */\n    _this.flatInteriorPoints_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.maxDeltaRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.orientedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>|null}\n     */\n    _this.orientedFlatCoordinates_ = null;\n    if (!endss && !Array.isArray(coordinates[0])) {\n      var polygons = /** @type {Array<Polygon>} */coordinates;\n      /** @type {Array<number>} */\n      var flatCoordinates = [];\n      var thisEndss = [];\n      for (var i = 0, ii = polygons.length; i < ii; ++i) {\n        var polygon = polygons[i];\n        var offset = flatCoordinates.length;\n        var ends = polygon.getEnds();\n        for (var j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] += offset;\n        }\n        extend(flatCoordinates, polygon.getFlatCoordinates());\n        thisEndss.push(ends);\n      }\n      layout = polygons.length === 0 ? _this.getLayout() : polygons[0].getLayout();\n      coordinates = flatCoordinates;\n      endss = thisEndss;\n    }\n    if (layout !== undefined && endss) {\n      _this.setFlatCoordinates(layout, /** @type {Array<number>} */coordinates);\n      _this.endss_ = endss;\n    } else {\n      _this.setCoordinates(/** @type {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} */\n      coordinates, layout);\n    }\n    return _this;\n  }\n\n  /**\n   * Append the passed polygon to this multipolygon.\n   * @param {Polygon} polygon Polygon.\n   * @api\n   */\n  _inherits(MultiPolygon, _SimpleGeometry);\n  return _createClass(MultiPolygon, [{\n    key: \"appendPolygon\",\n    value: function appendPolygon(polygon) {\n      /** @type {Array<number>} */\n      var ends;\n      if (!this.flatCoordinates) {\n        this.flatCoordinates = polygon.getFlatCoordinates().slice();\n        ends = polygon.getEnds().slice();\n        this.endss_.push();\n      } else {\n        var offset = this.flatCoordinates.length;\n        extend(this.flatCoordinates, polygon.getFlatCoordinates());\n        ends = polygon.getEnds().slice();\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n          ends[i] += offset;\n        }\n      }\n      this.endss_.push(ends);\n      this.changed();\n    }\n\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!MultiPolygon} Clone.\n     * @api\n     */\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var len = this.endss_.length;\n      var newEndss = new Array(len);\n      for (var i = 0; i < len; ++i) {\n        newEndss[i] = this.endss_[i].slice();\n      }\n      var multiPolygon = new MultiPolygon(this.flatCoordinates.slice(), this.layout, newEndss);\n      multiPolygon.applyProperties(this);\n      return multiPolygon;\n    }\n\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n  }, {\n    key: \"closestPointXY\",\n    value: function closestPointXY(x, y, closestPoint, minSquaredDistance) {\n      if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n        return minSquaredDistance;\n      }\n      if (this.maxDeltaRevision_ != this.getRevision()) {\n        this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(this.flatCoordinates, 0, this.endss_, this.stride, 0));\n        this.maxDeltaRevision_ = this.getRevision();\n      }\n      return assignClosestMultiArrayPoint(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n    }\n\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @return {boolean} Contains (x, y).\n     */\n  }, {\n    key: \"containsXY\",\n    value: function containsXY(x, y) {\n      return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);\n    }\n\n    /**\n     * Return the area of the multipolygon on projected plane.\n     * @return {number} Area (on projected plane).\n     * @api\n     */\n  }, {\n    key: \"getArea\",\n    value: function getArea() {\n      return linearRingssArea(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);\n    }\n\n    /**\n     * Get the coordinate array for this geometry.  This array has the structure\n     * of a GeoJSON coordinate array for multi-polygons.\n     *\n     * @param {boolean} [right] Orient coordinates according to the right-hand\n     *     rule (counter-clockwise for exterior and clockwise for interior rings).\n     *     If `false`, coordinates will be oriented according to the left-hand rule\n     *     (clockwise for exterior and counter-clockwise for interior rings).\n     *     By default, coordinate orientation will depend on how the geometry was\n     *     constructed.\n     * @return {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} Coordinates.\n     * @api\n     */\n  }, {\n    key: \"getCoordinates\",\n    value: function getCoordinates(right) {\n      var flatCoordinates;\n      if (right !== undefined) {\n        flatCoordinates = this.getOrientedFlatCoordinates().slice();\n        orientLinearRingsArray(flatCoordinates, 0, this.endss_, this.stride, right);\n      } else {\n        flatCoordinates = this.flatCoordinates;\n      }\n      return inflateMultiCoordinatesArray(flatCoordinates, 0, this.endss_, this.stride);\n    }\n\n    /**\n     * @return {Array<Array<number>>} Endss.\n     */\n  }, {\n    key: \"getEndss\",\n    value: function getEndss() {\n      return this.endss_;\n    }\n\n    /**\n     * @return {Array<number>} Flat interior points.\n     */\n  }, {\n    key: \"getFlatInteriorPoints\",\n    value: function getFlatInteriorPoints() {\n      if (this.flatInteriorPointsRevision_ != this.getRevision()) {\n        var flatCenters = linearRingssCenter(this.flatCoordinates, 0, this.endss_, this.stride);\n        this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);\n        this.flatInteriorPointsRevision_ = this.getRevision();\n      }\n      return /** @type {Array<number>} */this.flatInteriorPoints_;\n    }\n\n    /**\n     * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.\n     * @return {MultiPoint} Interior points as XYM coordinates, where M is\n     * the length of the horizontal intersection that the point belongs to.\n     * @api\n     */\n  }, {\n    key: \"getInteriorPoints\",\n    value: function getInteriorPoints() {\n      return new MultiPoint(this.getFlatInteriorPoints().slice(), 'XYM');\n    }\n\n    /**\n     * @return {Array<number>} Oriented flat coordinates.\n     */\n  }, {\n    key: \"getOrientedFlatCoordinates\",\n    value: function getOrientedFlatCoordinates() {\n      if (this.orientedRevision_ != this.getRevision()) {\n        var flatCoordinates = this.flatCoordinates;\n        if (linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {\n          this.orientedFlatCoordinates_ = flatCoordinates;\n        } else {\n          this.orientedFlatCoordinates_ = flatCoordinates.slice();\n          this.orientedFlatCoordinates_.length = orientLinearRingsArray(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);\n        }\n        this.orientedRevision_ = this.getRevision();\n      }\n      return /** @type {Array<number>} */this.orientedFlatCoordinates_;\n    }\n\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {MultiPolygon} Simplified MultiPolygon.\n     * @protected\n     */\n  }, {\n    key: \"getSimplifiedGeometryInternal\",\n    value: function getSimplifiedGeometryInternal(squaredTolerance) {\n      /** @type {Array<number>} */\n      var simplifiedFlatCoordinates = [];\n      /** @type {Array<Array<number>>} */\n      var simplifiedEndss = [];\n      simplifiedFlatCoordinates.length = quantizeMultiArray(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);\n      return new MultiPolygon(simplifiedFlatCoordinates, 'XY', simplifiedEndss);\n    }\n\n    /**\n     * Return the polygon at the specified index.\n     * @param {number} index Index.\n     * @return {Polygon} Polygon.\n     * @api\n     */\n  }, {\n    key: \"getPolygon\",\n    value: function getPolygon(index) {\n      if (index < 0 || this.endss_.length <= index) {\n        return null;\n      }\n      var offset;\n      if (index === 0) {\n        offset = 0;\n      } else {\n        var prevEnds = this.endss_[index - 1];\n        offset = prevEnds[prevEnds.length - 1];\n      }\n      var ends = this.endss_[index].slice();\n      var end = ends[ends.length - 1];\n      if (offset !== 0) {\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n          ends[i] -= offset;\n        }\n      }\n      return new Polygon(this.flatCoordinates.slice(offset, end), this.layout, ends);\n    }\n\n    /**\n     * Return the polygons of this multipolygon.\n     * @return {Array<Polygon>} Polygons.\n     * @api\n     */\n  }, {\n    key: \"getPolygons\",\n    value: function getPolygons() {\n      var layout = this.layout;\n      var flatCoordinates = this.flatCoordinates;\n      var endss = this.endss_;\n      var polygons = [];\n      var offset = 0;\n      for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i].slice();\n        var end = ends[ends.length - 1];\n        if (offset !== 0) {\n          for (var j = 0, jj = ends.length; j < jj; ++j) {\n            ends[j] -= offset;\n          }\n        }\n        var polygon = new Polygon(flatCoordinates.slice(offset, end), layout, ends);\n        polygons.push(polygon);\n        offset = end;\n      }\n      return polygons;\n    }\n\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./Geometry.js\").Type} Geometry type.\n     * @api\n     */\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return 'MultiPolygon';\n    }\n\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n  }, {\n    key: \"intersectsExtent\",\n    value: function intersectsExtent(extent) {\n      return intersectsLinearRingMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);\n    }\n\n    /**\n     * Set the coordinates of the multipolygon.\n     * @param {!Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} coordinates Coordinates.\n     * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n     * @api\n     */\n  }, {\n    key: \"setCoordinates\",\n    value: function setCoordinates(coordinates, layout) {\n      this.setLayout(layout, coordinates, 3);\n      if (!this.flatCoordinates) {\n        this.flatCoordinates = [];\n      }\n      var endss = deflateMultiCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);\n      if (endss.length === 0) {\n        this.flatCoordinates.length = 0;\n      } else {\n        var lastEnds = endss[endss.length - 1];\n        this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];\n      }\n      this.changed();\n    }\n  }]);\n}(SimpleGeometry);\nexport default MultiPolygon;","map":{"version":3,"names":["MultiPoint","Polygon","SimpleGeometry","assignClosestMultiArrayPoint","multiArrayMaxSquaredDelta","closestSquaredDistanceXY","deflateMultiCoordinatesArray","extend","getInteriorPointsOfMultiArray","inflateMultiCoordinatesArray","intersectsLinearRingMultiArray","linearRingssAreOriented","orientLinearRingsArray","linearRingss","linearRingssArea","linearRingssCenter","linearRingssContainsXY","quantizeMultiArray","MultiPolygon","_SimpleGeometry","coordinates","layout","endss","_this","_classCallCheck","_callSuper","endss_","flatInteriorPointsRevision_","flatInteriorPoints_","maxDelta_","maxDeltaRevision_","orientedRevision_","orientedFlatCoordinates_","Array","isArray","polygons","flatCoordinates","thisEndss","i","ii","length","polygon","offset","ends","getEnds","j","jj","getFlatCoordinates","push","getLayout","undefined","setFlatCoordinates","setCoordinates","_inherits","_createClass","key","value","appendPolygon","slice","changed","clone","len","newEndss","multiPolygon","applyProperties","closestPointXY","x","y","closestPoint","minSquaredDistance","getExtent","getRevision","Math","sqrt","stride","getOrientedFlatCoordinates","containsXY","getArea","getCoordinates","right","getEndss","getFlatInteriorPoints","flatCenters","getInteriorPoints","getSimplifiedGeometryInternal","squaredTolerance","simplifiedFlatCoordinates","simplifiedEndss","getPolygon","index","prevEnds","end","getPolygons","getType","intersectsExtent","extent","setLayout","lastEnds"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol/geom/MultiPolygon.js"],"sourcesContent":["/**\n * @module ol/geom/MultiPolygon\n */\nimport MultiPoint from './MultiPoint.js';\nimport Polygon from './Polygon.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {\n  assignClosestMultiArrayPoint,\n  multiArrayMaxSquaredDelta,\n} from './flat/closest.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport {deflateMultiCoordinatesArray} from './flat/deflate.js';\nimport {extend} from '../array.js';\nimport {getInteriorPointsOfMultiArray} from './flat/interiorpoint.js';\nimport {inflateMultiCoordinatesArray} from './flat/inflate.js';\nimport {intersectsLinearRingMultiArray} from './flat/intersectsextent.js';\nimport {\n  linearRingssAreOriented,\n  orientLinearRingsArray,\n} from './flat/orient.js';\nimport {linearRingss as linearRingssArea} from './flat/area.js';\nimport {linearRingss as linearRingssCenter} from './flat/center.js';\nimport {linearRingssContainsXY} from './flat/contains.js';\nimport {quantizeMultiArray} from './flat/simplify.js';\n\n/**\n * @classdesc\n * Multi-polygon geometry.\n *\n * @api\n */\nclass MultiPolygon extends SimpleGeometry {\n  /**\n   * @param {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.\n   *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.\n   */\n  constructor(coordinates, layout, endss) {\n    super();\n\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n    this.endss_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatInteriorPointsRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>|null}\n     */\n    this.flatInteriorPoints_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.orientedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>|null}\n     */\n    this.orientedFlatCoordinates_ = null;\n\n    if (!endss && !Array.isArray(coordinates[0])) {\n      const polygons = /** @type {Array<Polygon>} */ (coordinates);\n      /** @type {Array<number>} */\n      const flatCoordinates = [];\n      const thisEndss = [];\n      for (let i = 0, ii = polygons.length; i < ii; ++i) {\n        const polygon = polygons[i];\n        const offset = flatCoordinates.length;\n        const ends = polygon.getEnds();\n        for (let j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] += offset;\n        }\n        extend(flatCoordinates, polygon.getFlatCoordinates());\n        thisEndss.push(ends);\n      }\n      layout =\n        polygons.length === 0 ? this.getLayout() : polygons[0].getLayout();\n      coordinates = flatCoordinates;\n      endss = thisEndss;\n    }\n    if (layout !== undefined && endss) {\n      this.setFlatCoordinates(\n        layout,\n        /** @type {Array<number>} */ (coordinates)\n      );\n      this.endss_ = endss;\n    } else {\n      this.setCoordinates(\n        /** @type {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} */ (\n          coordinates\n        ),\n        layout\n      );\n    }\n  }\n\n  /**\n   * Append the passed polygon to this multipolygon.\n   * @param {Polygon} polygon Polygon.\n   * @api\n   */\n  appendPolygon(polygon) {\n    /** @type {Array<number>} */\n    let ends;\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = polygon.getFlatCoordinates().slice();\n      ends = polygon.getEnds().slice();\n      this.endss_.push();\n    } else {\n      const offset = this.flatCoordinates.length;\n      extend(this.flatCoordinates, polygon.getFlatCoordinates());\n      ends = polygon.getEnds().slice();\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] += offset;\n      }\n    }\n    this.endss_.push(ends);\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiPolygon} Clone.\n   * @api\n   */\n  clone() {\n    const len = this.endss_.length;\n    const newEndss = new Array(len);\n    for (let i = 0; i < len; ++i) {\n      newEndss[i] = this.endss_[i].slice();\n    }\n\n    const multiPolygon = new MultiPolygon(\n      this.flatCoordinates.slice(),\n      this.layout,\n      newEndss\n    );\n    multiPolygon.applyProperties(this);\n\n    return multiPolygon;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(\n        multiArrayMaxSquaredDelta(\n          this.flatCoordinates,\n          0,\n          this.endss_,\n          this.stride,\n          0\n        )\n      );\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestMultiArrayPoint(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.endss_,\n      this.stride,\n      this.maxDelta_,\n      true,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance\n    );\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  containsXY(x, y) {\n    return linearRingssContainsXY(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.endss_,\n      this.stride,\n      x,\n      y\n    );\n  }\n\n  /**\n   * Return the area of the multipolygon on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  getArea() {\n    return linearRingssArea(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.endss_,\n      this.stride\n    );\n  }\n\n  /**\n   * Get the coordinate array for this geometry.  This array has the structure\n   * of a GeoJSON coordinate array for multi-polygons.\n   *\n   * @param {boolean} [right] Orient coordinates according to the right-hand\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\n   *     If `false`, coordinates will be oriented according to the left-hand rule\n   *     (clockwise for exterior and counter-clockwise for interior rings).\n   *     By default, coordinate orientation will depend on how the geometry was\n   *     constructed.\n   * @return {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} Coordinates.\n   * @api\n   */\n  getCoordinates(right) {\n    let flatCoordinates;\n    if (right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      orientLinearRingsArray(\n        flatCoordinates,\n        0,\n        this.endss_,\n        this.stride,\n        right\n      );\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n\n    return inflateMultiCoordinatesArray(\n      flatCoordinates,\n      0,\n      this.endss_,\n      this.stride\n    );\n  }\n\n  /**\n   * @return {Array<Array<number>>} Endss.\n   */\n  getEndss() {\n    return this.endss_;\n  }\n\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  getFlatInteriorPoints() {\n    if (this.flatInteriorPointsRevision_ != this.getRevision()) {\n      const flatCenters = linearRingssCenter(\n        this.flatCoordinates,\n        0,\n        this.endss_,\n        this.stride\n      );\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(\n        this.getOrientedFlatCoordinates(),\n        0,\n        this.endss_,\n        this.stride,\n        flatCenters\n      );\n      this.flatInteriorPointsRevision_ = this.getRevision();\n    }\n    return /** @type {Array<number>} */ (this.flatInteriorPoints_);\n  }\n\n  /**\n   * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.\n   * @return {MultiPoint} Interior points as XYM coordinates, where M is\n   * the length of the horizontal intersection that the point belongs to.\n   * @api\n   */\n  getInteriorPoints() {\n    return new MultiPoint(this.getFlatInteriorPoints().slice(), 'XYM');\n  }\n\n  /**\n   * @return {Array<number>} Oriented flat coordinates.\n   */\n  getOrientedFlatCoordinates() {\n    if (this.orientedRevision_ != this.getRevision()) {\n      const flatCoordinates = this.flatCoordinates;\n      if (\n        linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)\n      ) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length = orientLinearRingsArray(\n          this.orientedFlatCoordinates_,\n          0,\n          this.endss_,\n          this.stride\n        );\n      }\n      this.orientedRevision_ = this.getRevision();\n    }\n    return /** @type {Array<number>} */ (this.orientedFlatCoordinates_);\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {MultiPolygon} Simplified MultiPolygon.\n   * @protected\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    /** @type {Array<number>} */\n    const simplifiedFlatCoordinates = [];\n    /** @type {Array<Array<number>>} */\n    const simplifiedEndss = [];\n    simplifiedFlatCoordinates.length = quantizeMultiArray(\n      this.flatCoordinates,\n      0,\n      this.endss_,\n      this.stride,\n      Math.sqrt(squaredTolerance),\n      simplifiedFlatCoordinates,\n      0,\n      simplifiedEndss\n    );\n    return new MultiPolygon(simplifiedFlatCoordinates, 'XY', simplifiedEndss);\n  }\n\n  /**\n   * Return the polygon at the specified index.\n   * @param {number} index Index.\n   * @return {Polygon} Polygon.\n   * @api\n   */\n  getPolygon(index) {\n    if (index < 0 || this.endss_.length <= index) {\n      return null;\n    }\n    let offset;\n    if (index === 0) {\n      offset = 0;\n    } else {\n      const prevEnds = this.endss_[index - 1];\n      offset = prevEnds[prevEnds.length - 1];\n    }\n    const ends = this.endss_[index].slice();\n    const end = ends[ends.length - 1];\n    if (offset !== 0) {\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] -= offset;\n      }\n    }\n    return new Polygon(\n      this.flatCoordinates.slice(offset, end),\n      this.layout,\n      ends\n    );\n  }\n\n  /**\n   * Return the polygons of this multipolygon.\n   * @return {Array<Polygon>} Polygons.\n   * @api\n   */\n  getPolygons() {\n    const layout = this.layout;\n    const flatCoordinates = this.flatCoordinates;\n    const endss = this.endss_;\n    const polygons = [];\n    let offset = 0;\n    for (let i = 0, ii = endss.length; i < ii; ++i) {\n      const ends = endss[i].slice();\n      const end = ends[ends.length - 1];\n      if (offset !== 0) {\n        for (let j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] -= offset;\n        }\n      }\n      const polygon = new Polygon(\n        flatCoordinates.slice(offset, end),\n        layout,\n        ends\n      );\n      polygons.push(polygon);\n      offset = end;\n    }\n    return polygons;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'MultiPolygon';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    return intersectsLinearRingMultiArray(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.endss_,\n      this.stride,\n      extent\n    );\n  }\n\n  /**\n   * Set the coordinates of the multipolygon.\n   * @param {!Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 3);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    const endss = deflateMultiCoordinatesArray(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride,\n      this.endss_\n    );\n    if (endss.length === 0) {\n      this.flatCoordinates.length = 0;\n    } else {\n      const lastEnds = endss[endss.length - 1];\n      this.flatCoordinates.length =\n        lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];\n    }\n    this.changed();\n  }\n}\n\nexport default MultiPolygon;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}