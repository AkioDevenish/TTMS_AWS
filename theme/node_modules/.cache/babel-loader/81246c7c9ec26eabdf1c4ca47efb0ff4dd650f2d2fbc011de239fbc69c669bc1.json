{"ast":null,"code":"import _classCallCheck from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _callSuper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _superPropGet from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/superPropGet.js\";\nimport _inherits from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reverse.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.unshift.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\n/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ImageTile from '../../ImageTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport { apply as applyTransform, compose as composeTransform, makeInverse, toString as toTransformString } from '../../transform.js';\nimport { ascending } from '../../array.js';\nimport { containsCoordinate, createEmpty, equals, getHeight, getIntersection, getRotatedViewport, getTopLeft, getWidth, intersects } from '../../extent.js';\nimport { fromUserExtent } from '../../proj.js';\nimport { getUid } from '../../util.js';\nimport { toSize } from '../../size.js';\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nvar CanvasTileLayerRenderer = /*#__PURE__*/function (_CanvasLayerRenderer) {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   */\n  function CanvasTileLayerRenderer(tileLayer) {\n    var _this;\n    _classCallCheck(this, CanvasTileLayerRenderer);\n    _this = _callSuper(this, CanvasTileLayerRenderer, [tileLayer]);\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    _this.extentChanged = true;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    _this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    _this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    _this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    _this.renderedRevision;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    _this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.newTiles_ = false;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    _this.tmpExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    _this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n    return _this;\n  }\n\n  /**\n   * @protected\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  _inherits(CanvasTileLayerRenderer, _CanvasLayerRenderer);\n  return _createClass(CanvasTileLayerRenderer, [{\n    key: \"isDrawableTile\",\n    value: function isDrawableTile(tile) {\n      var tileLayer = this.getLayer();\n      var tileState = tile.getState();\n      var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n      return tileState == TileState.LOADED || tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError;\n    }\n\n    /**\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     * @return {!import(\"../../Tile.js\").default} Tile.\n     */\n  }, {\n    key: \"getTile\",\n    value: function getTile(z, x, y, frameState) {\n      var pixelRatio = frameState.pixelRatio;\n      var projection = frameState.viewState.projection;\n      var tileLayer = this.getLayer();\n      var tileSource = tileLayer.getSource();\n      var tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n      if (tile.getState() == TileState.ERROR) {\n        if (tileLayer.getUseInterimTilesOnError() && tileLayer.getPreload() > 0) {\n          // Preloaded tiles for lower resolutions might have finished loading.\n          this.newTiles_ = true;\n        }\n      }\n      if (!this.isDrawableTile(tile)) {\n        tile = tile.getInterimTile();\n      }\n      return tile;\n    }\n\n    /**\n     * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n     * @return {Uint8ClampedArray} Data at the pixel location.\n     */\n  }, {\n    key: \"getData\",\n    value: function getData(pixel) {\n      var frameState = this.frameState;\n      if (!frameState) {\n        return null;\n      }\n      var layer = this.getLayer();\n      var coordinate = applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n      var layerExtent = layer.getExtent();\n      if (layerExtent) {\n        if (!containsCoordinate(layerExtent, coordinate)) {\n          return null;\n        }\n      }\n      var pixelRatio = frameState.pixelRatio;\n      var projection = frameState.viewState.projection;\n      var viewState = frameState.viewState;\n      var source = layer.getRenderSource();\n      var tileGrid = source.getTileGridForProjection(viewState.projection);\n      var tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n      for (var z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {\n        var tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n        var tile = source.getTile(z, tileCoord[1], tileCoord[2], pixelRatio, projection);\n        if (!(tile instanceof ImageTile || tile instanceof ReprojTile) || tile instanceof ReprojTile && tile.getState() === TileState.EMPTY) {\n          return null;\n        }\n        if (tile.getState() !== TileState.LOADED) {\n          continue;\n        }\n        var tileOrigin = tileGrid.getOrigin(z);\n        var tileSize = toSize(tileGrid.getTileSize(z));\n        var tileResolution = tileGrid.getResolution(z);\n        var col = Math.floor(tilePixelRatio * ((coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0]));\n        var row = Math.floor(tilePixelRatio * ((tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1]));\n        var gutter = Math.round(tilePixelRatio * source.getGutterForProjection(viewState.projection));\n        return this.getImageData(tile.getImage(), col + gutter, row + gutter);\n      }\n      return null;\n    }\n\n    /**\n     * @param {Object<number, Object<string, import(\"../../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n     * @param {number} zoom Zoom level.\n     * @param {import(\"../../Tile.js\").default} tile Tile.\n     * @return {boolean|void} If `false`, the tile will not be considered loaded.\n     */\n  }, {\n    key: \"loadedTileCallback\",\n    value: function loadedTileCallback(tiles, zoom, tile) {\n      if (this.isDrawableTile(tile)) {\n        return _superPropGet(CanvasTileLayerRenderer, \"loadedTileCallback\", this, 3)([tiles, zoom, tile]);\n      }\n      return false;\n    }\n\n    /**\n     * Determine whether render should be called.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     */\n  }, {\n    key: \"prepareFrame\",\n    value: function prepareFrame(frameState) {\n      return !!this.getLayer().getSource();\n    }\n\n    /**\n     * Render the layer.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     * @param {HTMLElement} target Target that may be used to render content to.\n     * @return {HTMLElement} The rendered element.\n     */\n  }, {\n    key: \"renderFrame\",\n    value: function renderFrame(frameState, target) {\n      var layerState = frameState.layerStatesArray[frameState.layerIndex];\n      var viewState = frameState.viewState;\n      var projection = viewState.projection;\n      var viewResolution = viewState.resolution;\n      var viewCenter = viewState.center;\n      var rotation = viewState.rotation;\n      var pixelRatio = frameState.pixelRatio;\n      var tileLayer = this.getLayer();\n      var tileSource = tileLayer.getSource();\n      var sourceRevision = tileSource.getRevision();\n      var tileGrid = tileSource.getTileGridForProjection(projection);\n      var z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n      var tileResolution = tileGrid.getResolution(z);\n      var extent = frameState.extent;\n      var resolution = frameState.viewState.resolution;\n      var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n      // desired dimensions of the canvas in pixels\n      var width = Math.round(getWidth(extent) / resolution * pixelRatio);\n      var height = Math.round(getHeight(extent) / resolution * pixelRatio);\n      var layerExtent = layerState.extent && fromUserExtent(layerState.extent, projection);\n      if (layerExtent) {\n        extent = getIntersection(extent, fromUserExtent(layerState.extent, projection));\n      }\n      var dx = tileResolution * width / 2 / tilePixelRatio;\n      var dy = tileResolution * height / 2 / tilePixelRatio;\n      var canvasExtent = [viewCenter[0] - dx, viewCenter[1] - dy, viewCenter[0] + dx, viewCenter[1] + dy];\n      var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n\n      /**\n       * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n       */\n      var tilesToDrawByZ = {};\n      tilesToDrawByZ[z] = {};\n      var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);\n      var tmpExtent = this.tmpExtent;\n      var tmpTileRange = this.tmpTileRange_;\n      this.newTiles_ = false;\n      var viewport = rotation ? getRotatedViewport(viewState.center, resolution, rotation, frameState.size) : undefined;\n      for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (rotation && !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {\n            continue;\n          }\n          var tile = this.getTile(z, x, y, frameState);\n          if (this.isDrawableTile(tile)) {\n            var uid = getUid(this);\n            if (tile.getState() == TileState.LOADED) {\n              tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n              var inTransition = tile.inTransition(uid);\n              if (inTransition && layerState.opacity !== 1) {\n                // Skipping transition when layer is not fully opaque avoids visual artifacts.\n                tile.endTransition(uid);\n                inTransition = false;\n              }\n              if (!this.newTiles_ && (inTransition || !this.renderedTiles.includes(tile))) {\n                this.newTiles_ = true;\n              }\n            }\n            if (tile.getAlpha(uid, frameState.time) === 1) {\n              // don't look for alt tiles if alpha is 1\n              continue;\n            }\n          }\n          var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);\n          var covered = false;\n          if (childTileRange) {\n            covered = findLoadedTiles(z + 1, childTileRange);\n          }\n          if (!covered) {\n            tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, tmpTileRange, tmpExtent);\n          }\n        }\n      }\n      var canvasScale = tileResolution / viewResolution * pixelRatio / tilePixelRatio;\n\n      // set forward and inverse pixel transforms\n      composeTransform(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);\n      var canvasTransform = toTransformString(this.pixelTransform);\n      this.useContainer(target, canvasTransform, this.getBackground(frameState));\n      var context = this.context;\n      var canvas = context.canvas;\n      makeInverse(this.inversePixelTransform, this.pixelTransform);\n\n      // set scale transform for calculating tile positions on the canvas\n      composeTransform(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);\n      if (canvas.width != width || canvas.height != height) {\n        canvas.width = width;\n        canvas.height = height;\n      } else if (!this.containerReused) {\n        context.clearRect(0, 0, width, height);\n      }\n      if (layerExtent) {\n        this.clipUnrotated(context, frameState, layerExtent);\n      }\n      if (!tileSource.getInterpolate()) {\n        context.imageSmoothingEnabled = false;\n      }\n      this.preRender(context, frameState);\n      this.renderedTiles.length = 0;\n      /** @type {Array<number>} */\n      var zs = Object.keys(tilesToDrawByZ).map(Number);\n      zs.sort(ascending);\n      var clips, clipZs, currentClip;\n      if (layerState.opacity === 1 && (!this.containerReused || tileSource.getOpaque(frameState.viewState.projection))) {\n        zs = zs.reverse();\n      } else {\n        clips = [];\n        clipZs = [];\n      }\n      for (var i = zs.length - 1; i >= 0; --i) {\n        var currentZ = zs[i];\n        var currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\n        var currentResolution = tileGrid.getResolution(currentZ);\n        var currentScale = currentResolution / tileResolution;\n        var _dx = currentTilePixelSize[0] * currentScale * canvasScale;\n        var _dy = currentTilePixelSize[1] * currentScale * canvasScale;\n        var originTileCoord = tileGrid.getTileCoordForCoordAndZ(getTopLeft(canvasExtent), currentZ);\n        var originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n        var origin = applyTransform(this.tempTransform, [tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution, tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution]);\n        var tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);\n        var tilesToDraw = tilesToDrawByZ[currentZ];\n        for (var tileCoordKey in tilesToDraw) {\n          var _tile = /** @type {import(\"../../ImageTile.js\").default} */\n          tilesToDraw[tileCoordKey];\n          var tileCoord = _tile.tileCoord;\n\n          // Calculate integer positions and sizes so that tiles align\n          var xIndex = originTileCoord[1] - tileCoord[1];\n          var nextX = Math.round(origin[0] - (xIndex - 1) * _dx);\n          var yIndex = originTileCoord[2] - tileCoord[2];\n          var nextY = Math.round(origin[1] - (yIndex - 1) * _dy);\n          var _x = Math.round(origin[0] - xIndex * _dx);\n          var _y = Math.round(origin[1] - yIndex * _dy);\n          var w = nextX - _x;\n          var h = nextY - _y;\n          var transition = z === currentZ;\n          var _inTransition = transition && _tile.getAlpha(getUid(this), frameState.time) !== 1;\n          var contextSaved = false;\n          if (!_inTransition) {\n            if (clips) {\n              // Clip mask for regions in this tile that already filled by a higher z tile\n              currentClip = [_x, _y, _x + w, _y, _x + w, _y + h, _x, _y + h];\n              for (var _i = 0, ii = clips.length; _i < ii; ++_i) {\n                if (z !== currentZ && currentZ < clipZs[_i]) {\n                  var clip = clips[_i];\n                  if (intersects([_x, _y, _x + w, _y + h], [clip[0], clip[3], clip[4], clip[7]])) {\n                    if (!contextSaved) {\n                      context.save();\n                      contextSaved = true;\n                    }\n                    context.beginPath();\n                    // counter-clockwise (outer ring) for current tile\n                    context.moveTo(currentClip[0], currentClip[1]);\n                    context.lineTo(currentClip[2], currentClip[3]);\n                    context.lineTo(currentClip[4], currentClip[5]);\n                    context.lineTo(currentClip[6], currentClip[7]);\n                    // clockwise (inner ring) for higher z tile\n                    context.moveTo(clip[6], clip[7]);\n                    context.lineTo(clip[4], clip[5]);\n                    context.lineTo(clip[2], clip[3]);\n                    context.lineTo(clip[0], clip[1]);\n                    context.clip();\n                  }\n                }\n              }\n              clips.push(currentClip);\n              clipZs.push(currentZ);\n            } else {\n              context.clearRect(_x, _y, w, h);\n            }\n          }\n          this.drawTileImage(_tile, frameState, _x, _y, w, h, tileGutter, transition);\n          if (clips && !_inTransition) {\n            if (contextSaved) {\n              context.restore();\n            }\n            this.renderedTiles.unshift(_tile);\n          } else {\n            this.renderedTiles.push(_tile);\n          }\n          this.updateUsedTiles(frameState.usedTiles, tileSource, _tile);\n        }\n      }\n      this.renderedRevision = sourceRevision;\n      this.renderedResolution = tileResolution;\n      this.extentChanged = !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n      this.renderedExtent_ = canvasExtent;\n      this.renderedPixelRatio = pixelRatio;\n      this.renderedProjection = projection;\n      this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());\n      this.scheduleExpireCache(frameState, tileSource);\n      this.postRender(context, frameState);\n      if (layerState.extent) {\n        context.restore();\n      }\n      context.imageSmoothingEnabled = true;\n      if (canvasTransform !== canvas.style.transform) {\n        canvas.style.transform = canvasTransform;\n      }\n      return this.container;\n    }\n\n    /**\n     * @param {import(\"../../ImageTile.js\").default} tile Tile.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     * @param {number} x Left of the tile.\n     * @param {number} y Top of the tile.\n     * @param {number} w Width of the tile.\n     * @param {number} h Height of the tile.\n     * @param {number} gutter Tile gutter.\n     * @param {boolean} transition Apply an alpha transition.\n     */\n  }, {\n    key: \"drawTileImage\",\n    value: function drawTileImage(tile, frameState, x, y, w, h, gutter, transition) {\n      var image = this.getTileImage(tile);\n      if (!image) {\n        return;\n      }\n      var uid = getUid(this);\n      var layerState = frameState.layerStatesArray[frameState.layerIndex];\n      var alpha = layerState.opacity * (transition ? tile.getAlpha(uid, frameState.time) : 1);\n      var alphaChanged = alpha !== this.context.globalAlpha;\n      if (alphaChanged) {\n        this.context.save();\n        this.context.globalAlpha = alpha;\n      }\n      this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);\n      if (alphaChanged) {\n        this.context.restore();\n      }\n      if (alpha !== layerState.opacity) {\n        frameState.animate = true;\n      } else if (transition) {\n        tile.endTransition(uid);\n      }\n    }\n\n    /**\n     * @return {HTMLCanvasElement} Image\n     */\n  }, {\n    key: \"getImage\",\n    value: function getImage() {\n      var context = this.context;\n      return context ? context.canvas : null;\n    }\n\n    /**\n     * Get the image from a tile.\n     * @param {import(\"../../ImageTile.js\").default} tile Tile.\n     * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n     * @protected\n     */\n  }, {\n    key: \"getTileImage\",\n    value: function getTileImage(tile) {\n      return tile.getImage();\n    }\n\n    /**\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n     * @protected\n     */\n  }, {\n    key: \"scheduleExpireCache\",\n    value: function scheduleExpireCache(frameState, tileSource) {\n      if (tileSource.canExpireCache()) {\n        /**\n         * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n         * @param {import(\"../../Map.js\").default} map Map.\n         * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n         */\n        var postRenderFunction = function (tileSource, map, frameState) {\n          var tileSourceKey = getUid(tileSource);\n          if (tileSourceKey in frameState.usedTiles) {\n            tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);\n          }\n        }.bind(null, tileSource);\n        frameState.postRenderFunctions.push(/** @type {import(\"../../Map.js\").PostRenderFunction} */\n        postRenderFunction);\n      }\n    }\n\n    /**\n     * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n     * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n     * @param {import('../../Tile.js').default} tile Tile.\n     * @protected\n     */\n  }, {\n    key: \"updateUsedTiles\",\n    value: function updateUsedTiles(usedTiles, tileSource, tile) {\n      // FIXME should we use tilesToDrawByZ instead?\n      var tileSourceKey = getUid(tileSource);\n      if (!(tileSourceKey in usedTiles)) {\n        usedTiles[tileSourceKey] = {};\n      }\n      usedTiles[tileSourceKey][tile.getKey()] = true;\n    }\n\n    /**\n     * Manage tile pyramid.\n     * This function performs a number of functions related to the tiles at the\n     * current zoom and lower zoom levels:\n     * - registers idle tiles in frameState.wantedTiles so that they are not\n     *   discarded by the tile queue\n     * - enqueues missing tiles\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n     * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n     * @param {import(\"../../extent.js\").Extent} extent Extent.\n     * @param {number} currentZ Current Z.\n     * @param {number} preload Load low resolution tiles up to `preload` levels.\n     * @param {function(import(\"../../Tile.js\").default):void} [tileCallback] Tile callback.\n     * @protected\n     */\n  }, {\n    key: \"manageTilePyramid\",\n    value: function manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, tileCallback) {\n      var tileSourceKey = getUid(tileSource);\n      if (!(tileSourceKey in frameState.wantedTiles)) {\n        frameState.wantedTiles[tileSourceKey] = {};\n      }\n      var wantedTiles = frameState.wantedTiles[tileSourceKey];\n      var tileQueue = frameState.tileQueue;\n      var minZoom = tileGrid.getMinZoom();\n      var rotation = frameState.viewState.rotation;\n      var viewport = rotation ? getRotatedViewport(frameState.viewState.center, frameState.viewState.resolution, rotation, frameState.size) : undefined;\n      var tileCount = 0;\n      var tile, tileRange, tileResolution, x, y, z;\n      for (z = minZoom; z <= currentZ; ++z) {\n        tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n        tileResolution = tileGrid.getResolution(z);\n        for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n          for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n            if (rotation && !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {\n              continue;\n            }\n            if (currentZ - z <= preload) {\n              ++tileCount;\n              tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n              if (tile.getState() == TileState.IDLE) {\n                wantedTiles[tile.getKey()] = true;\n                if (!tileQueue.isKeyQueued(tile.getKey())) {\n                  tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);\n                }\n              }\n              if (tileCallback !== undefined) {\n                tileCallback(tile);\n              }\n            } else {\n              tileSource.useTile(z, x, y, projection);\n            }\n          }\n        }\n      }\n      tileSource.updateCacheSize(tileCount, projection);\n    }\n  }]);\n}(CanvasLayerRenderer);\nexport default CanvasTileLayerRenderer;","map":{"version":3,"names":["CanvasLayerRenderer","ImageTile","ReprojTile","TileRange","TileState","apply","applyTransform","compose","composeTransform","makeInverse","toString","toTransformString","ascending","containsCoordinate","createEmpty","equals","getHeight","getIntersection","getRotatedViewport","getTopLeft","getWidth","intersects","fromUserExtent","getUid","toSize","CanvasTileLayerRenderer","_CanvasLayerRenderer","tileLayer","_this","_classCallCheck","_callSuper","extentChanged","renderedExtent_","renderedPixelRatio","renderedProjection","renderedRevision","renderedTiles","newTiles_","tmpExtent","tmpTileRange_","_inherits","_createClass","key","value","isDrawableTile","tile","getLayer","tileState","getState","useInterimTilesOnError","getUseInterimTilesOnError","LOADED","EMPTY","ERROR","getTile","z","x","y","frameState","pixelRatio","projection","viewState","tileSource","getSource","getPreload","getInterimTile","getData","pixel","layer","coordinate","pixelToCoordinateTransform","slice","layerExtent","getExtent","source","getRenderSource","tileGrid","getTileGridForProjection","tilePixelRatio","getTilePixelRatio","getZForResolution","resolution","getMinZoom","tileCoord","getTileCoordForCoordAndZ","tileOrigin","getOrigin","tileSize","getTileSize","tileResolution","getResolution","col","Math","floor","row","gutter","round","getGutterForProjection","getImageData","getImage","loadedTileCallback","tiles","zoom","_superPropGet","prepareFrame","renderFrame","target","layerState","layerStatesArray","layerIndex","viewResolution","viewCenter","center","rotation","sourceRevision","getRevision","zDirection","extent","width","height","dx","dy","canvasExtent","tileRange","getTileRangeForExtentAndZ","tilesToDrawByZ","findLoadedTiles","createLoadedTileFinder","tmpTileRange","viewport","size","undefined","minX","maxX","minY","maxY","tileCoordIntersectsViewport","uid","inTransition","opacity","endTransition","includes","getAlpha","time","childTileRange","getTileCoordChildTileRange","covered","forEachTileCoordParentTileRange","canvasScale","pixelTransform","canvasTransform","useContainer","getBackground","context","canvas","inversePixelTransform","tempTransform","containerReused","clearRect","clipUnrotated","getInterpolate","imageSmoothingEnabled","preRender","length","zs","Object","keys","map","Number","sort","clips","clipZs","currentClip","getOpaque","reverse","i","currentZ","currentTilePixelSize","getTilePixelSize","currentResolution","currentScale","originTileCoord","originTileExtent","getTileCoordExtent","origin","tileGutter","tilesToDraw","tileCoordKey","xIndex","nextX","yIndex","nextY","w","h","transition","contextSaved","ii","clip","save","beginPath","moveTo","lineTo","push","drawTileImage","restore","unshift","updateUsedTiles","usedTiles","renderedResolution","manageTilePyramid","scheduleExpireCache","postRender","style","transform","container","image","getTileImage","alpha","alphaChanged","globalAlpha","drawImage","animate","canExpireCache","postRenderFunction","tileSourceKey","expireCache","bind","postRenderFunctions","getKey","preload","tileCallback","wantedTiles","tileQueue","minZoom","tileCount","IDLE","isKeyQueued","enqueue","getTileCoordCenter","useTile","updateCacheSize"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol/renderer/canvas/TileLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ImageTile from '../../ImageTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  makeInverse,\n  toString as toTransformString,\n} from '../../transform.js';\nimport {ascending} from '../../array.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  equals,\n  getHeight,\n  getIntersection,\n  getRotatedViewport,\n  getTopLeft,\n  getWidth,\n  intersects,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {getUid} from '../../util.js';\nimport {toSize} from '../../size.js';\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   */\n  constructor(tileLayer) {\n    super(tileLayer);\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedRevision;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.newTiles_ = false;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tmpExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n  }\n\n  /**\n   * @protected\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  isDrawableTile(tile) {\n    const tileLayer = this.getLayer();\n    const tileState = tile.getState();\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return (\n      tileState == TileState.LOADED ||\n      tileState == TileState.EMPTY ||\n      (tileState == TileState.ERROR && !useInterimTilesOnError)\n    );\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const projection = frameState.viewState.projection;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    let tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n    if (tile.getState() == TileState.ERROR) {\n      if (tileLayer.getUseInterimTilesOnError() && tileLayer.getPreload() > 0) {\n        // Preloaded tiles for lower resolutions might have finished loading.\n        this.newTiles_ = true;\n      }\n    }\n    if (!this.isDrawableTile(tile)) {\n      tile = tile.getInterimTile();\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice()\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const pixelRatio = frameState.pixelRatio;\n    const projection = frameState.viewState.projection;\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = source.getTile(\n        z,\n        tileCoord[1],\n        tileCoord[2],\n        pixelRatio,\n        projection\n      );\n      if (\n        !(tile instanceof ImageTile || tile instanceof ReprojTile) ||\n        (tile instanceof ReprojTile && tile.getState() === TileState.EMPTY)\n      ) {\n        return null;\n      }\n\n      if (tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      const col = Math.floor(\n        tilePixelRatio *\n          ((coordinate[0] - tileOrigin[0]) / tileResolution -\n            tileCoord[1] * tileSize[0])\n      );\n\n      const row = Math.floor(\n        tilePixelRatio *\n          ((tileOrigin[1] - coordinate[1]) / tileResolution -\n            tileCoord[2] * tileSize[1])\n      );\n\n      const gutter = Math.round(\n        tilePixelRatio * source.getGutterForProjection(viewState.projection)\n      );\n\n      return this.getImageData(tile.getImage(), col + gutter, row + gutter);\n    }\n\n    return null;\n  }\n\n  /**\n   * @param {Object<number, Object<string, import(\"../../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n  loadedTileCallback(tiles, zoom, tile) {\n    if (this.isDrawableTile(tile)) {\n      return super.loadedTileCallback(tiles, zoom, tile);\n    }\n    return false;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    return !!this.getLayer().getSource();\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const rotation = viewState.rotation;\n    const pixelRatio = frameState.pixelRatio;\n\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const sourceRevision = tileSource.getRevision();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n\n    let extent = frameState.extent;\n    const resolution = frameState.viewState.resolution;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n    // desired dimensions of the canvas in pixels\n    const width = Math.round((getWidth(extent) / resolution) * pixelRatio);\n    const height = Math.round((getHeight(extent) / resolution) * pixelRatio);\n\n    const layerExtent =\n      layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      extent = getIntersection(\n        extent,\n        fromUserExtent(layerState.extent, projection)\n      );\n    }\n\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\n    const canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy,\n    ];\n\n    const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n\n    /**\n     * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n     */\n    const tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n\n    const findLoadedTiles = this.createLoadedTileFinder(\n      tileSource,\n      projection,\n      tilesToDrawByZ\n    );\n\n    const tmpExtent = this.tmpExtent;\n    const tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n    const viewport = rotation\n      ? getRotatedViewport(\n          viewState.center,\n          resolution,\n          rotation,\n          frameState.size\n        )\n      : undefined;\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        if (\n          rotation &&\n          !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n        ) {\n          continue;\n        }\n        const tile = this.getTile(z, x, y, frameState);\n        if (this.isDrawableTile(tile)) {\n          const uid = getUid(this);\n          if (tile.getState() == TileState.LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            let inTransition = tile.inTransition(uid);\n            if (inTransition && layerState.opacity !== 1) {\n              // Skipping transition when layer is not fully opaque avoids visual artifacts.\n              tile.endTransition(uid);\n              inTransition = false;\n            }\n            if (\n              !this.newTiles_ &&\n              (inTransition || !this.renderedTiles.includes(tile))\n            ) {\n              this.newTiles_ = true;\n            }\n          }\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don't look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n\n        const childTileRange = tileGrid.getTileCoordChildTileRange(\n          tile.tileCoord,\n          tmpTileRange,\n          tmpExtent\n        );\n\n        let covered = false;\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(\n            tile.tileCoord,\n            findLoadedTiles,\n            tmpTileRange,\n            tmpExtent\n          );\n        }\n      }\n    }\n\n    const canvasScale =\n      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\n\n    // set forward and inverse pixel transforms\n    composeTransform(\n      this.pixelTransform,\n      frameState.size[0] / 2,\n      frameState.size[1] / 2,\n      1 / pixelRatio,\n      1 / pixelRatio,\n      rotation,\n      -width / 2,\n      -height / 2\n    );\n\n    const canvasTransform = toTransformString(this.pixelTransform);\n\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\n    const context = this.context;\n    const canvas = context.canvas;\n\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      canvasScale,\n      canvasScale,\n      0,\n      -width / 2,\n      -height / 2\n    );\n\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n\n    if (layerExtent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n\n    this.renderedTiles.length = 0;\n    /** @type {Array<number>} */\n    let zs = Object.keys(tilesToDrawByZ).map(Number);\n    zs.sort(ascending);\n\n    let clips, clipZs, currentClip;\n    if (\n      layerState.opacity === 1 &&\n      (!this.containerReused ||\n        tileSource.getOpaque(frameState.viewState.projection))\n    ) {\n      zs = zs.reverse();\n    } else {\n      clips = [];\n      clipZs = [];\n    }\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(\n        currentZ,\n        pixelRatio,\n        projection\n      );\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\n        getTopLeft(canvasExtent),\n        currentZ\n      );\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n          tileResolution,\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n          tileResolution,\n      ]);\n      const tileGutter =\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\n      const tilesToDraw = tilesToDrawByZ[currentZ];\n      for (const tileCoordKey in tilesToDraw) {\n        const tile = /** @type {import(\"../../ImageTile.js\").default} */ (\n          tilesToDraw[tileCoordKey]\n        );\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = z === currentZ;\n\n        const inTransition =\n          transition && tile.getAlpha(getUid(this), frameState.time) !== 1;\n        let contextSaved = false;\n        if (!inTransition) {\n          if (clips) {\n            // Clip mask for regions in this tile that already filled by a higher z tile\n            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n            for (let i = 0, ii = clips.length; i < ii; ++i) {\n              if (z !== currentZ && currentZ < clipZs[i]) {\n                const clip = clips[i];\n                if (\n                  intersects(\n                    [x, y, x + w, y + h],\n                    [clip[0], clip[3], clip[4], clip[7]]\n                  )\n                ) {\n                  if (!contextSaved) {\n                    context.save();\n                    contextSaved = true;\n                  }\n                  context.beginPath();\n                  // counter-clockwise (outer ring) for current tile\n                  context.moveTo(currentClip[0], currentClip[1]);\n                  context.lineTo(currentClip[2], currentClip[3]);\n                  context.lineTo(currentClip[4], currentClip[5]);\n                  context.lineTo(currentClip[6], currentClip[7]);\n                  // clockwise (inner ring) for higher z tile\n                  context.moveTo(clip[6], clip[7]);\n                  context.lineTo(clip[4], clip[5]);\n                  context.lineTo(clip[2], clip[3]);\n                  context.lineTo(clip[0], clip[1]);\n                  context.clip();\n                }\n              }\n            }\n            clips.push(currentClip);\n            clipZs.push(currentZ);\n          } else {\n            context.clearRect(x, y, w, h);\n          }\n        }\n        this.drawTileImage(\n          tile,\n          frameState,\n          x,\n          y,\n          w,\n          h,\n          tileGutter,\n          transition\n        );\n        if (clips && !inTransition) {\n          if (contextSaved) {\n            context.restore();\n          }\n          this.renderedTiles.unshift(tile);\n        } else {\n          this.renderedTiles.push(tile);\n        }\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution;\n    this.extentChanged =\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n    this.renderedProjection = projection;\n\n    this.manageTilePyramid(\n      frameState,\n      tileSource,\n      tileGrid,\n      pixelRatio,\n      projection,\n      extent,\n      z,\n      tileLayer.getPreload()\n    );\n    this.scheduleExpireCache(frameState, tileSource);\n\n    this.postRender(context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    if (canvasTransform !== canvas.style.transform) {\n      canvas.style.transform = canvasTransform;\n    }\n\n    return this.container;\n  }\n\n  /**\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   */\n  drawTileImage(tile, frameState, x, y, w, h, gutter, transition) {\n    const image = this.getTileImage(tile);\n    if (!image) {\n      return;\n    }\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha =\n      layerState.opacity *\n      (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== this.context.globalAlpha;\n    if (alphaChanged) {\n      this.context.save();\n      this.context.globalAlpha = alpha;\n    }\n    this.context.drawImage(\n      image,\n      gutter,\n      gutter,\n      image.width - 2 * gutter,\n      image.height - 2 * gutter,\n      x,\n      y,\n      w,\n      h\n    );\n\n    if (alphaChanged) {\n      this.context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @protected\n   */\n  scheduleExpireCache(frameState, tileSource) {\n    if (tileSource.canExpireCache()) {\n      /**\n       * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n       * @param {import(\"../../Map.js\").default} map Map.\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = function (tileSource, map, frameState) {\n        const tileSourceKey = getUid(tileSource);\n        if (tileSourceKey in frameState.usedTiles) {\n          tileSource.expireCache(\n            frameState.viewState.projection,\n            frameState.usedTiles[tileSourceKey]\n          );\n        }\n      }.bind(null, tileSource);\n\n      frameState.postRenderFunctions.push(\n        /** @type {import(\"../../Map.js\").PostRenderFunction} */ (\n          postRenderFunction\n        )\n      );\n    }\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n\n  /**\n   * Manage tile pyramid.\n   * This function performs a number of functions related to the tiles at the\n   * current zoom and lower zoom levels:\n   * - registers idle tiles in frameState.wantedTiles so that they are not\n   *   discarded by the tile queue\n   * - enqueues missing tiles\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\n   * @param {number} currentZ Current Z.\n   * @param {number} preload Load low resolution tiles up to `preload` levels.\n   * @param {function(import(\"../../Tile.js\").default):void} [tileCallback] Tile callback.\n   * @protected\n   */\n  manageTilePyramid(\n    frameState,\n    tileSource,\n    tileGrid,\n    pixelRatio,\n    projection,\n    extent,\n    currentZ,\n    preload,\n    tileCallback\n  ) {\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const tileQueue = frameState.tileQueue;\n    const minZoom = tileGrid.getMinZoom();\n    const rotation = frameState.viewState.rotation;\n    const viewport = rotation\n      ? getRotatedViewport(\n          frameState.viewState.center,\n          frameState.viewState.resolution,\n          rotation,\n          frameState.size\n        )\n      : undefined;\n    let tileCount = 0;\n    let tile, tileRange, tileResolution, x, y, z;\n    for (z = minZoom; z <= currentZ; ++z) {\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n      tileResolution = tileGrid.getResolution(z);\n      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (\n            rotation &&\n            !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n          ) {\n            continue;\n          }\n          if (currentZ - z <= preload) {\n            ++tileCount;\n            tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n            if (tile.getState() == TileState.IDLE) {\n              wantedTiles[tile.getKey()] = true;\n              if (!tileQueue.isKeyQueued(tile.getKey())) {\n                tileQueue.enqueue([\n                  tile,\n                  tileSourceKey,\n                  tileGrid.getTileCoordCenter(tile.tileCoord),\n                  tileResolution,\n                ]);\n              }\n            }\n            if (tileCallback !== undefined) {\n              tileCallback(tile);\n            }\n          } else {\n            tileSource.useTile(z, x, y, projection);\n          }\n        }\n      }\n    }\n    tileSource.updateCacheSize(tileCount, projection);\n  }\n}\n\nexport default CanvasTileLayerRenderer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}