{"ast":null,"code":"import _classCallCheck from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _callSuper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _superPropGet from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/superPropGet.js\";\nimport _inherits from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.last-index-of.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.date.now.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.filter.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/esnext.iterator.reduce.js\";\nimport \"core-js/modules/esnext.iterator.some.js\";\n/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\nimport CanvasBuilderGroup from '../../render/canvas/BuilderGroup.js';\nimport CanvasExecutorGroup from '../../render/canvas/ExecutorGroup.js';\nimport CanvasTileLayerRenderer from './TileLayer.js';\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport { HIT_DETECT_RESOLUTION, createHitDetectionImageData, hitDetect } from '../../render/canvas/hitdetect.js';\nimport { apply as applyTransform, create as createTransform, multiply, reset as resetTransform, scale, scale as scaleTransform, translate as translateTransform } from '../../transform.js';\nimport { boundingExtent, buffer, containsExtent, equals, getIntersection, getTopLeft, intersects } from '../../extent.js';\nimport { getSquaredTolerance as getSquaredRenderTolerance, renderFeature as _renderFeature } from '../vector.js';\nimport { getUid } from '../../util.js';\nimport { toSize } from '../../size.js';\nimport { wrapX } from '../../coordinate.js';\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nvar IMAGE_REPLAYS = {\n  'image': ['Polygon', 'Circle', 'LineString', 'Image', 'Text'],\n  'hybrid': ['Polygon', 'LineString'],\n  'vector': []\n};\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nvar VECTOR_REPLAYS = {\n  'hybrid': ['Image', 'Text', 'Default'],\n  'vector': ['Polygon', 'Circle', 'LineString', 'Image', 'Text', 'Default']\n};\n\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n * @extends {CanvasTileLayerRenderer<import(\"../../layer/VectorTile.js\").default>}\n */\nvar CanvasVectorTileLayerRenderer = /*#__PURE__*/function (_CanvasTileLayerRende) {\n  /**\n   * @param {import(\"../../layer/VectorTile.js\").default} layer VectorTile layer.\n   */\n  function CanvasVectorTileLayerRenderer(layer) {\n    var _this;\n    _classCallCheck(this, CanvasVectorTileLayerRenderer);\n    _this = _callSuper(this, CanvasVectorTileLayerRenderer, [layer]);\n\n    /** @private */\n    _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(_this);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.renderedLayerRevision_;\n\n    /**\n     * @private\n     * @type {import(\"../../transform\").Transform}\n     */\n    _this.renderedPixelToCoordinateTransform_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.renderedRotation_;\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    _this.tmpTransform_ = createTransform();\n    return _this;\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection\").default} projection Projection.\n   * @return {boolean|undefined} Tile needs to be rendered.\n   */\n  _inherits(CanvasVectorTileLayerRenderer, _CanvasTileLayerRende);\n  return _createClass(CanvasVectorTileLayerRenderer, [{\n    key: \"prepareTile\",\n    value: function prepareTile(tile, pixelRatio, projection) {\n      var render;\n      var state = tile.getState();\n      if (state === TileState.LOADED || state === TileState.ERROR) {\n        this.updateExecutorGroup_(tile, pixelRatio, projection);\n        if (this.tileImageNeedsRender_(tile)) {\n          render = true;\n        }\n      }\n      return render;\n    }\n\n    /**\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     * @return {!import(\"../../Tile.js\").default} Tile.\n     */\n  }, {\n    key: \"getTile\",\n    value: function getTile(z, x, y, frameState) {\n      var pixelRatio = frameState.pixelRatio;\n      var viewState = frameState.viewState;\n      var resolution = viewState.resolution;\n      var projection = viewState.projection;\n      var layer = this.getLayer();\n      var tile = layer.getSource().getTile(z, x, y, pixelRatio, projection);\n      var viewHints = frameState.viewHints;\n      var hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n      if (hifi || !tile.wantedResolution) {\n        tile.wantedResolution = resolution;\n      }\n      var render = this.prepareTile(tile, pixelRatio, projection);\n      if (render && (hifi || Date.now() - frameState.time < 8) && layer.getRenderMode() !== 'vector') {\n        this.renderTileImage_(tile, frameState);\n      }\n      return _superPropGet(CanvasVectorTileLayerRenderer, \"getTile\", this, 3)([z, x, y, frameState]);\n    }\n\n    /**\n     * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n     * @return {boolean} Tile is drawable.\n     */\n  }, {\n    key: \"isDrawableTile\",\n    value: function isDrawableTile(tile) {\n      var layer = this.getLayer();\n      return _superPropGet(CanvasVectorTileLayerRenderer, \"isDrawableTile\", this, 3)([tile]) && (layer.getRenderMode() === 'vector' ? getUid(layer) in tile.executorGroups : tile.hasContext(layer));\n    }\n\n    /**\n     * @inheritDoc\n     */\n  }, {\n    key: \"getTileImage\",\n    value: function getTileImage(tile) {\n      return tile.getImage(this.getLayer());\n    }\n\n    /**\n     * Determine whether render should be called.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     */\n  }, {\n    key: \"prepareFrame\",\n    value: function prepareFrame(frameState) {\n      var layerRevision = this.getLayer().getRevision();\n      if (this.renderedLayerRevision_ !== layerRevision) {\n        this.renderedLayerRevision_ = layerRevision;\n        this.renderedTiles.length = 0;\n      }\n      return _superPropGet(CanvasVectorTileLayerRenderer, \"prepareFrame\", this, 3)([frameState]);\n    }\n\n    /**\n     * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n     * @private\n     */\n  }, {\n    key: \"updateExecutorGroup_\",\n    value: function updateExecutorGroup_(tile, pixelRatio, projection) {\n      var _this2 = this;\n      var layer = /** @type {import(\"../../layer/VectorTile.js\").default} */\n      this.getLayer();\n      var revision = layer.getRevision();\n      var renderOrder = layer.getRenderOrder() || null;\n      var resolution = tile.wantedResolution;\n      var builderState = tile.getReplayState(layer);\n      if (!builderState.dirty && builderState.renderedResolution === resolution && builderState.renderedRevision == revision && builderState.renderedRenderOrder == renderOrder) {\n        return;\n      }\n      var source = layer.getSource();\n      var declutter = layer.getDeclutter();\n      var sourceTileGrid = source.getTileGrid();\n      var tileGrid = source.getTileGridForProjection(projection);\n      var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      var sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);\n      var layerUid = getUid(layer);\n      delete tile.hitDetectionImageData[layerUid];\n      tile.executorGroups[layerUid] = [];\n      if (declutter) {\n        tile.declutterExecutorGroups[layerUid] = [];\n      }\n      builderState.dirty = false;\n      var _loop = function _loop() {\n        var sourceTile = sourceTiles[t];\n        if (sourceTile.getState() != TileState.LOADED) {\n          return 1; // continue\n        }\n        var sourceTileCoord = sourceTile.tileCoord;\n        var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n        var sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n        var builderExtent = buffer(sharedExtent, layer.getRenderBuffer() * resolution, _this2.tmpExtent);\n        var bufferedExtent = equals(sourceTileExtent, sharedExtent) ? null : builderExtent;\n        var builderGroup = new CanvasBuilderGroup(0, builderExtent, resolution, pixelRatio);\n        var declutterBuilderGroup = declutter ? new CanvasBuilderGroup(0, sharedExtent, resolution, pixelRatio) : undefined;\n        var squaredTolerance = getSquaredRenderTolerance(resolution, pixelRatio);\n\n        /**\n         * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n         * @this {CanvasVectorTileLayerRenderer}\n         */\n        var render = function render(feature) {\n          var styles;\n          var styleFunction = feature.getStyleFunction() || layer.getStyleFunction();\n          if (styleFunction) {\n            styles = styleFunction(feature, resolution);\n          }\n          if (styles) {\n            var dirty = this.renderFeature(feature, squaredTolerance, styles, builderGroup, declutterBuilderGroup);\n            builderState.dirty = builderState.dirty || dirty;\n          }\n        };\n        var features = sourceTile.getFeatures();\n        if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {\n          features.sort(renderOrder);\n        }\n        for (var i = 0, ii = features.length; i < ii; ++i) {\n          var feature = features[i];\n          if (!bufferedExtent || intersects(bufferedExtent, feature.getGeometry().getExtent())) {\n            render.call(_this2, feature);\n          }\n        }\n        var executorGroupInstructions = builderGroup.finish();\n        // no need to clip when the render tile is covered by a single source tile\n        var replayExtent = layer.getRenderMode() !== 'vector' && declutter && sourceTiles.length === 1 ? null : sharedExtent;\n        var renderingReplayGroup = new CanvasExecutorGroup(replayExtent, resolution, pixelRatio, source.getOverlaps(), executorGroupInstructions, layer.getRenderBuffer());\n        tile.executorGroups[layerUid].push(renderingReplayGroup);\n        if (declutterBuilderGroup) {\n          var declutterExecutorGroup = new CanvasExecutorGroup(null, resolution, pixelRatio, source.getOverlaps(), declutterBuilderGroup.finish(), layer.getRenderBuffer());\n          tile.declutterExecutorGroups[layerUid].push(declutterExecutorGroup);\n        }\n      };\n      for (var t = 0, tt = sourceTiles.length; t < tt; ++t) {\n        if (_loop()) continue;\n      }\n      builderState.renderedRevision = revision;\n      builderState.renderedRenderOrder = renderOrder;\n      builderState.renderedResolution = resolution;\n    }\n\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n     * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n     * @return {T|undefined} Callback result.\n     * @template T\n     */\n  }, {\n    key: \"forEachFeatureAtCoordinate\",\n    value: function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {\n      var resolution = frameState.viewState.resolution;\n      var rotation = frameState.viewState.rotation;\n      hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n      var layer = this.getLayer();\n      var source = layer.getSource();\n      var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n      var hitExtent = boundingExtent([coordinate]);\n      buffer(hitExtent, resolution * hitTolerance, hitExtent);\n\n      /** @type {!Object<string, import(\"../Map.js\").HitMatch<T>|true>} */\n      var features = {};\n\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n       * @param {number} distanceSq The squared distance to the click position.\n       * @return {T|undefined} Callback result.\n       */\n      var featureCallback = function featureCallback(feature, geometry, distanceSq) {\n        var key = feature.getId();\n        if (key === undefined) {\n          key = getUid(feature);\n        }\n        var match = features[key];\n        if (!match) {\n          if (distanceSq === 0) {\n            features[key] = true;\n            return callback(feature, layer, geometry);\n          }\n          matches.push(features[key] = {\n            feature: feature,\n            layer: layer,\n            geometry: geometry,\n            distanceSq: distanceSq,\n            callback: callback\n          });\n        } else if (match !== true && distanceSq < match.distanceSq) {\n          if (distanceSq === 0) {\n            features[key] = true;\n            matches.splice(matches.lastIndexOf(match), 1);\n            return callback(feature, layer, geometry);\n          }\n          match.geometry = geometry;\n          match.distanceSq = distanceSq;\n        }\n        return undefined;\n      };\n      var renderedTiles = /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */\n      this.renderedTiles;\n      var found;\n      var _loop2 = function _loop2() {\n        var tile = renderedTiles[i];\n        var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n        if (!intersects(tileExtent, hitExtent)) {\n          return 1; // continue\n        }\n        var layerUid = getUid(layer);\n        var executorGroups = [tile.executorGroups[layerUid]];\n        var declutterExecutorGroups = tile.declutterExecutorGroups[layerUid];\n        if (declutterExecutorGroups) {\n          executorGroups.push(declutterExecutorGroups);\n        }\n        executorGroups.some(function (executorGroups) {\n          var declutteredFeatures = executorGroups === declutterExecutorGroups ? frameState.declutterTree.all().map(function (item) {\n            return item.value;\n          }) : null;\n          for (var t = 0, tt = executorGroups.length; t < tt; ++t) {\n            var executorGroup = executorGroups[t];\n            found = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, declutteredFeatures);\n            if (found) {\n              return true;\n            }\n          }\n        });\n      };\n      for (var i = 0, ii = renderedTiles.length; !found && i < ii; ++i) {\n        if (_loop2()) continue;\n      }\n      return found;\n    }\n\n    /**\n     * Asynchronous layer level hit detection.\n     * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n     * @return {Promise<Array<import(\"../../Feature.js\").FeatureLike>>} Promise that resolves with an array of features.\n     */\n  }, {\n    key: \"getFeatures\",\n    value: function getFeatures(pixel) {\n      var _this3 = this;\n      return new Promise(function (resolve, reject) {\n        var layer = _this3.getLayer();\n        var layerUid = getUid(layer);\n        var source = layer.getSource();\n        var projection = _this3.renderedProjection;\n        var projectionExtent = projection.getExtent();\n        var resolution = _this3.renderedResolution;\n        var tileGrid = source.getTileGridForProjection(projection);\n        var coordinate = applyTransform(_this3.renderedPixelToCoordinateTransform_, pixel.slice());\n        var tileCoord = tileGrid.getTileCoordForCoordAndResolution(coordinate, resolution);\n        /** @type {import(\"../../VectorRenderTile.js\").default|undefined} */\n        var tile;\n        for (var i = 0, ii = _this3.renderedTiles.length; i < ii; ++i) {\n          if (tileCoord.toString() === _this3.renderedTiles[i].tileCoord.toString()) {\n            tile = /** @type {import(\"../../VectorRenderTile.js\").default} */\n            _this3.renderedTiles[i];\n            if (tile.getState() === TileState.LOADED) {\n              var _extent = tileGrid.getTileCoordExtent(tile.tileCoord);\n              if (source.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, _extent)) {\n                wrapX(coordinate, projection);\n              }\n              break;\n            }\n            tile = undefined;\n          }\n        }\n        if (!tile || tile.loadingSourceTiles > 0) {\n          resolve([]);\n          return;\n        }\n        var extent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n        var corner = getTopLeft(extent);\n        var tilePixel = [(coordinate[0] - corner[0]) / resolution, (corner[1] - coordinate[1]) / resolution];\n        /** @type {Array<import(\"../../Feature.js\").FeatureLike>} */\n        var features = tile.getSourceTiles().reduce(function (accumulator, sourceTile) {\n          return accumulator.concat(sourceTile.getFeatures());\n        }, []);\n        /** @type {ImageData|undefined} */\n        var hitDetectionImageData = tile.hitDetectionImageData[layerUid];\n        if (!hitDetectionImageData) {\n          var tileSize = toSize(tileGrid.getTileSize(tileGrid.getZForResolution(resolution, source.zDirection)));\n          var rotation = _this3.renderedRotation_;\n          var transforms = [_this3.getRenderTransform(tileGrid.getTileCoordCenter(tile.wrappedTileCoord), resolution, 0, HIT_DETECT_RESOLUTION, tileSize[0] * HIT_DETECT_RESOLUTION, tileSize[1] * HIT_DETECT_RESOLUTION, 0)];\n          hitDetectionImageData = createHitDetectionImageData(tileSize, transforms, features, layer.getStyleFunction(), tileGrid.getTileCoordExtent(tile.wrappedTileCoord), tile.getReplayState(layer).renderedResolution, rotation);\n          tile.hitDetectionImageData[layerUid] = hitDetectionImageData;\n        }\n        resolve(hitDetect(tilePixel, features, hitDetectionImageData));\n      });\n    }\n\n    /**\n     * Perform action necessary to get the layer rendered after new fonts have loaded\n     */\n  }, {\n    key: \"handleFontsChanged\",\n    value: function handleFontsChanged() {\n      var layer = this.getLayer();\n      if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n        layer.changed();\n      }\n    }\n\n    /**\n     * Handle changes in image style state.\n     * @param {import(\"../../events/Event.js\").default} event Image style change event.\n     * @private\n     */\n  }, {\n    key: \"handleStyleImageChange_\",\n    value: function handleStyleImageChange_(event) {\n      this.renderIfReadyAndVisible();\n    }\n\n    /**\n     * Render declutter items for this layer\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     */\n  }, {\n    key: \"renderDeclutter\",\n    value: function renderDeclutter(frameState) {\n      var context = this.context;\n      var alpha = context.globalAlpha;\n      context.globalAlpha = this.getLayer().getOpacity();\n      var viewHints = frameState.viewHints;\n      var hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n      var tiles = /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */\n      this.renderedTiles;\n      for (var i = 0, ii = tiles.length; i < ii; ++i) {\n        var tile = tiles[i];\n        var declutterExecutorGroups = tile.declutterExecutorGroups[getUid(this.getLayer())];\n        if (declutterExecutorGroups) {\n          for (var j = declutterExecutorGroups.length - 1; j >= 0; --j) {\n            declutterExecutorGroups[j].execute(this.context, 1, this.getTileRenderTransform(tile, frameState), frameState.viewState.rotation, hifi, undefined, frameState.declutterTree);\n          }\n        }\n      }\n      context.globalAlpha = alpha;\n    }\n  }, {\n    key: \"getTileRenderTransform\",\n    value: function getTileRenderTransform(tile, frameState) {\n      var pixelRatio = frameState.pixelRatio;\n      var viewState = frameState.viewState;\n      var center = viewState.center;\n      var resolution = viewState.resolution;\n      var rotation = viewState.rotation;\n      var size = frameState.size;\n      var width = Math.round(size[0] * pixelRatio);\n      var height = Math.round(size[1] * pixelRatio);\n      var source = this.getLayer().getSource();\n      var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n      var tileCoord = tile.tileCoord;\n      var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      var worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tileExtent[0];\n      var transform = multiply(scale(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio), this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, worldOffset));\n      return transform;\n    }\n\n    /**\n     * Render the vectors for this layer.\n     * @param {CanvasRenderingContext2D} context Target context.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     */\n  }, {\n    key: \"postRender\",\n    value: function postRender(context, frameState) {\n      var viewHints = frameState.viewHints;\n      var hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n      this.renderedPixelToCoordinateTransform_ = frameState.pixelToCoordinateTransform.slice();\n      this.renderedRotation_ = frameState.viewState.rotation;\n      var layer = /** @type {import(\"../../layer/VectorTile.js\").default} */\n      this.getLayer();\n      var renderMode = layer.getRenderMode();\n      var alpha = context.globalAlpha;\n      context.globalAlpha = layer.getOpacity();\n      var replayTypes = VECTOR_REPLAYS[renderMode];\n      var viewState = frameState.viewState;\n      var rotation = viewState.rotation;\n      var tileSource = layer.getSource();\n      var tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n      var z = tileGrid.getZForResolution(viewState.resolution, tileSource.zDirection);\n      var tiles = this.renderedTiles;\n      var clips = [];\n      var clipZs = [];\n      var ready = true;\n      for (var i = tiles.length - 1; i >= 0; --i) {\n        var tile = /** @type {import(\"../../VectorRenderTile.js\").default} */\n        tiles[i];\n        ready = ready && !tile.getReplayState(layer).dirty;\n        var executorGroups = tile.executorGroups[getUid(layer)].filter(function (group) {\n          return group.hasExecutors(replayTypes);\n        });\n        if (executorGroups.length === 0) {\n          continue;\n        }\n        var transform = this.getTileRenderTransform(tile, frameState);\n        var currentZ = tile.tileCoord[0];\n        var contextSaved = false;\n        // Clip mask for regions in this tile that already filled by a higher z tile\n        var currentClip = executorGroups[0].getClipCoords(transform);\n        if (currentClip) {\n          for (var j = 0, jj = clips.length; j < jj; ++j) {\n            if (z !== currentZ && currentZ < clipZs[j]) {\n              var clip = clips[j];\n              if (intersects([currentClip[0], currentClip[3], currentClip[4], currentClip[7]], [clip[0], clip[3], clip[4], clip[7]])) {\n                if (!contextSaved) {\n                  context.save();\n                  contextSaved = true;\n                }\n                context.beginPath();\n                // counter-clockwise (outer ring) for current tile\n                context.moveTo(currentClip[0], currentClip[1]);\n                context.lineTo(currentClip[2], currentClip[3]);\n                context.lineTo(currentClip[4], currentClip[5]);\n                context.lineTo(currentClip[6], currentClip[7]);\n                // clockwise (inner ring) for higher z tile\n                context.moveTo(clip[6], clip[7]);\n                context.lineTo(clip[4], clip[5]);\n                context.lineTo(clip[2], clip[3]);\n                context.lineTo(clip[0], clip[1]);\n                context.clip();\n              }\n            }\n          }\n          clips.push(currentClip);\n          clipZs.push(currentZ);\n        }\n        for (var t = 0, tt = executorGroups.length; t < tt; ++t) {\n          var executorGroup = executorGroups[t];\n          executorGroup.execute(context, 1, transform, rotation, hifi, replayTypes);\n        }\n        if (contextSaved) {\n          context.restore();\n        }\n      }\n      context.globalAlpha = alpha;\n      this.ready = ready;\n      _superPropGet(CanvasVectorTileLayerRenderer, \"postRender\", this, 3)([context, frameState]);\n    }\n\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n     * @param {import(\"../../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n     * @param {import(\"../../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder group for decluttering.\n     * @return {boolean} `true` if an image is loading.\n     */\n  }, {\n    key: \"renderFeature\",\n    value: function renderFeature(feature, squaredTolerance, styles, builderGroup, declutterBuilderGroup) {\n      if (!styles) {\n        return false;\n      }\n      var loading = false;\n      if (Array.isArray(styles)) {\n        for (var i = 0, ii = styles.length; i < ii; ++i) {\n          loading = _renderFeature(builderGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_, undefined, declutterBuilderGroup) || loading;\n        }\n      } else {\n        loading = _renderFeature(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, undefined, declutterBuilderGroup);\n      }\n      return loading;\n    }\n\n    /**\n     * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n     * @return {boolean} A new tile image was rendered.\n     * @private\n     */\n  }, {\n    key: \"tileImageNeedsRender_\",\n    value: function tileImageNeedsRender_(tile) {\n      var layer = /** @type {import(\"../../layer/VectorTile.js\").default} */\n      this.getLayer();\n      if (layer.getRenderMode() === 'vector') {\n        return false;\n      }\n      var replayState = tile.getReplayState(layer);\n      var revision = layer.getRevision();\n      var resolution = tile.wantedResolution;\n      return replayState.renderedTileResolution !== resolution || replayState.renderedTileRevision !== revision;\n    }\n\n    /**\n     * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n     * @param {import(\"../../Map\").FrameState} frameState Frame state.\n     * @private\n     */\n  }, {\n    key: \"renderTileImage_\",\n    value: function renderTileImage_(tile, frameState) {\n      var layer = /** @type {import(\"../../layer/VectorTile.js\").default} */\n      this.getLayer();\n      var replayState = tile.getReplayState(layer);\n      var revision = layer.getRevision();\n      var executorGroups = tile.executorGroups[getUid(layer)];\n      replayState.renderedTileRevision = revision;\n      var tileCoord = tile.wrappedTileCoord;\n      var z = tileCoord[0];\n      var source = layer.getSource();\n      var pixelRatio = frameState.pixelRatio;\n      var viewState = frameState.viewState;\n      var projection = viewState.projection;\n      var tileGrid = source.getTileGridForProjection(projection);\n      var tileResolution = tileGrid.getResolution(tile.tileCoord[0]);\n      var renderPixelRatio = frameState.pixelRatio / tile.wantedResolution * tileResolution;\n      var resolution = tileGrid.getResolution(z);\n      var context = tile.getContext(layer);\n\n      // Increase tile size when overzooming for low pixel ratio, to avoid blurry tiles\n      pixelRatio = Math.round(Math.max(pixelRatio, renderPixelRatio / pixelRatio));\n      var size = source.getTilePixelSize(z, pixelRatio, projection);\n      context.canvas.width = size[0];\n      context.canvas.height = size[1];\n      var renderScale = pixelRatio / renderPixelRatio;\n      if (renderScale !== 1) {\n        var canvasTransform = resetTransform(this.tmpTransform_);\n        scaleTransform(canvasTransform, renderScale, renderScale);\n        context.setTransform.apply(context, canvasTransform);\n      }\n      var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n      var pixelScale = renderPixelRatio / resolution;\n      var transform = resetTransform(this.tmpTransform_);\n      scaleTransform(transform, pixelScale, -pixelScale);\n      translateTransform(transform, -tileExtent[0], -tileExtent[3]);\n      for (var i = 0, ii = executorGroups.length; i < ii; ++i) {\n        var executorGroup = executorGroups[i];\n        executorGroup.execute(context, renderScale, transform, 0, true, IMAGE_REPLAYS[layer.getRenderMode()]);\n      }\n      replayState.renderedTileResolution = tile.wantedResolution;\n    }\n  }]);\n}(CanvasTileLayerRenderer);\nexport default CanvasVectorTileLayerRenderer;","map":{"version":3,"names":["CanvasBuilderGroup","CanvasExecutorGroup","CanvasTileLayerRenderer","TileState","ViewHint","HIT_DETECT_RESOLUTION","createHitDetectionImageData","hitDetect","apply","applyTransform","create","createTransform","multiply","reset","resetTransform","scale","scaleTransform","translate","translateTransform","boundingExtent","buffer","containsExtent","equals","getIntersection","getTopLeft","intersects","getSquaredTolerance","getSquaredRenderTolerance","renderFeature","getUid","toSize","wrapX","IMAGE_REPLAYS","VECTOR_REPLAYS","CanvasVectorTileLayerRenderer","_CanvasTileLayerRende","layer","_this","_classCallCheck","_callSuper","boundHandleStyleImageChange_","handleStyleImageChange_","bind","renderedLayerRevision_","renderedPixelToCoordinateTransform_","renderedRotation_","tmpTransform_","_inherits","_createClass","key","value","prepareTile","tile","pixelRatio","projection","render","state","getState","LOADED","ERROR","updateExecutorGroup_","tileImageNeedsRender_","getTile","z","x","y","frameState","viewState","resolution","getLayer","getSource","viewHints","hifi","ANIMATING","INTERACTING","wantedResolution","Date","now","time","getRenderMode","renderTileImage_","_superPropGet","isDrawableTile","executorGroups","hasContext","getTileImage","getImage","prepareFrame","layerRevision","getRevision","renderedTiles","length","_this2","revision","renderOrder","getRenderOrder","builderState","getReplayState","dirty","renderedResolution","renderedRevision","renderedRenderOrder","source","declutter","getDeclutter","sourceTileGrid","getTileGrid","tileGrid","getTileGridForProjection","tileExtent","getTileCoordExtent","wrappedTileCoord","sourceTiles","getSourceTiles","layerUid","hitDetectionImageData","declutterExecutorGroups","_loop","sourceTile","t","sourceTileCoord","tileCoord","sourceTileExtent","sharedExtent","builderExtent","getRenderBuffer","tmpExtent","bufferedExtent","builderGroup","declutterBuilderGroup","undefined","squaredTolerance","feature","styles","styleFunction","getStyleFunction","features","getFeatures","sort","i","ii","getGeometry","getExtent","call","executorGroupInstructions","finish","replayExtent","renderingReplayGroup","getOverlaps","push","declutterExecutorGroup","tt","forEachFeatureAtCoordinate","coordinate","hitTolerance","callback","matches","rotation","hitExtent","featureCallback","geometry","distanceSq","getId","match","splice","lastIndexOf","found","_loop2","some","declutteredFeatures","declutterTree","all","map","item","executorGroup","pixel","_this3","Promise","resolve","reject","renderedProjection","projectionExtent","slice","getTileCoordForCoordAndResolution","toString","extent","getWrapX","canWrapX","loadingSourceTiles","corner","tilePixel","reduce","accumulator","concat","tileSize","getTileSize","getZForResolution","zDirection","transforms","getRenderTransform","getTileCoordCenter","handleFontsChanged","getVisible","changed","event","renderIfReadyAndVisible","renderDeclutter","context","alpha","globalAlpha","getOpacity","tiles","j","execute","getTileRenderTransform","center","size","width","Math","round","height","worldOffset","transform","inversePixelTransform","postRender","pixelToCoordinateTransform","renderMode","replayTypes","tileSource","clips","clipZs","ready","filter","group","hasExecutors","currentZ","contextSaved","currentClip","getClipCoords","jj","clip","save","beginPath","moveTo","lineTo","restore","loading","Array","isArray","replayState","renderedTileResolution","renderedTileRevision","tileResolution","getResolution","renderPixelRatio","getContext","max","getTilePixelSize","canvas","renderScale","canvasTransform","setTransform","pixelScale"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol/renderer/canvas/VectorTileLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\nimport CanvasBuilderGroup from '../../render/canvas/BuilderGroup.js';\nimport CanvasExecutorGroup from '../../render/canvas/ExecutorGroup.js';\nimport CanvasTileLayerRenderer from './TileLayer.js';\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport {\n  HIT_DETECT_RESOLUTION,\n  createHitDetectionImageData,\n  hitDetect,\n} from '../../render/canvas/hitdetect.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  multiply,\n  reset as resetTransform,\n  scale,\n  scale as scaleTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {\n  boundingExtent,\n  buffer,\n  containsExtent,\n  equals,\n  getIntersection,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport {\n  getSquaredTolerance as getSquaredRenderTolerance,\n  renderFeature,\n} from '../vector.js';\nimport {getUid} from '../../util.js';\nimport {toSize} from '../../size.js';\nimport {wrapX} from '../../coordinate.js';\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nconst IMAGE_REPLAYS = {\n  'image': ['Polygon', 'Circle', 'LineString', 'Image', 'Text'],\n  'hybrid': ['Polygon', 'LineString'],\n  'vector': [],\n};\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nconst VECTOR_REPLAYS = {\n  'hybrid': ['Image', 'Text', 'Default'],\n  'vector': ['Polygon', 'Circle', 'LineString', 'Image', 'Text', 'Default'],\n};\n\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n * @extends {CanvasTileLayerRenderer<import(\"../../layer/VectorTile.js\").default>}\n */\nclass CanvasVectorTileLayerRenderer extends CanvasTileLayerRenderer {\n  /**\n   * @param {import(\"../../layer/VectorTile.js\").default} layer VectorTile layer.\n   */\n  constructor(layer) {\n    super(layer);\n\n    /** @private */\n    this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedLayerRevision_;\n\n    /**\n     * @private\n     * @type {import(\"../../transform\").Transform}\n     */\n    this.renderedPixelToCoordinateTransform_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRotation_;\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tmpTransform_ = createTransform();\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection\").default} projection Projection.\n   * @return {boolean|undefined} Tile needs to be rendered.\n   */\n  prepareTile(tile, pixelRatio, projection) {\n    let render;\n    const state = tile.getState();\n    if (state === TileState.LOADED || state === TileState.ERROR) {\n      this.updateExecutorGroup_(tile, pixelRatio, projection);\n      if (this.tileImageNeedsRender_(tile)) {\n        render = true;\n      }\n    }\n    return render;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const resolution = viewState.resolution;\n    const projection = viewState.projection;\n    const layer = this.getLayer();\n    const tile = layer.getSource().getTile(z, x, y, pixelRatio, projection);\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    if (hifi || !tile.wantedResolution) {\n      tile.wantedResolution = resolution;\n    }\n    const render = this.prepareTile(tile, pixelRatio, projection);\n    if (\n      render &&\n      (hifi || Date.now() - frameState.time < 8) &&\n      layer.getRenderMode() !== 'vector'\n    ) {\n      this.renderTileImage_(tile, frameState);\n    }\n    return super.getTile(z, x, y, frameState);\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  isDrawableTile(tile) {\n    const layer = this.getLayer();\n    return (\n      super.isDrawableTile(tile) &&\n      (layer.getRenderMode() === 'vector'\n        ? getUid(layer) in tile.executorGroups\n        : tile.hasContext(layer))\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getTileImage(tile) {\n    return tile.getImage(this.getLayer());\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    const layerRevision = this.getLayer().getRevision();\n    if (this.renderedLayerRevision_ !== layerRevision) {\n      this.renderedLayerRevision_ = layerRevision;\n      this.renderedTiles.length = 0;\n    }\n    return super.prepareFrame(frameState);\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  updateExecutorGroup_(tile, pixelRatio, projection) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const revision = layer.getRevision();\n    const renderOrder = layer.getRenderOrder() || null;\n\n    const resolution = tile.wantedResolution;\n    const builderState = tile.getReplayState(layer);\n    if (\n      !builderState.dirty &&\n      builderState.renderedResolution === resolution &&\n      builderState.renderedRevision == revision &&\n      builderState.renderedRenderOrder == renderOrder\n    ) {\n      return;\n    }\n\n    const source = layer.getSource();\n    const declutter = layer.getDeclutter();\n    const sourceTileGrid = source.getTileGrid();\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n\n    const sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);\n    const layerUid = getUid(layer);\n    delete tile.hitDetectionImageData[layerUid];\n    tile.executorGroups[layerUid] = [];\n    if (declutter) {\n      tile.declutterExecutorGroups[layerUid] = [];\n    }\n    builderState.dirty = false;\n    for (let t = 0, tt = sourceTiles.length; t < tt; ++t) {\n      const sourceTile = sourceTiles[t];\n      if (sourceTile.getState() != TileState.LOADED) {\n        continue;\n      }\n      const sourceTileCoord = sourceTile.tileCoord;\n      const sourceTileExtent =\n        sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n      const sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n      const builderExtent = buffer(\n        sharedExtent,\n        layer.getRenderBuffer() * resolution,\n        this.tmpExtent\n      );\n      const bufferedExtent = equals(sourceTileExtent, sharedExtent)\n        ? null\n        : builderExtent;\n      const builderGroup = new CanvasBuilderGroup(\n        0,\n        builderExtent,\n        resolution,\n        pixelRatio\n      );\n      const declutterBuilderGroup = declutter\n        ? new CanvasBuilderGroup(0, sharedExtent, resolution, pixelRatio)\n        : undefined;\n      const squaredTolerance = getSquaredRenderTolerance(\n        resolution,\n        pixelRatio\n      );\n\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @this {CanvasVectorTileLayerRenderer}\n       */\n      const render = function (feature) {\n        let styles;\n        const styleFunction =\n          feature.getStyleFunction() || layer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n        if (styles) {\n          const dirty = this.renderFeature(\n            feature,\n            squaredTolerance,\n            styles,\n            builderGroup,\n            declutterBuilderGroup\n          );\n          builderState.dirty = builderState.dirty || dirty;\n        }\n      };\n\n      const features = sourceTile.getFeatures();\n      if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n      for (let i = 0, ii = features.length; i < ii; ++i) {\n        const feature = features[i];\n        if (\n          !bufferedExtent ||\n          intersects(bufferedExtent, feature.getGeometry().getExtent())\n        ) {\n          render.call(this, feature);\n        }\n      }\n      const executorGroupInstructions = builderGroup.finish();\n      // no need to clip when the render tile is covered by a single source tile\n      const replayExtent =\n        layer.getRenderMode() !== 'vector' &&\n        declutter &&\n        sourceTiles.length === 1\n          ? null\n          : sharedExtent;\n      const renderingReplayGroup = new CanvasExecutorGroup(\n        replayExtent,\n        resolution,\n        pixelRatio,\n        source.getOverlaps(),\n        executorGroupInstructions,\n        layer.getRenderBuffer()\n      );\n      tile.executorGroups[layerUid].push(renderingReplayGroup);\n      if (declutterBuilderGroup) {\n        const declutterExecutorGroup = new CanvasExecutorGroup(\n          null,\n          resolution,\n          pixelRatio,\n          source.getOverlaps(),\n          declutterBuilderGroup.finish(),\n          layer.getRenderBuffer()\n        );\n        tile.declutterExecutorGroups[layerUid].push(declutterExecutorGroup);\n      }\n    }\n    builderState.renderedRevision = revision;\n    builderState.renderedRenderOrder = renderOrder;\n    builderState.renderedResolution = resolution;\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches\n  ) {\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n    const layer = this.getLayer();\n    const source = layer.getSource();\n    const tileGrid = source.getTileGridForProjection(\n      frameState.viewState.projection\n    );\n\n    const hitExtent = boundingExtent([coordinate]);\n    buffer(hitExtent, resolution * hitTolerance, hitExtent);\n\n    /** @type {!Object<string, import(\"../Map.js\").HitMatch<T>|true>} */\n    const features = {};\n\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {number} distanceSq The squared distance to the click position.\n     * @return {T|undefined} Callback result.\n     */\n    const featureCallback = function (feature, geometry, distanceSq) {\n      let key = feature.getId();\n      if (key === undefined) {\n        key = getUid(feature);\n      }\n      const match = features[key];\n      if (!match) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          return callback(feature, layer, geometry);\n        }\n        matches.push(\n          (features[key] = {\n            feature: feature,\n            layer: layer,\n            geometry: geometry,\n            distanceSq: distanceSq,\n            callback: callback,\n          })\n        );\n      } else if (match !== true && distanceSq < match.distanceSq) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          matches.splice(matches.lastIndexOf(match), 1);\n          return callback(feature, layer, geometry);\n        }\n        match.geometry = geometry;\n        match.distanceSq = distanceSq;\n      }\n      return undefined;\n    };\n\n    const renderedTiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n\n    let found;\n    for (let i = 0, ii = renderedTiles.length; !found && i < ii; ++i) {\n      const tile = renderedTiles[i];\n      const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      if (!intersects(tileExtent, hitExtent)) {\n        continue;\n      }\n\n      const layerUid = getUid(layer);\n      const executorGroups = [tile.executorGroups[layerUid]];\n      const declutterExecutorGroups = tile.declutterExecutorGroups[layerUid];\n      if (declutterExecutorGroups) {\n        executorGroups.push(declutterExecutorGroups);\n      }\n      executorGroups.some((executorGroups) => {\n        const declutteredFeatures =\n          executorGroups === declutterExecutorGroups\n            ? frameState.declutterTree.all().map((item) => item.value)\n            : null;\n        for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n          const executorGroup = executorGroups[t];\n          found = executorGroup.forEachFeatureAtCoordinate(\n            coordinate,\n            resolution,\n            rotation,\n            hitTolerance,\n            featureCallback,\n            declutteredFeatures\n          );\n          if (found) {\n            return true;\n          }\n        }\n      });\n    }\n    return found;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature.js\").FeatureLike>>} Promise that resolves with an array of features.\n   */\n  getFeatures(pixel) {\n    return new Promise((resolve, reject) => {\n      const layer = this.getLayer();\n      const layerUid = getUid(layer);\n      const source = layer.getSource();\n      const projection = this.renderedProjection;\n      const projectionExtent = projection.getExtent();\n      const resolution = this.renderedResolution;\n      const tileGrid = source.getTileGridForProjection(projection);\n      const coordinate = applyTransform(\n        this.renderedPixelToCoordinateTransform_,\n        pixel.slice()\n      );\n      const tileCoord = tileGrid.getTileCoordForCoordAndResolution(\n        coordinate,\n        resolution\n      );\n      /** @type {import(\"../../VectorRenderTile.js\").default|undefined} */\n      let tile;\n      for (let i = 0, ii = this.renderedTiles.length; i < ii; ++i) {\n        if (\n          tileCoord.toString() === this.renderedTiles[i].tileCoord.toString()\n        ) {\n          tile = /** @type {import(\"../../VectorRenderTile.js\").default} */ (\n            this.renderedTiles[i]\n          );\n          if (tile.getState() === TileState.LOADED) {\n            const extent = tileGrid.getTileCoordExtent(tile.tileCoord);\n            if (\n              source.getWrapX() &&\n              projection.canWrapX() &&\n              !containsExtent(projectionExtent, extent)\n            ) {\n              wrapX(coordinate, projection);\n            }\n            break;\n          }\n          tile = undefined;\n        }\n      }\n      if (!tile || tile.loadingSourceTiles > 0) {\n        resolve([]);\n        return;\n      }\n      const extent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      const corner = getTopLeft(extent);\n      const tilePixel = [\n        (coordinate[0] - corner[0]) / resolution,\n        (corner[1] - coordinate[1]) / resolution,\n      ];\n      /** @type {Array<import(\"../../Feature.js\").FeatureLike>} */\n      const features = tile\n        .getSourceTiles()\n        .reduce(function (accumulator, sourceTile) {\n          return accumulator.concat(sourceTile.getFeatures());\n        }, []);\n      /** @type {ImageData|undefined} */\n      let hitDetectionImageData = tile.hitDetectionImageData[layerUid];\n      if (!hitDetectionImageData) {\n        const tileSize = toSize(\n          tileGrid.getTileSize(\n            tileGrid.getZForResolution(resolution, source.zDirection)\n          )\n        );\n        const rotation = this.renderedRotation_;\n        const transforms = [\n          this.getRenderTransform(\n            tileGrid.getTileCoordCenter(tile.wrappedTileCoord),\n            resolution,\n            0,\n            HIT_DETECT_RESOLUTION,\n            tileSize[0] * HIT_DETECT_RESOLUTION,\n            tileSize[1] * HIT_DETECT_RESOLUTION,\n            0\n          ),\n        ];\n        hitDetectionImageData = createHitDetectionImageData(\n          tileSize,\n          transforms,\n          features,\n          layer.getStyleFunction(),\n          tileGrid.getTileCoordExtent(tile.wrappedTileCoord),\n          tile.getReplayState(layer).renderedResolution,\n          rotation\n        );\n        tile.hitDetectionImageData[layerUid] = hitDetectionImageData;\n      }\n      resolve(hitDetect(tilePixel, features, hitDetectionImageData));\n    });\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   */\n  handleFontsChanged() {\n    const layer = this.getLayer();\n    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  }\n\n  /**\n   * Render declutter items for this layer\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeclutter(frameState) {\n    const context = this.context;\n    const alpha = context.globalAlpha;\n    context.globalAlpha = this.getLayer().getOpacity();\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    const tiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    for (let i = 0, ii = tiles.length; i < ii; ++i) {\n      const tile = tiles[i];\n      const declutterExecutorGroups =\n        tile.declutterExecutorGroups[getUid(this.getLayer())];\n      if (declutterExecutorGroups) {\n        for (let j = declutterExecutorGroups.length - 1; j >= 0; --j) {\n          declutterExecutorGroups[j].execute(\n            this.context,\n            1,\n            this.getTileRenderTransform(tile, frameState),\n            frameState.viewState.rotation,\n            hifi,\n            undefined,\n            frameState.declutterTree\n          );\n        }\n      }\n    }\n    context.globalAlpha = alpha;\n  }\n\n  getTileRenderTransform(tile, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const center = viewState.center;\n    const resolution = viewState.resolution;\n    const rotation = viewState.rotation;\n    const size = frameState.size;\n    const width = Math.round(size[0] * pixelRatio);\n    const height = Math.round(size[1] * pixelRatio);\n\n    const source = this.getLayer().getSource();\n    const tileGrid = source.getTileGridForProjection(\n      frameState.viewState.projection\n    );\n    const tileCoord = tile.tileCoord;\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n    const worldOffset =\n      tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tileExtent[0];\n    const transform = multiply(\n      scale(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio),\n      this.getRenderTransform(\n        center,\n        resolution,\n        rotation,\n        pixelRatio,\n        width,\n        height,\n        worldOffset\n      )\n    );\n    return transform;\n  }\n\n  /**\n   * Render the vectors for this layer.\n   * @param {CanvasRenderingContext2D} context Target context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  postRender(context, frameState) {\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n\n    this.renderedPixelToCoordinateTransform_ =\n      frameState.pixelToCoordinateTransform.slice();\n    this.renderedRotation_ = frameState.viewState.rotation;\n\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const renderMode = layer.getRenderMode();\n    const alpha = context.globalAlpha;\n    context.globalAlpha = layer.getOpacity();\n    const replayTypes = VECTOR_REPLAYS[renderMode];\n    const viewState = frameState.viewState;\n    const rotation = viewState.rotation;\n    const tileSource = layer.getSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const z = tileGrid.getZForResolution(\n      viewState.resolution,\n      tileSource.zDirection\n    );\n\n    const tiles = this.renderedTiles;\n    const clips = [];\n    const clipZs = [];\n    let ready = true;\n    for (let i = tiles.length - 1; i >= 0; --i) {\n      const tile = /** @type {import(\"../../VectorRenderTile.js\").default} */ (\n        tiles[i]\n      );\n      ready = ready && !tile.getReplayState(layer).dirty;\n      const executorGroups = tile.executorGroups[getUid(layer)].filter(\n        (group) => group.hasExecutors(replayTypes)\n      );\n      if (executorGroups.length === 0) {\n        continue;\n      }\n      const transform = this.getTileRenderTransform(tile, frameState);\n      const currentZ = tile.tileCoord[0];\n      let contextSaved = false;\n      // Clip mask for regions in this tile that already filled by a higher z tile\n      const currentClip = executorGroups[0].getClipCoords(transform);\n      if (currentClip) {\n        for (let j = 0, jj = clips.length; j < jj; ++j) {\n          if (z !== currentZ && currentZ < clipZs[j]) {\n            const clip = clips[j];\n            if (\n              intersects(\n                [\n                  currentClip[0],\n                  currentClip[3],\n                  currentClip[4],\n                  currentClip[7],\n                ],\n                [clip[0], clip[3], clip[4], clip[7]]\n              )\n            ) {\n              if (!contextSaved) {\n                context.save();\n                contextSaved = true;\n              }\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n      }\n      for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n        const executorGroup = executorGroups[t];\n        executorGroup.execute(\n          context,\n          1,\n          transform,\n          rotation,\n          hifi,\n          replayTypes\n        );\n      }\n      if (contextSaved) {\n        context.restore();\n      }\n    }\n    context.globalAlpha = alpha;\n    this.ready = ready;\n\n    super.postRender(context, frameState);\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder group for decluttering.\n   * @return {boolean} `true` if an image is loading.\n   */\n  renderFeature(\n    feature,\n    squaredTolerance,\n    styles,\n    builderGroup,\n    declutterBuilderGroup\n  ) {\n    if (!styles) {\n      return false;\n    }\n    let loading = false;\n    if (Array.isArray(styles)) {\n      for (let i = 0, ii = styles.length; i < ii; ++i) {\n        loading =\n          renderFeature(\n            builderGroup,\n            feature,\n            styles[i],\n            squaredTolerance,\n            this.boundHandleStyleImageChange_,\n            undefined,\n            declutterBuilderGroup\n          ) || loading;\n      }\n    } else {\n      loading = renderFeature(\n        builderGroup,\n        feature,\n        styles,\n        squaredTolerance,\n        this.boundHandleStyleImageChange_,\n        undefined,\n        declutterBuilderGroup\n      );\n    }\n    return loading;\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @return {boolean} A new tile image was rendered.\n   * @private\n   */\n  tileImageNeedsRender_(tile) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    if (layer.getRenderMode() === 'vector') {\n      return false;\n    }\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const resolution = tile.wantedResolution;\n    return (\n      replayState.renderedTileResolution !== resolution ||\n      replayState.renderedTileRevision !== revision\n    );\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {import(\"../../Map\").FrameState} frameState Frame state.\n   * @private\n   */\n  renderTileImage_(tile, frameState) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const executorGroups = tile.executorGroups[getUid(layer)];\n    replayState.renderedTileRevision = revision;\n\n    const tileCoord = tile.wrappedTileCoord;\n    const z = tileCoord[0];\n    const source = layer.getSource();\n    let pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileResolution = tileGrid.getResolution(tile.tileCoord[0]);\n    const renderPixelRatio =\n      (frameState.pixelRatio / tile.wantedResolution) * tileResolution;\n    const resolution = tileGrid.getResolution(z);\n    const context = tile.getContext(layer);\n\n    // Increase tile size when overzooming for low pixel ratio, to avoid blurry tiles\n    pixelRatio = Math.round(\n      Math.max(pixelRatio, renderPixelRatio / pixelRatio)\n    );\n    const size = source.getTilePixelSize(z, pixelRatio, projection);\n    context.canvas.width = size[0];\n    context.canvas.height = size[1];\n    const renderScale = pixelRatio / renderPixelRatio;\n    if (renderScale !== 1) {\n      const canvasTransform = resetTransform(this.tmpTransform_);\n      scaleTransform(canvasTransform, renderScale, renderScale);\n      context.setTransform.apply(context, canvasTransform);\n    }\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n    const pixelScale = renderPixelRatio / resolution;\n    const transform = resetTransform(this.tmpTransform_);\n    scaleTransform(transform, pixelScale, -pixelScale);\n    translateTransform(transform, -tileExtent[0], -tileExtent[3]);\n    for (let i = 0, ii = executorGroups.length; i < ii; ++i) {\n      const executorGroup = executorGroups[i];\n      executorGroup.execute(\n        context,\n        renderScale,\n        transform,\n        0,\n        true,\n        IMAGE_REPLAYS[layer.getRenderMode()]\n      );\n    }\n    replayState.renderedTileResolution = tile.wantedResolution;\n  }\n}\n\nexport default CanvasVectorTileLayerRenderer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}