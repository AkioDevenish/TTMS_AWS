{"ast":null,"code":"import _classCallCheck from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _callSuper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reverse.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\n/**\n * @module ol/render/canvas/Builder\n */\nimport CanvasInstruction from './Instruction.js';\nimport Relationship from '../../extent/Relationship.js';\nimport VectorContext from '../VectorContext.js';\nimport { asColorLike } from '../../colorlike.js';\nimport { buffer, clone, containsCoordinate, coordinateRelationship } from '../../extent.js';\nimport { defaultFillStyle, defaultLineCap, defaultLineDash, defaultLineDashOffset, defaultLineJoin, defaultLineWidth, defaultMiterLimit, defaultStrokeStyle } from '../canvas.js';\nimport { equals, reverseSubArray } from '../../array.js';\nimport { inflateCoordinates, inflateCoordinatesArray, inflateMultiCoordinatesArray } from '../../geom/flat/inflate.js';\nvar CanvasBuilder = /*#__PURE__*/function (_VectorContext) {\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   */\n  function CanvasBuilder(tolerance, maxExtent, resolution, pixelRatio) {\n    var _this;\n    _classCallCheck(this, CanvasBuilder);\n    _this = _callSuper(this, CanvasBuilder);\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    _this.tolerance = tolerance;\n\n    /**\n     * @protected\n     * @const\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    _this.maxExtent = maxExtent;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    _this.pixelRatio = pixelRatio;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    _this.maxLineWidth = 0;\n\n    /**\n     * @protected\n     * @const\n     * @type {number}\n     */\n    _this.resolution = resolution;\n\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n    _this.beginGeometryInstruction1_ = null;\n\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n    _this.beginGeometryInstruction2_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    _this.bufferedMaxExtent_ = null;\n\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    _this.instructions = [];\n\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n    _this.coordinates = [];\n\n    /**\n     * @private\n     * @type {import(\"../../coordinate.js\").Coordinate}\n     */\n    _this.tmpCoordinate_ = [];\n\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    _this.hitDetectionInstructions = [];\n\n    /**\n     * @protected\n     * @type {import(\"../canvas.js\").FillStrokeState}\n     */\n    _this.state = /** @type {import(\"../canvas.js\").FillStrokeState} */{};\n    return _this;\n  }\n\n  /**\n   * @protected\n   * @param {Array<number>} dashArray Dash array.\n   * @return {Array<number>} Dash array with pixel ratio applied\n   */\n  _inherits(CanvasBuilder, _VectorContext);\n  return _createClass(CanvasBuilder, [{\n    key: \"applyPixelRatio\",\n    value: function applyPixelRatio(dashArray) {\n      var pixelRatio = this.pixelRatio;\n      return pixelRatio == 1 ? dashArray : dashArray.map(function (dash) {\n        return dash * pixelRatio;\n      });\n    }\n\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} stride Stride.\n     * @protected\n     * @return {number} My end\n     */\n  }, {\n    key: \"appendFlatPointCoordinates\",\n    value: function appendFlatPointCoordinates(flatCoordinates, stride) {\n      var extent = this.getBufferedMaxExtent();\n      var tmpCoord = this.tmpCoordinate_;\n      var coordinates = this.coordinates;\n      var myEnd = coordinates.length;\n      for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n        tmpCoord[0] = flatCoordinates[i];\n        tmpCoord[1] = flatCoordinates[i + 1];\n        if (containsCoordinate(extent, tmpCoord)) {\n          coordinates[myEnd++] = tmpCoord[0];\n          coordinates[myEnd++] = tmpCoord[1];\n        }\n      }\n      return myEnd;\n    }\n\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {number} end End.\n     * @param {number} stride Stride.\n     * @param {boolean} closed Last input coordinate equals first.\n     * @param {boolean} skipFirst Skip first coordinate.\n     * @protected\n     * @return {number} My end.\n     */\n  }, {\n    key: \"appendFlatLineCoordinates\",\n    value: function appendFlatLineCoordinates(flatCoordinates, offset, end, stride, closed, skipFirst) {\n      var coordinates = this.coordinates;\n      var myEnd = coordinates.length;\n      var extent = this.getBufferedMaxExtent();\n      if (skipFirst) {\n        offset += stride;\n      }\n      var lastXCoord = flatCoordinates[offset];\n      var lastYCoord = flatCoordinates[offset + 1];\n      var nextCoord = this.tmpCoordinate_;\n      var skipped = true;\n      var i, lastRel, nextRel;\n      for (i = offset + stride; i < end; i += stride) {\n        nextCoord[0] = flatCoordinates[i];\n        nextCoord[1] = flatCoordinates[i + 1];\n        nextRel = coordinateRelationship(extent, nextCoord);\n        if (nextRel !== lastRel) {\n          if (skipped) {\n            coordinates[myEnd++] = lastXCoord;\n            coordinates[myEnd++] = lastYCoord;\n            skipped = false;\n          }\n          coordinates[myEnd++] = nextCoord[0];\n          coordinates[myEnd++] = nextCoord[1];\n        } else if (nextRel === Relationship.INTERSECTING) {\n          coordinates[myEnd++] = nextCoord[0];\n          coordinates[myEnd++] = nextCoord[1];\n          skipped = false;\n        } else {\n          skipped = true;\n        }\n        lastXCoord = nextCoord[0];\n        lastYCoord = nextCoord[1];\n        lastRel = nextRel;\n      }\n\n      // Last coordinate equals first or only one point to append:\n      if (closed && skipped || i === offset + stride) {\n        coordinates[myEnd++] = lastXCoord;\n        coordinates[myEnd++] = lastYCoord;\n      }\n      return myEnd;\n    }\n\n    /**\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     * @param {number} offset Offset.\n     * @param {Array<number>} ends Ends.\n     * @param {number} stride Stride.\n     * @param {Array<number>} builderEnds Builder ends.\n     * @return {number} Offset.\n     */\n  }, {\n    key: \"drawCustomCoordinates_\",\n    value: function drawCustomCoordinates_(flatCoordinates, offset, ends, stride, builderEnds) {\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        var builderEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);\n        builderEnds.push(builderEnd);\n        offset = end;\n      }\n      return offset;\n    }\n\n    /**\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {Function} renderer Renderer.\n     * @param {Function} hitDetectionRenderer Renderer.\n     */\n  }, {\n    key: \"drawCustom\",\n    value: function drawCustom(geometry, feature, renderer, hitDetectionRenderer) {\n      this.beginGeometry(geometry, feature);\n      var type = geometry.getType();\n      var stride = geometry.getStride();\n      var builderBegin = this.coordinates.length;\n      var flatCoordinates, builderEnd, builderEnds, builderEndss;\n      var offset;\n      switch (type) {\n        case 'MultiPolygon':\n          flatCoordinates = /** @type {import(\"../../geom/MultiPolygon.js\").default} */geometry.getOrientedFlatCoordinates();\n          builderEndss = [];\n          var endss = /** @type {import(\"../../geom/MultiPolygon.js\").default} */geometry.getEndss();\n          offset = 0;\n          for (var i = 0, ii = endss.length; i < ii; ++i) {\n            var myEnds = [];\n            offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);\n            builderEndss.push(myEnds);\n          }\n          this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEndss, geometry, renderer, inflateMultiCoordinatesArray]);\n          this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEndss, geometry, hitDetectionRenderer || renderer, inflateMultiCoordinatesArray]);\n          break;\n        case 'Polygon':\n        case 'MultiLineString':\n          builderEnds = [];\n          flatCoordinates = type == 'Polygon' ? /** @type {import(\"../../geom/Polygon.js\").default} */geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();\n          offset = this.drawCustomCoordinates_(flatCoordinates, 0, /** @type {import(\"../../geom/Polygon.js\").default|import(\"../../geom/MultiLineString.js\").default} */geometry.getEnds(), stride, builderEnds);\n          this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnds, geometry, renderer, inflateCoordinatesArray]);\n          this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnds, geometry, hitDetectionRenderer || renderer, inflateCoordinatesArray]);\n          break;\n        case 'LineString':\n        case 'Circle':\n          flatCoordinates = geometry.getFlatCoordinates();\n          builderEnd = this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n          this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, renderer, inflateCoordinates]);\n          this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, hitDetectionRenderer || renderer, inflateCoordinates]);\n          break;\n        case 'MultiPoint':\n          flatCoordinates = geometry.getFlatCoordinates();\n          builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);\n          if (builderEnd > builderBegin) {\n            this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, renderer, inflateCoordinates]);\n            this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, hitDetectionRenderer || renderer, inflateCoordinates]);\n          }\n          break;\n        case 'Point':\n          flatCoordinates = geometry.getFlatCoordinates();\n          this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);\n          builderEnd = this.coordinates.length;\n          this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, renderer]);\n          this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, hitDetectionRenderer || renderer]);\n          break;\n        default:\n      }\n      this.endGeometry(feature);\n    }\n\n    /**\n     * @protected\n     * @param {import(\"../../geom/Geometry\").default|import(\"../Feature.js\").default} geometry The geometry.\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     */\n  }, {\n    key: \"beginGeometry\",\n    value: function beginGeometry(geometry, feature) {\n      this.beginGeometryInstruction1_ = [CanvasInstruction.BEGIN_GEOMETRY, feature, 0, geometry];\n      this.instructions.push(this.beginGeometryInstruction1_);\n      this.beginGeometryInstruction2_ = [CanvasInstruction.BEGIN_GEOMETRY, feature, 0, geometry];\n      this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);\n    }\n\n    /**\n     * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\n     */\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      return {\n        instructions: this.instructions,\n        hitDetectionInstructions: this.hitDetectionInstructions,\n        coordinates: this.coordinates\n      };\n    }\n\n    /**\n     * Reverse the hit detection instructions.\n     */\n  }, {\n    key: \"reverseHitDetectionInstructions\",\n    value: function reverseHitDetectionInstructions() {\n      var hitDetectionInstructions = this.hitDetectionInstructions;\n      // step 1 - reverse array\n      hitDetectionInstructions.reverse();\n      // step 2 - reverse instructions within geometry blocks\n      var i;\n      var n = hitDetectionInstructions.length;\n      var instruction;\n      var type;\n      var begin = -1;\n      for (i = 0; i < n; ++i) {\n        instruction = hitDetectionInstructions[i];\n        type = /** @type {import(\"./Instruction.js\").default} */instruction[0];\n        if (type == CanvasInstruction.END_GEOMETRY) {\n          begin = i;\n        } else if (type == CanvasInstruction.BEGIN_GEOMETRY) {\n          instruction[2] = i;\n          reverseSubArray(this.hitDetectionInstructions, begin, i);\n          begin = -1;\n        }\n      }\n    }\n\n    /**\n     * @param {import(\"../../style/Fill.js\").default} fillStyle Fill style.\n     * @param {import(\"../../style/Stroke.js\").default} strokeStyle Stroke style.\n     */\n  }, {\n    key: \"setFillStrokeStyle\",\n    value: function setFillStrokeStyle(fillStyle, strokeStyle) {\n      var state = this.state;\n      if (fillStyle) {\n        var fillStyleColor = fillStyle.getColor();\n        state.fillStyle = asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle);\n      } else {\n        state.fillStyle = undefined;\n      }\n      if (strokeStyle) {\n        var strokeStyleColor = strokeStyle.getColor();\n        state.strokeStyle = asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle);\n        var strokeStyleLineCap = strokeStyle.getLineCap();\n        state.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : defaultLineCap;\n        var strokeStyleLineDash = strokeStyle.getLineDash();\n        state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : defaultLineDash;\n        var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n        state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset;\n        var strokeStyleLineJoin = strokeStyle.getLineJoin();\n        state.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : defaultLineJoin;\n        var strokeStyleWidth = strokeStyle.getWidth();\n        state.lineWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : defaultLineWidth;\n        var strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n        state.miterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : defaultMiterLimit;\n        if (state.lineWidth > this.maxLineWidth) {\n          this.maxLineWidth = state.lineWidth;\n          // invalidate the buffered max extent cache\n          this.bufferedMaxExtent_ = null;\n        }\n      } else {\n        state.strokeStyle = undefined;\n        state.lineCap = undefined;\n        state.lineDash = null;\n        state.lineDashOffset = undefined;\n        state.lineJoin = undefined;\n        state.lineWidth = undefined;\n        state.miterLimit = undefined;\n      }\n    }\n\n    /**\n     * @param {import(\"../canvas.js\").FillStrokeState} state State.\n     * @return {Array<*>} Fill instruction.\n     */\n  }, {\n    key: \"createFill\",\n    value: function createFill(state) {\n      var fillStyle = state.fillStyle;\n      /** @type {Array<*>} */\n      var fillInstruction = [CanvasInstruction.SET_FILL_STYLE, fillStyle];\n      if (typeof fillStyle !== 'string') {\n        // Fill is a pattern or gradient - align it!\n        fillInstruction.push(true);\n      }\n      return fillInstruction;\n    }\n\n    /**\n     * @param {import(\"../canvas.js\").FillStrokeState} state State.\n     */\n  }, {\n    key: \"applyStroke\",\n    value: function applyStroke(state) {\n      this.instructions.push(this.createStroke(state));\n    }\n\n    /**\n     * @param {import(\"../canvas.js\").FillStrokeState} state State.\n     * @return {Array<*>} Stroke instruction.\n     */\n  }, {\n    key: \"createStroke\",\n    value: function createStroke(state) {\n      return [CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap, state.lineJoin, state.miterLimit, this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio];\n    }\n\n    /**\n     * @param {import(\"../canvas.js\").FillStrokeState} state State.\n     * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState):Array<*>} createFill Create fill.\n     */\n  }, {\n    key: \"updateFillStyle\",\n    value: function updateFillStyle(state, createFill) {\n      var fillStyle = state.fillStyle;\n      if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {\n        if (fillStyle !== undefined) {\n          this.instructions.push(createFill.call(this, state));\n        }\n        state.currentFillStyle = fillStyle;\n      }\n    }\n\n    /**\n     * @param {import(\"../canvas.js\").FillStrokeState} state State.\n     * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState): void} applyStroke Apply stroke.\n     */\n  }, {\n    key: \"updateStrokeStyle\",\n    value: function updateStrokeStyle(state, applyStroke) {\n      var strokeStyle = state.strokeStyle;\n      var lineCap = state.lineCap;\n      var lineDash = state.lineDash;\n      var lineDashOffset = state.lineDashOffset;\n      var lineJoin = state.lineJoin;\n      var lineWidth = state.lineWidth;\n      var miterLimit = state.miterLimit;\n      if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !equals(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {\n        if (strokeStyle !== undefined) {\n          applyStroke.call(this, state);\n        }\n        state.currentStrokeStyle = strokeStyle;\n        state.currentLineCap = lineCap;\n        state.currentLineDash = lineDash;\n        state.currentLineDashOffset = lineDashOffset;\n        state.currentLineJoin = lineJoin;\n        state.currentLineWidth = lineWidth;\n        state.currentMiterLimit = miterLimit;\n      }\n    }\n\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     */\n  }, {\n    key: \"endGeometry\",\n    value: function endGeometry(feature) {\n      this.beginGeometryInstruction1_[2] = this.instructions.length;\n      this.beginGeometryInstruction1_ = null;\n      this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;\n      this.beginGeometryInstruction2_ = null;\n      var endGeometryInstruction = [CanvasInstruction.END_GEOMETRY, feature];\n      this.instructions.push(endGeometryInstruction);\n      this.hitDetectionInstructions.push(endGeometryInstruction);\n    }\n\n    /**\n     * Get the buffered rendering extent.  Rendering will be clipped to the extent\n     * provided to the constructor.  To account for symbolizers that may intersect\n     * this extent, we calculate a buffered extent (e.g. based on stroke width).\n     * @return {import(\"../../extent.js\").Extent} The buffered rendering extent.\n     * @protected\n     */\n  }, {\n    key: \"getBufferedMaxExtent\",\n    value: function getBufferedMaxExtent() {\n      if (!this.bufferedMaxExtent_) {\n        this.bufferedMaxExtent_ = clone(this.maxExtent);\n        if (this.maxLineWidth > 0) {\n          var width = this.resolution * (this.maxLineWidth + 1) / 2;\n          buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);\n        }\n      }\n      return this.bufferedMaxExtent_;\n    }\n  }]);\n}(VectorContext);\nexport default CanvasBuilder;","map":{"version":3,"names":["CanvasInstruction","Relationship","VectorContext","asColorLike","buffer","clone","containsCoordinate","coordinateRelationship","defaultFillStyle","defaultLineCap","defaultLineDash","defaultLineDashOffset","defaultLineJoin","defaultLineWidth","defaultMiterLimit","defaultStrokeStyle","equals","reverseSubArray","inflateCoordinates","inflateCoordinatesArray","inflateMultiCoordinatesArray","CanvasBuilder","_VectorContext","tolerance","maxExtent","resolution","pixelRatio","_this","_classCallCheck","_callSuper","maxLineWidth","beginGeometryInstruction1_","beginGeometryInstruction2_","bufferedMaxExtent_","instructions","coordinates","tmpCoordinate_","hitDetectionInstructions","state","_inherits","_createClass","key","value","applyPixelRatio","dashArray","map","dash","appendFlatPointCoordinates","flatCoordinates","stride","extent","getBufferedMaxExtent","tmpCoord","myEnd","length","i","ii","appendFlatLineCoordinates","offset","end","closed","skipFirst","lastXCoord","lastYCoord","nextCoord","skipped","lastRel","nextRel","INTERSECTING","drawCustomCoordinates_","ends","builderEnds","builderEnd","push","drawCustom","geometry","feature","renderer","hitDetectionRenderer","beginGeometry","type","getType","getStride","builderBegin","builderEndss","getOrientedFlatCoordinates","endss","getEndss","myEnds","CUSTOM","getFlatCoordinates","getEnds","endGeometry","BEGIN_GEOMETRY","finish","reverseHitDetectionInstructions","reverse","n","instruction","begin","END_GEOMETRY","setFillStrokeStyle","fillStyle","strokeStyle","fillStyleColor","getColor","undefined","strokeStyleColor","strokeStyleLineCap","getLineCap","lineCap","strokeStyleLineDash","getLineDash","lineDash","slice","strokeStyleLineDashOffset","getLineDashOffset","lineDashOffset","strokeStyleLineJoin","getLineJoin","lineJoin","strokeStyleWidth","getWidth","lineWidth","strokeStyleMiterLimit","getMiterLimit","miterLimit","createFill","fillInstruction","SET_FILL_STYLE","applyStroke","createStroke","SET_STROKE_STYLE","updateFillStyle","currentFillStyle","call","updateStrokeStyle","currentStrokeStyle","currentLineCap","currentLineDash","currentLineDashOffset","currentLineJoin","currentLineWidth","currentMiterLimit","endGeometryInstruction","width"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol/render/canvas/Builder.js"],"sourcesContent":["/**\n * @module ol/render/canvas/Builder\n */\nimport CanvasInstruction from './Instruction.js';\nimport Relationship from '../../extent/Relationship.js';\nimport VectorContext from '../VectorContext.js';\nimport {asColorLike} from '../../colorlike.js';\nimport {\n  buffer,\n  clone,\n  containsCoordinate,\n  coordinateRelationship,\n} from '../../extent.js';\nimport {\n  defaultFillStyle,\n  defaultLineCap,\n  defaultLineDash,\n  defaultLineDashOffset,\n  defaultLineJoin,\n  defaultLineWidth,\n  defaultMiterLimit,\n  defaultStrokeStyle,\n} from '../canvas.js';\nimport {equals, reverseSubArray} from '../../array.js';\nimport {\n  inflateCoordinates,\n  inflateCoordinatesArray,\n  inflateMultiCoordinatesArray,\n} from '../../geom/flat/inflate.js';\n\nclass CanvasBuilder extends VectorContext {\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   */\n  constructor(tolerance, maxExtent, resolution, pixelRatio) {\n    super();\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.tolerance = tolerance;\n\n    /**\n     * @protected\n     * @const\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.maxExtent = maxExtent;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.pixelRatio = pixelRatio;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.maxLineWidth = 0;\n\n    /**\n     * @protected\n     * @const\n     * @type {number}\n     */\n    this.resolution = resolution;\n\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n    this.beginGeometryInstruction1_ = null;\n\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n    this.beginGeometryInstruction2_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.bufferedMaxExtent_ = null;\n\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    this.instructions = [];\n\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n    this.coordinates = [];\n\n    /**\n     * @private\n     * @type {import(\"../../coordinate.js\").Coordinate}\n     */\n    this.tmpCoordinate_ = [];\n\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    this.hitDetectionInstructions = [];\n\n    /**\n     * @protected\n     * @type {import(\"../canvas.js\").FillStrokeState}\n     */\n    this.state = /** @type {import(\"../canvas.js\").FillStrokeState} */ ({});\n  }\n\n  /**\n   * @protected\n   * @param {Array<number>} dashArray Dash array.\n   * @return {Array<number>} Dash array with pixel ratio applied\n   */\n  applyPixelRatio(dashArray) {\n    const pixelRatio = this.pixelRatio;\n    return pixelRatio == 1\n      ? dashArray\n      : dashArray.map(function (dash) {\n          return dash * pixelRatio;\n        });\n  }\n\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} stride Stride.\n   * @protected\n   * @return {number} My end\n   */\n  appendFlatPointCoordinates(flatCoordinates, stride) {\n    const extent = this.getBufferedMaxExtent();\n    const tmpCoord = this.tmpCoordinate_;\n    const coordinates = this.coordinates;\n    let myEnd = coordinates.length;\n    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      tmpCoord[0] = flatCoordinates[i];\n      tmpCoord[1] = flatCoordinates[i + 1];\n      if (containsCoordinate(extent, tmpCoord)) {\n        coordinates[myEnd++] = tmpCoord[0];\n        coordinates[myEnd++] = tmpCoord[1];\n      }\n    }\n    return myEnd;\n  }\n\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {boolean} closed Last input coordinate equals first.\n   * @param {boolean} skipFirst Skip first coordinate.\n   * @protected\n   * @return {number} My end.\n   */\n  appendFlatLineCoordinates(\n    flatCoordinates,\n    offset,\n    end,\n    stride,\n    closed,\n    skipFirst\n  ) {\n    const coordinates = this.coordinates;\n    let myEnd = coordinates.length;\n    const extent = this.getBufferedMaxExtent();\n    if (skipFirst) {\n      offset += stride;\n    }\n    let lastXCoord = flatCoordinates[offset];\n    let lastYCoord = flatCoordinates[offset + 1];\n    const nextCoord = this.tmpCoordinate_;\n    let skipped = true;\n\n    let i, lastRel, nextRel;\n    for (i = offset + stride; i < end; i += stride) {\n      nextCoord[0] = flatCoordinates[i];\n      nextCoord[1] = flatCoordinates[i + 1];\n      nextRel = coordinateRelationship(extent, nextCoord);\n      if (nextRel !== lastRel) {\n        if (skipped) {\n          coordinates[myEnd++] = lastXCoord;\n          coordinates[myEnd++] = lastYCoord;\n          skipped = false;\n        }\n        coordinates[myEnd++] = nextCoord[0];\n        coordinates[myEnd++] = nextCoord[1];\n      } else if (nextRel === Relationship.INTERSECTING) {\n        coordinates[myEnd++] = nextCoord[0];\n        coordinates[myEnd++] = nextCoord[1];\n        skipped = false;\n      } else {\n        skipped = true;\n      }\n      lastXCoord = nextCoord[0];\n      lastYCoord = nextCoord[1];\n      lastRel = nextRel;\n    }\n\n    // Last coordinate equals first or only one point to append:\n    if ((closed && skipped) || i === offset + stride) {\n      coordinates[myEnd++] = lastXCoord;\n      coordinates[myEnd++] = lastYCoord;\n    }\n    return myEnd;\n  }\n\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {Array<number>} builderEnds Builder ends.\n   * @return {number} Offset.\n   */\n  drawCustomCoordinates_(flatCoordinates, offset, ends, stride, builderEnds) {\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      const end = ends[i];\n      const builderEnd = this.appendFlatLineCoordinates(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        false,\n        false\n      );\n      builderEnds.push(builderEnd);\n      offset = end;\n    }\n    return offset;\n  }\n\n  /**\n   * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {Function} renderer Renderer.\n   * @param {Function} hitDetectionRenderer Renderer.\n   */\n  drawCustom(geometry, feature, renderer, hitDetectionRenderer) {\n    this.beginGeometry(geometry, feature);\n\n    const type = geometry.getType();\n    const stride = geometry.getStride();\n    const builderBegin = this.coordinates.length;\n\n    let flatCoordinates, builderEnd, builderEnds, builderEndss;\n    let offset;\n\n    switch (type) {\n      case 'MultiPolygon':\n        flatCoordinates =\n          /** @type {import(\"../../geom/MultiPolygon.js\").default} */ (\n            geometry\n          ).getOrientedFlatCoordinates();\n        builderEndss = [];\n        const endss =\n          /** @type {import(\"../../geom/MultiPolygon.js\").default} */ (\n            geometry\n          ).getEndss();\n        offset = 0;\n        for (let i = 0, ii = endss.length; i < ii; ++i) {\n          const myEnds = [];\n          offset = this.drawCustomCoordinates_(\n            flatCoordinates,\n            offset,\n            endss[i],\n            stride,\n            myEnds\n          );\n          builderEndss.push(myEnds);\n        }\n        this.instructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEndss,\n          geometry,\n          renderer,\n          inflateMultiCoordinatesArray,\n        ]);\n        this.hitDetectionInstructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEndss,\n          geometry,\n          hitDetectionRenderer || renderer,\n          inflateMultiCoordinatesArray,\n        ]);\n        break;\n      case 'Polygon':\n      case 'MultiLineString':\n        builderEnds = [];\n        flatCoordinates =\n          type == 'Polygon'\n            ? /** @type {import(\"../../geom/Polygon.js\").default} */ (\n                geometry\n              ).getOrientedFlatCoordinates()\n            : geometry.getFlatCoordinates();\n        offset = this.drawCustomCoordinates_(\n          flatCoordinates,\n          0,\n          /** @type {import(\"../../geom/Polygon.js\").default|import(\"../../geom/MultiLineString.js\").default} */ (\n            geometry\n          ).getEnds(),\n          stride,\n          builderEnds\n        );\n        this.instructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEnds,\n          geometry,\n          renderer,\n          inflateCoordinatesArray,\n        ]);\n        this.hitDetectionInstructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEnds,\n          geometry,\n          hitDetectionRenderer || renderer,\n          inflateCoordinatesArray,\n        ]);\n        break;\n      case 'LineString':\n      case 'Circle':\n        flatCoordinates = geometry.getFlatCoordinates();\n        builderEnd = this.appendFlatLineCoordinates(\n          flatCoordinates,\n          0,\n          flatCoordinates.length,\n          stride,\n          false,\n          false\n        );\n        this.instructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEnd,\n          geometry,\n          renderer,\n          inflateCoordinates,\n        ]);\n        this.hitDetectionInstructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEnd,\n          geometry,\n          hitDetectionRenderer || renderer,\n          inflateCoordinates,\n        ]);\n        break;\n      case 'MultiPoint':\n        flatCoordinates = geometry.getFlatCoordinates();\n        builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);\n\n        if (builderEnd > builderBegin) {\n          this.instructions.push([\n            CanvasInstruction.CUSTOM,\n            builderBegin,\n            builderEnd,\n            geometry,\n            renderer,\n            inflateCoordinates,\n          ]);\n          this.hitDetectionInstructions.push([\n            CanvasInstruction.CUSTOM,\n            builderBegin,\n            builderEnd,\n            geometry,\n            hitDetectionRenderer || renderer,\n            inflateCoordinates,\n          ]);\n        }\n        break;\n      case 'Point':\n        flatCoordinates = geometry.getFlatCoordinates();\n        this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);\n        builderEnd = this.coordinates.length;\n\n        this.instructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEnd,\n          geometry,\n          renderer,\n        ]);\n        this.hitDetectionInstructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEnd,\n          geometry,\n          hitDetectionRenderer || renderer,\n        ]);\n        break;\n      default:\n    }\n    this.endGeometry(feature);\n  }\n\n  /**\n   * @protected\n   * @param {import(\"../../geom/Geometry\").default|import(\"../Feature.js\").default} geometry The geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n  beginGeometry(geometry, feature) {\n    this.beginGeometryInstruction1_ = [\n      CanvasInstruction.BEGIN_GEOMETRY,\n      feature,\n      0,\n      geometry,\n    ];\n    this.instructions.push(this.beginGeometryInstruction1_);\n    this.beginGeometryInstruction2_ = [\n      CanvasInstruction.BEGIN_GEOMETRY,\n      feature,\n      0,\n      geometry,\n    ];\n    this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);\n  }\n\n  /**\n   * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\n   */\n  finish() {\n    return {\n      instructions: this.instructions,\n      hitDetectionInstructions: this.hitDetectionInstructions,\n      coordinates: this.coordinates,\n    };\n  }\n\n  /**\n   * Reverse the hit detection instructions.\n   */\n  reverseHitDetectionInstructions() {\n    const hitDetectionInstructions = this.hitDetectionInstructions;\n    // step 1 - reverse array\n    hitDetectionInstructions.reverse();\n    // step 2 - reverse instructions within geometry blocks\n    let i;\n    const n = hitDetectionInstructions.length;\n    let instruction;\n    let type;\n    let begin = -1;\n    for (i = 0; i < n; ++i) {\n      instruction = hitDetectionInstructions[i];\n      type = /** @type {import(\"./Instruction.js\").default} */ (instruction[0]);\n      if (type == CanvasInstruction.END_GEOMETRY) {\n        begin = i;\n      } else if (type == CanvasInstruction.BEGIN_GEOMETRY) {\n        instruction[2] = i;\n        reverseSubArray(this.hitDetectionInstructions, begin, i);\n        begin = -1;\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../../style/Fill.js\").default} fillStyle Fill style.\n   * @param {import(\"../../style/Stroke.js\").default} strokeStyle Stroke style.\n   */\n  setFillStrokeStyle(fillStyle, strokeStyle) {\n    const state = this.state;\n    if (fillStyle) {\n      const fillStyleColor = fillStyle.getColor();\n      state.fillStyle = asColorLike(\n        fillStyleColor ? fillStyleColor : defaultFillStyle\n      );\n    } else {\n      state.fillStyle = undefined;\n    }\n    if (strokeStyle) {\n      const strokeStyleColor = strokeStyle.getColor();\n      state.strokeStyle = asColorLike(\n        strokeStyleColor ? strokeStyleColor : defaultStrokeStyle\n      );\n      const strokeStyleLineCap = strokeStyle.getLineCap();\n      state.lineCap =\n        strokeStyleLineCap !== undefined ? strokeStyleLineCap : defaultLineCap;\n      const strokeStyleLineDash = strokeStyle.getLineDash();\n      state.lineDash = strokeStyleLineDash\n        ? strokeStyleLineDash.slice()\n        : defaultLineDash;\n      const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n      state.lineDashOffset = strokeStyleLineDashOffset\n        ? strokeStyleLineDashOffset\n        : defaultLineDashOffset;\n      const strokeStyleLineJoin = strokeStyle.getLineJoin();\n      state.lineJoin =\n        strokeStyleLineJoin !== undefined\n          ? strokeStyleLineJoin\n          : defaultLineJoin;\n      const strokeStyleWidth = strokeStyle.getWidth();\n      state.lineWidth =\n        strokeStyleWidth !== undefined ? strokeStyleWidth : defaultLineWidth;\n      const strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n      state.miterLimit =\n        strokeStyleMiterLimit !== undefined\n          ? strokeStyleMiterLimit\n          : defaultMiterLimit;\n\n      if (state.lineWidth > this.maxLineWidth) {\n        this.maxLineWidth = state.lineWidth;\n        // invalidate the buffered max extent cache\n        this.bufferedMaxExtent_ = null;\n      }\n    } else {\n      state.strokeStyle = undefined;\n      state.lineCap = undefined;\n      state.lineDash = null;\n      state.lineDashOffset = undefined;\n      state.lineJoin = undefined;\n      state.lineWidth = undefined;\n      state.miterLimit = undefined;\n    }\n  }\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @return {Array<*>} Fill instruction.\n   */\n  createFill(state) {\n    const fillStyle = state.fillStyle;\n    /** @type {Array<*>} */\n    const fillInstruction = [CanvasInstruction.SET_FILL_STYLE, fillStyle];\n    if (typeof fillStyle !== 'string') {\n      // Fill is a pattern or gradient - align it!\n      fillInstruction.push(true);\n    }\n    return fillInstruction;\n  }\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   */\n  applyStroke(state) {\n    this.instructions.push(this.createStroke(state));\n  }\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @return {Array<*>} Stroke instruction.\n   */\n  createStroke(state) {\n    return [\n      CanvasInstruction.SET_STROKE_STYLE,\n      state.strokeStyle,\n      state.lineWidth * this.pixelRatio,\n      state.lineCap,\n      state.lineJoin,\n      state.miterLimit,\n      this.applyPixelRatio(state.lineDash),\n      state.lineDashOffset * this.pixelRatio,\n    ];\n  }\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState):Array<*>} createFill Create fill.\n   */\n  updateFillStyle(state, createFill) {\n    const fillStyle = state.fillStyle;\n    if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {\n      if (fillStyle !== undefined) {\n        this.instructions.push(createFill.call(this, state));\n      }\n      state.currentFillStyle = fillStyle;\n    }\n  }\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState): void} applyStroke Apply stroke.\n   */\n  updateStrokeStyle(state, applyStroke) {\n    const strokeStyle = state.strokeStyle;\n    const lineCap = state.lineCap;\n    const lineDash = state.lineDash;\n    const lineDashOffset = state.lineDashOffset;\n    const lineJoin = state.lineJoin;\n    const lineWidth = state.lineWidth;\n    const miterLimit = state.miterLimit;\n    if (\n      state.currentStrokeStyle != strokeStyle ||\n      state.currentLineCap != lineCap ||\n      (lineDash != state.currentLineDash &&\n        !equals(state.currentLineDash, lineDash)) ||\n      state.currentLineDashOffset != lineDashOffset ||\n      state.currentLineJoin != lineJoin ||\n      state.currentLineWidth != lineWidth ||\n      state.currentMiterLimit != miterLimit\n    ) {\n      if (strokeStyle !== undefined) {\n        applyStroke.call(this, state);\n      }\n      state.currentStrokeStyle = strokeStyle;\n      state.currentLineCap = lineCap;\n      state.currentLineDash = lineDash;\n      state.currentLineDashOffset = lineDashOffset;\n      state.currentLineJoin = lineJoin;\n      state.currentLineWidth = lineWidth;\n      state.currentMiterLimit = miterLimit;\n    }\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n  endGeometry(feature) {\n    this.beginGeometryInstruction1_[2] = this.instructions.length;\n    this.beginGeometryInstruction1_ = null;\n    this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;\n    this.beginGeometryInstruction2_ = null;\n    const endGeometryInstruction = [CanvasInstruction.END_GEOMETRY, feature];\n    this.instructions.push(endGeometryInstruction);\n    this.hitDetectionInstructions.push(endGeometryInstruction);\n  }\n\n  /**\n   * Get the buffered rendering extent.  Rendering will be clipped to the extent\n   * provided to the constructor.  To account for symbolizers that may intersect\n   * this extent, we calculate a buffered extent (e.g. based on stroke width).\n   * @return {import(\"../../extent.js\").Extent} The buffered rendering extent.\n   * @protected\n   */\n  getBufferedMaxExtent() {\n    if (!this.bufferedMaxExtent_) {\n      this.bufferedMaxExtent_ = clone(this.maxExtent);\n      if (this.maxLineWidth > 0) {\n        const width = (this.resolution * (this.maxLineWidth + 1)) / 2;\n        buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);\n      }\n    }\n    return this.bufferedMaxExtent_;\n  }\n}\n\nexport default CanvasBuilder;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}