{"ast":null,"code":"import _classCallCheck from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _callSuper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport \"core-js/modules/es.function.bind.js\";\n/**\n * @module ol/ImageTile\n */\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport { createCanvasContext2D } from './dom.js';\nimport { listenImage } from './Image.js';\nvar ImageTile = /*#__PURE__*/function (_Tile) {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {string} src Image source URI.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {import(\"./Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @param {import(\"./Tile.js\").Options} [options] Tile options.\n   */\n  function ImageTile(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {\n    var _this;\n    _classCallCheck(this, ImageTile);\n    _this = _callSuper(this, ImageTile, [tileCoord, state, options]);\n\n    /**\n     * @private\n     * @type {?string}\n     */\n    _this.crossOrigin_ = crossOrigin;\n\n    /**\n     * Image URI\n     *\n     * @private\n     * @type {string}\n     */\n    _this.src_ = src;\n    _this.key = src;\n\n    /**\n     * @private\n     * @type {HTMLImageElement|HTMLCanvasElement}\n     */\n    _this.image_ = new Image();\n    if (crossOrigin !== null) {\n      _this.image_.crossOrigin = crossOrigin;\n    }\n\n    /**\n     * @private\n     * @type {?function():void}\n     */\n    _this.unlisten_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./Tile.js\").LoadFunction}\n     */\n    _this.tileLoadFunction_ = tileLoadFunction;\n    return _this;\n  }\n\n  /**\n   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @api\n   */\n  _inherits(ImageTile, _Tile);\n  return _createClass(ImageTile, [{\n    key: \"getImage\",\n    value: function getImage() {\n      return this.image_;\n    }\n\n    /**\n     * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).\n     * @param {HTMLCanvasElement|HTMLImageElement} element Element.\n     */\n  }, {\n    key: \"setImage\",\n    value: function setImage(element) {\n      this.image_ = element;\n      this.state = TileState.LOADED;\n      this.unlistenImage_();\n      this.changed();\n    }\n\n    /**\n     * Tracks loading or read errors.\n     *\n     * @private\n     */\n  }, {\n    key: \"handleImageError_\",\n    value: function handleImageError_() {\n      this.state = TileState.ERROR;\n      this.unlistenImage_();\n      this.image_ = getBlankImage();\n      this.changed();\n    }\n\n    /**\n     * Tracks successful image load.\n     *\n     * @private\n     */\n  }, {\n    key: \"handleImageLoad_\",\n    value: function handleImageLoad_() {\n      var image = /** @type {HTMLImageElement} */this.image_;\n      if (image.naturalWidth && image.naturalHeight) {\n        this.state = TileState.LOADED;\n      } else {\n        this.state = TileState.EMPTY;\n      }\n      this.unlistenImage_();\n      this.changed();\n    }\n\n    /**\n     * Load the image or retry if loading previously failed.\n     * Loading is taken care of by the tile queue, and calling this method is\n     * only needed for preloading or for reloading in case of an error.\n     *\n     * To retry loading tiles on failed requests, use a custom `tileLoadFunction`\n     * that checks for error status codes and reloads only when the status code is\n     * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been\n     * made already:\n     *\n     * ```js\n     * const retryCodes = [408, 429, 500, 502, 503, 504];\n     * const retries = {};\n     * source.setTileLoadFunction((tile, src) => {\n     *   const image = tile.getImage();\n     *   fetch(src)\n     *     .then((response) => {\n     *       if (retryCodes.includes(response.status)) {\n     *         retries[src] = (retries[src] || 0) + 1;\n     *         if (retries[src] <= 3) {\n     *           setTimeout(() => tile.load(), retries[src] * 1000);\n     *         }\n     *         return Promise.reject();\n     *       }\n     *       return response.blob();\n     *     })\n     *     .then((blob) => {\n     *       const imageUrl = URL.createObjectURL(blob);\n     *       image.src = imageUrl;\n     *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);\n     *     })\n     *     .catch(() => tile.setState(3)); // error\n     * });\n     * ```\n     *\n     * @api\n     */\n  }, {\n    key: \"load\",\n    value: function load() {\n      if (this.state == TileState.ERROR) {\n        this.state = TileState.IDLE;\n        this.image_ = new Image();\n        if (this.crossOrigin_ !== null) {\n          this.image_.crossOrigin = this.crossOrigin_;\n        }\n      }\n      if (this.state == TileState.IDLE) {\n        this.state = TileState.LOADING;\n        this.changed();\n        this.tileLoadFunction_(this, this.src_);\n        this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));\n      }\n    }\n\n    /**\n     * Discards event handlers which listen for load completion or errors.\n     *\n     * @private\n     */\n  }, {\n    key: \"unlistenImage_\",\n    value: function unlistenImage_() {\n      if (this.unlisten_) {\n        this.unlisten_();\n        this.unlisten_ = null;\n      }\n    }\n  }]);\n}(Tile);\n/**\n * Get a 1-pixel blank image.\n * @return {HTMLCanvasElement} Blank image.\n */\nfunction getBlankImage() {\n  var ctx = createCanvasContext2D(1, 1);\n  ctx.fillStyle = 'rgba(0,0,0,0)';\n  ctx.fillRect(0, 0, 1, 1);\n  return ctx.canvas;\n}\nexport default ImageTile;","map":{"version":3,"names":["Tile","TileState","createCanvasContext2D","listenImage","ImageTile","_Tile","tileCoord","state","src","crossOrigin","tileLoadFunction","options","_this","_classCallCheck","_callSuper","crossOrigin_","src_","key","image_","Image","unlisten_","tileLoadFunction_","_inherits","_createClass","value","getImage","setImage","element","LOADED","unlistenImage_","changed","handleImageError_","ERROR","getBlankImage","handleImageLoad_","image","naturalWidth","naturalHeight","EMPTY","load","IDLE","LOADING","bind","ctx","fillStyle","fillRect","canvas"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol/ImageTile.js"],"sourcesContent":["/**\n * @module ol/ImageTile\n */\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport {createCanvasContext2D} from './dom.js';\nimport {listenImage} from './Image.js';\n\nclass ImageTile extends Tile {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {string} src Image source URI.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {import(\"./Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @param {import(\"./Tile.js\").Options} [options] Tile options.\n   */\n  constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {\n    super(tileCoord, state, options);\n\n    /**\n     * @private\n     * @type {?string}\n     */\n    this.crossOrigin_ = crossOrigin;\n\n    /**\n     * Image URI\n     *\n     * @private\n     * @type {string}\n     */\n    this.src_ = src;\n\n    this.key = src;\n\n    /**\n     * @private\n     * @type {HTMLImageElement|HTMLCanvasElement}\n     */\n    this.image_ = new Image();\n    if (crossOrigin !== null) {\n      this.image_.crossOrigin = crossOrigin;\n    }\n\n    /**\n     * @private\n     * @type {?function():void}\n     */\n    this.unlisten_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./Tile.js\").LoadFunction}\n     */\n    this.tileLoadFunction_ = tileLoadFunction;\n  }\n\n  /**\n   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @api\n   */\n  getImage() {\n    return this.image_;\n  }\n\n  /**\n   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).\n   * @param {HTMLCanvasElement|HTMLImageElement} element Element.\n   */\n  setImage(element) {\n    this.image_ = element;\n    this.state = TileState.LOADED;\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Tracks loading or read errors.\n   *\n   * @private\n   */\n  handleImageError_() {\n    this.state = TileState.ERROR;\n    this.unlistenImage_();\n    this.image_ = getBlankImage();\n    this.changed();\n  }\n\n  /**\n   * Tracks successful image load.\n   *\n   * @private\n   */\n  handleImageLoad_() {\n    const image = /** @type {HTMLImageElement} */ (this.image_);\n    if (image.naturalWidth && image.naturalHeight) {\n      this.state = TileState.LOADED;\n    } else {\n      this.state = TileState.EMPTY;\n    }\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   *\n   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`\n   * that checks for error status codes and reloads only when the status code is\n   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been\n   * made already:\n   *\n   * ```js\n   * const retryCodes = [408, 429, 500, 502, 503, 504];\n   * const retries = {};\n   * source.setTileLoadFunction((tile, src) => {\n   *   const image = tile.getImage();\n   *   fetch(src)\n   *     .then((response) => {\n   *       if (retryCodes.includes(response.status)) {\n   *         retries[src] = (retries[src] || 0) + 1;\n   *         if (retries[src] <= 3) {\n   *           setTimeout(() => tile.load(), retries[src] * 1000);\n   *         }\n   *         return Promise.reject();\n   *       }\n   *       return response.blob();\n   *     })\n   *     .then((blob) => {\n   *       const imageUrl = URL.createObjectURL(blob);\n   *       image.src = imageUrl;\n   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);\n   *     })\n   *     .catch(() => tile.setState(3)); // error\n   * });\n   * ```\n   *\n   * @api\n   */\n  load() {\n    if (this.state == TileState.ERROR) {\n      this.state = TileState.IDLE;\n      this.image_ = new Image();\n      if (this.crossOrigin_ !== null) {\n        this.image_.crossOrigin = this.crossOrigin_;\n      }\n    }\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      this.tileLoadFunction_(this, this.src_);\n      this.unlisten_ = listenImage(\n        this.image_,\n        this.handleImageLoad_.bind(this),\n        this.handleImageError_.bind(this)\n      );\n    }\n  }\n\n  /**\n   * Discards event handlers which listen for load completion or errors.\n   *\n   * @private\n   */\n  unlistenImage_() {\n    if (this.unlisten_) {\n      this.unlisten_();\n      this.unlisten_ = null;\n    }\n  }\n}\n\n/**\n * Get a 1-pixel blank image.\n * @return {HTMLCanvasElement} Blank image.\n */\nfunction getBlankImage() {\n  const ctx = createCanvasContext2D(1, 1);\n  ctx.fillStyle = 'rgba(0,0,0,0)';\n  ctx.fillRect(0, 0, 1, 1);\n  return ctx.canvas;\n}\n\nexport default ImageTile;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}