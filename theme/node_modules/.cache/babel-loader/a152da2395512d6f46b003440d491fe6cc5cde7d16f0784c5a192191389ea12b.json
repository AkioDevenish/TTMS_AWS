{"ast":null,"code":"import _classCallCheck from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _callSuper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.repeat.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\n/*\r\n  Copyright (c) 2016 Jean-Marc VIGLINO, \r\n  released under the CeCILL license (http://www.cecill.info/).\r\n*/\n\nimport ol_Object from 'ol/Object.js';\nimport { linear as ol_easing_linear } from 'ol/easing.js';\nimport ol_Map from 'ol/Map.js';\nimport { getCenter as ol_extent_getCenter } from 'ol/extent.js';\nimport { unByKey as ol_Observable_unByKey } from 'ol/Observable.js';\nimport ol_layer_Base from 'ol/layer/Base.js';\nimport ol_style_Style from 'ol/style/Style.js';\nimport ol_style_Circle from 'ol/style/Circle.js';\nimport ol_style_Stroke from 'ol/style/Stroke.js';\nimport ol_layer_Vector from 'ol/layer/Vector.js';\nimport ol_source_Vector from 'ol/source/Vector.js';\nimport ol_render_getVectorContext from '../util/getVectorContext.js';\nimport ol_ext_getVectorContextStyle from '../util/getVectorContextStyle.js';\n\n/** Feature animation base class\r\n * Use the {@link ol.Map#animateFeature} or {@link ol.layer.Vector#animateFeature} to animate a feature\r\n * on postcompose in a map or a layer\r\n* @constructor\r\n* @fires animationstart\r\n* @fires animating\r\n* @fires animationrepeat\r\n* @fires animationend\r\n* @fires drawing\r\n* @param {ol_featureAnimationOptions} options\r\n*\t@param {Number} options.duration duration of the animation in ms, default 1000\r\n*\t@param {bool} options.revers revers the animation direction\r\n*\t@param {Number} options.repeat number of time to repeat the animation, default 0\r\n*\t@param {ol.style.Style} options.hiddenStyle a style to display the feature when playing the animation\r\n*\t  to be used to make the feature selectable when playing animation \r\n*\t  (@see {@link ../examples/map.featureanimation.select.html}), default the feature \r\n*\t  will be hidden when playing (and not selectable)\r\n*\t@param {ol_easing_Function} options.fade an easing function used to fade in the feature, default none\r\n*\t@param {ol_easing_Function} options.easing an easing function for the animation, default ol_easing_linear\r\n*/\nvar ol_featureAnimation = /*#__PURE__*/function (_ol_Object) {\n  function olfeatureAnimation(options) {\n    var _this;\n    _classCallCheck(this, olfeatureAnimation);\n    options = options || {};\n    _this = _callSuper(this, olfeatureAnimation);\n    _this.duration_ = typeof options.duration == 'number' ? options.duration >= 0 ? options.duration : 0 : 1000;\n    _this.fade_ = typeof options.fade == 'function' ? options.fade : null;\n    _this.repeat_ = Number(options.repeat);\n    var easing = typeof options.easing == 'function' ? options.easing : ol_easing_linear;\n    if (options.revers) _this.easing_ = function (t) {\n      return 1 - easing(t);\n    };else _this.easing_ = easing;\n    _this.hiddenStyle = options.hiddenStyle;\n    return _this;\n  }\n  /** Draw a geometry\r\n  * @param {olx.animateFeatureEvent} e\r\n  * @param {ol.geom} geom geometry for shadow\r\n  * @param {ol.geom} shadow geometry for shadow (ie. style with zIndex = -1)\r\n  * @private\r\n  */\n  _inherits(olfeatureAnimation, _ol_Object);\n  return _createClass(olfeatureAnimation, [{\n    key: \"drawGeom_\",\n    value: function drawGeom_(e, geom, shadow) {\n      // Drawing event\n      var drawingEvt = {\n        type: 'drawing',\n        time: e.time,\n        feature: e.feature,\n        start: e.start,\n        stop: e.stop,\n        rotation: e.rotation,\n        style: e.style,\n        extra: e.extra\n      };\n      this.dispatchEvent(drawingEvt);\n      var style = drawingEvt.style instanceof Array ? drawingEvt.style : [drawingEvt.style];\n      // Draw\n      if (this.fade_) {\n        e.context.globalAlpha = this.fade_(1 - e.elapsed);\n      }\n      for (var i = 0; i < style.length; i++) {\n        // Prevent crach if the style is not ready (image not loaded)\n        try {\n          var vectorContext = e.vectorContext || ol_render_getVectorContext(e);\n          var s = ol_ext_getVectorContextStyle(e, style[i]);\n          vectorContext.setStyle(s);\n          if (s.getZIndex() < 0) {\n            vectorContext.drawGeometry(shadow || geom);\n          } else {\n            vectorContext.drawGeometry(geom);\n          }\n        } catch (error) {/* ok */}\n      }\n    }\n    /** Function to perform manipulations onpostcompose.\r\n     * This function is called with an ol_featureAnimationEvent argument.\r\n     * The function will be overridden by the child implementation.\r\n     * Return true to keep this function for the next frame, false to remove it.\r\n     * @param {ol_featureAnimationEvent} e\r\n     * @return {bool} true to continue animation.\r\n     * @api\r\n     */\n  }, {\n    key: \"animate\",\n    value: function animate(/* e */\n    ) {\n      return false;\n    }\n  }]);\n}(ol_Object);\n\n/** Hidden style: a transparent style\r\n */\nol_featureAnimation.hiddenStyle = new ol_style_Style({\n  image: new ol_style_Circle({}),\n  stroke: new ol_style_Stroke({\n    color: 'transparent'\n  })\n});\n\n/** An animation controler object an object to control animation with start, stop and isPlaying function.    \r\n * To be used with {@link olx.Map#animateFeature} or {@link ol.layer.Vector#animateFeature}\r\n * @typedef {Object} animationControler\r\n * @property {function} start - start animation.\r\n * @property {function} stop - stop animation option arguments can be passed in animationend event.\r\n * @property {function} isPlaying - return true if animation is playing.\r\n */\n\n/** Animate feature on a map\r\n * @function \r\n * @param {ol.Feature} feature Feature to animate\r\n * @param {ol_featureAnimation|Array<ol_featureAnimation>} fanim the animation to play\r\n * @return {animationControler} an object to control animation with start, stop and isPlaying function\r\n */\nol_Map.prototype.animateFeature = function (feature, fanim) {\n  // Get or create an animation layer associated with the map \n  var layer = this._featureAnimationLayer;\n  if (!layer) {\n    layer = this._featureAnimationLayer = new ol_layer_Vector({\n      source: new ol_source_Vector()\n    });\n    layer.setMap(this);\n  }\n  // Animate feature on this layer\n  layer.getSource().addFeature(feature);\n  var listener = fanim.on('animationend', function (e) {\n    if (e.feature === feature) {\n      // Remove feature on end\n      layer.getSource().removeFeature(feature);\n      ol_Observable_unByKey(listener);\n    }\n  });\n  layer.animateFeature(feature, fanim);\n};\n\n/** Animate feature on a vector layer \r\n * @fires animationstart, animationend\r\n * @param {ol.Feature} feature Feature to animate\r\n * @param {ol_featureAnimation|Array<ol_featureAnimation>} fanim the animation to play\r\n * @param {boolean} useFilter use the filters of the layer\r\n * @return {animationControler} an object to control animation with start, stop and isPlaying function\r\n */\nol_layer_Base.prototype.animateFeature = function (feature, fanim, useFilter) {\n  var self = this;\n  var listenerKey;\n\n  // Save style\n  var style = feature.getStyle();\n  var flashStyle = style || (this.getStyleFunction ? this.getStyleFunction()(feature) : null);\n  if (!flashStyle) flashStyle = [];\n  if (!(flashStyle instanceof Array)) flashStyle = [flashStyle];\n\n  // Structure pass for animating\n  var event = {\n    // Frame context\n    vectorContext: null,\n    frameState: null,\n    start: 0,\n    time: 0,\n    elapsed: 0,\n    extent: false,\n    // Feature information\n    feature: feature,\n    geom: feature.getGeometry(),\n    typeGeom: feature.getGeometry().getType(),\n    bbox: feature.getGeometry().getExtent(),\n    coord: ol_extent_getCenter(feature.getGeometry().getExtent()),\n    style: flashStyle\n  };\n  if (!(fanim instanceof Array)) fanim = [fanim];\n  // Remove null animations\n  for (var i = fanim.length - 1; i >= 0; i--) {\n    if (fanim[i].duration_ === 0) fanim.splice(i, 1);\n  }\n  var nb = 0,\n    step = 0;\n  // Filter availiable on the layer\n  var filters = useFilter && this.getFilters ? this.getFilters() : [];\n  function animate(e) {\n    event.type = e.type;\n    try {\n      event.vectorContext = e.vectorContext || ol_render_getVectorContext(e);\n    } catch (e) {/* nothing todo */}\n    event.frameState = e.frameState;\n    event.inversePixelTransform = e.inversePixelTransform;\n    if (!event.extent) {\n      event.extent = e.frameState.extent;\n      event.start = e.frameState.time;\n      event.context = e.context;\n    }\n    event.time = e.frameState.time - event.start;\n    event.elapsed = event.time / fanim[step].duration_;\n    if (event.elapsed > 1) event.elapsed = 1;\n\n    // Filter\n    e.context.save();\n    filters.forEach(function (f) {\n      if (f.get('active')) f.precompose(e);\n    });\n    if (this.getOpacity) {\n      e.context.globalAlpha = this.getOpacity();\n    }\n\n    // Before anim\n    /*\r\n    var beforeEvent = { \r\n      type: 'beforeanim', \r\n      step: step,\r\n      start: event.start,\r\n      time: event.time,\r\n      elapsed: event.elapsed,\r\n      rotation: event.rotation||0,\r\n      geom: event.geom,\r\n      coordinate: event.coord,\r\n      feature: feature,\r\n      extra: event.extra || {}, \r\n      style: flashStyle\r\n    };\r\n    fanim[step].dispatchEvent(beforeEvent);\r\n    self.dispatchEvent(beforeEvent);\r\n    */\n\n    // Stop animation?\n    if (!fanim[step].animate(event)) {\n      nb++;\n      // Repeat animation\n      if (nb < fanim[step].repeat_) {\n        event.extent = false;\n        fanim[step].dispatchEvent({\n          type: 'animationrepeat',\n          feature: feature\n        });\n      } else if (step < fanim.length - 1) {\n        // newt step\n        fanim[step].dispatchEvent({\n          type: 'animationend',\n          feature: feature\n        });\n        step++;\n        nb = 0;\n        event.extent = false;\n      } else {\n        // the end\n        stop();\n      }\n    } else {\n      var animEvent = {\n        type: 'animating',\n        step: step,\n        start: event.start,\n        time: event.time,\n        elapsed: event.elapsed,\n        rotation: event.rotation || 0,\n        geom: event.geom,\n        coordinate: event.coord,\n        feature: feature,\n        extra: event.extra || {},\n        style: flashStyle\n      };\n      fanim[step].dispatchEvent(animEvent);\n      self.dispatchEvent(animEvent);\n    }\n    filters.forEach(function (f) {\n      if (f.get('active')) f.postcompose(e);\n    });\n    e.context.restore();\n\n    // tell OL3 to continue postcompose animation\n    e.frameState.animate = true;\n  }\n\n  // Stop animation\n  function stop(options) {\n    ol_Observable_unByKey(listenerKey);\n    listenerKey = null;\n    feature.setStyle(style);\n    event.stop = new Date().getTime();\n    // Send event\n    var eventEnd = {\n      type: 'animationend',\n      feature: feature\n    };\n    if (options) {\n      for (var i in options) if (options.hasOwnProperty(i)) {\n        eventEnd[i] = options[i];\n      }\n    }\n    fanim[step].dispatchEvent(eventEnd);\n    self.dispatchEvent(eventEnd);\n  }\n\n  // Launch animation\n  function start(options) {\n    if (fanim.length && !listenerKey) {\n      // Restart at stop time\n      if (event.stop) {\n        event.start = new Date().getTime() - event.stop + event.start;\n        event.stop = 0;\n      }\n      // Compose\n      listenerKey = self.on(['postcompose', 'postrender'], animate.bind(self));\n      // map or layer?\n      if (self.renderSync) {\n        try {\n          self.renderSync();\n        } catch (e) {/* ok */}\n      } else {\n        self.changed();\n      }\n      // Hide feature while animating\n      feature.setStyle(fanim[step].hiddenStyle || ol_featureAnimation.hiddenStyle);\n      // Send event\n      var eventStart = {\n        type: 'animationstart',\n        feature: feature\n      };\n      if (options) {\n        for (var i in options) if (options.hasOwnProperty(i)) {\n          eventStart[i] = options[i];\n        }\n      }\n      fanim[step].dispatchEvent(eventStart);\n      self.dispatchEvent(eventStart);\n    }\n  }\n  start();\n\n  // Return animation controler\n  return {\n    start: start,\n    stop: stop,\n    isPlaying: function isPlaying() {\n      return !!listenerKey;\n    }\n  };\n};\nexport default ol_featureAnimation;","map":{"version":3,"names":["ol_Object","linear","ol_easing_linear","ol_Map","getCenter","ol_extent_getCenter","unByKey","ol_Observable_unByKey","ol_layer_Base","ol_style_Style","ol_style_Circle","ol_style_Stroke","ol_layer_Vector","ol_source_Vector","ol_render_getVectorContext","ol_ext_getVectorContextStyle","ol_featureAnimation","_ol_Object","olfeatureAnimation","options","_this","_classCallCheck","_callSuper","duration_","duration","fade_","fade","repeat_","Number","repeat","easing","revers","easing_","t","hiddenStyle","_inherits","_createClass","key","value","drawGeom_","e","geom","shadow","drawingEvt","type","time","feature","start","stop","rotation","style","extra","dispatchEvent","Array","context","globalAlpha","elapsed","i","length","vectorContext","s","setStyle","getZIndex","drawGeometry","error","animate","image","stroke","color","prototype","animateFeature","fanim","layer","_featureAnimationLayer","source","setMap","getSource","addFeature","listener","on","removeFeature","useFilter","self","listenerKey","getStyle","flashStyle","getStyleFunction","event","frameState","extent","getGeometry","typeGeom","getType","bbox","getExtent","coord","splice","nb","step","filters","getFilters","inversePixelTransform","save","forEach","f","get","precompose","getOpacity","animEvent","coordinate","postcompose","restore","Date","getTime","eventEnd","hasOwnProperty","bind","renderSync","changed","eventStart","isPlaying"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol-ext/featureanimation/FeatureAnimation.js"],"sourcesContent":["/*\r\n  Copyright (c) 2016 Jean-Marc VIGLINO, \r\n  released under the CeCILL license (http://www.cecill.info/).\r\n*/\r\n\r\nimport ol_Object from 'ol/Object.js'\r\nimport {linear as ol_easing_linear} from 'ol/easing.js'\r\nimport ol_Map from 'ol/Map.js'\r\nimport {getCenter as ol_extent_getCenter} from 'ol/extent.js'\r\nimport {unByKey as ol_Observable_unByKey} from 'ol/Observable.js'\r\nimport ol_layer_Base from 'ol/layer/Base.js'\r\nimport ol_style_Style from 'ol/style/Style.js'\r\nimport ol_style_Circle from 'ol/style/Circle.js'\r\nimport ol_style_Stroke from 'ol/style/Stroke.js'\r\nimport ol_layer_Vector from 'ol/layer/Vector.js'\r\nimport ol_source_Vector from 'ol/source/Vector.js'\r\n\r\nimport ol_render_getVectorContext from '../util/getVectorContext.js';\r\nimport ol_ext_getVectorContextStyle from '../util/getVectorContextStyle.js'\r\n\r\n/** Feature animation base class\r\n * Use the {@link ol.Map#animateFeature} or {@link ol.layer.Vector#animateFeature} to animate a feature\r\n * on postcompose in a map or a layer\r\n* @constructor\r\n* @fires animationstart\r\n* @fires animating\r\n* @fires animationrepeat\r\n* @fires animationend\r\n* @fires drawing\r\n* @param {ol_featureAnimationOptions} options\r\n*\t@param {Number} options.duration duration of the animation in ms, default 1000\r\n*\t@param {bool} options.revers revers the animation direction\r\n*\t@param {Number} options.repeat number of time to repeat the animation, default 0\r\n*\t@param {ol.style.Style} options.hiddenStyle a style to display the feature when playing the animation\r\n*\t  to be used to make the feature selectable when playing animation \r\n*\t  (@see {@link ../examples/map.featureanimation.select.html}), default the feature \r\n*\t  will be hidden when playing (and not selectable)\r\n*\t@param {ol_easing_Function} options.fade an easing function used to fade in the feature, default none\r\n*\t@param {ol_easing_Function} options.easing an easing function for the animation, default ol_easing_linear\r\n*/\r\nvar ol_featureAnimation = class olfeatureAnimation extends ol_Object {\r\n  constructor(options) {\r\n    options = options || {}\r\n    super();\r\n\r\n    this.duration_ = typeof (options.duration) == 'number' ? (options.duration >= 0 ? options.duration : 0) : 1000\r\n    this.fade_ = typeof (options.fade) == 'function' ? options.fade : null\r\n    this.repeat_ = Number(options.repeat)\r\n\r\n    var easing = typeof (options.easing) == 'function' ? options.easing : ol_easing_linear\r\n    if (options.revers)\r\n      this.easing_ = function (t) { return (1 - easing(t)) }\r\n    else\r\n      this.easing_ = easing\r\n\r\n    this.hiddenStyle = options.hiddenStyle\r\n  }\r\n  /** Draw a geometry\r\n  * @param {olx.animateFeatureEvent} e\r\n  * @param {ol.geom} geom geometry for shadow\r\n  * @param {ol.geom} shadow geometry for shadow (ie. style with zIndex = -1)\r\n  * @private\r\n  */\r\n  drawGeom_(e, geom, shadow) {\r\n    // Drawing event\r\n    var drawingEvt = {\r\n      type: 'drawing',\r\n      time: e.time,\r\n      feature: e.feature,\r\n      start: e.start,\r\n      stop: e.stop,\r\n      rotation: e.rotation,\r\n      style: e.style,\r\n      extra: e.extra\r\n    }\r\n    this.dispatchEvent(drawingEvt)\r\n    var style = (drawingEvt.style instanceof Array) ? drawingEvt.style : [drawingEvt.style];\r\n    // Draw\r\n    if (this.fade_) {\r\n      e.context.globalAlpha = this.fade_(1 - e.elapsed)\r\n    }\r\n    for (var i = 0; i < style.length; i++) {\r\n      // Prevent crach if the style is not ready (image not loaded)\r\n      try {\r\n        var vectorContext = e.vectorContext || ol_render_getVectorContext(e)\r\n        var s = ol_ext_getVectorContextStyle(e, style[i])\r\n        vectorContext.setStyle(s)\r\n        if (s.getZIndex() < 0) {\r\n          vectorContext.drawGeometry(shadow || geom)\r\n        } else {\r\n          vectorContext.drawGeometry(geom)\r\n        }\r\n      } catch (error) { /* ok */ }\r\n    }\r\n  }\r\n  /** Function to perform manipulations onpostcompose.\r\n   * This function is called with an ol_featureAnimationEvent argument.\r\n   * The function will be overridden by the child implementation.\r\n   * Return true to keep this function for the next frame, false to remove it.\r\n   * @param {ol_featureAnimationEvent} e\r\n   * @return {bool} true to continue animation.\r\n   * @api\r\n   */\r\n  animate( /* e */) {\r\n    return false\r\n  }\r\n}\r\n\r\n/** Hidden style: a transparent style\r\n */\r\nol_featureAnimation.hiddenStyle = new ol_style_Style({ \r\n  image: new ol_style_Circle({}), \r\n  stroke: new ol_style_Stroke({ \r\n    color: 'transparent' \r\n  }) \r\n});\r\n\r\n/** An animation controler object an object to control animation with start, stop and isPlaying function.    \r\n * To be used with {@link olx.Map#animateFeature} or {@link ol.layer.Vector#animateFeature}\r\n * @typedef {Object} animationControler\r\n * @property {function} start - start animation.\r\n * @property {function} stop - stop animation option arguments can be passed in animationend event.\r\n * @property {function} isPlaying - return true if animation is playing.\r\n */\r\n\r\n/** Animate feature on a map\r\n * @function \r\n * @param {ol.Feature} feature Feature to animate\r\n * @param {ol_featureAnimation|Array<ol_featureAnimation>} fanim the animation to play\r\n * @return {animationControler} an object to control animation with start, stop and isPlaying function\r\n */\r\nol_Map.prototype.animateFeature = function(feature, fanim) {\r\n  // Get or create an animation layer associated with the map \r\n  var layer = this._featureAnimationLayer;\r\n  if (!layer) {\r\n    layer = this._featureAnimationLayer = new ol_layer_Vector({ source: new ol_source_Vector() });\r\n    layer.setMap(this);\r\n  }\r\n  // Animate feature on this layer\r\n  layer.getSource().addFeature(feature);\r\n  var listener = fanim.on('animationend', function(e) {\r\n    if (e.feature===feature) {\r\n      // Remove feature on end\r\n      layer.getSource().removeFeature(feature);\r\n      ol_Observable_unByKey(listener);\r\n    }\r\n  });\r\n  layer.animateFeature(feature, fanim);\r\n};\r\n\r\n/** Animate feature on a vector layer \r\n * @fires animationstart, animationend\r\n * @param {ol.Feature} feature Feature to animate\r\n * @param {ol_featureAnimation|Array<ol_featureAnimation>} fanim the animation to play\r\n * @param {boolean} useFilter use the filters of the layer\r\n * @return {animationControler} an object to control animation with start, stop and isPlaying function\r\n */\r\nol_layer_Base.prototype.animateFeature = function(feature, fanim, useFilter) {\r\n  var self = this;\r\n  var listenerKey;\r\n\r\n  // Save style\r\n  var style = feature.getStyle();\r\n  var flashStyle = style || (this.getStyleFunction ? this.getStyleFunction()(feature) : null);\r\n  if (!flashStyle) flashStyle=[];\r\n  if (!(flashStyle instanceof Array)) flashStyle = [flashStyle];\r\n\r\n  // Structure pass for animating\r\n  var event = {\r\n    // Frame context\r\n    vectorContext: null,\r\n    frameState: null,\r\n    start: 0,\r\n    time: 0,\r\n    elapsed: 0,\r\n    extent: false,\r\n    // Feature information\r\n    feature: feature,\r\n    geom: feature.getGeometry(),\r\n    typeGeom: feature.getGeometry().getType(),\r\n    bbox: feature.getGeometry().getExtent(),\r\n    coord: ol_extent_getCenter(feature.getGeometry().getExtent()),\r\n    style: flashStyle\r\n  };\r\n\r\n  if (!(fanim instanceof Array)) fanim = [fanim];\r\n  // Remove null animations\r\n  for (var i=fanim.length-1; i>=0; i--) {\r\n    if (fanim[i].duration_===0) fanim.splice(i,1);\r\n  }\r\n\r\n  var nb=0, step = 0;\r\n  // Filter availiable on the layer\r\n  var filters = (useFilter && this.getFilters) ? this.getFilters() : [];\r\n\r\n  function animate(e) {\r\n    event.type = e.type;\r\n    try {\r\n      event.vectorContext = e.vectorContext || ol_render_getVectorContext(e);\r\n    } catch(e) { /* nothing todo */ }\r\n    event.frameState = e.frameState;\r\n    event.inversePixelTransform = e.inversePixelTransform;\r\n    if (!event.extent) {\r\n      event.extent = e.frameState.extent;\r\n      event.start = e.frameState.time;\r\n      event.context = e.context;\r\n    }\r\n    event.time = e.frameState.time - event.start;\r\n    event.elapsed = event.time / fanim[step].duration_;\r\n    if (event.elapsed > 1) event.elapsed = 1;\r\n\r\n    // Filter\r\n    e.context.save();\r\n    filters.forEach(function(f) {\r\n      if (f.get('active')) f.precompose(e);\r\n    });\r\n    if (this.getOpacity) {\r\n      e.context.globalAlpha = this.getOpacity();\r\n    }\r\n    \r\n    // Before anim\r\n    /*\r\n    var beforeEvent = { \r\n      type: 'beforeanim', \r\n      step: step,\r\n      start: event.start,\r\n      time: event.time,\r\n      elapsed: event.elapsed,\r\n      rotation: event.rotation||0,\r\n      geom: event.geom,\r\n      coordinate: event.coord,\r\n      feature: feature,\r\n      extra: event.extra || {}, \r\n      style: flashStyle\r\n    };\r\n    fanim[step].dispatchEvent(beforeEvent);\r\n    self.dispatchEvent(beforeEvent);\r\n    */\r\n\r\n    // Stop animation?\r\n    if (!fanim[step].animate(event)) {\r\n      nb++;\r\n      // Repeat animation\r\n      if (nb < fanim[step].repeat_) {\r\n        event.extent = false;\r\n        fanim[step].dispatchEvent({ type:'animationrepeat', feature: feature });\r\n      } else if (step < fanim.length-1) {\r\n        // newt step\r\n        fanim[step].dispatchEvent({ type:'animationend', feature: feature });\r\n        step++;\r\n        nb=0;\r\n        event.extent = false;\r\n      } else {\r\n        // the end\r\n        stop();\r\n      }\r\n    } else {\r\n      var animEvent = { \r\n        type: 'animating', \r\n        step: step,\r\n        start: event.start,\r\n        time: event.time,\r\n        elapsed: event.elapsed,\r\n        rotation: event.rotation||0,\r\n        geom: event.geom,\r\n        coordinate: event.coord,\r\n        feature: feature,\r\n        extra: event.extra || {}, \r\n        style: flashStyle\r\n      };\r\n      fanim[step].dispatchEvent(animEvent);\r\n      self.dispatchEvent(animEvent);\r\n    }\r\n\r\n    filters.forEach(function(f) {\r\n      if (f.get('active')) f.postcompose(e);\r\n    });\r\n    e.context.restore();\r\n\r\n    // tell OL3 to continue postcompose animation\r\n    e.frameState.animate = true;\r\n  }\r\n\r\n  // Stop animation\r\n  function stop(options) {\r\n    ol_Observable_unByKey(listenerKey);\r\n    listenerKey = null;\r\n    feature.setStyle(style);\r\n    event.stop = (new Date).getTime();\r\n    // Send event\r\n    var eventEnd = { type:'animationend', feature: feature };\r\n    if (options) {\r\n      for (var i in options) if (options.hasOwnProperty(i)) {\r\n        eventEnd[i] = options[i]; \r\n      }\r\n    }\r\n    fanim[step].dispatchEvent(eventEnd);\r\n    self.dispatchEvent(eventEnd);\r\n  }\r\n\r\n  // Launch animation\r\n  function start(options) {\r\n    if (fanim.length && !listenerKey) {\r\n      // Restart at stop time\r\n      if (event.stop) {\r\n        event.start = (new Date).getTime() - event.stop + event.start;\r\n        event.stop = 0;\r\n      }\r\n      // Compose\r\n      listenerKey = self.on(['postcompose','postrender'], animate.bind(self));\r\n      // map or layer?\r\n      if (self.renderSync) {\r\n        try { self.renderSync(); } catch(e) { /* ok */ }\r\n      } else {\r\n        self.changed();\r\n      }\r\n      // Hide feature while animating\r\n      feature.setStyle(fanim[step].hiddenStyle || ol_featureAnimation.hiddenStyle);\r\n      // Send event\r\n      var eventStart = { type:'animationstart', feature: feature };\r\n      if (options) {\r\n        for (var i in options) if (options.hasOwnProperty(i)) {\r\n          eventStart[i] = options[i]; \r\n        }\r\n      }\r\n      fanim[step].dispatchEvent(eventStart);\r\n      self.dispatchEvent(eventStart);\r\n    }\r\n  }\r\n  start();\r\n\r\n  // Return animation controler\r\n  return {\r\n    start: start,\r\n    stop: stop,\r\n    isPlaying: function() { return (!!listenerKey); }\r\n  };\r\n};\r\n\r\nexport default ol_featureAnimation\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}