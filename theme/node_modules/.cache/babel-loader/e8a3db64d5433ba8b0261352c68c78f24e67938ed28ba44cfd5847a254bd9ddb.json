{"ast":null,"code":"import _classCallCheck from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _callSuper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.constructor.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.data-view.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.date.now.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.uint16-array.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\n/**\n * @module ol/webgl/Helper\n */\nimport ContextEventType from '../webgl/ContextEventType.js';\nimport Disposable from '../Disposable.js';\nimport WebGLPostProcessingPass from './PostProcessingPass.js';\nimport { FLOAT, UNSIGNED_BYTE, UNSIGNED_INT, UNSIGNED_SHORT, getContext } from '../webgl.js';\nimport { clear } from '../obj.js';\nimport { compose as composeTransform, create as createTransform } from '../transform.js';\nimport { create, fromTransform } from '../vec/mat4.js';\nimport { getUid } from '../util.js';\n\n/**\n * @typedef {Object} BufferCacheEntry\n * @property {import(\"./Buffer.js\").default} buffer Buffer.\n * @property {WebGLBuffer} webGlBuffer WebGlBuffer.\n */\n\n/**\n * Shader types, either `FRAGMENT_SHADER` or `VERTEX_SHADER`.\n * @enum {number}\n */\nexport var ShaderType = {\n  FRAGMENT_SHADER: 0x8b30,\n  VERTEX_SHADER: 0x8b31\n};\n\n/**\n * Names of uniforms made available to all shaders.\n * Please note: changing these *will* break custom shaders!\n * @enum {string}\n */\nexport var DefaultUniform = {\n  PROJECTION_MATRIX: 'u_projectionMatrix',\n  SCREEN_TO_WORLD_MATRIX: 'u_screenToWorldMatrix',\n  TIME: 'u_time',\n  ZOOM: 'u_zoom',\n  RESOLUTION: 'u_resolution',\n  ROTATION: 'u_rotation',\n  VIEWPORT_SIZE_PX: 'u_viewportSizePx',\n  PIXEL_RATIO: 'u_pixelRatio',\n  HIT_DETECTION: 'u_hitDetection'\n};\n\n/**\n * Attribute types, either `UNSIGNED_BYTE`, `UNSIGNED_SHORT`, `UNSIGNED_INT` or `FLOAT`\n * Note: an attribute stored in a `Float32Array` should be of type `FLOAT`.\n * @enum {number}\n */\nexport var AttributeType = {\n  UNSIGNED_BYTE: UNSIGNED_BYTE,\n  UNSIGNED_SHORT: UNSIGNED_SHORT,\n  UNSIGNED_INT: UNSIGNED_INT,\n  FLOAT: FLOAT\n};\n\n/**\n * Description of an attribute in a buffer\n * @typedef {Object} AttributeDescription\n * @property {string} name Attribute name to use in shaders\n * @property {number} size Number of components per attributes\n * @property {AttributeType} [type] Attribute type, i.e. number of bytes used to store the value. This is\n * determined by the class of typed array which the buffer uses (eg. `Float32Array` for a `FLOAT` attribute).\n * Default is `FLOAT`.\n */\n\n/**\n * @typedef {number|Array<number>|HTMLCanvasElement|HTMLImageElement|ImageData|import(\"../transform\").Transform} UniformLiteralValue\n */\n\n/**\n * Uniform value can be a number, array of numbers (2 to 4), canvas element or a callback returning\n * one of the previous types.\n * @typedef {UniformLiteralValue|function(import(\"../Map.js\").FrameState):UniformLiteralValue} UniformValue\n */\n\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas which will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n\n/**\n * @typedef {Object} Options\n * @property {Object<string,UniformValue>} [uniforms] Uniform definitions; property names must match the uniform\n * names in the provided or default shaders.\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n * @property {string} [canvasCacheKey] The cache key for the canvas.\n */\n\n/**\n * @typedef {Object} UniformInternalDescription\n * @property {string} name Name\n * @property {UniformValue} [value] Value\n * @property {UniformValue} [prevValue] The previous value.\n * @property {WebGLTexture} [texture] Texture\n * @private\n */\n\n/**\n * @typedef {Object} CanvasCacheItem\n * @property {WebGLRenderingContext} context The context of this canvas.\n * @property {number} users The count of users of this canvas.\n */\n\n/**\n * @type {Object<string,CanvasCacheItem>}\n */\nvar canvasCache = {};\n\n/**\n * @param {string} key The cache key for the canvas.\n * @return {string} The shared cache key.\n */\nfunction getSharedCanvasCacheKey(key) {\n  return 'shared/' + key;\n}\nvar uniqueCanvasCacheKeyCount = 0;\n\n/**\n * @return {string} The unique cache key.\n */\nfunction getUniqueCanvasCacheKey() {\n  var key = 'unique/' + uniqueCanvasCacheKeyCount;\n  uniqueCanvasCacheKeyCount += 1;\n  return key;\n}\n\n/**\n * @param {string} key The cache key for the canvas.\n * @return {WebGLRenderingContext} The canvas.\n */\nfunction getOrCreateContext(key) {\n  var cacheItem = canvasCache[key];\n  if (!cacheItem) {\n    var canvas = document.createElement('canvas');\n    canvas.width = 1;\n    canvas.height = 1;\n    canvas.style.position = 'absolute';\n    canvas.style.left = '0';\n    var context = getContext(canvas);\n    cacheItem = {\n      users: 0,\n      context: context\n    };\n    canvasCache[key] = cacheItem;\n  }\n  cacheItem.users += 1;\n  return cacheItem.context;\n}\n\n/**\n * @param {string} key The cache key for the canvas.\n */\nfunction releaseCanvas(key) {\n  var cacheItem = canvasCache[key];\n  if (!cacheItem) {\n    return;\n  }\n  cacheItem.users -= 1;\n  if (cacheItem.users > 0) {\n    return;\n  }\n  var gl = cacheItem.context;\n  var extension = gl.getExtension('WEBGL_lose_context');\n  if (extension) {\n    extension.loseContext();\n  }\n  var canvas = gl.canvas;\n  canvas.width = 1;\n  canvas.height = 1;\n  delete canvasCache[key];\n}\n\n/**\n * @classdesc\n * This class is intended to provide low-level functions related to WebGL rendering, so that accessing\n * directly the WebGL API should not be required anymore.\n *\n * Several operations are handled by the `WebGLHelper` class:\n *\n * ### Define custom shaders and uniforms\n *\n *   *Shaders* are low-level programs executed on the GPU and written in GLSL. There are two types of shaders:\n *\n *   Vertex shaders are used to manipulate the position and attribute of *vertices* of rendered primitives (ie. corners of a square).\n *   Outputs are:\n *\n *   * `gl_Position`: position of the vertex in screen space\n *\n *   * Varyings usually prefixed with `v_` are passed on to the fragment shader\n *\n *   Fragment shaders are used to control the actual color of the pixels drawn on screen. Their only output is `gl_FragColor`.\n *\n *   Both shaders can take *uniforms* or *attributes* as input. Attributes are explained later. Uniforms are common, read-only values that\n *   can be changed at every frame and can be of type float, arrays of float or images.\n *\n *   Shaders must be compiled and assembled into a program like so:\n *   ```js\n *   // here we simply create two shaders and assemble them in a program which is then used\n *   // for subsequent rendering calls; note how a frameState is required to set up a program,\n *   // as several default uniforms are computed from it (projection matrix, zoom level, etc.)\n *   const vertexShader = new WebGLVertex(VERTEX_SHADER);\n *   const fragmentShader = new WebGLFragment(FRAGMENT_SHADER);\n *   const program = this.context.getProgram(fragmentShader, vertexShader);\n *   helper.useProgram(this.program, frameState);\n *   ```\n *\n *   Uniforms are defined using the `uniforms` option and can either be explicit values or callbacks taking the frame state as argument.\n *   You can also change their value along the way like so:\n *   ```js\n *   helper.setUniformFloatValue('u_value', valueAsNumber);\n *   ```\n *\n * ### Defining post processing passes\n *\n *   *Post processing* describes the act of rendering primitives to a texture, and then rendering this texture to the final canvas\n *   while applying special effects in screen space.\n *   Typical uses are: blurring, color manipulation, depth of field, filtering...\n *\n *   The `WebGLHelper` class offers the possibility to define post processes at creation time using the `postProcesses` option.\n *   A post process step accepts the following options:\n *\n *   * `fragmentShader` and `vertexShader`: text literals in GLSL language that will be compiled and used in the post processing step.\n *   * `uniforms`: uniforms can be defined for the post processing steps just like for the main render.\n *   * `scaleRatio`: allows using an intermediate texture smaller or higher than the final canvas in the post processing step.\n *     This is typically used in blur steps to reduce the performance overhead by using an already downsampled texture as input.\n *\n *   The {@link module:ol/webgl/PostProcessingPass~WebGLPostProcessingPass} class is used internally, refer to its documentation for more info.\n *\n * ### Binding WebGL buffers and flushing data into them\n *\n *   Data that must be passed to the GPU has to be transferred using {@link module:ol/webgl/Buffer~WebGLArrayBuffer} objects.\n *   A buffer has to be created only once, but must be bound every time the buffer content will be used for rendering.\n *   This is done using {@link bindBuffer}.\n *   When the buffer's array content has changed, the new data has to be flushed to the GPU memory; this is done using\n *   {@link flushBufferData}. Note: this operation is expensive and should be done as infrequently as possible.\n *\n *   When binding an array buffer, a `target` parameter must be given: it should be either {@link module:ol/webgl.ARRAY_BUFFER}\n *   (if the buffer contains vertices data) or {@link module:ol/webgl.ELEMENT_ARRAY_BUFFER} (if the buffer contains indices data).\n *\n *   Examples below:\n *   ```js\n *   // at initialization phase\n *   const verticesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);\n *   const indicesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);\n *\n *   // when array values have changed\n *   helper.flushBufferData(ARRAY_BUFFER, this.verticesBuffer);\n *   helper.flushBufferData(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n *\n *   // at rendering phase\n *   helper.bindBuffer(ARRAY_BUFFER, this.verticesBuffer);\n *   helper.bindBuffer(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n *   ```\n *\n * ### Specifying attributes\n *\n *   The GPU only receives the data as arrays of numbers. These numbers must be handled differently depending on what it describes (position, texture coordinate...).\n *   Attributes are used to specify these uses. Specify the attribute names with\n *   {@link module:ol/webgl/Helper~WebGLHelper#enableAttributes} (see code snippet below).\n *\n *   Please note that you will have to specify the type and offset of the attributes in the data array. You can refer to the documentation of [WebGLRenderingContext.vertexAttribPointer](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer) for more explanation.\n *   ```js\n *   // here we indicate that the data array has the following structure:\n *   // [posX, posY, offsetX, offsetY, texCoordU, texCoordV, posX, posY, ...]\n *   helper.enableAttributes([\n *     {\n *        name: 'a_position',\n *        size: 2\n *     },\n *     {\n *       name: 'a_offset',\n *       size: 2\n *     },\n *     {\n *       name: 'a_texCoord',\n *       size: 2\n *     }\n *   ])\n *   ```\n *\n * ### Rendering primitives\n *\n *   Once all the steps above have been achieved, rendering primitives to the screen is done using {@link prepareDraw}, {@link drawElements} and {@link finalizeDraw}.\n *   ```js\n *   // frame preparation step\n *   helper.prepareDraw(frameState);\n *\n *   // call this for every data array that has to be rendered on screen\n *   helper.drawElements(0, this.indicesBuffer.getArray().length);\n *\n *   // finalize the rendering by applying post processes\n *   helper.finalizeDraw(frameState);\n *   ```\n *\n * For an example usage of this class, refer to {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n */\nvar WebGLHelper = /*#__PURE__*/function (_Disposable) {\n  /**\n   * @param {Options} [options] Options.\n   */\n  function WebGLHelper(options) {\n    var _this;\n    _classCallCheck(this, WebGLHelper);\n    _this = _callSuper(this, WebGLHelper);\n    options = options || {};\n\n    /** @private */\n    _this.boundHandleWebGLContextLost_ = _this.handleWebGLContextLost.bind(_this);\n\n    /** @private */\n    _this.boundHandleWebGLContextRestored_ = _this.handleWebGLContextRestored.bind(_this);\n\n    /**\n     * @private\n     * @type {string}\n     */\n    _this.canvasCacheKey_ = options.canvasCacheKey ? getSharedCanvasCacheKey(options.canvasCacheKey) : getUniqueCanvasCacheKey();\n\n    /**\n     * @private\n     * @type {WebGLRenderingContext}\n     */\n    _this.gl_ = getOrCreateContext(_this.canvasCacheKey_);\n\n    /**\n     * @private\n     * @type {!Object<string, BufferCacheEntry>}\n     */\n    _this.bufferCache_ = {};\n\n    /**\n     * @private\n     * @type {Object<string, Object>}\n     */\n    _this.extensionCache_ = {};\n\n    /**\n     * @private\n     * @type {WebGLProgram}\n     */\n    _this.currentProgram_ = null;\n\n    /**\n     * @private\n     * @type boolean\n     */\n    _this.needsToBeRecreated_ = false;\n    var canvas = _this.gl_.canvas;\n    canvas.addEventListener(ContextEventType.LOST, _this.boundHandleWebGLContextLost_);\n    canvas.addEventListener(ContextEventType.RESTORED, _this.boundHandleWebGLContextRestored_);\n\n    /**\n     * @private\n     * @type {import(\"../transform.js\").Transform}\n     */\n    _this.offsetRotateMatrix_ = createTransform();\n\n    /**\n     * @private\n     * @type {import(\"../transform.js\").Transform}\n     */\n    _this.offsetScaleMatrix_ = createTransform();\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    _this.tmpMat4_ = create();\n\n    /**\n     * @private\n     * @type {Object<string, Object<string, WebGLUniformLocation>>}\n     */\n    _this.uniformLocationsByProgram_ = {};\n\n    /**\n     * @private\n     * @type {Object<string, Object<string, number>>}\n     */\n    _this.attribLocationsByProgram_ = {};\n\n    /**\n     * Holds info about custom uniforms used in the post processing pass.\n     * If the uniform is a texture, the WebGL Texture object will be stored here.\n     * @type {Array<UniformInternalDescription>}\n     * @private\n     */\n    _this.uniforms_ = [];\n    if (options.uniforms) {\n      _this.setUniforms(options.uniforms);\n    }\n\n    /**\n     * An array of PostProcessingPass objects is kept in this variable, built from the steps provided in the\n     * options. If no post process was given, a default one is used (so as not to have to make an exception to\n     * the frame buffer logic).\n     * @type {Array<WebGLPostProcessingPass>}\n     * @private\n     */\n    _this.postProcessPasses_ = options.postProcesses ? options.postProcesses.map(function (options) {\n      return new WebGLPostProcessingPass({\n        webGlContext: _this.gl_,\n        scaleRatio: options.scaleRatio,\n        vertexShader: options.vertexShader,\n        fragmentShader: options.fragmentShader,\n        uniforms: options.uniforms\n      });\n    }) : [new WebGLPostProcessingPass({\n      webGlContext: _this.gl_\n    })];\n\n    /**\n     * @type {string|null}\n     * @private\n     */\n    _this.shaderCompileErrors_ = null;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.startTime_ = Date.now();\n    return _this;\n  }\n\n  /**\n   * @param {Object<string, UniformValue>} uniforms Uniform definitions.\n   */\n  _inherits(WebGLHelper, _Disposable);\n  return _createClass(WebGLHelper, [{\n    key: \"setUniforms\",\n    value: function setUniforms(uniforms) {\n      this.uniforms_ = [];\n      this.addUniforms(uniforms);\n    }\n\n    /**\n     * @param {Object<string, UniformValue>} uniforms Uniform definitions.\n     */\n  }, {\n    key: \"addUniforms\",\n    value: function addUniforms(uniforms) {\n      for (var name in uniforms) {\n        this.uniforms_.push({\n          name: name,\n          value: uniforms[name]\n        });\n      }\n    }\n\n    /**\n     * @param {string} canvasCacheKey The canvas cache key.\n     * @return {boolean} The provided key matches the one this helper was constructed with.\n     */\n  }, {\n    key: \"canvasCacheKeyMatches\",\n    value: function canvasCacheKeyMatches(canvasCacheKey) {\n      return this.canvasCacheKey_ === getSharedCanvasCacheKey(canvasCacheKey);\n    }\n\n    /**\n     * Get a WebGL extension.  If the extension is not supported, null is returned.\n     * Extensions are cached after they are enabled for the first time.\n     * @param {string} name The extension name.\n     * @return {Object|null} The extension or null if not supported.\n     */\n  }, {\n    key: \"getExtension\",\n    value: function getExtension(name) {\n      if (name in this.extensionCache_) {\n        return this.extensionCache_[name];\n      }\n      var extension = this.gl_.getExtension(name);\n      this.extensionCache_[name] = extension;\n      return extension;\n    }\n\n    /**\n     * Just bind the buffer if it's in the cache. Otherwise create\n     * the WebGL buffer, bind it, populate it, and add an entry to\n     * the cache.\n     * @param {import(\"./Buffer\").default} buffer Buffer.\n     */\n  }, {\n    key: \"bindBuffer\",\n    value: function bindBuffer(buffer) {\n      var gl = this.gl_;\n      var bufferKey = getUid(buffer);\n      var bufferCache = this.bufferCache_[bufferKey];\n      if (!bufferCache) {\n        var webGlBuffer = gl.createBuffer();\n        bufferCache = {\n          buffer: buffer,\n          webGlBuffer: webGlBuffer\n        };\n        this.bufferCache_[bufferKey] = bufferCache;\n      }\n      gl.bindBuffer(buffer.getType(), bufferCache.webGlBuffer);\n    }\n\n    /**\n     * Update the data contained in the buffer array; this is required for the\n     * new data to be rendered\n     * @param {import(\"./Buffer\").default} buffer Buffer.\n     */\n  }, {\n    key: \"flushBufferData\",\n    value: function flushBufferData(buffer) {\n      var gl = this.gl_;\n      this.bindBuffer(buffer);\n      gl.bufferData(buffer.getType(), buffer.getArray(), buffer.getUsage());\n    }\n\n    /**\n     * @param {import(\"./Buffer.js\").default} buf Buffer.\n     */\n  }, {\n    key: \"deleteBuffer\",\n    value: function deleteBuffer(buf) {\n      var gl = this.gl_;\n      var bufferKey = getUid(buf);\n      var bufferCacheEntry = this.bufferCache_[bufferKey];\n      if (bufferCacheEntry && !gl.isContextLost()) {\n        gl.deleteBuffer(bufferCacheEntry.webGlBuffer);\n      }\n      delete this.bufferCache_[bufferKey];\n    }\n\n    /**\n     * Clean up.\n     */\n  }, {\n    key: \"disposeInternal\",\n    value: function disposeInternal() {\n      var canvas = this.gl_.canvas;\n      canvas.removeEventListener(ContextEventType.LOST, this.boundHandleWebGLContextLost_);\n      canvas.removeEventListener(ContextEventType.RESTORED, this.boundHandleWebGLContextRestored_);\n      releaseCanvas(this.canvasCacheKey_);\n      delete this.gl_;\n    }\n\n    /**\n     * Clear the buffer & set the viewport to draw.\n     * Post process passes will be initialized here, the first one being bound as a render target for\n     * subsequent draw calls.\n     * @param {import(\"../Map.js\").FrameState} frameState current frame state\n     * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.\n     * @param {boolean} [enableDepth] If true, enables depth testing.\n     */\n  }, {\n    key: \"prepareDraw\",\n    value: function prepareDraw(frameState, disableAlphaBlend, enableDepth) {\n      var gl = this.gl_;\n      var canvas = this.getCanvas();\n      var size = frameState.size;\n      var pixelRatio = frameState.pixelRatio;\n      if (canvas.width !== size[0] * pixelRatio || canvas.height !== size[1] * pixelRatio) {\n        canvas.width = size[0] * pixelRatio;\n        canvas.height = size[1] * pixelRatio;\n        canvas.style.width = size[0] + 'px';\n        canvas.style.height = size[1] + 'px';\n      }\n\n      // loop backwards in post processes list\n      for (var i = this.postProcessPasses_.length - 1; i >= 0; i--) {\n        this.postProcessPasses_[i].init(frameState);\n      }\n      gl.bindTexture(gl.TEXTURE_2D, null);\n      gl.clearColor(0.0, 0.0, 0.0, 0.0);\n      gl.depthRange(0.0, 1.0);\n      gl.clearDepth(1.0);\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n      gl.enable(gl.BLEND);\n      gl.blendFunc(gl.ONE, disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);\n      if (enableDepth) {\n        gl.enable(gl.DEPTH_TEST);\n        gl.depthFunc(gl.LEQUAL);\n      } else {\n        gl.disable(gl.DEPTH_TEST);\n      }\n    }\n\n    /**\n     * Prepare a program to use a texture.\n     * @param {WebGLTexture} texture The texture.\n     * @param {number} slot The texture slot.\n     * @param {string} uniformName The corresponding uniform name.\n     */\n  }, {\n    key: \"bindTexture\",\n    value: function bindTexture(texture, slot, uniformName) {\n      var gl = this.gl_;\n      gl.activeTexture(gl.TEXTURE0 + slot);\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n      gl.uniform1i(this.getUniformLocation(uniformName), slot);\n    }\n\n    /**\n     * Clear the render target & bind it for future draw operations.\n     * This is similar to `prepareDraw`, only post processes will not be applied.\n     * Note: the whole viewport will be drawn to the render target, regardless of its size.\n     * @param {import(\"../Map.js\").FrameState} frameState current frame state\n     * @param {import(\"./RenderTarget.js\").default} renderTarget Render target to draw to\n     * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.\n     * @param {boolean} [enableDepth] If true, enables depth testing.\n     */\n  }, {\n    key: \"prepareDrawToRenderTarget\",\n    value: function prepareDrawToRenderTarget(frameState, renderTarget, disableAlphaBlend, enableDepth) {\n      var gl = this.gl_;\n      var size = renderTarget.getSize();\n      gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.getFramebuffer());\n      gl.bindRenderbuffer(gl.RENDERBUFFER, renderTarget.getDepthbuffer());\n      gl.viewport(0, 0, size[0], size[1]);\n      gl.bindTexture(gl.TEXTURE_2D, renderTarget.getTexture());\n      gl.clearColor(0.0, 0.0, 0.0, 0.0);\n      gl.depthRange(0.0, 1.0);\n      gl.clearDepth(1.0);\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n      gl.enable(gl.BLEND);\n      gl.blendFunc(gl.ONE, disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);\n      if (enableDepth) {\n        gl.enable(gl.DEPTH_TEST);\n        gl.depthFunc(gl.LEQUAL);\n      } else {\n        gl.disable(gl.DEPTH_TEST);\n      }\n    }\n\n    /**\n     * Execute a draw call based on the currently bound program, texture, buffers, attributes.\n     * @param {number} start Start index.\n     * @param {number} end End index.\n     */\n  }, {\n    key: \"drawElements\",\n    value: function drawElements(start, end) {\n      var gl = this.gl_;\n      this.getExtension('OES_element_index_uint');\n      var elementType = gl.UNSIGNED_INT;\n      var elementSize = 4;\n      var numItems = end - start;\n      var offsetInBytes = start * elementSize;\n      gl.drawElements(gl.TRIANGLES, numItems, elementType, offsetInBytes);\n    }\n\n    /**\n     * Apply the successive post process passes which will eventually render to the actual canvas.\n     * @param {import(\"../Map.js\").FrameState} frameState current frame state\n     * @param {function(WebGLRenderingContext, import(\"../Map.js\").FrameState):void} [preCompose] Called before composing.\n     * @param {function(WebGLRenderingContext, import(\"../Map.js\").FrameState):void} [postCompose] Called before composing.\n     */\n  }, {\n    key: \"finalizeDraw\",\n    value: function finalizeDraw(frameState, preCompose, postCompose) {\n      // apply post processes using the next one as target\n      for (var i = 0, ii = this.postProcessPasses_.length; i < ii; i++) {\n        if (i === ii - 1) {\n          this.postProcessPasses_[i].apply(frameState, null, preCompose, postCompose);\n        } else {\n          this.postProcessPasses_[i].apply(frameState, this.postProcessPasses_[i + 1]);\n        }\n      }\n    }\n\n    /**\n     * @return {HTMLCanvasElement} Canvas.\n     */\n  }, {\n    key: \"getCanvas\",\n    value: function getCanvas() {\n      return /** @type {HTMLCanvasElement} */this.gl_.canvas;\n    }\n\n    /**\n     * Get the WebGL rendering context\n     * @return {WebGLRenderingContext} The rendering context.\n     */\n  }, {\n    key: \"getGL\",\n    value: function getGL() {\n      return this.gl_;\n    }\n\n    /**\n     * Sets the default matrix uniforms for a given frame state. This is called internally in `prepareDraw`.\n     * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n     */\n  }, {\n    key: \"applyFrameState\",\n    value: function applyFrameState(frameState) {\n      var size = frameState.size;\n      var rotation = frameState.viewState.rotation;\n      var pixelRatio = frameState.pixelRatio;\n      this.setUniformFloatValue(DefaultUniform.TIME, (Date.now() - this.startTime_) * 0.001);\n      this.setUniformFloatValue(DefaultUniform.ZOOM, frameState.viewState.zoom);\n      this.setUniformFloatValue(DefaultUniform.RESOLUTION, frameState.viewState.resolution);\n      this.setUniformFloatValue(DefaultUniform.PIXEL_RATIO, pixelRatio);\n      this.setUniformFloatVec2(DefaultUniform.VIEWPORT_SIZE_PX, [size[0], size[1]]);\n      this.setUniformFloatValue(DefaultUniform.ROTATION, rotation);\n    }\n\n    /**\n     * Sets the `u_hitDetection` uniform.\n     * @param {boolean} enabled Whether to enable the hit detection code path\n     */\n  }, {\n    key: \"applyHitDetectionUniform\",\n    value: function applyHitDetectionUniform(enabled) {\n      var loc = this.getUniformLocation(DefaultUniform.HIT_DETECTION);\n      this.getGL().uniform1i(loc, enabled ? 1 : 0);\n\n      // hit detection uses a fixed pixel ratio\n      if (enabled) {\n        this.setUniformFloatValue(DefaultUniform.PIXEL_RATIO, 0.5);\n      }\n    }\n\n    /**\n     * Sets the custom uniforms based on what was given in the constructor. This is called internally in `prepareDraw`.\n     * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n     */\n  }, {\n    key: \"applyUniforms\",\n    value: function applyUniforms(frameState) {\n      var _this2 = this;\n      var gl = this.gl_;\n      var value;\n      var textureSlot = 0;\n      this.uniforms_.forEach(function (uniform) {\n        value = typeof uniform.value === 'function' ? uniform.value(frameState) : uniform.value;\n\n        // apply value based on type\n        if (value instanceof HTMLCanvasElement || value instanceof HTMLImageElement || value instanceof ImageData) {\n          // create a texture & put data\n          if (!uniform.texture) {\n            uniform.prevValue = undefined;\n            uniform.texture = gl.createTexture();\n          }\n          _this2.bindTexture(uniform.texture, textureSlot, uniform.name);\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n          var imageReady = !(value instanceof HTMLImageElement) || /** @type {HTMLImageElement} */value.complete;\n          if (imageReady && uniform.prevValue !== value) {\n            uniform.prevValue = value;\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);\n          }\n          textureSlot++;\n        } else if (Array.isArray(value) && value.length === 6) {\n          _this2.setUniformMatrixValue(uniform.name, fromTransform(_this2.tmpMat4_, value));\n        } else if (Array.isArray(value) && value.length <= 4) {\n          switch (value.length) {\n            case 2:\n              gl.uniform2f(_this2.getUniformLocation(uniform.name), value[0], value[1]);\n              return;\n            case 3:\n              gl.uniform3f(_this2.getUniformLocation(uniform.name), value[0], value[1], value[2]);\n              return;\n            case 4:\n              gl.uniform4f(_this2.getUniformLocation(uniform.name), value[0], value[1], value[2], value[3]);\n              return;\n            default:\n              return;\n          }\n        } else if (typeof value === 'number') {\n          gl.uniform1f(_this2.getUniformLocation(uniform.name), value);\n        }\n      });\n    }\n\n    /**\n     * Set up a program for use. The program will be set as the current one. Then, the uniforms used\n     * in the program will be set based on the current frame state and the helper configuration.\n     * @param {WebGLProgram} program Program.\n     * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n     */\n  }, {\n    key: \"useProgram\",\n    value: function useProgram(program, frameState) {\n      var gl = this.gl_;\n      gl.useProgram(program);\n      this.currentProgram_ = program;\n      this.applyFrameState(frameState);\n      this.applyUniforms(frameState);\n    }\n\n    /**\n     * Will attempt to compile a vertex or fragment shader based on source\n     * On error, the shader will be returned but\n     * `gl.getShaderParameter(shader, gl.COMPILE_STATUS)` will return `true`\n     * Use `gl.getShaderInfoLog(shader)` to have details\n     * @param {string} source Shader source\n     * @param {ShaderType} type VERTEX_SHADER or FRAGMENT_SHADER\n     * @return {WebGLShader} Shader object\n     */\n  }, {\n    key: \"compileShader\",\n    value: function compileShader(source, type) {\n      var gl = this.gl_;\n      var shader = gl.createShader(type);\n      gl.shaderSource(shader, source);\n      gl.compileShader(shader);\n      return shader;\n    }\n\n    /**\n     * Create a program for a vertex and fragment shader.  Throws if shader compilation fails.\n     * @param {string} fragmentShaderSource Fragment shader source.\n     * @param {string} vertexShaderSource Vertex shader source.\n     * @return {WebGLProgram} Program\n     */\n  }, {\n    key: \"getProgram\",\n    value: function getProgram(fragmentShaderSource, vertexShaderSource) {\n      var gl = this.gl_;\n      var fragmentShader = this.compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);\n      var vertexShader = this.compileShader(vertexShaderSource, gl.VERTEX_SHADER);\n      var program = gl.createProgram();\n      gl.attachShader(program, fragmentShader);\n      gl.attachShader(program, vertexShader);\n      gl.linkProgram(program);\n      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n        var message = \"Fragment shader compilation failed: \".concat(gl.getShaderInfoLog(fragmentShader));\n        throw new Error(message);\n      }\n      gl.deleteShader(fragmentShader);\n      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n        var _message = \"Vertex shader compilation failed: \".concat(gl.getShaderInfoLog(vertexShader));\n        throw new Error(_message);\n      }\n      gl.deleteShader(vertexShader);\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        var _message2 = \"GL program linking failed: \".concat(gl.getProgramInfoLog(program));\n        throw new Error(_message2);\n      }\n      return program;\n    }\n\n    /**\n     * Will get the location from the shader or the cache\n     * @param {string} name Uniform name\n     * @return {WebGLUniformLocation} uniformLocation\n     */\n  }, {\n    key: \"getUniformLocation\",\n    value: function getUniformLocation(name) {\n      var programUid = getUid(this.currentProgram_);\n      if (this.uniformLocationsByProgram_[programUid] === undefined) {\n        this.uniformLocationsByProgram_[programUid] = {};\n      }\n      if (this.uniformLocationsByProgram_[programUid][name] === undefined) {\n        this.uniformLocationsByProgram_[programUid][name] = this.gl_.getUniformLocation(this.currentProgram_, name);\n      }\n      return this.uniformLocationsByProgram_[programUid][name];\n    }\n\n    /**\n     * Will get the location from the shader or the cache\n     * @param {string} name Attribute name\n     * @return {number} attribLocation\n     */\n  }, {\n    key: \"getAttributeLocation\",\n    value: function getAttributeLocation(name) {\n      var programUid = getUid(this.currentProgram_);\n      if (this.attribLocationsByProgram_[programUid] === undefined) {\n        this.attribLocationsByProgram_[programUid] = {};\n      }\n      if (this.attribLocationsByProgram_[programUid][name] === undefined) {\n        this.attribLocationsByProgram_[programUid][name] = this.gl_.getAttribLocation(this.currentProgram_, name);\n      }\n      return this.attribLocationsByProgram_[programUid][name];\n    }\n\n    /**\n     * Sets the given transform to apply the rotation/translation/scaling of the given frame state.\n     * The resulting transform can be used to convert world space coordinates to view coordinates in the [-1, 1] range.\n     * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n     * @param {import(\"../transform\").Transform} transform Transform to update.\n     * @return {import(\"../transform\").Transform} The updated transform object.\n     */\n  }, {\n    key: \"makeProjectionTransform\",\n    value: function makeProjectionTransform(frameState, transform) {\n      var size = frameState.size;\n      var rotation = frameState.viewState.rotation;\n      var resolution = frameState.viewState.resolution;\n      var center = frameState.viewState.center;\n      composeTransform(transform, 0, 0, 2 / (resolution * size[0]), 2 / (resolution * size[1]), -rotation, -center[0], -center[1]);\n      return transform;\n    }\n\n    /**\n     * Give a value for a standard float uniform\n     * @param {string} uniform Uniform name\n     * @param {number} value Value\n     */\n  }, {\n    key: \"setUniformFloatValue\",\n    value: function setUniformFloatValue(uniform, value) {\n      this.gl_.uniform1f(this.getUniformLocation(uniform), value);\n    }\n\n    /**\n     * Give a value for a vec2 uniform\n     * @param {string} uniform Uniform name\n     * @param {Array<number>} value Array of length 4.\n     */\n  }, {\n    key: \"setUniformFloatVec2\",\n    value: function setUniformFloatVec2(uniform, value) {\n      this.gl_.uniform2fv(this.getUniformLocation(uniform), value);\n    }\n\n    /**\n     * Give a value for a vec4 uniform\n     * @param {string} uniform Uniform name\n     * @param {Array<number>} value Array of length 4.\n     */\n  }, {\n    key: \"setUniformFloatVec4\",\n    value: function setUniformFloatVec4(uniform, value) {\n      this.gl_.uniform4fv(this.getUniformLocation(uniform), value);\n    }\n\n    /**\n     * Give a value for a standard matrix4 uniform\n     * @param {string} uniform Uniform name\n     * @param {Array<number>} value Matrix value\n     */\n  }, {\n    key: \"setUniformMatrixValue\",\n    value: function setUniformMatrixValue(uniform, value) {\n      this.gl_.uniformMatrix4fv(this.getUniformLocation(uniform), false, value);\n    }\n\n    /**\n     * Will set the currently bound buffer to an attribute of the shader program. Used by `#enableAttributes`\n     * internally.\n     * @param {string} attribName Attribute name\n     * @param {number} size Number of components per attributes\n     * @param {number} type UNSIGNED_INT, UNSIGNED_BYTE, UNSIGNED_SHORT or FLOAT\n     * @param {number} stride Stride in bytes (0 means attribs are packed)\n     * @param {number} offset Offset in bytes\n     * @private\n     */\n  }, {\n    key: \"enableAttributeArray_\",\n    value: function enableAttributeArray_(attribName, size, type, stride, offset) {\n      var location = this.getAttributeLocation(attribName);\n      // the attribute has not been found in the shaders or is not used; do not enable it\n      if (location < 0) {\n        return;\n      }\n      this.gl_.enableVertexAttribArray(location);\n      this.gl_.vertexAttribPointer(location, size, type, false, stride, offset);\n    }\n\n    /**\n     * Will enable the following attributes to be read from the currently bound buffer,\n     * i.e. tell the GPU where to read the different attributes in the buffer. An error in the\n     * size/type/order of attributes will most likely break the rendering and throw a WebGL exception.\n     * @param {Array<AttributeDescription>} attributes Ordered list of attributes to read from the buffer\n     */\n  }, {\n    key: \"enableAttributes\",\n    value: function enableAttributes(attributes) {\n      var stride = computeAttributesStride(attributes);\n      var offset = 0;\n      for (var i = 0; i < attributes.length; i++) {\n        var attr = attributes[i];\n        this.enableAttributeArray_(attr.name, attr.size, attr.type || FLOAT, stride, offset);\n        offset += attr.size * getByteSizeFromType(attr.type);\n      }\n    }\n\n    /**\n     * WebGL context was lost\n     * @param {WebGLContextEvent} event The context loss event.\n     * @private\n     */\n  }, {\n    key: \"handleWebGLContextLost\",\n    value: function handleWebGLContextLost(event) {\n      clear(this.bufferCache_);\n      this.currentProgram_ = null;\n      event.preventDefault();\n    }\n\n    /**\n     * WebGL context was restored\n     * @private\n     */\n  }, {\n    key: \"handleWebGLContextRestored\",\n    value: function handleWebGLContextRestored() {\n      this.needsToBeRecreated_ = true;\n    }\n\n    /**\n     * Returns whether this helper needs to be recreated, as the context was lost and then restored.\n     * @return {boolean} Whether this helper needs to be recreated.\n     */\n  }, {\n    key: \"needsToBeRecreated\",\n    value: function needsToBeRecreated() {\n      return this.needsToBeRecreated_;\n    }\n\n    /**\n     * Will create or reuse a given webgl texture and apply the given size. If no image data\n     * specified, the texture will be empty, otherwise image data will be used and the `size`\n     * parameter will be ignored.\n     * Note: wrap parameters are set to clamp to edge, min filter is set to linear.\n     * @param {Array<number>} size Expected size of the texture\n     * @param {ImageData|HTMLImageElement|HTMLCanvasElement} [data] Image data/object to bind to the texture\n     * @param {WebGLTexture} [texture] Existing texture to reuse\n     * @return {WebGLTexture} The generated texture\n     */\n  }, {\n    key: \"createTexture\",\n    value: function createTexture(size, data, texture) {\n      var gl = this.gl_;\n      texture = texture || gl.createTexture();\n\n      // set params & size\n      var level = 0;\n      var internalFormat = gl.RGBA;\n      var border = 0;\n      var format = gl.RGBA;\n      var type = gl.UNSIGNED_BYTE;\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n      if (data) {\n        gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, format, type, data);\n      } else {\n        gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, size[0], size[1], border, format, type, null);\n      }\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      return texture;\n    }\n  }]);\n}(Disposable);\n/**\n * Compute a stride in bytes based on a list of attributes\n * @param {Array<AttributeDescription>} attributes Ordered list of attributes\n * @return {number} Stride, ie amount of values for each vertex in the vertex buffer\n */\nexport function computeAttributesStride(attributes) {\n  var stride = 0;\n  for (var i = 0; i < attributes.length; i++) {\n    var attr = attributes[i];\n    stride += attr.size * getByteSizeFromType(attr.type);\n  }\n  return stride;\n}\n\n/**\n * Computes the size in byte of an attribute type.\n * @param {AttributeType} type Attribute type\n * @return {number} The size in bytes\n */\nfunction getByteSizeFromType(type) {\n  switch (type) {\n    case AttributeType.UNSIGNED_BYTE:\n      return Uint8Array.BYTES_PER_ELEMENT;\n    case AttributeType.UNSIGNED_SHORT:\n      return Uint16Array.BYTES_PER_ELEMENT;\n    case AttributeType.UNSIGNED_INT:\n      return Uint32Array.BYTES_PER_ELEMENT;\n    case AttributeType.FLOAT:\n    default:\n      return Float32Array.BYTES_PER_ELEMENT;\n  }\n}\nexport default WebGLHelper;","map":{"version":3,"names":["ContextEventType","Disposable","WebGLPostProcessingPass","FLOAT","UNSIGNED_BYTE","UNSIGNED_INT","UNSIGNED_SHORT","getContext","clear","compose","composeTransform","create","createTransform","fromTransform","getUid","ShaderType","FRAGMENT_SHADER","VERTEX_SHADER","DefaultUniform","PROJECTION_MATRIX","SCREEN_TO_WORLD_MATRIX","TIME","ZOOM","RESOLUTION","ROTATION","VIEWPORT_SIZE_PX","PIXEL_RATIO","HIT_DETECTION","AttributeType","canvasCache","getSharedCanvasCacheKey","key","uniqueCanvasCacheKeyCount","getUniqueCanvasCacheKey","getOrCreateContext","cacheItem","canvas","document","createElement","width","height","style","position","left","context","users","releaseCanvas","gl","extension","getExtension","loseContext","WebGLHelper","_Disposable","options","_this","_classCallCheck","_callSuper","boundHandleWebGLContextLost_","handleWebGLContextLost","bind","boundHandleWebGLContextRestored_","handleWebGLContextRestored","canvasCacheKey_","canvasCacheKey","gl_","bufferCache_","extensionCache_","currentProgram_","needsToBeRecreated_","addEventListener","LOST","RESTORED","offsetRotateMatrix_","offsetScaleMatrix_","tmpMat4_","uniformLocationsByProgram_","attribLocationsByProgram_","uniforms_","uniforms","setUniforms","postProcessPasses_","postProcesses","map","webGlContext","scaleRatio","vertexShader","fragmentShader","shaderCompileErrors_","startTime_","Date","now","_inherits","_createClass","value","addUniforms","name","push","canvasCacheKeyMatches","bindBuffer","buffer","bufferKey","bufferCache","webGlBuffer","createBuffer","getType","flushBufferData","bufferData","getArray","getUsage","deleteBuffer","buf","bufferCacheEntry","isContextLost","disposeInternal","removeEventListener","prepareDraw","frameState","disableAlphaBlend","enableDepth","getCanvas","size","pixelRatio","i","length","init","bindTexture","TEXTURE_2D","clearColor","depthRange","clearDepth","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","enable","BLEND","blendFunc","ONE","ZERO","ONE_MINUS_SRC_ALPHA","DEPTH_TEST","depthFunc","LEQUAL","disable","texture","slot","uniformName","activeTexture","TEXTURE0","uniform1i","getUniformLocation","prepareDrawToRenderTarget","renderTarget","getSize","bindFramebuffer","FRAMEBUFFER","getFramebuffer","bindRenderbuffer","RENDERBUFFER","getDepthbuffer","viewport","getTexture","drawElements","start","end","elementType","elementSize","numItems","offsetInBytes","TRIANGLES","finalizeDraw","preCompose","postCompose","ii","apply","getGL","applyFrameState","rotation","viewState","setUniformFloatValue","zoom","resolution","setUniformFloatVec2","applyHitDetectionUniform","enabled","loc","applyUniforms","_this2","textureSlot","forEach","uniform","HTMLCanvasElement","HTMLImageElement","ImageData","prevValue","undefined","createTexture","texParameteri","TEXTURE_MIN_FILTER","LINEAR","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","imageReady","complete","texImage2D","RGBA","Array","isArray","setUniformMatrixValue","uniform2f","uniform3f","uniform4f","uniform1f","useProgram","program","compileShader","source","type","shader","createShader","shaderSource","getProgram","fragmentShaderSource","vertexShaderSource","createProgram","attachShader","linkProgram","getShaderParameter","COMPILE_STATUS","message","concat","getShaderInfoLog","Error","deleteShader","getProgramParameter","LINK_STATUS","getProgramInfoLog","programUid","getAttributeLocation","getAttribLocation","makeProjectionTransform","transform","center","uniform2fv","setUniformFloatVec4","uniform4fv","uniformMatrix4fv","enableAttributeArray_","attribName","stride","offset","location","enableVertexAttribArray","vertexAttribPointer","enableAttributes","attributes","computeAttributesStride","attr","getByteSizeFromType","event","preventDefault","needsToBeRecreated","data","level","internalFormat","border","format","Uint8Array","BYTES_PER_ELEMENT","Uint16Array","Uint32Array","Float32Array"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol/webgl/Helper.js"],"sourcesContent":["/**\n * @module ol/webgl/Helper\n */\nimport ContextEventType from '../webgl/ContextEventType.js';\nimport Disposable from '../Disposable.js';\nimport WebGLPostProcessingPass from './PostProcessingPass.js';\nimport {\n  FLOAT,\n  UNSIGNED_BYTE,\n  UNSIGNED_INT,\n  UNSIGNED_SHORT,\n  getContext,\n} from '../webgl.js';\nimport {clear} from '../obj.js';\nimport {\n  compose as composeTransform,\n  create as createTransform,\n} from '../transform.js';\nimport {create, fromTransform} from '../vec/mat4.js';\nimport {getUid} from '../util.js';\n\n/**\n * @typedef {Object} BufferCacheEntry\n * @property {import(\"./Buffer.js\").default} buffer Buffer.\n * @property {WebGLBuffer} webGlBuffer WebGlBuffer.\n */\n\n/**\n * Shader types, either `FRAGMENT_SHADER` or `VERTEX_SHADER`.\n * @enum {number}\n */\nexport const ShaderType = {\n  FRAGMENT_SHADER: 0x8b30,\n  VERTEX_SHADER: 0x8b31,\n};\n\n/**\n * Names of uniforms made available to all shaders.\n * Please note: changing these *will* break custom shaders!\n * @enum {string}\n */\nexport const DefaultUniform = {\n  PROJECTION_MATRIX: 'u_projectionMatrix',\n  SCREEN_TO_WORLD_MATRIX: 'u_screenToWorldMatrix',\n  TIME: 'u_time',\n  ZOOM: 'u_zoom',\n  RESOLUTION: 'u_resolution',\n  ROTATION: 'u_rotation',\n  VIEWPORT_SIZE_PX: 'u_viewportSizePx',\n  PIXEL_RATIO: 'u_pixelRatio',\n  HIT_DETECTION: 'u_hitDetection',\n};\n\n/**\n * Attribute types, either `UNSIGNED_BYTE`, `UNSIGNED_SHORT`, `UNSIGNED_INT` or `FLOAT`\n * Note: an attribute stored in a `Float32Array` should be of type `FLOAT`.\n * @enum {number}\n */\nexport const AttributeType = {\n  UNSIGNED_BYTE: UNSIGNED_BYTE,\n  UNSIGNED_SHORT: UNSIGNED_SHORT,\n  UNSIGNED_INT: UNSIGNED_INT,\n  FLOAT: FLOAT,\n};\n\n/**\n * Description of an attribute in a buffer\n * @typedef {Object} AttributeDescription\n * @property {string} name Attribute name to use in shaders\n * @property {number} size Number of components per attributes\n * @property {AttributeType} [type] Attribute type, i.e. number of bytes used to store the value. This is\n * determined by the class of typed array which the buffer uses (eg. `Float32Array` for a `FLOAT` attribute).\n * Default is `FLOAT`.\n */\n\n/**\n * @typedef {number|Array<number>|HTMLCanvasElement|HTMLImageElement|ImageData|import(\"../transform\").Transform} UniformLiteralValue\n */\n\n/**\n * Uniform value can be a number, array of numbers (2 to 4), canvas element or a callback returning\n * one of the previous types.\n * @typedef {UniformLiteralValue|function(import(\"../Map.js\").FrameState):UniformLiteralValue} UniformValue\n */\n\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas which will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n\n/**\n * @typedef {Object} Options\n * @property {Object<string,UniformValue>} [uniforms] Uniform definitions; property names must match the uniform\n * names in the provided or default shaders.\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n * @property {string} [canvasCacheKey] The cache key for the canvas.\n */\n\n/**\n * @typedef {Object} UniformInternalDescription\n * @property {string} name Name\n * @property {UniformValue} [value] Value\n * @property {UniformValue} [prevValue] The previous value.\n * @property {WebGLTexture} [texture] Texture\n * @private\n */\n\n/**\n * @typedef {Object} CanvasCacheItem\n * @property {WebGLRenderingContext} context The context of this canvas.\n * @property {number} users The count of users of this canvas.\n */\n\n/**\n * @type {Object<string,CanvasCacheItem>}\n */\nconst canvasCache = {};\n\n/**\n * @param {string} key The cache key for the canvas.\n * @return {string} The shared cache key.\n */\nfunction getSharedCanvasCacheKey(key) {\n  return 'shared/' + key;\n}\n\nlet uniqueCanvasCacheKeyCount = 0;\n\n/**\n * @return {string} The unique cache key.\n */\nfunction getUniqueCanvasCacheKey() {\n  const key = 'unique/' + uniqueCanvasCacheKeyCount;\n  uniqueCanvasCacheKeyCount += 1;\n  return key;\n}\n\n/**\n * @param {string} key The cache key for the canvas.\n * @return {WebGLRenderingContext} The canvas.\n */\nfunction getOrCreateContext(key) {\n  let cacheItem = canvasCache[key];\n  if (!cacheItem) {\n    const canvas = document.createElement('canvas');\n    canvas.width = 1;\n    canvas.height = 1;\n    canvas.style.position = 'absolute';\n    canvas.style.left = '0';\n    const context = getContext(canvas);\n    cacheItem = {users: 0, context};\n    canvasCache[key] = cacheItem;\n  }\n\n  cacheItem.users += 1;\n  return cacheItem.context;\n}\n\n/**\n * @param {string} key The cache key for the canvas.\n */\nfunction releaseCanvas(key) {\n  const cacheItem = canvasCache[key];\n  if (!cacheItem) {\n    return;\n  }\n\n  cacheItem.users -= 1;\n  if (cacheItem.users > 0) {\n    return;\n  }\n\n  const gl = cacheItem.context;\n  const extension = gl.getExtension('WEBGL_lose_context');\n  if (extension) {\n    extension.loseContext();\n  }\n  const canvas = gl.canvas;\n  canvas.width = 1;\n  canvas.height = 1;\n\n  delete canvasCache[key];\n}\n\n/**\n * @classdesc\n * This class is intended to provide low-level functions related to WebGL rendering, so that accessing\n * directly the WebGL API should not be required anymore.\n *\n * Several operations are handled by the `WebGLHelper` class:\n *\n * ### Define custom shaders and uniforms\n *\n *   *Shaders* are low-level programs executed on the GPU and written in GLSL. There are two types of shaders:\n *\n *   Vertex shaders are used to manipulate the position and attribute of *vertices* of rendered primitives (ie. corners of a square).\n *   Outputs are:\n *\n *   * `gl_Position`: position of the vertex in screen space\n *\n *   * Varyings usually prefixed with `v_` are passed on to the fragment shader\n *\n *   Fragment shaders are used to control the actual color of the pixels drawn on screen. Their only output is `gl_FragColor`.\n *\n *   Both shaders can take *uniforms* or *attributes* as input. Attributes are explained later. Uniforms are common, read-only values that\n *   can be changed at every frame and can be of type float, arrays of float or images.\n *\n *   Shaders must be compiled and assembled into a program like so:\n *   ```js\n *   // here we simply create two shaders and assemble them in a program which is then used\n *   // for subsequent rendering calls; note how a frameState is required to set up a program,\n *   // as several default uniforms are computed from it (projection matrix, zoom level, etc.)\n *   const vertexShader = new WebGLVertex(VERTEX_SHADER);\n *   const fragmentShader = new WebGLFragment(FRAGMENT_SHADER);\n *   const program = this.context.getProgram(fragmentShader, vertexShader);\n *   helper.useProgram(this.program, frameState);\n *   ```\n *\n *   Uniforms are defined using the `uniforms` option and can either be explicit values or callbacks taking the frame state as argument.\n *   You can also change their value along the way like so:\n *   ```js\n *   helper.setUniformFloatValue('u_value', valueAsNumber);\n *   ```\n *\n * ### Defining post processing passes\n *\n *   *Post processing* describes the act of rendering primitives to a texture, and then rendering this texture to the final canvas\n *   while applying special effects in screen space.\n *   Typical uses are: blurring, color manipulation, depth of field, filtering...\n *\n *   The `WebGLHelper` class offers the possibility to define post processes at creation time using the `postProcesses` option.\n *   A post process step accepts the following options:\n *\n *   * `fragmentShader` and `vertexShader`: text literals in GLSL language that will be compiled and used in the post processing step.\n *   * `uniforms`: uniforms can be defined for the post processing steps just like for the main render.\n *   * `scaleRatio`: allows using an intermediate texture smaller or higher than the final canvas in the post processing step.\n *     This is typically used in blur steps to reduce the performance overhead by using an already downsampled texture as input.\n *\n *   The {@link module:ol/webgl/PostProcessingPass~WebGLPostProcessingPass} class is used internally, refer to its documentation for more info.\n *\n * ### Binding WebGL buffers and flushing data into them\n *\n *   Data that must be passed to the GPU has to be transferred using {@link module:ol/webgl/Buffer~WebGLArrayBuffer} objects.\n *   A buffer has to be created only once, but must be bound every time the buffer content will be used for rendering.\n *   This is done using {@link bindBuffer}.\n *   When the buffer's array content has changed, the new data has to be flushed to the GPU memory; this is done using\n *   {@link flushBufferData}. Note: this operation is expensive and should be done as infrequently as possible.\n *\n *   When binding an array buffer, a `target` parameter must be given: it should be either {@link module:ol/webgl.ARRAY_BUFFER}\n *   (if the buffer contains vertices data) or {@link module:ol/webgl.ELEMENT_ARRAY_BUFFER} (if the buffer contains indices data).\n *\n *   Examples below:\n *   ```js\n *   // at initialization phase\n *   const verticesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);\n *   const indicesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);\n *\n *   // when array values have changed\n *   helper.flushBufferData(ARRAY_BUFFER, this.verticesBuffer);\n *   helper.flushBufferData(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n *\n *   // at rendering phase\n *   helper.bindBuffer(ARRAY_BUFFER, this.verticesBuffer);\n *   helper.bindBuffer(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n *   ```\n *\n * ### Specifying attributes\n *\n *   The GPU only receives the data as arrays of numbers. These numbers must be handled differently depending on what it describes (position, texture coordinate...).\n *   Attributes are used to specify these uses. Specify the attribute names with\n *   {@link module:ol/webgl/Helper~WebGLHelper#enableAttributes} (see code snippet below).\n *\n *   Please note that you will have to specify the type and offset of the attributes in the data array. You can refer to the documentation of [WebGLRenderingContext.vertexAttribPointer](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer) for more explanation.\n *   ```js\n *   // here we indicate that the data array has the following structure:\n *   // [posX, posY, offsetX, offsetY, texCoordU, texCoordV, posX, posY, ...]\n *   helper.enableAttributes([\n *     {\n *        name: 'a_position',\n *        size: 2\n *     },\n *     {\n *       name: 'a_offset',\n *       size: 2\n *     },\n *     {\n *       name: 'a_texCoord',\n *       size: 2\n *     }\n *   ])\n *   ```\n *\n * ### Rendering primitives\n *\n *   Once all the steps above have been achieved, rendering primitives to the screen is done using {@link prepareDraw}, {@link drawElements} and {@link finalizeDraw}.\n *   ```js\n *   // frame preparation step\n *   helper.prepareDraw(frameState);\n *\n *   // call this for every data array that has to be rendered on screen\n *   helper.drawElements(0, this.indicesBuffer.getArray().length);\n *\n *   // finalize the rendering by applying post processes\n *   helper.finalizeDraw(frameState);\n *   ```\n *\n * For an example usage of this class, refer to {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n */\nclass WebGLHelper extends Disposable {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n    options = options || {};\n\n    /** @private */\n    this.boundHandleWebGLContextLost_ = this.handleWebGLContextLost.bind(this);\n\n    /** @private */\n    this.boundHandleWebGLContextRestored_ =\n      this.handleWebGLContextRestored.bind(this);\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.canvasCacheKey_ = options.canvasCacheKey\n      ? getSharedCanvasCacheKey(options.canvasCacheKey)\n      : getUniqueCanvasCacheKey();\n\n    /**\n     * @private\n     * @type {WebGLRenderingContext}\n     */\n    this.gl_ = getOrCreateContext(this.canvasCacheKey_);\n\n    /**\n     * @private\n     * @type {!Object<string, BufferCacheEntry>}\n     */\n    this.bufferCache_ = {};\n\n    /**\n     * @private\n     * @type {Object<string, Object>}\n     */\n    this.extensionCache_ = {};\n\n    /**\n     * @private\n     * @type {WebGLProgram}\n     */\n    this.currentProgram_ = null;\n\n    /**\n     * @private\n     * @type boolean\n     */\n    this.needsToBeRecreated_ = false;\n\n    const canvas = this.gl_.canvas;\n\n    canvas.addEventListener(\n      ContextEventType.LOST,\n      this.boundHandleWebGLContextLost_\n    );\n    canvas.addEventListener(\n      ContextEventType.RESTORED,\n      this.boundHandleWebGLContextRestored_\n    );\n\n    /**\n     * @private\n     * @type {import(\"../transform.js\").Transform}\n     */\n    this.offsetRotateMatrix_ = createTransform();\n\n    /**\n     * @private\n     * @type {import(\"../transform.js\").Transform}\n     */\n    this.offsetScaleMatrix_ = createTransform();\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.tmpMat4_ = create();\n\n    /**\n     * @private\n     * @type {Object<string, Object<string, WebGLUniformLocation>>}\n     */\n    this.uniformLocationsByProgram_ = {};\n\n    /**\n     * @private\n     * @type {Object<string, Object<string, number>>}\n     */\n    this.attribLocationsByProgram_ = {};\n\n    /**\n     * Holds info about custom uniforms used in the post processing pass.\n     * If the uniform is a texture, the WebGL Texture object will be stored here.\n     * @type {Array<UniformInternalDescription>}\n     * @private\n     */\n    this.uniforms_ = [];\n    if (options.uniforms) {\n      this.setUniforms(options.uniforms);\n    }\n\n    /**\n     * An array of PostProcessingPass objects is kept in this variable, built from the steps provided in the\n     * options. If no post process was given, a default one is used (so as not to have to make an exception to\n     * the frame buffer logic).\n     * @type {Array<WebGLPostProcessingPass>}\n     * @private\n     */\n    this.postProcessPasses_ = options.postProcesses\n      ? options.postProcesses.map(\n          (options) =>\n            new WebGLPostProcessingPass({\n              webGlContext: this.gl_,\n              scaleRatio: options.scaleRatio,\n              vertexShader: options.vertexShader,\n              fragmentShader: options.fragmentShader,\n              uniforms: options.uniforms,\n            })\n        )\n      : [new WebGLPostProcessingPass({webGlContext: this.gl_})];\n\n    /**\n     * @type {string|null}\n     * @private\n     */\n    this.shaderCompileErrors_ = null;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.startTime_ = Date.now();\n  }\n\n  /**\n   * @param {Object<string, UniformValue>} uniforms Uniform definitions.\n   */\n  setUniforms(uniforms) {\n    this.uniforms_ = [];\n    this.addUniforms(uniforms);\n  }\n\n  /**\n   * @param {Object<string, UniformValue>} uniforms Uniform definitions.\n   */\n  addUniforms(uniforms) {\n    for (const name in uniforms) {\n      this.uniforms_.push({\n        name: name,\n        value: uniforms[name],\n      });\n    }\n  }\n\n  /**\n   * @param {string} canvasCacheKey The canvas cache key.\n   * @return {boolean} The provided key matches the one this helper was constructed with.\n   */\n  canvasCacheKeyMatches(canvasCacheKey) {\n    return this.canvasCacheKey_ === getSharedCanvasCacheKey(canvasCacheKey);\n  }\n\n  /**\n   * Get a WebGL extension.  If the extension is not supported, null is returned.\n   * Extensions are cached after they are enabled for the first time.\n   * @param {string} name The extension name.\n   * @return {Object|null} The extension or null if not supported.\n   */\n  getExtension(name) {\n    if (name in this.extensionCache_) {\n      return this.extensionCache_[name];\n    }\n    const extension = this.gl_.getExtension(name);\n    this.extensionCache_[name] = extension;\n    return extension;\n  }\n\n  /**\n   * Just bind the buffer if it's in the cache. Otherwise create\n   * the WebGL buffer, bind it, populate it, and add an entry to\n   * the cache.\n   * @param {import(\"./Buffer\").default} buffer Buffer.\n   */\n  bindBuffer(buffer) {\n    const gl = this.gl_;\n    const bufferKey = getUid(buffer);\n    let bufferCache = this.bufferCache_[bufferKey];\n    if (!bufferCache) {\n      const webGlBuffer = gl.createBuffer();\n      bufferCache = {\n        buffer: buffer,\n        webGlBuffer: webGlBuffer,\n      };\n      this.bufferCache_[bufferKey] = bufferCache;\n    }\n    gl.bindBuffer(buffer.getType(), bufferCache.webGlBuffer);\n  }\n\n  /**\n   * Update the data contained in the buffer array; this is required for the\n   * new data to be rendered\n   * @param {import(\"./Buffer\").default} buffer Buffer.\n   */\n  flushBufferData(buffer) {\n    const gl = this.gl_;\n    this.bindBuffer(buffer);\n    gl.bufferData(buffer.getType(), buffer.getArray(), buffer.getUsage());\n  }\n\n  /**\n   * @param {import(\"./Buffer.js\").default} buf Buffer.\n   */\n  deleteBuffer(buf) {\n    const gl = this.gl_;\n    const bufferKey = getUid(buf);\n    const bufferCacheEntry = this.bufferCache_[bufferKey];\n    if (bufferCacheEntry && !gl.isContextLost()) {\n      gl.deleteBuffer(bufferCacheEntry.webGlBuffer);\n    }\n    delete this.bufferCache_[bufferKey];\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    const canvas = this.gl_.canvas;\n    canvas.removeEventListener(\n      ContextEventType.LOST,\n      this.boundHandleWebGLContextLost_\n    );\n    canvas.removeEventListener(\n      ContextEventType.RESTORED,\n      this.boundHandleWebGLContextRestored_\n    );\n\n    releaseCanvas(this.canvasCacheKey_);\n\n    delete this.gl_;\n  }\n\n  /**\n   * Clear the buffer & set the viewport to draw.\n   * Post process passes will be initialized here, the first one being bound as a render target for\n   * subsequent draw calls.\n   * @param {import(\"../Map.js\").FrameState} frameState current frame state\n   * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.\n   * @param {boolean} [enableDepth] If true, enables depth testing.\n   */\n  prepareDraw(frameState, disableAlphaBlend, enableDepth) {\n    const gl = this.gl_;\n    const canvas = this.getCanvas();\n    const size = frameState.size;\n    const pixelRatio = frameState.pixelRatio;\n\n    if (\n      canvas.width !== size[0] * pixelRatio ||\n      canvas.height !== size[1] * pixelRatio\n    ) {\n      canvas.width = size[0] * pixelRatio;\n      canvas.height = size[1] * pixelRatio;\n      canvas.style.width = size[0] + 'px';\n      canvas.style.height = size[1] + 'px';\n    }\n\n    // loop backwards in post processes list\n    for (let i = this.postProcessPasses_.length - 1; i >= 0; i--) {\n      this.postProcessPasses_[i].init(frameState);\n    }\n\n    gl.bindTexture(gl.TEXTURE_2D, null);\n\n    gl.clearColor(0.0, 0.0, 0.0, 0.0);\n    gl.depthRange(0.0, 1.0);\n    gl.clearDepth(1.0);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);\n    if (enableDepth) {\n      gl.enable(gl.DEPTH_TEST);\n      gl.depthFunc(gl.LEQUAL);\n    } else {\n      gl.disable(gl.DEPTH_TEST);\n    }\n  }\n\n  /**\n   * Prepare a program to use a texture.\n   * @param {WebGLTexture} texture The texture.\n   * @param {number} slot The texture slot.\n   * @param {string} uniformName The corresponding uniform name.\n   */\n  bindTexture(texture, slot, uniformName) {\n    const gl = this.gl_;\n    gl.activeTexture(gl.TEXTURE0 + slot);\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.uniform1i(this.getUniformLocation(uniformName), slot);\n  }\n\n  /**\n   * Clear the render target & bind it for future draw operations.\n   * This is similar to `prepareDraw`, only post processes will not be applied.\n   * Note: the whole viewport will be drawn to the render target, regardless of its size.\n   * @param {import(\"../Map.js\").FrameState} frameState current frame state\n   * @param {import(\"./RenderTarget.js\").default} renderTarget Render target to draw to\n   * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.\n   * @param {boolean} [enableDepth] If true, enables depth testing.\n   */\n  prepareDrawToRenderTarget(\n    frameState,\n    renderTarget,\n    disableAlphaBlend,\n    enableDepth\n  ) {\n    const gl = this.gl_;\n    const size = renderTarget.getSize();\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.getFramebuffer());\n    gl.bindRenderbuffer(gl.RENDERBUFFER, renderTarget.getDepthbuffer());\n    gl.viewport(0, 0, size[0], size[1]);\n    gl.bindTexture(gl.TEXTURE_2D, renderTarget.getTexture());\n    gl.clearColor(0.0, 0.0, 0.0, 0.0);\n    gl.depthRange(0.0, 1.0);\n    gl.clearDepth(1.0);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);\n    if (enableDepth) {\n      gl.enable(gl.DEPTH_TEST);\n      gl.depthFunc(gl.LEQUAL);\n    } else {\n      gl.disable(gl.DEPTH_TEST);\n    }\n  }\n\n  /**\n   * Execute a draw call based on the currently bound program, texture, buffers, attributes.\n   * @param {number} start Start index.\n   * @param {number} end End index.\n   */\n  drawElements(start, end) {\n    const gl = this.gl_;\n    this.getExtension('OES_element_index_uint');\n\n    const elementType = gl.UNSIGNED_INT;\n    const elementSize = 4;\n\n    const numItems = end - start;\n    const offsetInBytes = start * elementSize;\n    gl.drawElements(gl.TRIANGLES, numItems, elementType, offsetInBytes);\n  }\n\n  /**\n   * Apply the successive post process passes which will eventually render to the actual canvas.\n   * @param {import(\"../Map.js\").FrameState} frameState current frame state\n   * @param {function(WebGLRenderingContext, import(\"../Map.js\").FrameState):void} [preCompose] Called before composing.\n   * @param {function(WebGLRenderingContext, import(\"../Map.js\").FrameState):void} [postCompose] Called before composing.\n   */\n  finalizeDraw(frameState, preCompose, postCompose) {\n    // apply post processes using the next one as target\n    for (let i = 0, ii = this.postProcessPasses_.length; i < ii; i++) {\n      if (i === ii - 1) {\n        this.postProcessPasses_[i].apply(\n          frameState,\n          null,\n          preCompose,\n          postCompose\n        );\n      } else {\n        this.postProcessPasses_[i].apply(\n          frameState,\n          this.postProcessPasses_[i + 1]\n        );\n      }\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  getCanvas() {\n    return /** @type {HTMLCanvasElement} */ (this.gl_.canvas);\n  }\n\n  /**\n   * Get the WebGL rendering context\n   * @return {WebGLRenderingContext} The rendering context.\n   */\n  getGL() {\n    return this.gl_;\n  }\n\n  /**\n   * Sets the default matrix uniforms for a given frame state. This is called internally in `prepareDraw`.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  applyFrameState(frameState) {\n    const size = frameState.size;\n    const rotation = frameState.viewState.rotation;\n    const pixelRatio = frameState.pixelRatio;\n\n    this.setUniformFloatValue(\n      DefaultUniform.TIME,\n      (Date.now() - this.startTime_) * 0.001\n    );\n    this.setUniformFloatValue(DefaultUniform.ZOOM, frameState.viewState.zoom);\n    this.setUniformFloatValue(\n      DefaultUniform.RESOLUTION,\n      frameState.viewState.resolution\n    );\n    this.setUniformFloatValue(DefaultUniform.PIXEL_RATIO, pixelRatio);\n    this.setUniformFloatVec2(DefaultUniform.VIEWPORT_SIZE_PX, [\n      size[0],\n      size[1],\n    ]);\n    this.setUniformFloatValue(DefaultUniform.ROTATION, rotation);\n  }\n\n  /**\n   * Sets the `u_hitDetection` uniform.\n   * @param {boolean} enabled Whether to enable the hit detection code path\n   */\n  applyHitDetectionUniform(enabled) {\n    const loc = this.getUniformLocation(DefaultUniform.HIT_DETECTION);\n    this.getGL().uniform1i(loc, enabled ? 1 : 0);\n\n    // hit detection uses a fixed pixel ratio\n    if (enabled) {\n      this.setUniformFloatValue(DefaultUniform.PIXEL_RATIO, 0.5);\n    }\n  }\n\n  /**\n   * Sets the custom uniforms based on what was given in the constructor. This is called internally in `prepareDraw`.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  applyUniforms(frameState) {\n    const gl = this.gl_;\n\n    let value;\n    let textureSlot = 0;\n    this.uniforms_.forEach((uniform) => {\n      value =\n        typeof uniform.value === 'function'\n          ? uniform.value(frameState)\n          : uniform.value;\n\n      // apply value based on type\n      if (\n        value instanceof HTMLCanvasElement ||\n        value instanceof HTMLImageElement ||\n        value instanceof ImageData\n      ) {\n        // create a texture & put data\n        if (!uniform.texture) {\n          uniform.prevValue = undefined;\n          uniform.texture = gl.createTexture();\n        }\n        this.bindTexture(uniform.texture, textureSlot, uniform.name);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n        const imageReady =\n          !(value instanceof HTMLImageElement) ||\n          /** @type {HTMLImageElement} */ (value).complete;\n        if (imageReady && uniform.prevValue !== value) {\n          uniform.prevValue = value;\n          gl.texImage2D(\n            gl.TEXTURE_2D,\n            0,\n            gl.RGBA,\n            gl.RGBA,\n            gl.UNSIGNED_BYTE,\n            value\n          );\n        }\n        textureSlot++;\n      } else if (Array.isArray(value) && value.length === 6) {\n        this.setUniformMatrixValue(\n          uniform.name,\n          fromTransform(this.tmpMat4_, value)\n        );\n      } else if (Array.isArray(value) && value.length <= 4) {\n        switch (value.length) {\n          case 2:\n            gl.uniform2f(\n              this.getUniformLocation(uniform.name),\n              value[0],\n              value[1]\n            );\n            return;\n          case 3:\n            gl.uniform3f(\n              this.getUniformLocation(uniform.name),\n              value[0],\n              value[1],\n              value[2]\n            );\n            return;\n          case 4:\n            gl.uniform4f(\n              this.getUniformLocation(uniform.name),\n              value[0],\n              value[1],\n              value[2],\n              value[3]\n            );\n            return;\n          default:\n            return;\n        }\n      } else if (typeof value === 'number') {\n        gl.uniform1f(this.getUniformLocation(uniform.name), value);\n      }\n    });\n  }\n\n  /**\n   * Set up a program for use. The program will be set as the current one. Then, the uniforms used\n   * in the program will be set based on the current frame state and the helper configuration.\n   * @param {WebGLProgram} program Program.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  useProgram(program, frameState) {\n    const gl = this.gl_;\n    gl.useProgram(program);\n    this.currentProgram_ = program;\n    this.applyFrameState(frameState);\n    this.applyUniforms(frameState);\n  }\n\n  /**\n   * Will attempt to compile a vertex or fragment shader based on source\n   * On error, the shader will be returned but\n   * `gl.getShaderParameter(shader, gl.COMPILE_STATUS)` will return `true`\n   * Use `gl.getShaderInfoLog(shader)` to have details\n   * @param {string} source Shader source\n   * @param {ShaderType} type VERTEX_SHADER or FRAGMENT_SHADER\n   * @return {WebGLShader} Shader object\n   */\n  compileShader(source, type) {\n    const gl = this.gl_;\n    const shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n    return shader;\n  }\n\n  /**\n   * Create a program for a vertex and fragment shader.  Throws if shader compilation fails.\n   * @param {string} fragmentShaderSource Fragment shader source.\n   * @param {string} vertexShaderSource Vertex shader source.\n   * @return {WebGLProgram} Program\n   */\n  getProgram(fragmentShaderSource, vertexShaderSource) {\n    const gl = this.gl_;\n\n    const fragmentShader = this.compileShader(\n      fragmentShaderSource,\n      gl.FRAGMENT_SHADER\n    );\n\n    const vertexShader = this.compileShader(\n      vertexShaderSource,\n      gl.VERTEX_SHADER\n    );\n\n    const program = gl.createProgram();\n    gl.attachShader(program, fragmentShader);\n    gl.attachShader(program, vertexShader);\n    gl.linkProgram(program);\n\n    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n      const message = `Fragment shader compilation failed: ${gl.getShaderInfoLog(\n        fragmentShader\n      )}`;\n      throw new Error(message);\n    }\n    gl.deleteShader(fragmentShader);\n\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n      const message = `Vertex shader compilation failed: ${gl.getShaderInfoLog(\n        vertexShader\n      )}`;\n      throw new Error(message);\n    }\n    gl.deleteShader(vertexShader);\n\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      const message = `GL program linking failed: ${gl.getProgramInfoLog(\n        program\n      )}`;\n      throw new Error(message);\n    }\n\n    return program;\n  }\n\n  /**\n   * Will get the location from the shader or the cache\n   * @param {string} name Uniform name\n   * @return {WebGLUniformLocation} uniformLocation\n   */\n  getUniformLocation(name) {\n    const programUid = getUid(this.currentProgram_);\n    if (this.uniformLocationsByProgram_[programUid] === undefined) {\n      this.uniformLocationsByProgram_[programUid] = {};\n    }\n    if (this.uniformLocationsByProgram_[programUid][name] === undefined) {\n      this.uniformLocationsByProgram_[programUid][name] =\n        this.gl_.getUniformLocation(this.currentProgram_, name);\n    }\n    return this.uniformLocationsByProgram_[programUid][name];\n  }\n\n  /**\n   * Will get the location from the shader or the cache\n   * @param {string} name Attribute name\n   * @return {number} attribLocation\n   */\n  getAttributeLocation(name) {\n    const programUid = getUid(this.currentProgram_);\n    if (this.attribLocationsByProgram_[programUid] === undefined) {\n      this.attribLocationsByProgram_[programUid] = {};\n    }\n    if (this.attribLocationsByProgram_[programUid][name] === undefined) {\n      this.attribLocationsByProgram_[programUid][name] =\n        this.gl_.getAttribLocation(this.currentProgram_, name);\n    }\n    return this.attribLocationsByProgram_[programUid][name];\n  }\n\n  /**\n   * Sets the given transform to apply the rotation/translation/scaling of the given frame state.\n   * The resulting transform can be used to convert world space coordinates to view coordinates in the [-1, 1] range.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../transform\").Transform} transform Transform to update.\n   * @return {import(\"../transform\").Transform} The updated transform object.\n   */\n  makeProjectionTransform(frameState, transform) {\n    const size = frameState.size;\n    const rotation = frameState.viewState.rotation;\n    const resolution = frameState.viewState.resolution;\n    const center = frameState.viewState.center;\n    composeTransform(\n      transform,\n      0,\n      0,\n      2 / (resolution * size[0]),\n      2 / (resolution * size[1]),\n      -rotation,\n      -center[0],\n      -center[1]\n    );\n    return transform;\n  }\n\n  /**\n   * Give a value for a standard float uniform\n   * @param {string} uniform Uniform name\n   * @param {number} value Value\n   */\n  setUniformFloatValue(uniform, value) {\n    this.gl_.uniform1f(this.getUniformLocation(uniform), value);\n  }\n\n  /**\n   * Give a value for a vec2 uniform\n   * @param {string} uniform Uniform name\n   * @param {Array<number>} value Array of length 4.\n   */\n  setUniformFloatVec2(uniform, value) {\n    this.gl_.uniform2fv(this.getUniformLocation(uniform), value);\n  }\n\n  /**\n   * Give a value for a vec4 uniform\n   * @param {string} uniform Uniform name\n   * @param {Array<number>} value Array of length 4.\n   */\n  setUniformFloatVec4(uniform, value) {\n    this.gl_.uniform4fv(this.getUniformLocation(uniform), value);\n  }\n\n  /**\n   * Give a value for a standard matrix4 uniform\n   * @param {string} uniform Uniform name\n   * @param {Array<number>} value Matrix value\n   */\n  setUniformMatrixValue(uniform, value) {\n    this.gl_.uniformMatrix4fv(this.getUniformLocation(uniform), false, value);\n  }\n\n  /**\n   * Will set the currently bound buffer to an attribute of the shader program. Used by `#enableAttributes`\n   * internally.\n   * @param {string} attribName Attribute name\n   * @param {number} size Number of components per attributes\n   * @param {number} type UNSIGNED_INT, UNSIGNED_BYTE, UNSIGNED_SHORT or FLOAT\n   * @param {number} stride Stride in bytes (0 means attribs are packed)\n   * @param {number} offset Offset in bytes\n   * @private\n   */\n  enableAttributeArray_(attribName, size, type, stride, offset) {\n    const location = this.getAttributeLocation(attribName);\n    // the attribute has not been found in the shaders or is not used; do not enable it\n    if (location < 0) {\n      return;\n    }\n    this.gl_.enableVertexAttribArray(location);\n    this.gl_.vertexAttribPointer(location, size, type, false, stride, offset);\n  }\n\n  /**\n   * Will enable the following attributes to be read from the currently bound buffer,\n   * i.e. tell the GPU where to read the different attributes in the buffer. An error in the\n   * size/type/order of attributes will most likely break the rendering and throw a WebGL exception.\n   * @param {Array<AttributeDescription>} attributes Ordered list of attributes to read from the buffer\n   */\n  enableAttributes(attributes) {\n    const stride = computeAttributesStride(attributes);\n    let offset = 0;\n    for (let i = 0; i < attributes.length; i++) {\n      const attr = attributes[i];\n      this.enableAttributeArray_(\n        attr.name,\n        attr.size,\n        attr.type || FLOAT,\n        stride,\n        offset\n      );\n      offset += attr.size * getByteSizeFromType(attr.type);\n    }\n  }\n\n  /**\n   * WebGL context was lost\n   * @param {WebGLContextEvent} event The context loss event.\n   * @private\n   */\n  handleWebGLContextLost(event) {\n    clear(this.bufferCache_);\n    this.currentProgram_ = null;\n\n    event.preventDefault();\n  }\n\n  /**\n   * WebGL context was restored\n   * @private\n   */\n  handleWebGLContextRestored() {\n    this.needsToBeRecreated_ = true;\n  }\n\n  /**\n   * Returns whether this helper needs to be recreated, as the context was lost and then restored.\n   * @return {boolean} Whether this helper needs to be recreated.\n   */\n  needsToBeRecreated() {\n    return this.needsToBeRecreated_;\n  }\n\n  /**\n   * Will create or reuse a given webgl texture and apply the given size. If no image data\n   * specified, the texture will be empty, otherwise image data will be used and the `size`\n   * parameter will be ignored.\n   * Note: wrap parameters are set to clamp to edge, min filter is set to linear.\n   * @param {Array<number>} size Expected size of the texture\n   * @param {ImageData|HTMLImageElement|HTMLCanvasElement} [data] Image data/object to bind to the texture\n   * @param {WebGLTexture} [texture] Existing texture to reuse\n   * @return {WebGLTexture} The generated texture\n   */\n  createTexture(size, data, texture) {\n    const gl = this.gl_;\n    texture = texture || gl.createTexture();\n\n    // set params & size\n    const level = 0;\n    const internalFormat = gl.RGBA;\n    const border = 0;\n    const format = gl.RGBA;\n    const type = gl.UNSIGNED_BYTE;\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    if (data) {\n      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, format, type, data);\n    } else {\n      gl.texImage2D(\n        gl.TEXTURE_2D,\n        level,\n        internalFormat,\n        size[0],\n        size[1],\n        border,\n        format,\n        type,\n        null\n      );\n    }\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n    return texture;\n  }\n}\n\n/**\n * Compute a stride in bytes based on a list of attributes\n * @param {Array<AttributeDescription>} attributes Ordered list of attributes\n * @return {number} Stride, ie amount of values for each vertex in the vertex buffer\n */\nexport function computeAttributesStride(attributes) {\n  let stride = 0;\n  for (let i = 0; i < attributes.length; i++) {\n    const attr = attributes[i];\n    stride += attr.size * getByteSizeFromType(attr.type);\n  }\n  return stride;\n}\n\n/**\n * Computes the size in byte of an attribute type.\n * @param {AttributeType} type Attribute type\n * @return {number} The size in bytes\n */\nfunction getByteSizeFromType(type) {\n  switch (type) {\n    case AttributeType.UNSIGNED_BYTE:\n      return Uint8Array.BYTES_PER_ELEMENT;\n    case AttributeType.UNSIGNED_SHORT:\n      return Uint16Array.BYTES_PER_ELEMENT;\n    case AttributeType.UNSIGNED_INT:\n      return Uint32Array.BYTES_PER_ELEMENT;\n    case AttributeType.FLOAT:\n    default:\n      return Float32Array.BYTES_PER_ELEMENT;\n  }\n}\n\nexport default WebGLHelper;\n"],"mappings":"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MAAM,GAAGW,EAAE,CAACX,MAAM;EACxBA,MAAM,CAACG,KAAK,GAAG,CAAC;EAChBH,MAAM,CAACI,MAAM,GAAG,CAAC;EAEjB,OAAOX,WAAW,CAACE,GAAG,CAAC;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA3HA,IA4HMoB,WAAW,0BAAAC,WAAA;EACf;AACF;AACA;EACE,SAAAD,YAAYE,OAAO,EAAE;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAJ,WAAA;IACnBG,KAAA,GAAAE,UAAA,OAAAL,WAAA;IACAE,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;;IAEvB;IACAC,KAAA,CAAKG,4BAA4B,GAAGH,KAAA,CAAKI,sBAAsB,CAACC,IAAI,CAAAL,KAAK,CAAC;;IAE1E;IACAA,KAAA,CAAKM,gCAAgC,GACnCN,KAAA,CAAKO,0BAA0B,CAACF,IAAI,CAAAL,KAAK,CAAC;;IAE5C;AACJ;AACA;AACA;IACIA,KAAA,CAAKQ,eAAe,GAAGT,OAAO,CAACU,cAAc,GACzCjC,uBAAuB,CAACuB,OAAO,CAACU,c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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}