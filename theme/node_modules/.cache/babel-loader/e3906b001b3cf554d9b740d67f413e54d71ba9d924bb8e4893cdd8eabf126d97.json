{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _callSuper from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _superPropGet from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/superPropGet.js\";\nimport _inherits from \"/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/web.timers.js\";\n/**\n * @module ol/renderer/webgl/TileLayerBase\n */\nimport LRUCache from '../../structs/LRUCache.js';\nimport ReprojDataTile from '../../reproj/DataTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport { abstract as _abstract, getUid } from '../../util.js';\nimport { create as createMat4 } from '../../vec/mat4.js';\nimport { createOrUpdate as createTileCoord, getKey as getTileCoordKey } from '../../tilecoord.js';\nimport { create as createTransform, reset as resetTransform, rotate as rotateTransform, scale as scaleTransform, translate as translateTransform } from '../../transform.js';\nimport { descending } from '../../array.js';\nimport { fromUserExtent } from '../../proj.js';\nimport { getIntersection, isEmpty } from '../../extent.js';\nimport { toSize } from '../../size.js';\nexport var Uniforms = {\n  TILE_TRANSFORM: 'u_tileTransform',\n  TRANSITION_ALPHA: 'u_transitionAlpha',\n  DEPTH: 'u_depth',\n  RENDER_EXTENT: 'u_renderExtent',\n  // intersection of layer, source, and view extent\n  PATTERN_ORIGIN: 'u_patternOrigin',\n  RESOLUTION: 'u_resolution',\n  ZOOM: 'u_zoom',\n  GLOBAL_ALPHA: 'u_globalAlpha',\n  PROJECTION_MATRIX: 'u_projectionMatrix',\n  SCREEN_TO_WORLD_MATRIX: 'u_screenToWorldMatrix'\n};\n\n/**\n * @type {Object<string, boolean>}\n */\nvar empty = {};\n\n/**\n * Transform a zoom level into a depth value; zoom level zero has a depth value of 0.5, and increasing values\n * have a depth trending towards 0\n * @param {number} z A zoom level.\n * @return {number} A depth value.\n */\nfunction depthForZ(z) {\n  return 1 / (z + 2);\n}\n\n/**\n * @typedef {import(\"../../webgl/BaseTileRepresentation.js\").default<import(\"../../Tile.js\").default>} AbstractTileRepresentation\n */\n/**\n * @typedef {Object} TileRepresentationLookup\n * @property {Set<string>} tileIds The set of tile ids in the lookup.\n * @property {Object<number, Set<AbstractTileRepresentation>>} representationsByZ Tile representations by zoom level.\n */\n\n/**\n * @return {TileRepresentationLookup} A new tile representation lookup.\n */\nexport function newTileRepresentationLookup() {\n  return {\n    tileIds: new Set(),\n    representationsByZ: {}\n  };\n}\n\n/**\n * Check if a tile is already in the tile representation lookup.\n * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of tile representations by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @return {boolean} The tile is already in the lookup.\n */\nfunction lookupHasTile(tileRepresentationLookup, tile) {\n  return tileRepresentationLookup.tileIds.has(getUid(tile));\n}\n\n/**\n * Add a tile representation to the lookup.\n * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of tile representations by zoom level.\n * @param {AbstractTileRepresentation} tileRepresentation A tile representation.\n * @param {number} z The zoom level.\n */\nfunction addTileRepresentationToLookup(tileRepresentationLookup, tileRepresentation, z) {\n  var representationsByZ = tileRepresentationLookup.representationsByZ;\n  if (!(z in representationsByZ)) {\n    representationsByZ[z] = new Set();\n  }\n  representationsByZ[z].add(tileRepresentation);\n  tileRepresentationLookup.tileIds.add(getUid(tileRepresentation.tile));\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  var layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(extent, fromUserExtent(layerState.extent, frameState.viewState.projection));\n  }\n  var source = /** @type {import(\"../../source/Tile.js\").default} */\n  layerState.layer.getRenderSource();\n  if (!source.getWrapX()) {\n    var gridExtent = source.getTileGridForProjection(frameState.viewState.projection).getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\nexport function getCacheKey(source, tileCoord) {\n  return \"\".concat(source.getKey(), \",\").concat(getTileCoordKey(tileCoord));\n}\n\n/**\n * @typedef {Object} Options\n * @property {Object<string, import(\"../../webgl/Helper\").UniformValue>} [uniforms] Additional uniforms\n * made available to shaders.\n * @property {number} [cacheSize=512] The tile representation cache size.\n * @property {Array<import('./Layer.js').PostProcessesOptions>} [postProcesses] Post-processes definitions.\n */\n\n/**\n * @typedef {import(\"../../layer/BaseTile.js\").default} BaseLayerType\n */\n\n/**\n * @classdesc\n * Base WebGL renderer for tile layers.\n * @template {BaseLayerType} LayerType\n * @template {import(\"../../Tile.js\").default} TileType\n * @template {import(\"../../webgl/BaseTileRepresentation.js\").default<TileType>} TileRepresentation\n * @extends {WebGLLayerRenderer<LayerType>}\n */\nvar WebGLBaseTileLayerRenderer = /*#__PURE__*/function (_WebGLLayerRenderer) {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} options Options.\n   */\n  function WebGLBaseTileLayerRenderer(tileLayer, options) {\n    var _this;\n    _classCallCheck(this, WebGLBaseTileLayerRenderer);\n    _this = _callSuper(this, WebGLBaseTileLayerRenderer, [tileLayer, {\n      uniforms: options.uniforms,\n      postProcesses: options.postProcesses\n    }]);\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    _this.renderComplete = false;\n\n    /**\n     * This transform converts representation coordinates to screen coordinates.\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    _this.tileTransform_ = createTransform();\n\n    /**\n     * @type {Array<number>}\n     * @protected\n     */\n    _this.tempMat4 = createMat4();\n\n    /**\n     * @type {import(\"../../TileRange.js\").default}\n     * @private\n     */\n    _this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    _this.tempTileCoord_ = createTileCoord(0, 0, 0);\n\n    /**\n     * @type {import(\"../../size.js\").Size}\n     * @private\n     */\n    _this.tempSize_ = [0, 0];\n    var cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<TileRepresentation>}\n     * @protected\n     */\n    _this.tileRepresentationCache = new LRUCache(cacheSize);\n\n    /**\n     * @protected\n     * @type {import(\"../../Map.js\").FrameState|null}\n     */\n    _this.frameState = null;\n\n    /**\n     * @private\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    _this.projection_ = undefined;\n    return _this;\n  }\n\n  /**\n   * @param {Options} options Options.\n   */\n  _inherits(WebGLBaseTileLayerRenderer, _WebGLLayerRenderer);\n  return _createClass(WebGLBaseTileLayerRenderer, [{\n    key: \"reset\",\n    value: function reset(options) {\n      _superPropGet(WebGLBaseTileLayerRenderer, \"reset\", this, 3)([{\n        uniforms: options.uniforms\n      }]);\n    }\n\n    /**\n     * @param {TileType} tile Tile.\n     * @return {boolean} Tile is drawable.\n     * @private\n     */\n  }, {\n    key: \"isDrawableTile_\",\n    value: function isDrawableTile_(tile) {\n      var tileLayer = this.getLayer();\n      var tileState = tile.getState();\n      var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n      return tileState == TileState.LOADED || tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError;\n    }\n\n    /**\n     * Determine whether renderFrame should be called.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     */\n  }, {\n    key: \"prepareFrameInternal\",\n    value: function prepareFrameInternal(frameState) {\n      if (!this.projection_) {\n        this.projection_ = frameState.viewState.projection;\n      } else if (frameState.viewState.projection !== this.projection_) {\n        this.clearCache();\n        this.projection_ = frameState.viewState.projection;\n      }\n      var layer = this.getLayer();\n      var source = layer.getRenderSource();\n      if (!source) {\n        return false;\n      }\n      if (isEmpty(getRenderExtent(frameState, frameState.extent))) {\n        return false;\n      }\n      return source.getState() === 'ready';\n    }\n\n    /**\n     * @abstract\n     * @param {import(\"../../webgl/BaseTileRepresentation.js\").TileRepresentationOptions<TileType>} options tile representation options\n     * @return {TileRepresentation} A new tile representation\n     * @protected\n     */\n  }, {\n    key: \"createTileRepresentation\",\n    value: function createTileRepresentation(options) {\n      return _abstract();\n    }\n\n    /**\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n     * @param {number} initialZ The zoom level.\n     * @param {TileRepresentationLookup} tileRepresentationLookup The zoom level.\n     * @param {number} preload Number of additional levels to load.\n     */\n  }, {\n    key: \"enqueueTiles\",\n    value: function enqueueTiles(frameState, extent, initialZ, tileRepresentationLookup, preload) {\n      var viewState = frameState.viewState;\n      var tileLayer = this.getLayer();\n      var tileSource = tileLayer.getRenderSource();\n      var tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n      var gutter = tileSource.getGutterForProjection(viewState.projection);\n      var tileSourceKey = getUid(tileSource);\n      if (!(tileSourceKey in frameState.wantedTiles)) {\n        frameState.wantedTiles[tileSourceKey] = {};\n      }\n      var wantedTiles = frameState.wantedTiles[tileSourceKey];\n      var tileRepresentationCache = this.tileRepresentationCache;\n      var map = tileLayer.getMapInternal();\n      var minZ = Math.max(initialZ - preload, tileGrid.getMinZoom(), tileGrid.getZForResolution(Math.min(tileLayer.getMaxResolution(), map ? map.getView().getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0)) : tileGrid.getResolution(0)), tileSource.zDirection));\n      for (var z = initialZ; z >= minZ; --z) {\n        var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, this.tempTileRange_);\n        var tileResolution = tileGrid.getResolution(z);\n        for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {\n          for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {\n            var tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n            var cacheKey = getCacheKey(tileSource, tileCoord);\n\n            /** @type {TileRepresentation} */\n            var tileRepresentation = void 0;\n\n            /** @type {TileType} */\n            var tile = void 0;\n            if (tileRepresentationCache.containsKey(cacheKey)) {\n              tileRepresentation = tileRepresentationCache.get(cacheKey);\n              tile = tileRepresentation.tile;\n            }\n            if (!tileRepresentation || tileRepresentation.tile.key !== tileSource.getKey()) {\n              tile = tileSource.getTile(z, x, y, frameState.pixelRatio, viewState.projection);\n            }\n            if (lookupHasTile(tileRepresentationLookup, tile)) {\n              continue;\n            }\n            if (!tileRepresentation) {\n              tileRepresentation = this.createTileRepresentation({\n                tile: tile,\n                grid: tileGrid,\n                helper: this.helper,\n                gutter: gutter\n              });\n              tileRepresentationCache.set(cacheKey, tileRepresentation);\n            } else {\n              if (this.isDrawableTile_(tile)) {\n                tileRepresentation.setTile(tile);\n              } else {\n                var interimTile = /** @type {TileType} */\n                tile.getInterimTile();\n                tileRepresentation.setTile(interimTile);\n              }\n            }\n            addTileRepresentationToLookup(tileRepresentationLookup, tileRepresentation, z);\n            var tileQueueKey = tile.getKey();\n            wantedTiles[tileQueueKey] = true;\n            if (tile.getState() === TileState.IDLE) {\n              if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n                frameState.tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tileCoord), tileResolution]);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     * @param {boolean} tilesWithAlpha True if at least one of the rendered tiles has alpha\n     * @protected\n     */\n  }, {\n    key: \"beforeTilesRender\",\n    value: function beforeTilesRender(frameState, tilesWithAlpha) {\n      this.helper.prepareDraw(this.frameState, !tilesWithAlpha, true);\n    }\n\n    /**\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     * @return {boolean} If returns false, tile mask rendering will be skipped\n     * @protected\n     */\n  }, {\n    key: \"beforeTilesMaskRender\",\n    value: function beforeTilesMaskRender(frameState) {\n      return false;\n    }\n\n    /**\n     * @param {TileRepresentation} tileRepresentation Tile representation\n     * @param {import(\"../../transform.js\").Transform} tileTransform Tile transform\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state\n     * @param {import(\"../../extent.js\").Extent} renderExtent Render extent\n     * @param {number} tileResolution Tile resolution\n     * @param {import(\"../../size.js\").Size} tileSize Tile size\n     * @param {import(\"../../coordinate.js\").Coordinate} tileOrigin Tile origin\n     * @param {import(\"../../extent.js\").Extent} tileExtent tile Extent\n     * @param {number} depth Depth\n     * @param {number} gutter Gutter\n     * @param {number} alpha Alpha\n     * @protected\n     */\n  }, {\n    key: \"renderTile\",\n    value: function renderTile(tileRepresentation, tileTransform, frameState, renderExtent, tileResolution, tileSize, tileOrigin, tileExtent, depth, gutter, alpha) {}\n\n    /**\n     * @param {TileRepresentation} tileRepresentation Tile representation\n     * @param {number} tileZ Tile Z\n     * @param {import(\"../../extent.js\").Extent} extent Render extent\n     * @param {number} depth Depth\n     * @protected\n     */\n  }, {\n    key: \"renderTileMask\",\n    value: function renderTileMask(tileRepresentation, tileZ, extent, depth) {}\n  }, {\n    key: \"drawTile_\",\n    value: function drawTile_(frameState, tileRepresentation, tileZ, gutter, extent, alphaLookup, tileGrid) {\n      if (!tileRepresentation.ready) {\n        return;\n      }\n      var tile = tileRepresentation.tile;\n      var tileCoord = tile.tileCoord;\n      var tileCoordKey = getTileCoordKey(tileCoord);\n      var alpha = tileCoordKey in alphaLookup ? alphaLookup[tileCoordKey] : 1;\n      var tileResolution = tileGrid.getResolution(tileZ);\n      var tileSize = toSize(tileGrid.getTileSize(tileZ), this.tempSize_);\n      var tileOrigin = tileGrid.getOrigin(tileZ);\n      var tileExtent = tileGrid.getTileCoordExtent(tileCoord);\n      // tiles with alpha are rendered last to allow blending\n      var depth = alpha < 1 ? -1 : depthForZ(tileZ);\n      if (alpha < 1) {\n        frameState.animate = true;\n      }\n      var viewState = frameState.viewState;\n      var centerX = viewState.center[0];\n      var centerY = viewState.center[1];\n      var tileWidthWithGutter = tileSize[0] + 2 * gutter;\n      var tileHeightWithGutter = tileSize[1] + 2 * gutter;\n      var aspectRatio = tileWidthWithGutter / tileHeightWithGutter;\n      var centerI = (centerX - tileOrigin[0]) / (tileSize[0] * tileResolution);\n      var centerJ = (tileOrigin[1] - centerY) / (tileSize[1] * tileResolution);\n      var tileScale = viewState.resolution / tileResolution;\n      var tileCenterI = tileCoord[1];\n      var tileCenterJ = tileCoord[2];\n      resetTransform(this.tileTransform_);\n      scaleTransform(this.tileTransform_, 2 / (frameState.size[0] * tileScale / tileWidthWithGutter), -2 / (frameState.size[1] * tileScale / tileWidthWithGutter));\n      rotateTransform(this.tileTransform_, viewState.rotation);\n      scaleTransform(this.tileTransform_, 1, 1 / aspectRatio);\n      translateTransform(this.tileTransform_, (tileSize[0] * (tileCenterI - centerI) - gutter) / tileWidthWithGutter, (tileSize[1] * (tileCenterJ - centerJ) - gutter) / tileHeightWithGutter);\n      this.renderTile(/** @type {TileRepresentation} */tileRepresentation, this.tileTransform_, frameState, extent, tileResolution, tileSize, tileOrigin, tileExtent, depth, gutter, alpha);\n    }\n\n    /**\n     * Render the layer.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     * @return {HTMLElement} The rendered element.\n     */\n  }, {\n    key: \"renderFrame\",\n    value: function renderFrame(frameState) {\n      var _this2 = this;\n      this.frameState = frameState;\n      this.renderComplete = true;\n      var gl = this.helper.getGL();\n      this.preRender(gl, frameState);\n      var viewState = frameState.viewState;\n      var tileLayer = this.getLayer();\n      var tileSource = tileLayer.getRenderSource();\n      var tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n      var gutter = tileSource.getGutterForProjection(viewState.projection);\n      var extent = getRenderExtent(frameState, frameState.extent);\n      var z = tileGrid.getZForResolution(viewState.resolution, tileSource.zDirection);\n\n      /**\n       * @type {TileRepresentationLookup}\n       */\n      var tileRepresentationLookup = newTileRepresentationLookup();\n      var preload = tileLayer.getPreload();\n      if (frameState.nextExtent) {\n        var targetZ = tileGrid.getZForResolution(viewState.nextResolution, tileSource.zDirection);\n        var nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n        this.enqueueTiles(frameState, nextExtent, targetZ, tileRepresentationLookup, preload);\n      }\n      this.enqueueTiles(frameState, extent, z, tileRepresentationLookup, 0);\n      if (preload > 0) {\n        setTimeout(function () {\n          _this2.enqueueTiles(frameState, extent, z - 1, tileRepresentationLookup, preload - 1);\n        }, 0);\n      }\n\n      /**\n       * A lookup of alpha values for tiles at the target rendering resolution\n       * for tiles that are in transition.  If a tile coord key is absent from\n       * this lookup, the tile should be rendered at alpha 1.\n       * @type {Object<string, number>}\n       */\n      var alphaLookup = {};\n      var uid = getUid(this);\n      var time = frameState.time;\n      var blend = false;\n\n      // look for cached tiles to use if a target tile is not ready\n      var _iterator = _createForOfIteratorHelper(tileRepresentationLookup.representationsByZ[z]),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _tileRepresentation3 = _step.value;\n          var tile = _tileRepresentation3.tile;\n          if ((tile instanceof ReprojTile || tile instanceof ReprojDataTile) && tile.getState() === TileState.EMPTY) {\n            continue;\n          }\n          var _tileCoord2 = tile.tileCoord;\n          if (_tileRepresentation3.ready) {\n            var alpha = tile.getAlpha(uid, time);\n            if (alpha === 1) {\n              // no need to look for alt tiles\n              tile.endTransition(uid);\n              continue;\n            }\n            blend = true;\n            var _tileCoordKey2 = getTileCoordKey(_tileCoord2);\n            alphaLookup[_tileCoordKey2] = alpha;\n          }\n          this.renderComplete = false;\n\n          // first look for child tiles (at z + 1)\n          var coveredByChildren = this.findAltTiles_(tileGrid, _tileCoord2, z + 1, tileRepresentationLookup);\n          if (coveredByChildren) {\n            continue;\n          }\n\n          // next look for parent tiles\n          var minZoom = tileGrid.getMinZoom();\n          for (var parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n            var coveredByParent = this.findAltTiles_(tileGrid, _tileCoord2, parentZ, tileRepresentationLookup);\n            if (coveredByParent) {\n              break;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var representationsByZ = tileRepresentationLookup.representationsByZ;\n      var zs = Object.keys(representationsByZ).map(Number).sort(descending);\n      var renderTileMask = this.beforeTilesMaskRender(frameState);\n      if (renderTileMask) {\n        for (var j = 0, jj = zs.length; j < jj; ++j) {\n          var tileZ = zs[j];\n          var _iterator2 = _createForOfIteratorHelper(representationsByZ[tileZ]),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var tileRepresentation = _step2.value;\n              var tileCoord = tileRepresentation.tile.tileCoord;\n              var tileCoordKey = getTileCoordKey(tileCoord);\n              // do not render the tile mask if alpha < 1\n              if (tileCoordKey in alphaLookup) {\n                continue;\n              }\n              var tileExtent = tileGrid.getTileCoordExtent(tileCoord);\n              this.renderTileMask(/** @type {TileRepresentation} */tileRepresentation, tileZ, tileExtent, depthForZ(tileZ));\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      }\n      this.beforeTilesRender(frameState, blend);\n      for (var _j = 0, _jj = zs.length; _j < _jj; ++_j) {\n        var _tileZ = zs[_j];\n        var _iterator3 = _createForOfIteratorHelper(representationsByZ[_tileZ]),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _tileRepresentation = _step3.value;\n            var _tileCoord = _tileRepresentation.tile.tileCoord;\n            var _tileCoordKey = getTileCoordKey(_tileCoord);\n            if (_tileCoordKey in alphaLookup) {\n              continue;\n            }\n            this.drawTile_(frameState, _tileRepresentation, _tileZ, gutter, extent, alphaLookup, tileGrid);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n      var _iterator4 = _createForOfIteratorHelper(representationsByZ[z]),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _tileRepresentation4 = _step4.value;\n          var _tileCoord3 = _tileRepresentation4.tile.tileCoord;\n          var _tileCoordKey3 = getTileCoordKey(_tileCoord3);\n          if (_tileCoordKey3 in alphaLookup) {\n            this.drawTile_(frameState, _tileRepresentation4, z, gutter, extent, alphaLookup, tileGrid);\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);\n      var canvas = this.helper.getCanvas();\n      var tileRepresentationCache = this.tileRepresentationCache;\n      while (tileRepresentationCache.canExpireCache()) {\n        var _tileRepresentation2 = tileRepresentationCache.pop();\n        _tileRepresentation2.dispose();\n      }\n\n      // TODO: let the renderers manage their own cache instead of managing the source cache\n      /**\n       * Here we unconditionally expire the source cache since the renderer maintains\n       * its own cache.\n       * @param {import(\"../../Map.js\").default} map Map.\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n       */\n      var postRenderFunction = function postRenderFunction(map, frameState) {\n        tileSource.updateCacheSize(0.1, frameState.viewState.projection);\n        tileSource.expireCache(frameState.viewState.projection, empty);\n      };\n      frameState.postRenderFunctions.push(postRenderFunction);\n      this.postRender(gl, frameState);\n      return canvas;\n    }\n\n    /**\n     * Look for tiles covering the provided tile coordinate at an alternate\n     * zoom level.  Loaded tiles will be added to the provided tile representation lookup.\n     * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n     * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n     * @param {number} altZ The alternate zoom level.\n     * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of\n     * tile representations by zoom level.\n     * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n     * @private\n     */\n  }, {\n    key: \"findAltTiles_\",\n    value: function findAltTiles_(tileGrid, tileCoord, altZ, tileRepresentationLookup) {\n      var tileRange = tileGrid.getTileRangeForTileCoordAndZ(tileCoord, altZ, this.tempTileRange_);\n      if (!tileRange) {\n        return false;\n      }\n      var covered = true;\n      var tileRepresentationCache = this.tileRepresentationCache;\n      var source = this.getLayer().getRenderSource();\n      for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          var cacheKey = getCacheKey(source, [altZ, x, y]);\n          var loaded = false;\n          if (tileRepresentationCache.containsKey(cacheKey)) {\n            var tileRepresentation = tileRepresentationCache.get(cacheKey);\n            if (tileRepresentation.ready && !lookupHasTile(tileRepresentationLookup, tileRepresentation.tile)) {\n              addTileRepresentationToLookup(tileRepresentationLookup, tileRepresentation, altZ);\n              loaded = true;\n            }\n          }\n          if (!loaded) {\n            covered = false;\n          }\n        }\n      }\n      return covered;\n    }\n  }, {\n    key: \"clearCache\",\n    value: function clearCache() {\n      var tileRepresentationCache = this.tileRepresentationCache;\n      tileRepresentationCache.forEach(function (tileRepresentation) {\n        return tileRepresentation.dispose();\n      });\n      tileRepresentationCache.clear();\n    }\n  }, {\n    key: \"removeHelper\",\n    value: function removeHelper() {\n      if (this.helper) {\n        this.clearCache();\n      }\n      _superPropGet(WebGLBaseTileLayerRenderer, \"removeHelper\", this, 3)([]);\n    }\n\n    /**\n     * Clean up.\n     */\n  }, {\n    key: \"disposeInternal\",\n    value: function disposeInternal() {\n      _superPropGet(WebGLBaseTileLayerRenderer, \"disposeInternal\", this, 3)([]);\n      delete this.frameState;\n    }\n  }]);\n}(WebGLLayerRenderer);\nexport default WebGLBaseTileLayerRenderer;","map":{"version":3,"names":["LRUCache","ReprojDataTile","ReprojTile","TileRange","TileState","WebGLLayerRenderer","abstract","getUid","create","createMat4","createOrUpdate","createTileCoord","getKey","getTileCoordKey","createTransform","reset","resetTransform","rotate","rotateTransform","scale","scaleTransform","translate","translateTransform","descending","fromUserExtent","getIntersection","isEmpty","toSize","Uniforms","TILE_TRANSFORM","TRANSITION_ALPHA","DEPTH","RENDER_EXTENT","PATTERN_ORIGIN","RESOLUTION","ZOOM","GLOBAL_ALPHA","PROJECTION_MATRIX","SCREEN_TO_WORLD_MATRIX","empty","depthForZ","z","newTileRepresentationLookup","tileIds","Set","representationsByZ","lookupHasTile","tileRepresentationLookup","tile","has","addTileRepresentationToLookup","tileRepresentation","add","getRenderExtent","frameState","extent","layerState","layerStatesArray","layerIndex","viewState","projection","source","layer","getRenderSource","getWrapX","gridExtent","getTileGridForProjection","getExtent","getCacheKey","tileCoord","concat","WebGLBaseTileLayerRenderer","_WebGLLayerRenderer","tileLayer","options","_this","_classCallCheck","_callSuper","uniforms","postProcesses","renderComplete","tileTransform_","tempMat4","tempTileRange_","tempTileCoord_","tempSize_","cacheSize","undefined","tileRepresentationCache","projection_","_inherits","_createClass","key","value","_superPropGet","isDrawableTile_","getLayer","tileState","getState","useInterimTilesOnError","getUseInterimTilesOnError","LOADED","EMPTY","ERROR","prepareFrameInternal","clearCache","createTileRepresentation","enqueueTiles","initialZ","preload","tileSource","tileGrid","gutter","getGutterForProjection","tileSourceKey","wantedTiles","map","getMapInternal","minZ","Math","max","getMinZoom","getZForResolution","min","getMaxResolution","getView","getResolutionForZoom","getResolution","zDirection","tileRange","getTileRangeForExtentAndZ","tileResolution","x","minX","maxX","y","minY","maxY","cacheKey","containsKey","get","getTile","pixelRatio","grid","helper","set","setTile","interimTile","getInterimTile","tileQueueKey","IDLE","tileQueue","isKeyQueued","enqueue","getTileCoordCenter","beforeTilesRender","tilesWithAlpha","prepareDraw","beforeTilesMaskRender","renderTile","tileTransform","renderExtent","tileSize","tileOrigin","tileExtent","depth","alpha","renderTileMask","tileZ","drawTile_","alphaLookup","ready","tileCoordKey","getTileSize","getOrigin","getTileCoordExtent","animate","centerX","center","centerY","tileWidthWithGutter","tileHeightWithGutter","aspectRatio","centerI","centerJ","tileScale","resolution","tileCenterI","tileCenterJ","size","rotation","renderFrame","_this2","gl","getGL","preRender","getPreload","nextExtent","targetZ","nextResolution","setTimeout","uid","time","blend","_iterator","_createForOfIteratorHelper","_step","s","n","done","getAlpha","endTransition","coveredByChildren","findAltTiles_","minZoom","parentZ","coveredByParent","err","e","f","zs","Object","keys","Number","sort","j","jj","length","_iterator2","_step2","_iterator3","_step3","_iterator4","_step4","finalizeDraw","dispatchPreComposeEvent","dispatchPostComposeEvent","canvas","getCanvas","canExpireCache","pop","dispose","postRenderFunction","updateCacheSize","expireCache","postRenderFunctions","push","postRender","altZ","getTileRangeForTileCoordAndZ","covered","loaded","forEach","clear","removeHelper","disposeInternal"],"sources":["/Users/akio/Downloads/themeforest-veRyTIGn-mofi-vue-js-admin-template/theme/node_modules/ol/renderer/webgl/TileLayerBase.js"],"sourcesContent":["/**\n * @module ol/renderer/webgl/TileLayerBase\n */\nimport LRUCache from '../../structs/LRUCache.js';\nimport ReprojDataTile from '../../reproj/DataTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport {abstract, getUid} from '../../util.js';\nimport {create as createMat4} from '../../vec/mat4.js';\nimport {\n  createOrUpdate as createTileCoord,\n  getKey as getTileCoordKey,\n} from '../../tilecoord.js';\nimport {\n  create as createTransform,\n  reset as resetTransform,\n  rotate as rotateTransform,\n  scale as scaleTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {descending} from '../../array.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {getIntersection, isEmpty} from '../../extent.js';\nimport {toSize} from '../../size.js';\n\nexport const Uniforms = {\n  TILE_TRANSFORM: 'u_tileTransform',\n  TRANSITION_ALPHA: 'u_transitionAlpha',\n  DEPTH: 'u_depth',\n  RENDER_EXTENT: 'u_renderExtent', // intersection of layer, source, and view extent\n  PATTERN_ORIGIN: 'u_patternOrigin',\n  RESOLUTION: 'u_resolution',\n  ZOOM: 'u_zoom',\n  GLOBAL_ALPHA: 'u_globalAlpha',\n  PROJECTION_MATRIX: 'u_projectionMatrix',\n  SCREEN_TO_WORLD_MATRIX: 'u_screenToWorldMatrix',\n};\n\n/**\n * @type {Object<string, boolean>}\n */\nconst empty = {};\n\n/**\n * Transform a zoom level into a depth value; zoom level zero has a depth value of 0.5, and increasing values\n * have a depth trending towards 0\n * @param {number} z A zoom level.\n * @return {number} A depth value.\n */\nfunction depthForZ(z) {\n  return 1 / (z + 2);\n}\n\n/**\n * @typedef {import(\"../../webgl/BaseTileRepresentation.js\").default<import(\"../../Tile.js\").default>} AbstractTileRepresentation\n */\n/**\n * @typedef {Object} TileRepresentationLookup\n * @property {Set<string>} tileIds The set of tile ids in the lookup.\n * @property {Object<number, Set<AbstractTileRepresentation>>} representationsByZ Tile representations by zoom level.\n */\n\n/**\n * @return {TileRepresentationLookup} A new tile representation lookup.\n */\nexport function newTileRepresentationLookup() {\n  return {tileIds: new Set(), representationsByZ: {}};\n}\n\n/**\n * Check if a tile is already in the tile representation lookup.\n * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of tile representations by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @return {boolean} The tile is already in the lookup.\n */\nfunction lookupHasTile(tileRepresentationLookup, tile) {\n  return tileRepresentationLookup.tileIds.has(getUid(tile));\n}\n\n/**\n * Add a tile representation to the lookup.\n * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of tile representations by zoom level.\n * @param {AbstractTileRepresentation} tileRepresentation A tile representation.\n * @param {number} z The zoom level.\n */\nfunction addTileRepresentationToLookup(\n  tileRepresentationLookup,\n  tileRepresentation,\n  z\n) {\n  const representationsByZ = tileRepresentationLookup.representationsByZ;\n  if (!(z in representationsByZ)) {\n    representationsByZ[z] = new Set();\n  }\n  representationsByZ[z].add(tileRepresentation);\n  tileRepresentationLookup.tileIds.add(getUid(tileRepresentation.tile));\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(\n      extent,\n      fromUserExtent(layerState.extent, frameState.viewState.projection)\n    );\n  }\n  const source = /** @type {import(\"../../source/Tile.js\").default} */ (\n    layerState.layer.getRenderSource()\n  );\n  if (!source.getWrapX()) {\n    const gridExtent = source\n      .getTileGridForProjection(frameState.viewState.projection)\n      .getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\n\nexport function getCacheKey(source, tileCoord) {\n  return `${source.getKey()},${getTileCoordKey(tileCoord)}`;\n}\n\n/**\n * @typedef {Object} Options\n * @property {Object<string, import(\"../../webgl/Helper\").UniformValue>} [uniforms] Additional uniforms\n * made available to shaders.\n * @property {number} [cacheSize=512] The tile representation cache size.\n * @property {Array<import('./Layer.js').PostProcessesOptions>} [postProcesses] Post-processes definitions.\n */\n\n/**\n * @typedef {import(\"../../layer/BaseTile.js\").default} BaseLayerType\n */\n\n/**\n * @classdesc\n * Base WebGL renderer for tile layers.\n * @template {BaseLayerType} LayerType\n * @template {import(\"../../Tile.js\").default} TileType\n * @template {import(\"../../webgl/BaseTileRepresentation.js\").default<TileType>} TileRepresentation\n * @extends {WebGLLayerRenderer<LayerType>}\n */\nclass WebGLBaseTileLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} options Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer, {\n      uniforms: options.uniforms,\n      postProcesses: options.postProcesses,\n    });\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    this.renderComplete = false;\n\n    /**\n     * This transform converts representation coordinates to screen coordinates.\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.tileTransform_ = createTransform();\n\n    /**\n     * @type {Array<number>}\n     * @protected\n     */\n    this.tempMat4 = createMat4();\n\n    /**\n     * @type {import(\"../../TileRange.js\").default}\n     * @private\n     */\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n\n    /**\n     * @type {import(\"../../size.js\").Size}\n     * @private\n     */\n    this.tempSize_ = [0, 0];\n\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<TileRepresentation>}\n     * @protected\n     */\n    this.tileRepresentationCache = new LRUCache(cacheSize);\n\n    /**\n     * @protected\n     * @type {import(\"../../Map.js\").FrameState|null}\n     */\n    this.frameState = null;\n\n    /**\n     * @private\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.projection_ = undefined;\n  }\n\n  /**\n   * @param {Options} options Options.\n   */\n  reset(options) {\n    super.reset({\n      uniforms: options.uniforms,\n    });\n  }\n\n  /**\n   * @param {TileType} tile Tile.\n   * @return {boolean} Tile is drawable.\n   * @private\n   */\n  isDrawableTile_(tile) {\n    const tileLayer = this.getLayer();\n    const tileState = tile.getState();\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return (\n      tileState == TileState.LOADED ||\n      tileState == TileState.EMPTY ||\n      (tileState == TileState.ERROR && !useInterimTilesOnError)\n    );\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrameInternal(frameState) {\n    if (!this.projection_) {\n      this.projection_ = frameState.viewState.projection;\n    } else if (frameState.viewState.projection !== this.projection_) {\n      this.clearCache();\n      this.projection_ = frameState.viewState.projection;\n    }\n\n    const layer = this.getLayer();\n    const source = layer.getRenderSource();\n    if (!source) {\n      return false;\n    }\n\n    if (isEmpty(getRenderExtent(frameState, frameState.extent))) {\n      return false;\n    }\n    return source.getState() === 'ready';\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../../webgl/BaseTileRepresentation.js\").TileRepresentationOptions<TileType>} options tile representation options\n   * @return {TileRepresentation} A new tile representation\n   * @protected\n   */\n  createTileRepresentation(options) {\n    return abstract();\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {TileRepresentationLookup} tileRepresentationLookup The zoom level.\n   * @param {number} preload Number of additional levels to load.\n   */\n  enqueueTiles(\n    frameState,\n    extent,\n    initialZ,\n    tileRepresentationLookup,\n    preload\n  ) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const gutter = tileSource.getGutterForProjection(viewState.projection);\n\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const tileRepresentationCache = this.tileRepresentationCache;\n\n    const map = tileLayer.getMapInternal();\n    const minZ = Math.max(\n      initialZ - preload,\n      tileGrid.getMinZoom(),\n      tileGrid.getZForResolution(\n        Math.min(\n          tileLayer.getMaxResolution(),\n          map\n            ? map\n                .getView()\n                .getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0))\n            : tileGrid.getResolution(0)\n        ),\n        tileSource.zDirection\n      )\n    );\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\n        extent,\n        z,\n        this.tempTileRange_\n      );\n\n      const tileResolution = tileGrid.getResolution(z);\n\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n          const cacheKey = getCacheKey(tileSource, tileCoord);\n\n          /** @type {TileRepresentation} */\n          let tileRepresentation;\n\n          /** @type {TileType} */\n          let tile;\n\n          if (tileRepresentationCache.containsKey(cacheKey)) {\n            tileRepresentation = tileRepresentationCache.get(cacheKey);\n            tile = tileRepresentation.tile;\n          }\n          if (\n            !tileRepresentation ||\n            tileRepresentation.tile.key !== tileSource.getKey()\n          ) {\n            tile = tileSource.getTile(\n              z,\n              x,\n              y,\n              frameState.pixelRatio,\n              viewState.projection\n            );\n          }\n\n          if (lookupHasTile(tileRepresentationLookup, tile)) {\n            continue;\n          }\n\n          if (!tileRepresentation) {\n            tileRepresentation = this.createTileRepresentation({\n              tile: tile,\n              grid: tileGrid,\n              helper: this.helper,\n              gutter: gutter,\n            });\n            tileRepresentationCache.set(cacheKey, tileRepresentation);\n          } else {\n            if (this.isDrawableTile_(tile)) {\n              tileRepresentation.setTile(tile);\n            } else {\n              const interimTile = /** @type {TileType} */ (\n                tile.getInterimTile()\n              );\n              tileRepresentation.setTile(interimTile);\n            }\n          }\n\n          addTileRepresentationToLookup(\n            tileRepresentationLookup,\n            tileRepresentation,\n            z\n          );\n\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              frameState.tileQueue.enqueue([\n                tile,\n                tileSourceKey,\n                tileGrid.getTileCoordCenter(tileCoord),\n                tileResolution,\n              ]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {boolean} tilesWithAlpha True if at least one of the rendered tiles has alpha\n   * @protected\n   */\n  beforeTilesRender(frameState, tilesWithAlpha) {\n    this.helper.prepareDraw(this.frameState, !tilesWithAlpha, true);\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} If returns false, tile mask rendering will be skipped\n   * @protected\n   */\n  beforeTilesMaskRender(frameState) {\n    return false;\n  }\n\n  /**\n   * @param {TileRepresentation} tileRepresentation Tile representation\n   * @param {import(\"../../transform.js\").Transform} tileTransform Tile transform\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state\n   * @param {import(\"../../extent.js\").Extent} renderExtent Render extent\n   * @param {number} tileResolution Tile resolution\n   * @param {import(\"../../size.js\").Size} tileSize Tile size\n   * @param {import(\"../../coordinate.js\").Coordinate} tileOrigin Tile origin\n   * @param {import(\"../../extent.js\").Extent} tileExtent tile Extent\n   * @param {number} depth Depth\n   * @param {number} gutter Gutter\n   * @param {number} alpha Alpha\n   * @protected\n   */\n  renderTile(\n    tileRepresentation,\n    tileTransform,\n    frameState,\n    renderExtent,\n    tileResolution,\n    tileSize,\n    tileOrigin,\n    tileExtent,\n    depth,\n    gutter,\n    alpha\n  ) {}\n\n  /**\n   * @param {TileRepresentation} tileRepresentation Tile representation\n   * @param {number} tileZ Tile Z\n   * @param {import(\"../../extent.js\").Extent} extent Render extent\n   * @param {number} depth Depth\n   * @protected\n   */\n  renderTileMask(tileRepresentation, tileZ, extent, depth) {}\n\n  drawTile_(\n    frameState,\n    tileRepresentation,\n    tileZ,\n    gutter,\n    extent,\n    alphaLookup,\n    tileGrid\n  ) {\n    if (!tileRepresentation.ready) {\n      return;\n    }\n    const tile = tileRepresentation.tile;\n    const tileCoord = tile.tileCoord;\n    const tileCoordKey = getTileCoordKey(tileCoord);\n    const alpha = tileCoordKey in alphaLookup ? alphaLookup[tileCoordKey] : 1;\n\n    const tileResolution = tileGrid.getResolution(tileZ);\n    const tileSize = toSize(tileGrid.getTileSize(tileZ), this.tempSize_);\n    const tileOrigin = tileGrid.getOrigin(tileZ);\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord);\n    // tiles with alpha are rendered last to allow blending\n    const depth = alpha < 1 ? -1 : depthForZ(tileZ);\n    if (alpha < 1) {\n      frameState.animate = true;\n    }\n\n    const viewState = frameState.viewState;\n    const centerX = viewState.center[0];\n    const centerY = viewState.center[1];\n\n    const tileWidthWithGutter = tileSize[0] + 2 * gutter;\n    const tileHeightWithGutter = tileSize[1] + 2 * gutter;\n\n    const aspectRatio = tileWidthWithGutter / tileHeightWithGutter;\n\n    const centerI = (centerX - tileOrigin[0]) / (tileSize[0] * tileResolution);\n    const centerJ = (tileOrigin[1] - centerY) / (tileSize[1] * tileResolution);\n\n    const tileScale = viewState.resolution / tileResolution;\n\n    const tileCenterI = tileCoord[1];\n    const tileCenterJ = tileCoord[2];\n\n    resetTransform(this.tileTransform_);\n    scaleTransform(\n      this.tileTransform_,\n      2 / ((frameState.size[0] * tileScale) / tileWidthWithGutter),\n      -2 / ((frameState.size[1] * tileScale) / tileWidthWithGutter)\n    );\n    rotateTransform(this.tileTransform_, viewState.rotation);\n    scaleTransform(this.tileTransform_, 1, 1 / aspectRatio);\n    translateTransform(\n      this.tileTransform_,\n      (tileSize[0] * (tileCenterI - centerI) - gutter) / tileWidthWithGutter,\n      (tileSize[1] * (tileCenterJ - centerJ) - gutter) / tileHeightWithGutter\n    );\n\n    this.renderTile(\n      /** @type {TileRepresentation} */ (tileRepresentation),\n      this.tileTransform_,\n      frameState,\n      extent,\n      tileResolution,\n      tileSize,\n      tileOrigin,\n      tileExtent,\n      depth,\n      gutter,\n      alpha\n    );\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState) {\n    this.frameState = frameState;\n    this.renderComplete = true;\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const gutter = tileSource.getGutterForProjection(viewState.projection);\n    const extent = getRenderExtent(frameState, frameState.extent);\n    const z = tileGrid.getZForResolution(\n      viewState.resolution,\n      tileSource.zDirection\n    );\n\n    /**\n     * @type {TileRepresentationLookup}\n     */\n    const tileRepresentationLookup = newTileRepresentationLookup();\n\n    const preload = tileLayer.getPreload();\n    if (frameState.nextExtent) {\n      const targetZ = tileGrid.getZForResolution(\n        viewState.nextResolution,\n        tileSource.zDirection\n      );\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(\n        frameState,\n        nextExtent,\n        targetZ,\n        tileRepresentationLookup,\n        preload\n      );\n    }\n\n    this.enqueueTiles(frameState, extent, z, tileRepresentationLookup, 0);\n    if (preload > 0) {\n      setTimeout(() => {\n        this.enqueueTiles(\n          frameState,\n          extent,\n          z - 1,\n          tileRepresentationLookup,\n          preload - 1\n        );\n      }, 0);\n    }\n\n    /**\n     * A lookup of alpha values for tiles at the target rendering resolution\n     * for tiles that are in transition.  If a tile coord key is absent from\n     * this lookup, the tile should be rendered at alpha 1.\n     * @type {Object<string, number>}\n     */\n    const alphaLookup = {};\n\n    const uid = getUid(this);\n    const time = frameState.time;\n    let blend = false;\n\n    // look for cached tiles to use if a target tile is not ready\n    for (const tileRepresentation of tileRepresentationLookup\n      .representationsByZ[z]) {\n      const tile = tileRepresentation.tile;\n      if (\n        (tile instanceof ReprojTile || tile instanceof ReprojDataTile) &&\n        tile.getState() === TileState.EMPTY\n      ) {\n        continue;\n      }\n      const tileCoord = tile.tileCoord;\n\n      if (tileRepresentation.ready) {\n        const alpha = tile.getAlpha(uid, time);\n        if (alpha === 1) {\n          // no need to look for alt tiles\n          tile.endTransition(uid);\n          continue;\n        }\n        blend = true;\n        const tileCoordKey = getTileCoordKey(tileCoord);\n        alphaLookup[tileCoordKey] = alpha;\n      }\n      this.renderComplete = false;\n\n      // first look for child tiles (at z + 1)\n      const coveredByChildren = this.findAltTiles_(\n        tileGrid,\n        tileCoord,\n        z + 1,\n        tileRepresentationLookup\n      );\n\n      if (coveredByChildren) {\n        continue;\n      }\n\n      // next look for parent tiles\n      const minZoom = tileGrid.getMinZoom();\n      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n        const coveredByParent = this.findAltTiles_(\n          tileGrid,\n          tileCoord,\n          parentZ,\n          tileRepresentationLookup\n        );\n\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n\n    const representationsByZ = tileRepresentationLookup.representationsByZ;\n    const zs = Object.keys(representationsByZ).map(Number).sort(descending);\n\n    const renderTileMask = this.beforeTilesMaskRender(frameState);\n\n    if (renderTileMask) {\n      for (let j = 0, jj = zs.length; j < jj; ++j) {\n        const tileZ = zs[j];\n        for (const tileRepresentation of representationsByZ[tileZ]) {\n          const tileCoord = tileRepresentation.tile.tileCoord;\n          const tileCoordKey = getTileCoordKey(tileCoord);\n          // do not render the tile mask if alpha < 1\n          if (tileCoordKey in alphaLookup) {\n            continue;\n          }\n          const tileExtent = tileGrid.getTileCoordExtent(tileCoord);\n          this.renderTileMask(\n            /** @type {TileRepresentation} */ (tileRepresentation),\n            tileZ,\n            tileExtent,\n            depthForZ(tileZ)\n          );\n        }\n      }\n    }\n\n    this.beforeTilesRender(frameState, blend);\n\n    for (let j = 0, jj = zs.length; j < jj; ++j) {\n      const tileZ = zs[j];\n      for (const tileRepresentation of representationsByZ[tileZ]) {\n        const tileCoord = tileRepresentation.tile.tileCoord;\n        const tileCoordKey = getTileCoordKey(tileCoord);\n        if (tileCoordKey in alphaLookup) {\n          continue;\n        }\n\n        this.drawTile_(\n          frameState,\n          tileRepresentation,\n          tileZ,\n          gutter,\n          extent,\n          alphaLookup,\n          tileGrid\n        );\n      }\n    }\n\n    for (const tileRepresentation of representationsByZ[z]) {\n      const tileCoord = tileRepresentation.tile.tileCoord;\n      const tileCoordKey = getTileCoordKey(tileCoord);\n      if (tileCoordKey in alphaLookup) {\n        this.drawTile_(\n          frameState,\n          tileRepresentation,\n          z,\n          gutter,\n          extent,\n          alphaLookup,\n          tileGrid\n        );\n      }\n    }\n\n    this.helper.finalizeDraw(\n      frameState,\n      this.dispatchPreComposeEvent,\n      this.dispatchPostComposeEvent\n    );\n\n    const canvas = this.helper.getCanvas();\n\n    const tileRepresentationCache = this.tileRepresentationCache;\n    while (tileRepresentationCache.canExpireCache()) {\n      const tileRepresentation = tileRepresentationCache.pop();\n      tileRepresentation.dispose();\n    }\n\n    // TODO: let the renderers manage their own cache instead of managing the source cache\n    /**\n     * Here we unconditionally expire the source cache since the renderer maintains\n     * its own cache.\n     * @param {import(\"../../Map.js\").default} map Map.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     */\n    const postRenderFunction = function (map, frameState) {\n      tileSource.updateCacheSize(0.1, frameState.viewState.projection);\n      tileSource.expireCache(frameState.viewState.projection, empty);\n    };\n\n    frameState.postRenderFunctions.push(postRenderFunction);\n\n    this.postRender(gl, frameState);\n    return canvas;\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile representation lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of\n   * tile representations by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findAltTiles_(tileGrid, tileCoord, altZ, tileRepresentationLookup) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(\n      tileCoord,\n      altZ,\n      this.tempTileRange_\n    );\n\n    if (!tileRange) {\n      return false;\n    }\n\n    let covered = true;\n    const tileRepresentationCache = this.tileRepresentationCache;\n    const source = this.getLayer().getRenderSource();\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(source, [altZ, x, y]);\n        let loaded = false;\n        if (tileRepresentationCache.containsKey(cacheKey)) {\n          const tileRepresentation = tileRepresentationCache.get(cacheKey);\n          if (\n            tileRepresentation.ready &&\n            !lookupHasTile(tileRepresentationLookup, tileRepresentation.tile)\n          ) {\n            addTileRepresentationToLookup(\n              tileRepresentationLookup,\n              tileRepresentation,\n              altZ\n            );\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  clearCache() {\n    const tileRepresentationCache = this.tileRepresentationCache;\n    tileRepresentationCache.forEach((tileRepresentation) =>\n      tileRepresentation.dispose()\n    );\n    tileRepresentationCache.clear();\n  }\n\n  removeHelper() {\n    if (this.helper) {\n      this.clearCache();\n    }\n\n    super.removeHelper();\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    super.disposeInternal();\n    delete this.frameState;\n  }\n}\n\nexport default WebGLBaseTileLayerRenderer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}